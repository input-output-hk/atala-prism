# Wallet Backend Motivation
While designing gRPC-agnostic Node API in SDK we realized that a pure stateless SDK, despite being useful, does not cover the needs of most PRISM use cases. Every single application that wants to build on top of PRISM has to re-implement the same logic. Just to name a few: managing derived private keys along with their respective DIDs, keeping track of the last operations the user has done with one of their DIDs, subscribing to the relevant operations coming from the PRISM Node instance. This brings us to this document's topic of discussion: creating a standalone PRISM wallet backend that would provide a _stateful_ API where the user would not have to take care of many of the aforementioned minute details.

This document will not provide any implementation insight, but rather discuss the problems in more details so that a separate upcoming design document can have something to base on. The following sections are going to outline the problems that the wallet backend will have to tackle.

## Managing derived private keys and DIDs that contain them
PRISM protocol follows a specific way one should derive their private keys depending on that key's usage and the index of a DID it belongs to. This topic is described in detail [here](../protocol/key-derivation.md#the-paths-used-in-our-protocol) and the reader is advised to familiarize with that document before continuing reading this section.

Normally, when a user wants to govern their identity, they don't really care how the private keys are generated and what key index is assigned to them. What the user wants in the end is to issue or revoke credentials, the way it is done is not very relevant to them. I propose to analyze the user flows and come up with a straightforward API to managing one's DIDs. For example, it is likely the case that we do not need to expose the notion of a key index to the user. Maybe it would make sense to come up with an API where a user just asks to derive a DID that is capable of issuing and revoking credentials. And then they would be able to make very straightforward operations such as issue credentials (without specifying which key to use), rotate the keys (again, no need to specify which ones to rotate), disabling DID etc.

Another important point in this section is the last used DID index. Wallet backend would have to keep track of it and save it to the Vault instance of their choosing (or maybe we want to support a wide, open-minded, range of storage facilities such as a generic S3 instance?). It would also have to be able to restore all DIDs given the root mnemonic code and Vault credentials.

## Keeping track of the relevant on-chain data
It is very important to know which operations the user submitted to the Node. Otherwise, the user will not be able to make any more operations as PRISM protocol requires submitting the last known operation hash when making a new operation in order to prevent [replay attacks](../protocol/protocol-v0.1.md#replay-attack). This means that wallet backend would need to have a reasonably scalable local persistent storage where it would store all operations it sent to PRISM Node and the ones it received from PRISM Node (see section TBD).

## Keeping track of the relevant off-chain data
There is a some data that is not supposed to be stored on-chain, but is very important to the holder of the wallet. Mainly, it is credentials' content. Wallet backend would need to be able to receive credentials, verify that the proof of their issuance was indeed posted on-chain and then save it to the local storage as well as to the connected Vault instance (if any). Similarly, issuer might want to store all credentials it has ever issued.

## Subscribing to new operations pulled from Cardano ledger
Sometimes the user is not the only owner of a DID and its credentials. Hence, when someone else makes updates to the DID or issues new credential batches using one of the controlled DIDs, the user wants to keep in sync with the new changes. To do this, wallet backend would have to [subscribe](../node/SubscriptionMechanism.md) to PRISM Node instance and listen for relevant operations.

## Integration with connector
As of point of me writing this, it is still unclear what role the connector is going to play in PRISM as a whole. Yet, communication is one of the important cornerstones of self-sovereign identity and hence wallet backend would ideally be able to handle communication with other parties in the system. Namely, keeping track of your current connections, receiving and storing messages, importing new connection tokens by external means etc. Coming up with a higher-level API for conveniently sharing/receiving credentials might potentially be beneficial as well.

# Conclusion
This proposal just scratches the very top of features we can/should implement with a standalone stateful PRISM wallet. If the wallet will ever see the light, it can be enhanced with multiple useful features such as auto-retrying rejected operations (for example if the wallet backend was not aware of some operation than happened shortly before we sent our failed operation), supporting [full-blown offline mode](../moe/full-offline-mode.md), notifying the user whenever someone makes unsolicited operations from their name and automatic key rotation (e.g. a mode that one can enable if they are sure that the DID will only ever be owned by one wallet).
