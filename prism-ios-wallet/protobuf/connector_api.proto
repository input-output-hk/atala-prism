syntax = "proto3";

package io.iohk.atala.prism.protos;

service ConnectorService {

  // Retrieve a connection for a given connection token.
  //
  // Available to: Holder, Issuer, Validator
  rpc GetConnectionByToken (GetConnectionByTokenRequest) returns (GetConnectionByTokenResponse) {}

  // Get active connections for current participant
  //
  // Available to: Holder, Issuer, Validator
  rpc GetConnectionsPaginated (GetConnectionsPaginatedRequest) returns (GetConnectionsPaginatedResponse) {}

  // Return info about connection token such as creator info
  //
  // Available to: Holder
  //
  // Errors:
  // Token does not exist (UNKNOWN)
  rpc GetConnectionTokenInfo (GetConnectionTokenInfoRequest) returns (GetConnectionTokenInfoResponse) {}

  // Instantiate connection from connection token
  //
  // Available to: Holder
  //
  // Errors:
  // Token does not exist (UNKNOWN)
  rpc AddConnectionFromToken (AddConnectionFromTokenRequest) returns (AddConnectionFromTokenResponse) {}

  // Delete active connection
  //
  // Available to: Holder, Issuer, Validator
  //
  // Errors:
  // Connection does not exist (UNKNOWN)
  rpc DeleteConnection (DeleteConnectionRequest) returns (DeleteConnectionResponse) {}

  // Bind DID to issuer
  //
  // Available to: Issuer
  //
  // Errors:
  // Invalid DID (INVALID_ARGUMENT)
  // Invalid DID document (INVALID_ARGUMENT)
  // DID Document does not match DID (INVALID_ARGUMENT)
  rpc RegisterDID (RegisterDIDRequest) returns (RegisterDIDResponse) {}

  // Change billing plan of participant who wants to generate connection tokens
  //
  // Available to: Issuer, Validator
  //
  // Errors:
  // Unknown billing plan (UNKNOWN)
  // User not allowed to set this billing plan (PERMISSION_DENIED)
  rpc ChangeBillingPlan (ChangeBillingPlanRequest) returns (ChangeBillingPlanResponse) {}

  // Generate connection token that can be used to instantiate connection
  //
  // Available to: Issuer, Validator
  //
  // Errors:
  // Billing plan doesn't allow token generation (PERMISSION_DENIED)
  rpc GenerateConnectionToken (GenerateConnectionTokenRequest) returns (GenerateConnectionTokenResponse) {}

  // Return messages received after given time moment, sorted in ascending order by receive time
  //
  // Available to: Issuer, Holder, Validator
  rpc GetMessagesPaginated (GetMessagesPaginatedRequest) returns (GetMessagesPaginatedResponse) {}

  // Stream the messages received after the given optional message
  rpc GetMessageStream (GetMessageStreamRequest) returns (stream GetMessageStreamResponse) {}

  // Return messages received on the given connection, the number is supposed to be small, so, no pagination is required.
  rpc GetMessagesForConnection (GetMessagesForConnectionRequest) returns (GetMessagesForConnectionResponse) {}

  // Returns public keys that can be used for secure communication with the other end of connection
  rpc GetConnectionCommunicationKeys (GetConnectionCommunicationKeysRequest) returns (GetConnectionCommunicationKeysResponse) {}

  // Send message over a connection
  //
  // Available to: Issuer, Holder, Validator
  //
  // Errors:
  // Unknown connection (UNKNOWN)
  // Connection closed (FAILED_PRECONDITION)
  rpc SendMessage (SendMessageRequest) returns (SendMessageResponse) {}

  // Generate a URL that can be used to do a payment
  rpc GetBraintreePaymentsConfig (GetBraintreePaymentsConfigRequest) returns (GetBraintreePaymentsConfigResponse) {}
  rpc ProcessPayment (ProcessPaymentRequest) returns (ProcessPaymentResponse);
  rpc GetPayments (GetPaymentsRequest) returns (GetPaymentsResponse);
  // Return the information about the Connector and Node builds
  rpc GetBuildInfo (GetBuildInfoRequest) returns (GetBuildInfoResponse);
  // Return the details for the authenticated user
  rpc GetCurrentUser (GetCurrentUserRequest) returns (GetCurrentUserResponse);
}

message GetConnectionByTokenRequest {
  string token = 1;
}

message GetConnectionByTokenResponse {
    io.iohk.atala.prism.protos.Connection connection = 1;
}

// Request connections instantiated by us / with us possibly after a known connection
message GetConnectionsPaginatedRequest {
  string lastSeenConnectionId = 1; // returned credentials will have been created after the last seen connection (optional field)
  int32 limit = 2; // maximum number of credentials to return; must be > 0
}

// Result with connections instantiated
message GetConnectionsPaginatedResponse {
  repeated io.iohk.atala.prism.protos.ConnectionInfo connections = 1; // connections sorted in ascending order by instantiation time
}

// Request to obtain information of connection token
message GetConnectionTokenInfoRequest {
  string token = 1; // token value to get information for
}

// Result with information on connection token
message GetConnectionTokenInfoResponse {
  io.iohk.atala.prism.protos.ParticipantInfo creator = 1; // [Will be deprecated] participant who generated the code
  string creatorName = 2; // same value as the one contained in `creator`
  bytes creatorLogo = 3; // same value as the one contained in `creator`
  string creatorDID = 4; // same value as the one contained in `creator` (if any)
}

// Request to instantiate a connection using token
message AddConnectionFromTokenRequest {
  string token = 1; // token to instantiate connection
  io.iohk.atala.prism.protos.ConnectorPublicKey holderPublicKey = 2;
  string paymentNonce = 3; // optional field, if present, we'll charge the user before adding the connection
  // Note that old clients will send the holderPublicKey instead, which we'll need to encode on the server.
  io.iohk.atala.prism.protos.EncodedPublicKey holderEncodedPublicKey = 4; // Uncompressed encoded public key
}

// Confirmation of connection instantiation
message AddConnectionFromTokenResponse {
  io.iohk.atala.prism.protos.ConnectionInfo connection = 1; // instantiated connection info
  string userId = 2; // your generated user id
}

// Request to delete a connection
message DeleteConnectionRequest {
  string connectionId = 1; // id of connection to delete
}

// Confirmation of connection deletion
message DeleteConnectionResponse {
}

// Request to generate a connection token
message GenerateConnectionTokenRequest {
}

// Result with generated token
message GenerateConnectionTokenResponse {
  string token = 1; // generated token
}

// Request to return messages for us after the given known message (if any)
message GetMessagesPaginatedRequest {
  string lastSeenMessageId = 1; // returned messages will have been received after the given message (if any)
  int32 limit = 2; // maximum number of messages to return, must be > 0
}

// Response with messages
message GetMessagesPaginatedResponse {
  repeated io.iohk.atala.prism.protos.ReceivedMessage messages = 1; // messages sorted in ascending order by receiving time
}

message GetMessageStreamRequest {
  // Last message seen by the client, so only newer messages are returned
  string lastSeenMessageId = 1;
}

message GetMessageStreamResponse {
  io.iohk.atala.prism.protos.ReceivedMessage message = 1;
}

message GetMessagesForConnectionRequest {
  string connectionId = 1;
}
message GetMessagesForConnectionResponse {
  repeated io.iohk.atala.prism.protos.ReceivedMessage messages = 1;
}

message GetConnectionCommunicationKeysRequest {
  string connectionId = 1;
}

message GetConnectionCommunicationKeysResponse {
  // keys that can be used for communication with the other end of connection with their ids
  // keyId inside might be empty if there is just one key in the collection
  repeated io.iohk.atala.prism.protos.ConnectionKey keys = 1;
}

// Request to send message
message SendMessageRequest {
  string connectionId = 1; // id of the connection
  bytes message = 2; // raw message
}

// Confirmation of message sending
message SendMessageResponse {
}

// REGISTRATION AND ACCOUNT MANAGEMENT

// Request to register DID
message RegisterDIDRequest {
  io.iohk.atala.prism.protos.SignedAtalaOperation createDIDOperation = 1;
  Role role = 2;
  string name = 3;
  bytes logo = 4;

  enum Role {
    issuer = 0;
    verifier = 1;
  }
}

message GetCurrentUserRequest {}
message GetCurrentUserResponse {
  Role role = 1;
  string name = 2;
  bytes logo = 3;

  enum Role {
    issuer = 0;
    verifier = 1;
  }
}

// Confirmation of DID registration
message RegisterDIDResponse {
  string did = 1;
  TransactionInfo transactionInfo = 2;
}

// Request to change the billing plan
message ChangeBillingPlanRequest {
  io.iohk.atala.prism.protos.BillingPlan billingPlan = 1; // new billing plan
}

// Confirmation of billing plan change
message ChangeBillingPlanResponse {
}

message GetBraintreePaymentsConfigRequest {}
message GetBraintreePaymentsConfigResponse {
  string tokenizationKey = 1;
}

message ProcessPaymentRequest {
  string amount = 1; // exact decimal amount
  string nonce = 2; // client nonce
}
message ProcessPaymentResponse {
  io.iohk.atala.prism.protos.Payment payment = 1;
}

message GetPaymentsRequest {}
message GetPaymentsResponse {
  repeated io.iohk.atala.prism.protos.Payment payments = 1;
}

message GetBuildInfoRequest {}
message GetBuildInfoResponse {
  string version = 1;
  string scalaVersion = 2;
  string sbtVersion = 3;
  string buildTime = 4;
  string nodeVersion = 5;
}



// MARK: - connector_models.proto

// GENERAL

// just an EC public key represented with big integers as strings
// TODO: merge with the node PublicKey
message ConnectorPublicKey {
    string x = 1;
    string y = 2;
}
// Public key ECPoint uncompressed encoded
message EncodedPublicKey {
    bytes publicKey = 1;
}

// Information on an Issuer
message IssuerInfo {
    string DID = 1;
    string name = 2;
    bytes logo = 3;
}

// Information on a Verifier
message VerifierInfo {
    string DID = 1;
    string name = 2;
    bytes logo = 3;
}

// Information on a Holder
message HolderInfo {
    string DID = 1;
    string name = 2;
}

// Type representing generic participant in the system, alternative of IssuerInfo, HolderInfo, or VerifierInfo.
message ParticipantInfo {
    oneof participant {
        IssuerInfo issuer = 1;
        HolderInfo holder = 2;
        VerifierInfo verifier = 3;
    }
}


// CONNECTIONS

// A connection between two parties authorizing
// the use of the connector as a messaging channel.
message Connection {
    // the connection token used to initialize the connection with the wallet
    string connectionToken = 1;
    string connectionId = 2;
}

// Information on the connection; both sides see the same connectionId and creation time, but each sees different participantInfo
message ConnectionInfo {
    string connectionId = 1;
    int64 created = 2; // moment of instantiation as milliseconds since the Unix Epoch
    ParticipantInfo participantInfo = 3; // [Will be deprecated] information about the participant at the other end
    string token = 4; // the token used to generate the connection
    string participantName = 5; // same value as the one contained in `participantInfo`
    bytes participantLogo = 6; // same value as the one contained in `participantInfo`
    string participantDID = 7; // same value as the one contained in `participantInfo`
}

// Communication key for connection participant
message ConnectionKey {
  // identifier of the key; can be empty if participant uses one key only
  string keyId = 1;
  EncodedPublicKey key = 2;
}


// MESSAGES

// Message received via a connection
message ReceivedMessage {
    string id = 1;
    int64 received = 2; // time when Connector received the message as milliseconds since the Unix Epoch
    string connectionId = 3; // connection where the message has been received
    bytes message = 4; // raw message
}

// Enumeration representing billing plan of Issuer. Possible values are hardcoded as new billing options would require implementation changes anyway.
enum BillingPlan {
    NO_PLAN = 0; // participant not able to generate connection tokens
    FREE_PLAN = 1; // connections are created for free
    SENDER_PAYS = 2; // side generating the token pays for the connection
    RECEIVER_PAYS = 3; // side receiving the token and using it to instantiate connection pays for it
}

message Payment {
    string id = 1;
    string amount = 2;
    int64 createdOn = 3;
    string status = 4;
    string failureReason = 5;
}


// MARK: - node_models.proto

message TimestampInfo {
    uint64 blockTimestamp = 1; // timestamp provided from the underlying blockchain
    uint32 blockSequenceNumber = 2; // transaction index inside the underlying blockchain block
    uint32 operationSequenceNumber = 3; // operation index inside the AtalaBlock
}

enum KeyUsage {
    // UNKNOWN_KEY is an invalid value - Protobuf uses 0 if no value is provided and we want user to explicitly choose the usage
    UNKNOWN_KEY = 0;
    MASTER_KEY = 1;
    ISSUING_KEY = 2;
    COMMUNICATION_KEY = 3;
    AUTHENTICATION_KEY = 4;
}

message ECKeyData {
    string curve = 1;
    bytes x = 2;
    bytes y = 3;
}

message PublicKey {
    string id = 1;
    KeyUsage usage = 2;
    TimestampInfo addedOn = 3;
    TimestampInfo revokedOn = 4;
    oneof keyData {
        ECKeyData ecKeyData = 8;
    };
}

message DIDData {
    string id = 1; // DID suffix, where DID is in form did:prism.atala:[DID suffix]
    repeated PublicKey publicKeys = 2;
}

message CredentialData {
    string id = 1;
    string issuer = 2;
    bytes contentHash = 3;
}

message CreateDIDOperation {
    DIDData didData = 1; // DIDData with did empty id field
}

message AddKeyAction {
    PublicKey key = 1;
}

message RemoveKeyAction {
    string keyId = 1;
}

message UpdateDIDAction {
    oneof action {
        AddKeyAction addKey = 1;
        RemoveKeyAction removeKey = 2;
    }
}

message UpdateDIDOperation {
    bytes previousOperationHash = 1;
    string id = 2;
    repeated UpdateDIDAction actions = 3;
}

message IssueCredentialOperation {
    CredentialData credentialData = 1; // credential data with id empty
}

message RevokeCredentialOperation {
    bytes previousOperationHash = 1;
    string credentialId = 2; // revoked credential id, as returned in IssueCredentialResponse
}

message CredentialBatchData {
    string issuerDID = 1;
    bytes merkleRoot = 2;
}

message IssueCredentialBatchOperation {
    CredentialBatchData credentialBatchData = 1;
}

message RevokeCredentialsOperation {
    bytes previousOperationHash = 1; // the hash of the operation that issued the batch
    string credentialBatchId = 2; // the corresponding batch id, as returned in IssueCredentialBatchResponse
    repeated bytes credentialsToRevoke = 3; // hashes of the credentials to revoke. If empty, the full batch is revoked
}

message AtalaOperation {
    oneof operation {
        CreateDIDOperation createDid = 1;
        UpdateDIDOperation updateDid = 2;
        IssueCredentialOperation issueCredential = 3;
        RevokeCredentialOperation revokeCredential = 4;
        IssueCredentialBatchOperation issueCredentialBatch = 5;
        RevokeCredentialsOperation revokeCredentials = 6;
    };
}

message SignedAtalaOperation {
    string signedWith = 1; // id of key used to sign
    bytes signature = 2; // signature of byte encoding of the operation
    AtalaOperation operation = 3;
}

// MARK: - common_models.proto

message HealthCheckRequest {}
message HealthCheckResponse {}

message Date {
    int32 year = 1; // positive value
    int32 month = 2; // value in the [1, 12] interval
    int32 day = 3; // value in the [1, 31] interval (depending on the month, the max value might be 28
}

enum Ledger {
    UNKNOWN_LEDGER = 0; // Invalid default value
    IN_MEMORY = 1;
    BITCOIN_TESTNET = 2;
    BITCOIN_MAINNET = 3;
    CARDANO_TESTNET = 4;
    CARDANO_MAINNET = 5;
}

message BlockInfo {
    int32 number = 1; // Number of the block in the ledger
    int64 timestamp = 2; // Millis since epoch when the block was created
    int32 index = 3; // Index of the transaction within the block
}

message TransactionInfo {
    string transactionId = 1; // ID of the transaction
    Ledger ledger = 2; // Ledger the transaction was published to
    BlockInfo block = 3; // Block the transaction was included in
}

enum TransactionStatus {
    UNKNOWN = 0; // The transaction is not an Atala PRISM transaction
    PENDING = 1; // The transaction is pending to be accepted by the blockchain
    IN_LEDGER = 2; // The transaction has been accepted by the blockchain, but is pending confirmation from Atala PRISM
    CONFIRMED = 3; // The transaction has been confirmed by Atala PRISM and is now considered immutable
}

// MARK: - credential_models.proto

/*
Based on requirements, diplomas need the following information

Universities
- Full name of the institution (Legal form with reference)
- Name of the qualifying / academic authority
- Decision on granting qualification / academic degree
- Issue Number
- Issue Date (day, month, year)
- Name and Surname of Graduate
- Qualified / academic degree awarded
- Additional specialty (if any)
- Name and surname of the head of the institution (Signature)
- Name and surname of persons / persons authorized to sign a diploma (Signature)

Given an example diploma we found a few extra fields present
- Registration number
- Decision number

Notoriously we see that national id number or other graduate date is not
required, only the name is.
We decided to add a SubjectData field with optional extra values for this.

In the case of schools, required information is:
- Name and surname School student
- Student's personal number (if any)
- Students Date of Birth
- Full legal name of Education institution
- Year completed by Student

We see that no signature is mentioned for the school diplomas

Given the schema below both types of certificates can be encoded, the distinction will be found
in IssuerData, where the IssuerType differentiate schools and universities
*/

message AlphaCredential {
    IssuerData issuerType = 1; // Data associated to the issuer organization. Currently University or School
    SubjectData subjectData = 2; // Personal data associated to the holder (student)
    string grantingDecision = 3; // e.g. [subject] was awarded Degree of Master Business Administration in Management
    repeated Signer signingAuthorities = 4; // head and other members of the institution that will sign the diploma
    string degreeAwarded = 5; // Degree name
    string additionalSpeciality = 6; // Optional additional speciality
    Date issuedOn = 7; // Date of issuance

    // Fields that are unclear. They may be updated or even deleted
    string issueNumber = 8; // NEED CLARIFICATION ON WHAT THIS IS
    string registrationNumber = 9; // NEED CLARIFICATION Registration number. This appears in the example diploma but it is unclear how this may relate to "Issue number"
    string decisionNumber = 10; //NEED CLARIFICATION Decision number. This appears in the example diploma but it is unclear how this may relate to "Issue number"
    string yearCompletedByStudent = 15; // WE NEED CLARIFICATIONS ON THIS FIELD. It is related to school diplomas
                                        // It may be replaceable by one of the fields related to OpenCerts. See below

    // Fields inspired from OpenCerts standard. See: https://github.com/OpenCerts/open-certificate/blob/master/schema/2.0/schema.json
    string description = 16; // Field reserved for general description of the credential
    Date expiresOn = 17;
    Date admissionDate = 18; // unclear meaning
    Date graduationDate = 19 ; // (OpenCerts description) The date that this student graduated from the course
    Date attainmentDate = 20 ; // (OpenCerts description) The date that this qualification was awarded to the recipient
    // Other fields we could add:
    /*
    qualificationLevel: (OpenCerts description) "This is an array of objects used to attach descriptors from
                         frameworks such as Singapore's SSEC-EQA or the internationally recognised ISCED. Multiple
                         instances are allowed to indicate either equivalents or to indicate a multi-level qualifications",
                         It consist of tuples of 4 strings
     fieldOfStudy: (OpenCerts description) "This is an array of objects used to attach descriptors from frameworks such
                   as Singapore's SSEC-FOS or the internationally recognised ISCED-F. Multiple instances are allowed to
                   indicate either equivalents or to indicate a multi-field qualification such as double degrees",
                   It consist of tuples of 4 strings
    cumulativeScore: Unclear description, it is a number. Probably applies to course certificates but not to degrees.
    transcript: It seems to consist of an array of data associated to each course that the student took to get the degree.
    additionalData: Unclear field without structure (a simple JSON object). It may be used to add extra data.
    */
}

message IssuerData {
    string issuerLegalName = 1; // Issuer legal name. E.g. "LLC BUSINESS AND TECHNOLOGY UNIVERSITY"
    string academicAuthority = 2; // In university case, this could be the faculty name.
                                  // E.g. Faculty of Business and Technology
    IssuerType issuerType = 3; // Issuer organization type. Currently University or School
    string did = 4; // public DID associated to the institution
    // OpenCerts adds some other data like URL, email, phone
}

message Signer {
    repeated string names = 1; // Names of the signer
    repeated string surnames = 2; // Surnames of the signer
    string role = 3; // Rector, Dean, etc.
    string did = 4; // public DID associated to the signer
    string title = 5; // Tittle to address the person. e.g. Mr, Dr, Prof, etc.
}

// For now Universites and schools.
enum IssuerType {
    University = 0;
    School = 1;
}

message SubjectData {
    repeated string names = 1; // Names of the subject.
    repeated string surnames = 2; // surnames of the subject.
    Date dateOfBirth = 3; // date of birth of the holder
    PersonalId idDocument = 4; // optional identification number of the holder
    // OpenCerts also adds phone, email, URL, studentId and unclear values "nric" and "fin".
}

message PersonalId {
    string id = 1; // unique identifier of the individual according to document type
    IdDocumentType documentType = 2; // E.g. passport, driver licence, national card
}

enum IdDocumentType {
    NationalIdCard = 0;
    Passport = 1;
}

/*
  Below we can see the messages used to exchange credentials between actors
*/
message IssuerSentCredential {
    oneof value {
        AlphaCredential alphaCredential = 1;
        Credential credential = 2;
    }
}

message Credential {
    // type id to enable dispatch to correct credential processor.
    string typeId = 1;

    // JSON or JWT encoded credential document (to discuss)
    string credentialDocument = 2;
}

message HolderSentCredential {
    AlphaCredential credential = 1;
}

message ProofRequest {
    repeated string typeIds = 1;
    string connectionToken = 2;
}

message EncryptedMessage {
    // identifier of the key used to encrypt the message; may be empty if the receiver uses only one key
    string keyId = 1;
    // encrypted content of the message; after decryption it should be deserialized as AtalaMessage instance
    bytes encryptedContent = 2;
}

message RegisterAddressMessage {
    string cardanoAddress = 1;
    string cardanoNetwork = 2;
}

message PayIdMessage {
    string paymentInformation = 1;
}

message MirrorMessage {
    oneof message {
        RegisterAddressMessage registerAddressMessage = 1;
        PayIdMessage payIdMessage = 2;
    }
}

// ATA-3250: Until we implement e2e encryption, we will share
// credentials using this message
message PlainTextCredential {
    string encodedCredential = 1; // the encoded signed credential
}

message AtalaMessage {
    oneof message {
        IssuerSentCredential issuerSentCredential = 1;
        HolderSentCredential holderSentCredential = 2;
        ProofRequest proofRequest = 3;
        EncryptedMessage encryptedMessage = 4;
        MirrorMessage mirrorMessage = 5;
        PlainTextCredential plainCredential = 6;
    }
}

