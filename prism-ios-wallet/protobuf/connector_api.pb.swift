// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: protobuf/connector_api.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Enumeration representing billing plan of Issuer. Possible values are hardcoded as new billing options would require implementation changes anyway.
enum Io_Iohk_Atala_Prism_Protos_BillingPlan: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// participant not able to generate connection tokens
  case noPlan // = 0

  /// connections are created for free
  case freePlan // = 1

  /// side generating the token pays for the connection
  case senderPays // = 2

  /// side receiving the token and using it to instantiate connection pays for it
  case receiverPays // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .noPlan
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noPlan
    case 1: self = .freePlan
    case 2: self = .senderPays
    case 3: self = .receiverPays
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .noPlan: return 0
    case .freePlan: return 1
    case .senderPays: return 2
    case .receiverPays: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Io_Iohk_Atala_Prism_Protos_BillingPlan: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Io_Iohk_Atala_Prism_Protos_BillingPlan] = [
    .noPlan,
    .freePlan,
    .senderPays,
    .receiverPays,
  ]
}

#endif  // swift(>=4.2)

enum Io_Iohk_Atala_Prism_Protos_KeyUsage: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// UNKNOWN_KEY is an invalid value - Protobuf uses 0 if no value is provided and we want user to explicitly choose the usage
  case unknownKey // = 0
  case masterKey // = 1
  case issuingKey // = 2
  case communicationKey // = 3
  case authenticationKey // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownKey
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownKey
    case 1: self = .masterKey
    case 2: self = .issuingKey
    case 3: self = .communicationKey
    case 4: self = .authenticationKey
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownKey: return 0
    case .masterKey: return 1
    case .issuingKey: return 2
    case .communicationKey: return 3
    case .authenticationKey: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Io_Iohk_Atala_Prism_Protos_KeyUsage: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Io_Iohk_Atala_Prism_Protos_KeyUsage] = [
    .unknownKey,
    .masterKey,
    .issuingKey,
    .communicationKey,
    .authenticationKey,
  ]
}

#endif  // swift(>=4.2)

enum Io_Iohk_Atala_Prism_Protos_Ledger: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Invalid default value
  case unknownLedger // = 0
  case inMemory // = 1
  case bitcoinTestnet // = 2
  case bitcoinMainnet // = 3
  case cardanoTestnet // = 4
  case cardanoMainnet // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownLedger
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownLedger
    case 1: self = .inMemory
    case 2: self = .bitcoinTestnet
    case 3: self = .bitcoinMainnet
    case 4: self = .cardanoTestnet
    case 5: self = .cardanoMainnet
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownLedger: return 0
    case .inMemory: return 1
    case .bitcoinTestnet: return 2
    case .bitcoinMainnet: return 3
    case .cardanoTestnet: return 4
    case .cardanoMainnet: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Io_Iohk_Atala_Prism_Protos_Ledger: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Io_Iohk_Atala_Prism_Protos_Ledger] = [
    .unknownLedger,
    .inMemory,
    .bitcoinTestnet,
    .bitcoinMainnet,
    .cardanoTestnet,
    .cardanoMainnet,
  ]
}

#endif  // swift(>=4.2)

enum Io_Iohk_Atala_Prism_Protos_TransactionStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// The transaction is not an Atala PRISM transaction
  case unknown // = 0

  /// The transaction is pending to be accepted by the blockchain
  case pending // = 1

  /// The transaction has been accepted by the blockchain, but is pending confirmation from Atala PRISM
  case inLedger // = 2

  /// The transaction has been confirmed by Atala PRISM and is now considered immutable
  case confirmed // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .pending
    case 2: self = .inLedger
    case 3: self = .confirmed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .pending: return 1
    case .inLedger: return 2
    case .confirmed: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Io_Iohk_Atala_Prism_Protos_TransactionStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Io_Iohk_Atala_Prism_Protos_TransactionStatus] = [
    .unknown,
    .pending,
    .inLedger,
    .confirmed,
  ]
}

#endif  // swift(>=4.2)

/// For now Universites and schools.
enum Io_Iohk_Atala_Prism_Protos_IssuerType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case university // = 0
  case school // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .university
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .university
    case 1: self = .school
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .university: return 0
    case .school: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Io_Iohk_Atala_Prism_Protos_IssuerType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Io_Iohk_Atala_Prism_Protos_IssuerType] = [
    .university,
    .school,
  ]
}

#endif  // swift(>=4.2)

enum Io_Iohk_Atala_Prism_Protos_IdDocumentType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case nationalIDCard // = 0
  case passport // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .nationalIDCard
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .nationalIDCard
    case 1: self = .passport
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .nationalIDCard: return 0
    case .passport: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Io_Iohk_Atala_Prism_Protos_IdDocumentType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Io_Iohk_Atala_Prism_Protos_IdDocumentType] = [
    .nationalIDCard,
    .passport,
  ]
}

#endif  // swift(>=4.2)

struct Io_Iohk_Atala_Prism_Protos_GetConnectionByTokenRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_GetConnectionByTokenResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var connection: Io_Iohk_Atala_Prism_Protos_Connection {
    get {return _storage._connection ?? Io_Iohk_Atala_Prism_Protos_Connection()}
    set {_uniqueStorage()._connection = newValue}
  }
  /// Returns true if `connection` has been explicitly set.
  var hasConnection: Bool {return _storage._connection != nil}
  /// Clears the value of `connection`. Subsequent reads from it will return its default value.
  mutating func clearConnection() {_uniqueStorage()._connection = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Request connections instantiated by us / with us possibly after a known connection
struct Io_Iohk_Atala_Prism_Protos_GetConnectionsPaginatedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// returned credentials will have been created after the last seen connection (optional field)
  var lastSeenConnectionID: String = String()

  /// maximum number of credentials to return; must be > 0
  var limit: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Result with connections instantiated
struct Io_Iohk_Atala_Prism_Protos_GetConnectionsPaginatedResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// connections sorted in ascending order by instantiation time
  var connections: [Io_Iohk_Atala_Prism_Protos_ConnectionInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request to obtain information of connection token
struct Io_Iohk_Atala_Prism_Protos_GetConnectionTokenInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// token value to get information for
  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Result with information on connection token
struct Io_Iohk_Atala_Prism_Protos_GetConnectionTokenInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// [Will be deprecated] participant who generated the code
  var creator: Io_Iohk_Atala_Prism_Protos_ParticipantInfo {
    get {return _storage._creator ?? Io_Iohk_Atala_Prism_Protos_ParticipantInfo()}
    set {_uniqueStorage()._creator = newValue}
  }
  /// Returns true if `creator` has been explicitly set.
  var hasCreator: Bool {return _storage._creator != nil}
  /// Clears the value of `creator`. Subsequent reads from it will return its default value.
  mutating func clearCreator() {_uniqueStorage()._creator = nil}

  /// same value as the one contained in `creator`
  var creatorName: String {
    get {return _storage._creatorName}
    set {_uniqueStorage()._creatorName = newValue}
  }

  /// same value as the one contained in `creator`
  var creatorLogo: Data {
    get {return _storage._creatorLogo}
    set {_uniqueStorage()._creatorLogo = newValue}
  }

  /// same value as the one contained in `creator` (if any)
  var creatorDid: String {
    get {return _storage._creatorDid}
    set {_uniqueStorage()._creatorDid = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Request to instantiate a connection using token
struct Io_Iohk_Atala_Prism_Protos_AddConnectionFromTokenRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// token to instantiate connection
  var token: String {
    get {return _storage._token}
    set {_uniqueStorage()._token = newValue}
  }

  var holderPublicKey: Io_Iohk_Atala_Prism_Protos_ConnectorPublicKey {
    get {return _storage._holderPublicKey ?? Io_Iohk_Atala_Prism_Protos_ConnectorPublicKey()}
    set {_uniqueStorage()._holderPublicKey = newValue}
  }
  /// Returns true if `holderPublicKey` has been explicitly set.
  var hasHolderPublicKey: Bool {return _storage._holderPublicKey != nil}
  /// Clears the value of `holderPublicKey`. Subsequent reads from it will return its default value.
  mutating func clearHolderPublicKey() {_uniqueStorage()._holderPublicKey = nil}

  /// optional field, if present, we'll charge the user before adding the connection
  var paymentNonce: String {
    get {return _storage._paymentNonce}
    set {_uniqueStorage()._paymentNonce = newValue}
  }

  /// Note that old clients will send the holderPublicKey instead, which we'll need to encode on the server.
  var holderEncodedPublicKey: Io_Iohk_Atala_Prism_Protos_EncodedPublicKey {
    get {return _storage._holderEncodedPublicKey ?? Io_Iohk_Atala_Prism_Protos_EncodedPublicKey()}
    set {_uniqueStorage()._holderEncodedPublicKey = newValue}
  }
  /// Returns true if `holderEncodedPublicKey` has been explicitly set.
  var hasHolderEncodedPublicKey: Bool {return _storage._holderEncodedPublicKey != nil}
  /// Clears the value of `holderEncodedPublicKey`. Subsequent reads from it will return its default value.
  mutating func clearHolderEncodedPublicKey() {_uniqueStorage()._holderEncodedPublicKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Confirmation of connection instantiation
struct Io_Iohk_Atala_Prism_Protos_AddConnectionFromTokenResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// instantiated connection info
  var connection: Io_Iohk_Atala_Prism_Protos_ConnectionInfo {
    get {return _storage._connection ?? Io_Iohk_Atala_Prism_Protos_ConnectionInfo()}
    set {_uniqueStorage()._connection = newValue}
  }
  /// Returns true if `connection` has been explicitly set.
  var hasConnection: Bool {return _storage._connection != nil}
  /// Clears the value of `connection`. Subsequent reads from it will return its default value.
  mutating func clearConnection() {_uniqueStorage()._connection = nil}

  /// your generated user id
  var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Request to delete a connection
struct Io_Iohk_Atala_Prism_Protos_DeleteConnectionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id of connection to delete
  var connectionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Confirmation of connection deletion
struct Io_Iohk_Atala_Prism_Protos_DeleteConnectionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request to generate a connection token
struct Io_Iohk_Atala_Prism_Protos_GenerateConnectionTokenRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Result with generated token
struct Io_Iohk_Atala_Prism_Protos_GenerateConnectionTokenResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// generated token
  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request to return messages for us after the given known message (if any)
struct Io_Iohk_Atala_Prism_Protos_GetMessagesPaginatedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// returned messages will have been received after the given message (if any)
  var lastSeenMessageID: String = String()

  /// maximum number of messages to return, must be > 0
  var limit: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response with messages
struct Io_Iohk_Atala_Prism_Protos_GetMessagesPaginatedResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// messages sorted in ascending order by receiving time
  var messages: [Io_Iohk_Atala_Prism_Protos_ReceivedMessage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_GetMessageStreamRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Last message seen by the client, so only newer messages are returned
  var lastSeenMessageID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_GetMessageStreamResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: Io_Iohk_Atala_Prism_Protos_ReceivedMessage {
    get {return _storage._message ?? Io_Iohk_Atala_Prism_Protos_ReceivedMessage()}
    set {_uniqueStorage()._message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return _storage._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {_uniqueStorage()._message = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Io_Iohk_Atala_Prism_Protos_GetMessagesForConnectionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var connectionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_GetMessagesForConnectionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var messages: [Io_Iohk_Atala_Prism_Protos_ReceivedMessage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_GetConnectionCommunicationKeysRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var connectionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_GetConnectionCommunicationKeysResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// keys that can be used for communication with the other end of connection with their ids
  /// keyId inside might be empty if there is just one key in the collection
  var keys: [Io_Iohk_Atala_Prism_Protos_ConnectionKey] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request to send message
struct Io_Iohk_Atala_Prism_Protos_SendMessageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id of the connection
  var connectionID: String = String()

  /// raw message
  var message: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Confirmation of message sending
struct Io_Iohk_Atala_Prism_Protos_SendMessageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request to register DID
struct Io_Iohk_Atala_Prism_Protos_RegisterDIDRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var createDidoperation: Io_Iohk_Atala_Prism_Protos_SignedAtalaOperation {
    get {return _storage._createDidoperation ?? Io_Iohk_Atala_Prism_Protos_SignedAtalaOperation()}
    set {_uniqueStorage()._createDidoperation = newValue}
  }
  /// Returns true if `createDidoperation` has been explicitly set.
  var hasCreateDidoperation: Bool {return _storage._createDidoperation != nil}
  /// Clears the value of `createDidoperation`. Subsequent reads from it will return its default value.
  mutating func clearCreateDidoperation() {_uniqueStorage()._createDidoperation = nil}

  var role: Io_Iohk_Atala_Prism_Protos_RegisterDIDRequest.Role {
    get {return _storage._role}
    set {_uniqueStorage()._role = newValue}
  }

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var logo: Data {
    get {return _storage._logo}
    set {_uniqueStorage()._logo = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Role: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case issuer // = 0
    case verifier // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .issuer
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .issuer
      case 1: self = .verifier
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .issuer: return 0
      case .verifier: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Io_Iohk_Atala_Prism_Protos_RegisterDIDRequest.Role: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Io_Iohk_Atala_Prism_Protos_RegisterDIDRequest.Role] = [
    .issuer,
    .verifier,
  ]
}

#endif  // swift(>=4.2)

struct Io_Iohk_Atala_Prism_Protos_GetCurrentUserRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_GetCurrentUserResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var role: Io_Iohk_Atala_Prism_Protos_GetCurrentUserResponse.Role = .issuer

  var name: String = String()

  var logo: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Role: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case issuer // = 0
    case verifier // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .issuer
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .issuer
      case 1: self = .verifier
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .issuer: return 0
      case .verifier: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Io_Iohk_Atala_Prism_Protos_GetCurrentUserResponse.Role: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Io_Iohk_Atala_Prism_Protos_GetCurrentUserResponse.Role] = [
    .issuer,
    .verifier,
  ]
}

#endif  // swift(>=4.2)

/// Confirmation of DID registration
struct Io_Iohk_Atala_Prism_Protos_RegisterDIDResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var did: String {
    get {return _storage._did}
    set {_uniqueStorage()._did = newValue}
  }

  var transactionInfo: Io_Iohk_Atala_Prism_Protos_TransactionInfo {
    get {return _storage._transactionInfo ?? Io_Iohk_Atala_Prism_Protos_TransactionInfo()}
    set {_uniqueStorage()._transactionInfo = newValue}
  }
  /// Returns true if `transactionInfo` has been explicitly set.
  var hasTransactionInfo: Bool {return _storage._transactionInfo != nil}
  /// Clears the value of `transactionInfo`. Subsequent reads from it will return its default value.
  mutating func clearTransactionInfo() {_uniqueStorage()._transactionInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Request to change the billing plan
struct Io_Iohk_Atala_Prism_Protos_ChangeBillingPlanRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// new billing plan
  var billingPlan: Io_Iohk_Atala_Prism_Protos_BillingPlan = .noPlan

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Confirmation of billing plan change
struct Io_Iohk_Atala_Prism_Protos_ChangeBillingPlanResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_GetBraintreePaymentsConfigRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_GetBraintreePaymentsConfigResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tokenizationKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_ProcessPaymentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// exact decimal amount
  var amount: String = String()

  /// client nonce
  var nonce: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_ProcessPaymentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var payment: Io_Iohk_Atala_Prism_Protos_Payment {
    get {return _storage._payment ?? Io_Iohk_Atala_Prism_Protos_Payment()}
    set {_uniqueStorage()._payment = newValue}
  }
  /// Returns true if `payment` has been explicitly set.
  var hasPayment: Bool {return _storage._payment != nil}
  /// Clears the value of `payment`. Subsequent reads from it will return its default value.
  mutating func clearPayment() {_uniqueStorage()._payment = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Io_Iohk_Atala_Prism_Protos_GetPaymentsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_GetPaymentsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var payments: [Io_Iohk_Atala_Prism_Protos_Payment] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_GetBuildInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_GetBuildInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: String = String()

  var scalaVersion: String = String()

  var sbtVersion: String = String()

  var buildTime: String = String()

  var nodeVersion: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// just an EC public key represented with big integers as strings
/// TODO: merge with the node PublicKey
struct Io_Iohk_Atala_Prism_Protos_ConnectorPublicKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: String = String()

  var y: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Public key ECPoint uncompressed encoded
struct Io_Iohk_Atala_Prism_Protos_EncodedPublicKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publicKey: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Information on an Issuer
struct Io_Iohk_Atala_Prism_Protos_IssuerInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var did: String = String()

  var name: String = String()

  var logo: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Information on a Verifier
struct Io_Iohk_Atala_Prism_Protos_VerifierInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var did: String = String()

  var name: String = String()

  var logo: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Information on a Holder
struct Io_Iohk_Atala_Prism_Protos_HolderInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var did: String = String()

  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Type representing generic participant in the system, alternative of IssuerInfo, HolderInfo, or VerifierInfo.
struct Io_Iohk_Atala_Prism_Protos_ParticipantInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var participant: OneOf_Participant? {
    get {return _storage._participant}
    set {_uniqueStorage()._participant = newValue}
  }

  var issuer: Io_Iohk_Atala_Prism_Protos_IssuerInfo {
    get {
      if case .issuer(let v)? = _storage._participant {return v}
      return Io_Iohk_Atala_Prism_Protos_IssuerInfo()
    }
    set {_uniqueStorage()._participant = .issuer(newValue)}
  }

  var holder: Io_Iohk_Atala_Prism_Protos_HolderInfo {
    get {
      if case .holder(let v)? = _storage._participant {return v}
      return Io_Iohk_Atala_Prism_Protos_HolderInfo()
    }
    set {_uniqueStorage()._participant = .holder(newValue)}
  }

  var verifier: Io_Iohk_Atala_Prism_Protos_VerifierInfo {
    get {
      if case .verifier(let v)? = _storage._participant {return v}
      return Io_Iohk_Atala_Prism_Protos_VerifierInfo()
    }
    set {_uniqueStorage()._participant = .verifier(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Participant: Equatable {
    case issuer(Io_Iohk_Atala_Prism_Protos_IssuerInfo)
    case holder(Io_Iohk_Atala_Prism_Protos_HolderInfo)
    case verifier(Io_Iohk_Atala_Prism_Protos_VerifierInfo)

  #if !swift(>=4.1)
    static func ==(lhs: Io_Iohk_Atala_Prism_Protos_ParticipantInfo.OneOf_Participant, rhs: Io_Iohk_Atala_Prism_Protos_ParticipantInfo.OneOf_Participant) -> Bool {
      switch (lhs, rhs) {
      case (.issuer(let l), .issuer(let r)): return l == r
      case (.holder(let l), .holder(let r)): return l == r
      case (.verifier(let l), .verifier(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A connection between two parties authorizing
/// the use of the connector as a messaging channel.
struct Io_Iohk_Atala_Prism_Protos_Connection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the connection token used to initialize the connection with the wallet
  var connectionToken: String = String()

  var connectionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Information on the connection; both sides see the same connectionId and creation time, but each sees different participantInfo
struct Io_Iohk_Atala_Prism_Protos_ConnectionInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var connectionID: String {
    get {return _storage._connectionID}
    set {_uniqueStorage()._connectionID = newValue}
  }

  /// moment of instantiation as milliseconds since the Unix Epoch
  var created: Int64 {
    get {return _storage._created}
    set {_uniqueStorage()._created = newValue}
  }

  /// [Will be deprecated] information about the participant at the other end
  var participantInfo: Io_Iohk_Atala_Prism_Protos_ParticipantInfo {
    get {return _storage._participantInfo ?? Io_Iohk_Atala_Prism_Protos_ParticipantInfo()}
    set {_uniqueStorage()._participantInfo = newValue}
  }
  /// Returns true if `participantInfo` has been explicitly set.
  var hasParticipantInfo: Bool {return _storage._participantInfo != nil}
  /// Clears the value of `participantInfo`. Subsequent reads from it will return its default value.
  mutating func clearParticipantInfo() {_uniqueStorage()._participantInfo = nil}

  /// the token used to generate the connection
  var token: String {
    get {return _storage._token}
    set {_uniqueStorage()._token = newValue}
  }

  /// same value as the one contained in `participantInfo`
  var participantName: String {
    get {return _storage._participantName}
    set {_uniqueStorage()._participantName = newValue}
  }

  /// same value as the one contained in `participantInfo`
  var participantLogo: Data {
    get {return _storage._participantLogo}
    set {_uniqueStorage()._participantLogo = newValue}
  }

  /// same value as the one contained in `participantInfo`
  var participantDid: String {
    get {return _storage._participantDid}
    set {_uniqueStorage()._participantDid = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Communication key for connection participant
struct Io_Iohk_Atala_Prism_Protos_ConnectionKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// identifier of the key; can be empty if participant uses one key only
  var keyID: String {
    get {return _storage._keyID}
    set {_uniqueStorage()._keyID = newValue}
  }

  var key: Io_Iohk_Atala_Prism_Protos_EncodedPublicKey {
    get {return _storage._key ?? Io_Iohk_Atala_Prism_Protos_EncodedPublicKey()}
    set {_uniqueStorage()._key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return _storage._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {_uniqueStorage()._key = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Message received via a connection
struct Io_Iohk_Atala_Prism_Protos_ReceivedMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  /// time when Connector received the message as milliseconds since the Unix Epoch
  var received: Int64 = 0

  /// connection where the message has been received
  var connectionID: String = String()

  /// raw message
  var message: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_Payment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var amount: String = String()

  var createdOn: Int64 = 0

  var status: String = String()

  var failureReason: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_TimestampInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// timestamp provided from the underlying blockchain
  var blockTimestamp: UInt64 = 0

  /// transaction index inside the underlying blockchain block
  var blockSequenceNumber: UInt32 = 0

  /// operation index inside the AtalaBlock
  var operationSequenceNumber: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_ECKeyData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var curve: String = String()

  var x: Data = SwiftProtobuf.Internal.emptyData

  var y: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_PublicKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var usage: Io_Iohk_Atala_Prism_Protos_KeyUsage {
    get {return _storage._usage}
    set {_uniqueStorage()._usage = newValue}
  }

  var addedOn: Io_Iohk_Atala_Prism_Protos_TimestampInfo {
    get {return _storage._addedOn ?? Io_Iohk_Atala_Prism_Protos_TimestampInfo()}
    set {_uniqueStorage()._addedOn = newValue}
  }
  /// Returns true if `addedOn` has been explicitly set.
  var hasAddedOn: Bool {return _storage._addedOn != nil}
  /// Clears the value of `addedOn`. Subsequent reads from it will return its default value.
  mutating func clearAddedOn() {_uniqueStorage()._addedOn = nil}

  var revokedOn: Io_Iohk_Atala_Prism_Protos_TimestampInfo {
    get {return _storage._revokedOn ?? Io_Iohk_Atala_Prism_Protos_TimestampInfo()}
    set {_uniqueStorage()._revokedOn = newValue}
  }
  /// Returns true if `revokedOn` has been explicitly set.
  var hasRevokedOn: Bool {return _storage._revokedOn != nil}
  /// Clears the value of `revokedOn`. Subsequent reads from it will return its default value.
  mutating func clearRevokedOn() {_uniqueStorage()._revokedOn = nil}

  var keyData: OneOf_KeyData? {
    get {return _storage._keyData}
    set {_uniqueStorage()._keyData = newValue}
  }

  var ecKeyData: Io_Iohk_Atala_Prism_Protos_ECKeyData {
    get {
      if case .ecKeyData(let v)? = _storage._keyData {return v}
      return Io_Iohk_Atala_Prism_Protos_ECKeyData()
    }
    set {_uniqueStorage()._keyData = .ecKeyData(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_KeyData: Equatable {
    case ecKeyData(Io_Iohk_Atala_Prism_Protos_ECKeyData)

  #if !swift(>=4.1)
    static func ==(lhs: Io_Iohk_Atala_Prism_Protos_PublicKey.OneOf_KeyData, rhs: Io_Iohk_Atala_Prism_Protos_PublicKey.OneOf_KeyData) -> Bool {
      switch (lhs, rhs) {
      case (.ecKeyData(let l), .ecKeyData(let r)): return l == r
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Io_Iohk_Atala_Prism_Protos_DIDData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// DID suffix, where DID is in form did:prism.atala:[DID suffix]
  var id: String = String()

  var publicKeys: [Io_Iohk_Atala_Prism_Protos_PublicKey] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_CredentialData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var issuer: String = String()

  var contentHash: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_CreateDIDOperation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// DIDData with did empty id field
  var didData: Io_Iohk_Atala_Prism_Protos_DIDData {
    get {return _storage._didData ?? Io_Iohk_Atala_Prism_Protos_DIDData()}
    set {_uniqueStorage()._didData = newValue}
  }
  /// Returns true if `didData` has been explicitly set.
  var hasDidData: Bool {return _storage._didData != nil}
  /// Clears the value of `didData`. Subsequent reads from it will return its default value.
  mutating func clearDidData() {_uniqueStorage()._didData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Io_Iohk_Atala_Prism_Protos_AddKeyAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: Io_Iohk_Atala_Prism_Protos_PublicKey {
    get {return _storage._key ?? Io_Iohk_Atala_Prism_Protos_PublicKey()}
    set {_uniqueStorage()._key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return _storage._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {_uniqueStorage()._key = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Io_Iohk_Atala_Prism_Protos_RemoveKeyAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keyID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_UpdateDIDAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var action: OneOf_Action? {
    get {return _storage._action}
    set {_uniqueStorage()._action = newValue}
  }

  var addKey: Io_Iohk_Atala_Prism_Protos_AddKeyAction {
    get {
      if case .addKey(let v)? = _storage._action {return v}
      return Io_Iohk_Atala_Prism_Protos_AddKeyAction()
    }
    set {_uniqueStorage()._action = .addKey(newValue)}
  }

  var removeKey: Io_Iohk_Atala_Prism_Protos_RemoveKeyAction {
    get {
      if case .removeKey(let v)? = _storage._action {return v}
      return Io_Iohk_Atala_Prism_Protos_RemoveKeyAction()
    }
    set {_uniqueStorage()._action = .removeKey(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Action: Equatable {
    case addKey(Io_Iohk_Atala_Prism_Protos_AddKeyAction)
    case removeKey(Io_Iohk_Atala_Prism_Protos_RemoveKeyAction)

  #if !swift(>=4.1)
    static func ==(lhs: Io_Iohk_Atala_Prism_Protos_UpdateDIDAction.OneOf_Action, rhs: Io_Iohk_Atala_Prism_Protos_UpdateDIDAction.OneOf_Action) -> Bool {
      switch (lhs, rhs) {
      case (.addKey(let l), .addKey(let r)): return l == r
      case (.removeKey(let l), .removeKey(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Io_Iohk_Atala_Prism_Protos_UpdateDIDOperation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var previousOperationHash: Data = SwiftProtobuf.Internal.emptyData

  var id: String = String()

  var actions: [Io_Iohk_Atala_Prism_Protos_UpdateDIDAction] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_IssueCredentialOperation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// credential data with id empty
  var credentialData: Io_Iohk_Atala_Prism_Protos_CredentialData {
    get {return _storage._credentialData ?? Io_Iohk_Atala_Prism_Protos_CredentialData()}
    set {_uniqueStorage()._credentialData = newValue}
  }
  /// Returns true if `credentialData` has been explicitly set.
  var hasCredentialData: Bool {return _storage._credentialData != nil}
  /// Clears the value of `credentialData`. Subsequent reads from it will return its default value.
  mutating func clearCredentialData() {_uniqueStorage()._credentialData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Io_Iohk_Atala_Prism_Protos_RevokeCredentialOperation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var previousOperationHash: Data = SwiftProtobuf.Internal.emptyData

  /// revoked credential id, as returned in IssueCredentialResponse
  var credentialID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_CredentialBatchData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var issuerDid: String = String()

  var merkleRoot: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_IssueCredentialBatchOperation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var credentialBatchData: Io_Iohk_Atala_Prism_Protos_CredentialBatchData {
    get {return _storage._credentialBatchData ?? Io_Iohk_Atala_Prism_Protos_CredentialBatchData()}
    set {_uniqueStorage()._credentialBatchData = newValue}
  }
  /// Returns true if `credentialBatchData` has been explicitly set.
  var hasCredentialBatchData: Bool {return _storage._credentialBatchData != nil}
  /// Clears the value of `credentialBatchData`. Subsequent reads from it will return its default value.
  mutating func clearCredentialBatchData() {_uniqueStorage()._credentialBatchData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Io_Iohk_Atala_Prism_Protos_RevokeCredentialsOperation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the hash of the operation that issued the batch
  var previousOperationHash: Data = SwiftProtobuf.Internal.emptyData

  /// the corresponding batch id, as returned in IssueCredentialBatchResponse
  var credentialBatchID: String = String()

  /// hashes of the credentials to revoke. If empty, the full batch is revoked
  var credentialsToRevoke: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_AtalaOperation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var operation: OneOf_Operation? {
    get {return _storage._operation}
    set {_uniqueStorage()._operation = newValue}
  }

  var createDid: Io_Iohk_Atala_Prism_Protos_CreateDIDOperation {
    get {
      if case .createDid(let v)? = _storage._operation {return v}
      return Io_Iohk_Atala_Prism_Protos_CreateDIDOperation()
    }
    set {_uniqueStorage()._operation = .createDid(newValue)}
  }

  var updateDid: Io_Iohk_Atala_Prism_Protos_UpdateDIDOperation {
    get {
      if case .updateDid(let v)? = _storage._operation {return v}
      return Io_Iohk_Atala_Prism_Protos_UpdateDIDOperation()
    }
    set {_uniqueStorage()._operation = .updateDid(newValue)}
  }

  var issueCredential: Io_Iohk_Atala_Prism_Protos_IssueCredentialOperation {
    get {
      if case .issueCredential(let v)? = _storage._operation {return v}
      return Io_Iohk_Atala_Prism_Protos_IssueCredentialOperation()
    }
    set {_uniqueStorage()._operation = .issueCredential(newValue)}
  }

  var revokeCredential: Io_Iohk_Atala_Prism_Protos_RevokeCredentialOperation {
    get {
      if case .revokeCredential(let v)? = _storage._operation {return v}
      return Io_Iohk_Atala_Prism_Protos_RevokeCredentialOperation()
    }
    set {_uniqueStorage()._operation = .revokeCredential(newValue)}
  }

  var issueCredentialBatch: Io_Iohk_Atala_Prism_Protos_IssueCredentialBatchOperation {
    get {
      if case .issueCredentialBatch(let v)? = _storage._operation {return v}
      return Io_Iohk_Atala_Prism_Protos_IssueCredentialBatchOperation()
    }
    set {_uniqueStorage()._operation = .issueCredentialBatch(newValue)}
  }

  var revokeCredentials: Io_Iohk_Atala_Prism_Protos_RevokeCredentialsOperation {
    get {
      if case .revokeCredentials(let v)? = _storage._operation {return v}
      return Io_Iohk_Atala_Prism_Protos_RevokeCredentialsOperation()
    }
    set {_uniqueStorage()._operation = .revokeCredentials(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Operation: Equatable {
    case createDid(Io_Iohk_Atala_Prism_Protos_CreateDIDOperation)
    case updateDid(Io_Iohk_Atala_Prism_Protos_UpdateDIDOperation)
    case issueCredential(Io_Iohk_Atala_Prism_Protos_IssueCredentialOperation)
    case revokeCredential(Io_Iohk_Atala_Prism_Protos_RevokeCredentialOperation)
    case issueCredentialBatch(Io_Iohk_Atala_Prism_Protos_IssueCredentialBatchOperation)
    case revokeCredentials(Io_Iohk_Atala_Prism_Protos_RevokeCredentialsOperation)

  #if !swift(>=4.1)
    static func ==(lhs: Io_Iohk_Atala_Prism_Protos_AtalaOperation.OneOf_Operation, rhs: Io_Iohk_Atala_Prism_Protos_AtalaOperation.OneOf_Operation) -> Bool {
      switch (lhs, rhs) {
      case (.createDid(let l), .createDid(let r)): return l == r
      case (.updateDid(let l), .updateDid(let r)): return l == r
      case (.issueCredential(let l), .issueCredential(let r)): return l == r
      case (.revokeCredential(let l), .revokeCredential(let r)): return l == r
      case (.issueCredentialBatch(let l), .issueCredentialBatch(let r)): return l == r
      case (.revokeCredentials(let l), .revokeCredentials(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Io_Iohk_Atala_Prism_Protos_SignedAtalaOperation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id of key used to sign
  var signedWith: String {
    get {return _storage._signedWith}
    set {_uniqueStorage()._signedWith = newValue}
  }

  /// signature of byte encoding of the operation
  var signature: Data {
    get {return _storage._signature}
    set {_uniqueStorage()._signature = newValue}
  }

  var operation: Io_Iohk_Atala_Prism_Protos_AtalaOperation {
    get {return _storage._operation ?? Io_Iohk_Atala_Prism_Protos_AtalaOperation()}
    set {_uniqueStorage()._operation = newValue}
  }
  /// Returns true if `operation` has been explicitly set.
  var hasOperation: Bool {return _storage._operation != nil}
  /// Clears the value of `operation`. Subsequent reads from it will return its default value.
  mutating func clearOperation() {_uniqueStorage()._operation = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Io_Iohk_Atala_Prism_Protos_HealthCheckRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_HealthCheckResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_Date {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// positive value
  var year: Int32 = 0

  /// value in the [1, 12] interval
  var month: Int32 = 0

  /// value in the [1, 31] interval (depending on the month, the max value might be 28
  var day: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_BlockInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Number of the block in the ledger
  var number: Int32 = 0

  /// Millis since epoch when the block was created
  var timestamp: Int64 = 0

  /// Index of the transaction within the block
  var index: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_TransactionInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the transaction
  var transactionID: String {
    get {return _storage._transactionID}
    set {_uniqueStorage()._transactionID = newValue}
  }

  /// Ledger the transaction was published to
  var ledger: Io_Iohk_Atala_Prism_Protos_Ledger {
    get {return _storage._ledger}
    set {_uniqueStorage()._ledger = newValue}
  }

  /// Block the transaction was included in
  var block: Io_Iohk_Atala_Prism_Protos_BlockInfo {
    get {return _storage._block ?? Io_Iohk_Atala_Prism_Protos_BlockInfo()}
    set {_uniqueStorage()._block = newValue}
  }
  /// Returns true if `block` has been explicitly set.
  var hasBlock: Bool {return _storage._block != nil}
  /// Clears the value of `block`. Subsequent reads from it will return its default value.
  mutating func clearBlock() {_uniqueStorage()._block = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Io_Iohk_Atala_Prism_Protos_AlphaCredential {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Data associated to the issuer organization. Currently University or School
  var issuerType: Io_Iohk_Atala_Prism_Protos_IssuerData {
    get {return _storage._issuerType ?? Io_Iohk_Atala_Prism_Protos_IssuerData()}
    set {_uniqueStorage()._issuerType = newValue}
  }
  /// Returns true if `issuerType` has been explicitly set.
  var hasIssuerType: Bool {return _storage._issuerType != nil}
  /// Clears the value of `issuerType`. Subsequent reads from it will return its default value.
  mutating func clearIssuerType() {_uniqueStorage()._issuerType = nil}

  /// Personal data associated to the holder (student)
  var subjectData: Io_Iohk_Atala_Prism_Protos_SubjectData {
    get {return _storage._subjectData ?? Io_Iohk_Atala_Prism_Protos_SubjectData()}
    set {_uniqueStorage()._subjectData = newValue}
  }
  /// Returns true if `subjectData` has been explicitly set.
  var hasSubjectData: Bool {return _storage._subjectData != nil}
  /// Clears the value of `subjectData`. Subsequent reads from it will return its default value.
  mutating func clearSubjectData() {_uniqueStorage()._subjectData = nil}

  /// e.g. [subject] was awarded Degree of Master Business Administration in Management
  var grantingDecision: String {
    get {return _storage._grantingDecision}
    set {_uniqueStorage()._grantingDecision = newValue}
  }

  /// head and other members of the institution that will sign the diploma
  var signingAuthorities: [Io_Iohk_Atala_Prism_Protos_Signer] {
    get {return _storage._signingAuthorities}
    set {_uniqueStorage()._signingAuthorities = newValue}
  }

  /// Degree name
  var degreeAwarded: String {
    get {return _storage._degreeAwarded}
    set {_uniqueStorage()._degreeAwarded = newValue}
  }

  /// Optional additional speciality
  var additionalSpeciality: String {
    get {return _storage._additionalSpeciality}
    set {_uniqueStorage()._additionalSpeciality = newValue}
  }

  /// Date of issuance
  var issuedOn: Io_Iohk_Atala_Prism_Protos_Date {
    get {return _storage._issuedOn ?? Io_Iohk_Atala_Prism_Protos_Date()}
    set {_uniqueStorage()._issuedOn = newValue}
  }
  /// Returns true if `issuedOn` has been explicitly set.
  var hasIssuedOn: Bool {return _storage._issuedOn != nil}
  /// Clears the value of `issuedOn`. Subsequent reads from it will return its default value.
  mutating func clearIssuedOn() {_uniqueStorage()._issuedOn = nil}

  /// Fields that are unclear. They may be updated or even deleted
  var issueNumber: String {
    get {return _storage._issueNumber}
    set {_uniqueStorage()._issueNumber = newValue}
  }

  /// NEED CLARIFICATION Registration number. This appears in the example diploma but it is unclear how this may relate to "Issue number"
  var registrationNumber: String {
    get {return _storage._registrationNumber}
    set {_uniqueStorage()._registrationNumber = newValue}
  }

  ///NEED CLARIFICATION Decision number. This appears in the example diploma but it is unclear how this may relate to "Issue number"
  var decisionNumber: String {
    get {return _storage._decisionNumber}
    set {_uniqueStorage()._decisionNumber = newValue}
  }

  /// WE NEED CLARIFICATIONS ON THIS FIELD. It is related to school diplomas
  var yearCompletedByStudent: String {
    get {return _storage._yearCompletedByStudent}
    set {_uniqueStorage()._yearCompletedByStudent = newValue}
  }

  /// Fields inspired from OpenCerts standard. See: https://github.com/OpenCerts/open-certificate/blob/master/schema/2.0/schema.json
  var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  var expiresOn: Io_Iohk_Atala_Prism_Protos_Date {
    get {return _storage._expiresOn ?? Io_Iohk_Atala_Prism_Protos_Date()}
    set {_uniqueStorage()._expiresOn = newValue}
  }
  /// Returns true if `expiresOn` has been explicitly set.
  var hasExpiresOn: Bool {return _storage._expiresOn != nil}
  /// Clears the value of `expiresOn`. Subsequent reads from it will return its default value.
  mutating func clearExpiresOn() {_uniqueStorage()._expiresOn = nil}

  /// unclear meaning
  var admissionDate: Io_Iohk_Atala_Prism_Protos_Date {
    get {return _storage._admissionDate ?? Io_Iohk_Atala_Prism_Protos_Date()}
    set {_uniqueStorage()._admissionDate = newValue}
  }
  /// Returns true if `admissionDate` has been explicitly set.
  var hasAdmissionDate: Bool {return _storage._admissionDate != nil}
  /// Clears the value of `admissionDate`. Subsequent reads from it will return its default value.
  mutating func clearAdmissionDate() {_uniqueStorage()._admissionDate = nil}

  /// (OpenCerts description) The date that this student graduated from the course
  var graduationDate: Io_Iohk_Atala_Prism_Protos_Date {
    get {return _storage._graduationDate ?? Io_Iohk_Atala_Prism_Protos_Date()}
    set {_uniqueStorage()._graduationDate = newValue}
  }
  /// Returns true if `graduationDate` has been explicitly set.
  var hasGraduationDate: Bool {return _storage._graduationDate != nil}
  /// Clears the value of `graduationDate`. Subsequent reads from it will return its default value.
  mutating func clearGraduationDate() {_uniqueStorage()._graduationDate = nil}

  /// (OpenCerts description) The date that this qualification was awarded to the recipient
  var attainmentDate: Io_Iohk_Atala_Prism_Protos_Date {
    get {return _storage._attainmentDate ?? Io_Iohk_Atala_Prism_Protos_Date()}
    set {_uniqueStorage()._attainmentDate = newValue}
  }
  /// Returns true if `attainmentDate` has been explicitly set.
  var hasAttainmentDate: Bool {return _storage._attainmentDate != nil}
  /// Clears the value of `attainmentDate`. Subsequent reads from it will return its default value.
  mutating func clearAttainmentDate() {_uniqueStorage()._attainmentDate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Io_Iohk_Atala_Prism_Protos_IssuerData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Issuer legal name. E.g. "LLC BUSINESS AND TECHNOLOGY UNIVERSITY"
  var issuerLegalName: String = String()

  /// In university case, this could be the faculty name.
  var academicAuthority: String = String()

  /// E.g. Faculty of Business and Technology
  var issuerType: Io_Iohk_Atala_Prism_Protos_IssuerType = .university

  /// public DID associated to the institution
  var did: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_Signer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Names of the signer
  var names: [String] = []

  /// Surnames of the signer
  var surnames: [String] = []

  /// Rector, Dean, etc.
  var role: String = String()

  /// public DID associated to the signer
  var did: String = String()

  /// Tittle to address the person. e.g. Mr, Dr, Prof, etc.
  var title: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_SubjectData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Names of the subject.
  var names: [String] {
    get {return _storage._names}
    set {_uniqueStorage()._names = newValue}
  }

  /// surnames of the subject.
  var surnames: [String] {
    get {return _storage._surnames}
    set {_uniqueStorage()._surnames = newValue}
  }

  /// date of birth of the holder
  var dateOfBirth: Io_Iohk_Atala_Prism_Protos_Date {
    get {return _storage._dateOfBirth ?? Io_Iohk_Atala_Prism_Protos_Date()}
    set {_uniqueStorage()._dateOfBirth = newValue}
  }
  /// Returns true if `dateOfBirth` has been explicitly set.
  var hasDateOfBirth: Bool {return _storage._dateOfBirth != nil}
  /// Clears the value of `dateOfBirth`. Subsequent reads from it will return its default value.
  mutating func clearDateOfBirth() {_uniqueStorage()._dateOfBirth = nil}

  /// optional identification number of the holder
  var idDocument: Io_Iohk_Atala_Prism_Protos_PersonalId {
    get {return _storage._idDocument ?? Io_Iohk_Atala_Prism_Protos_PersonalId()}
    set {_uniqueStorage()._idDocument = newValue}
  }
  /// Returns true if `idDocument` has been explicitly set.
  var hasIDDocument: Bool {return _storage._idDocument != nil}
  /// Clears the value of `idDocument`. Subsequent reads from it will return its default value.
  mutating func clearIDDocument() {_uniqueStorage()._idDocument = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Io_Iohk_Atala_Prism_Protos_PersonalId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// unique identifier of the individual according to document type
  var id: String = String()

  /// E.g. passport, driver licence, national card
  var documentType: Io_Iohk_Atala_Prism_Protos_IdDocumentType = .nationalIDCard

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
///Below we can see the messages used to exchange credentials between actors
struct Io_Iohk_Atala_Prism_Protos_IssuerSentCredential {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: OneOf_Value? {
    get {return _storage._value}
    set {_uniqueStorage()._value = newValue}
  }

  var alphaCredential: Io_Iohk_Atala_Prism_Protos_AlphaCredential {
    get {
      if case .alphaCredential(let v)? = _storage._value {return v}
      return Io_Iohk_Atala_Prism_Protos_AlphaCredential()
    }
    set {_uniqueStorage()._value = .alphaCredential(newValue)}
  }

  var credential: Io_Iohk_Atala_Prism_Protos_Credential {
    get {
      if case .credential(let v)? = _storage._value {return v}
      return Io_Iohk_Atala_Prism_Protos_Credential()
    }
    set {_uniqueStorage()._value = .credential(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable {
    case alphaCredential(Io_Iohk_Atala_Prism_Protos_AlphaCredential)
    case credential(Io_Iohk_Atala_Prism_Protos_Credential)

  #if !swift(>=4.1)
    static func ==(lhs: Io_Iohk_Atala_Prism_Protos_IssuerSentCredential.OneOf_Value, rhs: Io_Iohk_Atala_Prism_Protos_IssuerSentCredential.OneOf_Value) -> Bool {
      switch (lhs, rhs) {
      case (.alphaCredential(let l), .alphaCredential(let r)): return l == r
      case (.credential(let l), .credential(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Io_Iohk_Atala_Prism_Protos_Credential {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// type id to enable dispatch to correct credential processor.
  var typeID: String = String()

  /// JSON or JWT encoded credential document (to discuss)
  var credentialDocument: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_HolderSentCredential {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var credential: Io_Iohk_Atala_Prism_Protos_AlphaCredential {
    get {return _storage._credential ?? Io_Iohk_Atala_Prism_Protos_AlphaCredential()}
    set {_uniqueStorage()._credential = newValue}
  }
  /// Returns true if `credential` has been explicitly set.
  var hasCredential: Bool {return _storage._credential != nil}
  /// Clears the value of `credential`. Subsequent reads from it will return its default value.
  mutating func clearCredential() {_uniqueStorage()._credential = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Io_Iohk_Atala_Prism_Protos_ProofRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var typeIds: [String] = []

  var connectionToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_EncryptedMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// identifier of the key used to encrypt the message; may be empty if the receiver uses only one key
  var keyID: String = String()

  /// encrypted content of the message; after decryption it should be deserialized as AtalaMessage instance
  var encryptedContent: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_RegisterAddressMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cardanoAddress: String = String()

  var cardanoNetwork: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_PayIdMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var paymentInformation: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_MirrorMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: OneOf_Message? {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  var registerAddressMessage: Io_Iohk_Atala_Prism_Protos_RegisterAddressMessage {
    get {
      if case .registerAddressMessage(let v)? = _storage._message {return v}
      return Io_Iohk_Atala_Prism_Protos_RegisterAddressMessage()
    }
    set {_uniqueStorage()._message = .registerAddressMessage(newValue)}
  }

  var payIDMessage: Io_Iohk_Atala_Prism_Protos_PayIdMessage {
    get {
      if case .payIDMessage(let v)? = _storage._message {return v}
      return Io_Iohk_Atala_Prism_Protos_PayIdMessage()
    }
    set {_uniqueStorage()._message = .payIDMessage(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Message: Equatable {
    case registerAddressMessage(Io_Iohk_Atala_Prism_Protos_RegisterAddressMessage)
    case payIDMessage(Io_Iohk_Atala_Prism_Protos_PayIdMessage)

  #if !swift(>=4.1)
    static func ==(lhs: Io_Iohk_Atala_Prism_Protos_MirrorMessage.OneOf_Message, rhs: Io_Iohk_Atala_Prism_Protos_MirrorMessage.OneOf_Message) -> Bool {
      switch (lhs, rhs) {
      case (.registerAddressMessage(let l), .registerAddressMessage(let r)): return l == r
      case (.payIDMessage(let l), .payIDMessage(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ATA-3250: Until we implement e2e encryption, we will share
/// credentials using this message
struct Io_Iohk_Atala_Prism_Protos_PlainTextCredential {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the encoded signed credential
  var encodedCredential: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Atala_Prism_Protos_AtalaMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: OneOf_Message? {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  var issuerSentCredential: Io_Iohk_Atala_Prism_Protos_IssuerSentCredential {
    get {
      if case .issuerSentCredential(let v)? = _storage._message {return v}
      return Io_Iohk_Atala_Prism_Protos_IssuerSentCredential()
    }
    set {_uniqueStorage()._message = .issuerSentCredential(newValue)}
  }

  var holderSentCredential: Io_Iohk_Atala_Prism_Protos_HolderSentCredential {
    get {
      if case .holderSentCredential(let v)? = _storage._message {return v}
      return Io_Iohk_Atala_Prism_Protos_HolderSentCredential()
    }
    set {_uniqueStorage()._message = .holderSentCredential(newValue)}
  }

  var proofRequest: Io_Iohk_Atala_Prism_Protos_ProofRequest {
    get {
      if case .proofRequest(let v)? = _storage._message {return v}
      return Io_Iohk_Atala_Prism_Protos_ProofRequest()
    }
    set {_uniqueStorage()._message = .proofRequest(newValue)}
  }

  var encryptedMessage: Io_Iohk_Atala_Prism_Protos_EncryptedMessage {
    get {
      if case .encryptedMessage(let v)? = _storage._message {return v}
      return Io_Iohk_Atala_Prism_Protos_EncryptedMessage()
    }
    set {_uniqueStorage()._message = .encryptedMessage(newValue)}
  }

  var mirrorMessage: Io_Iohk_Atala_Prism_Protos_MirrorMessage {
    get {
      if case .mirrorMessage(let v)? = _storage._message {return v}
      return Io_Iohk_Atala_Prism_Protos_MirrorMessage()
    }
    set {_uniqueStorage()._message = .mirrorMessage(newValue)}
  }

  var plainCredential: Io_Iohk_Atala_Prism_Protos_PlainTextCredential {
    get {
      if case .plainCredential(let v)? = _storage._message {return v}
      return Io_Iohk_Atala_Prism_Protos_PlainTextCredential()
    }
    set {_uniqueStorage()._message = .plainCredential(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Message: Equatable {
    case issuerSentCredential(Io_Iohk_Atala_Prism_Protos_IssuerSentCredential)
    case holderSentCredential(Io_Iohk_Atala_Prism_Protos_HolderSentCredential)
    case proofRequest(Io_Iohk_Atala_Prism_Protos_ProofRequest)
    case encryptedMessage(Io_Iohk_Atala_Prism_Protos_EncryptedMessage)
    case mirrorMessage(Io_Iohk_Atala_Prism_Protos_MirrorMessage)
    case plainCredential(Io_Iohk_Atala_Prism_Protos_PlainTextCredential)

  #if !swift(>=4.1)
    static func ==(lhs: Io_Iohk_Atala_Prism_Protos_AtalaMessage.OneOf_Message, rhs: Io_Iohk_Atala_Prism_Protos_AtalaMessage.OneOf_Message) -> Bool {
      switch (lhs, rhs) {
      case (.issuerSentCredential(let l), .issuerSentCredential(let r)): return l == r
      case (.holderSentCredential(let l), .holderSentCredential(let r)): return l == r
      case (.proofRequest(let l), .proofRequest(let r)): return l == r
      case (.encryptedMessage(let l), .encryptedMessage(let r)): return l == r
      case (.mirrorMessage(let l), .mirrorMessage(let r)): return l == r
      case (.plainCredential(let l), .plainCredential(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "io.iohk.atala.prism.protos"

extension Io_Iohk_Atala_Prism_Protos_BillingPlan: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_PLAN"),
    1: .same(proto: "FREE_PLAN"),
    2: .same(proto: "SENDER_PAYS"),
    3: .same(proto: "RECEIVER_PAYS"),
  ]
}

extension Io_Iohk_Atala_Prism_Protos_KeyUsage: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_KEY"),
    1: .same(proto: "MASTER_KEY"),
    2: .same(proto: "ISSUING_KEY"),
    3: .same(proto: "COMMUNICATION_KEY"),
    4: .same(proto: "AUTHENTICATION_KEY"),
  ]
}

extension Io_Iohk_Atala_Prism_Protos_Ledger: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_LEDGER"),
    1: .same(proto: "IN_MEMORY"),
    2: .same(proto: "BITCOIN_TESTNET"),
    3: .same(proto: "BITCOIN_MAINNET"),
    4: .same(proto: "CARDANO_TESTNET"),
    5: .same(proto: "CARDANO_MAINNET"),
  ]
}

extension Io_Iohk_Atala_Prism_Protos_TransactionStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "PENDING"),
    2: .same(proto: "IN_LEDGER"),
    3: .same(proto: "CONFIRMED"),
  ]
}

extension Io_Iohk_Atala_Prism_Protos_IssuerType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "University"),
    1: .same(proto: "School"),
  ]
}

extension Io_Iohk_Atala_Prism_Protos_IdDocumentType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NationalIdCard"),
    1: .same(proto: "Passport"),
  ]
}

extension Io_Iohk_Atala_Prism_Protos_GetConnectionByTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetConnectionByTokenRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.token)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_GetConnectionByTokenRequest, rhs: Io_Iohk_Atala_Prism_Protos_GetConnectionByTokenRequest) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_GetConnectionByTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetConnectionByTokenResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "connection"),
  ]

  fileprivate class _StorageClass {
    var _connection: Io_Iohk_Atala_Prism_Protos_Connection? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _connection = source._connection
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._connection)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._connection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_GetConnectionByTokenResponse, rhs: Io_Iohk_Atala_Prism_Protos_GetConnectionByTokenResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._connection != rhs_storage._connection {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_GetConnectionsPaginatedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetConnectionsPaginatedRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lastSeenConnectionId"),
    2: .same(proto: "limit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.lastSeenConnectionID)
      case 2: try decoder.decodeSingularInt32Field(value: &self.limit)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lastSeenConnectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.lastSeenConnectionID, fieldNumber: 1)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_GetConnectionsPaginatedRequest, rhs: Io_Iohk_Atala_Prism_Protos_GetConnectionsPaginatedRequest) -> Bool {
    if lhs.lastSeenConnectionID != rhs.lastSeenConnectionID {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_GetConnectionsPaginatedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetConnectionsPaginatedResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "connections"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.connections)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.connections.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.connections, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_GetConnectionsPaginatedResponse, rhs: Io_Iohk_Atala_Prism_Protos_GetConnectionsPaginatedResponse) -> Bool {
    if lhs.connections != rhs.connections {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_GetConnectionTokenInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetConnectionTokenInfoRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.token)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_GetConnectionTokenInfoRequest, rhs: Io_Iohk_Atala_Prism_Protos_GetConnectionTokenInfoRequest) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_GetConnectionTokenInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetConnectionTokenInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
    2: .same(proto: "creatorName"),
    3: .same(proto: "creatorLogo"),
    4: .same(proto: "creatorDID"),
  ]

  fileprivate class _StorageClass {
    var _creator: Io_Iohk_Atala_Prism_Protos_ParticipantInfo? = nil
    var _creatorName: String = String()
    var _creatorLogo: Data = SwiftProtobuf.Internal.emptyData
    var _creatorDid: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _creator = source._creator
      _creatorName = source._creatorName
      _creatorLogo = source._creatorLogo
      _creatorDid = source._creatorDid
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._creator)
        case 2: try decoder.decodeSingularStringField(value: &_storage._creatorName)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._creatorLogo)
        case 4: try decoder.decodeSingularStringField(value: &_storage._creatorDid)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._creator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._creatorName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._creatorName, fieldNumber: 2)
      }
      if !_storage._creatorLogo.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._creatorLogo, fieldNumber: 3)
      }
      if !_storage._creatorDid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._creatorDid, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_GetConnectionTokenInfoResponse, rhs: Io_Iohk_Atala_Prism_Protos_GetConnectionTokenInfoResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._creator != rhs_storage._creator {return false}
        if _storage._creatorName != rhs_storage._creatorName {return false}
        if _storage._creatorLogo != rhs_storage._creatorLogo {return false}
        if _storage._creatorDid != rhs_storage._creatorDid {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_AddConnectionFromTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddConnectionFromTokenRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "holderPublicKey"),
    3: .same(proto: "paymentNonce"),
    4: .same(proto: "holderEncodedPublicKey"),
  ]

  fileprivate class _StorageClass {
    var _token: String = String()
    var _holderPublicKey: Io_Iohk_Atala_Prism_Protos_ConnectorPublicKey? = nil
    var _paymentNonce: String = String()
    var _holderEncodedPublicKey: Io_Iohk_Atala_Prism_Protos_EncodedPublicKey? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _token = source._token
      _holderPublicKey = source._holderPublicKey
      _paymentNonce = source._paymentNonce
      _holderEncodedPublicKey = source._holderEncodedPublicKey
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._token)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._holderPublicKey)
        case 3: try decoder.decodeSingularStringField(value: &_storage._paymentNonce)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._holderEncodedPublicKey)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._token.isEmpty {
        try visitor.visitSingularStringField(value: _storage._token, fieldNumber: 1)
      }
      if let v = _storage._holderPublicKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._paymentNonce.isEmpty {
        try visitor.visitSingularStringField(value: _storage._paymentNonce, fieldNumber: 3)
      }
      if let v = _storage._holderEncodedPublicKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_AddConnectionFromTokenRequest, rhs: Io_Iohk_Atala_Prism_Protos_AddConnectionFromTokenRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._token != rhs_storage._token {return false}
        if _storage._holderPublicKey != rhs_storage._holderPublicKey {return false}
        if _storage._paymentNonce != rhs_storage._paymentNonce {return false}
        if _storage._holderEncodedPublicKey != rhs_storage._holderEncodedPublicKey {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_AddConnectionFromTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddConnectionFromTokenResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "connection"),
    2: .same(proto: "userId"),
  ]

  fileprivate class _StorageClass {
    var _connection: Io_Iohk_Atala_Prism_Protos_ConnectionInfo? = nil
    var _userID: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _connection = source._connection
      _userID = source._userID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._connection)
        case 2: try decoder.decodeSingularStringField(value: &_storage._userID)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._connection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_AddConnectionFromTokenResponse, rhs: Io_Iohk_Atala_Prism_Protos_AddConnectionFromTokenResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._connection != rhs_storage._connection {return false}
        if _storage._userID != rhs_storage._userID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_DeleteConnectionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteConnectionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "connectionId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.connectionID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.connectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.connectionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_DeleteConnectionRequest, rhs: Io_Iohk_Atala_Prism_Protos_DeleteConnectionRequest) -> Bool {
    if lhs.connectionID != rhs.connectionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_DeleteConnectionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteConnectionResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_DeleteConnectionResponse, rhs: Io_Iohk_Atala_Prism_Protos_DeleteConnectionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_GenerateConnectionTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenerateConnectionTokenRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_GenerateConnectionTokenRequest, rhs: Io_Iohk_Atala_Prism_Protos_GenerateConnectionTokenRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_GenerateConnectionTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenerateConnectionTokenResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.token)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_GenerateConnectionTokenResponse, rhs: Io_Iohk_Atala_Prism_Protos_GenerateConnectionTokenResponse) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_GetMessagesPaginatedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMessagesPaginatedRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lastSeenMessageId"),
    2: .same(proto: "limit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.lastSeenMessageID)
      case 2: try decoder.decodeSingularInt32Field(value: &self.limit)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lastSeenMessageID.isEmpty {
      try visitor.visitSingularStringField(value: self.lastSeenMessageID, fieldNumber: 1)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_GetMessagesPaginatedRequest, rhs: Io_Iohk_Atala_Prism_Protos_GetMessagesPaginatedRequest) -> Bool {
    if lhs.lastSeenMessageID != rhs.lastSeenMessageID {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_GetMessagesPaginatedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMessagesPaginatedResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.messages)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_GetMessagesPaginatedResponse, rhs: Io_Iohk_Atala_Prism_Protos_GetMessagesPaginatedResponse) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_GetMessageStreamRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMessageStreamRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lastSeenMessageId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.lastSeenMessageID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lastSeenMessageID.isEmpty {
      try visitor.visitSingularStringField(value: self.lastSeenMessageID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_GetMessageStreamRequest, rhs: Io_Iohk_Atala_Prism_Protos_GetMessageStreamRequest) -> Bool {
    if lhs.lastSeenMessageID != rhs.lastSeenMessageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_GetMessageStreamResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMessageStreamResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  fileprivate class _StorageClass {
    var _message: Io_Iohk_Atala_Prism_Protos_ReceivedMessage? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _message = source._message
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._message)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._message {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_GetMessageStreamResponse, rhs: Io_Iohk_Atala_Prism_Protos_GetMessageStreamResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._message != rhs_storage._message {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_GetMessagesForConnectionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMessagesForConnectionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "connectionId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.connectionID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.connectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.connectionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_GetMessagesForConnectionRequest, rhs: Io_Iohk_Atala_Prism_Protos_GetMessagesForConnectionRequest) -> Bool {
    if lhs.connectionID != rhs.connectionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_GetMessagesForConnectionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMessagesForConnectionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.messages)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_GetMessagesForConnectionResponse, rhs: Io_Iohk_Atala_Prism_Protos_GetMessagesForConnectionResponse) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_GetConnectionCommunicationKeysRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetConnectionCommunicationKeysRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "connectionId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.connectionID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.connectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.connectionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_GetConnectionCommunicationKeysRequest, rhs: Io_Iohk_Atala_Prism_Protos_GetConnectionCommunicationKeysRequest) -> Bool {
    if lhs.connectionID != rhs.connectionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_GetConnectionCommunicationKeysResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetConnectionCommunicationKeysResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.keys)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_GetConnectionCommunicationKeysResponse, rhs: Io_Iohk_Atala_Prism_Protos_GetConnectionCommunicationKeysResponse) -> Bool {
    if lhs.keys != rhs.keys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_SendMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendMessageRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "connectionId"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.connectionID)
      case 2: try decoder.decodeSingularBytesField(value: &self.message)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.connectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.connectionID, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularBytesField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_SendMessageRequest, rhs: Io_Iohk_Atala_Prism_Protos_SendMessageRequest) -> Bool {
    if lhs.connectionID != rhs.connectionID {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_SendMessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendMessageResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_SendMessageResponse, rhs: Io_Iohk_Atala_Prism_Protos_SendMessageResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_RegisterDIDRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterDIDRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "createDIDOperation"),
    2: .same(proto: "role"),
    3: .same(proto: "name"),
    4: .same(proto: "logo"),
  ]

  fileprivate class _StorageClass {
    var _createDidoperation: Io_Iohk_Atala_Prism_Protos_SignedAtalaOperation? = nil
    var _role: Io_Iohk_Atala_Prism_Protos_RegisterDIDRequest.Role = .issuer
    var _name: String = String()
    var _logo: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _createDidoperation = source._createDidoperation
      _role = source._role
      _name = source._name
      _logo = source._logo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._createDidoperation)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._role)
        case 3: try decoder.decodeSingularStringField(value: &_storage._name)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._logo)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._createDidoperation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._role != .issuer {
        try visitor.visitSingularEnumField(value: _storage._role, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if !_storage._logo.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._logo, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_RegisterDIDRequest, rhs: Io_Iohk_Atala_Prism_Protos_RegisterDIDRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._createDidoperation != rhs_storage._createDidoperation {return false}
        if _storage._role != rhs_storage._role {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._logo != rhs_storage._logo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_RegisterDIDRequest.Role: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "issuer"),
    1: .same(proto: "verifier"),
  ]
}

extension Io_Iohk_Atala_Prism_Protos_GetCurrentUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetCurrentUserRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_GetCurrentUserRequest, rhs: Io_Iohk_Atala_Prism_Protos_GetCurrentUserRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_GetCurrentUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetCurrentUserResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "role"),
    2: .same(proto: "name"),
    3: .same(proto: "logo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.role)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularBytesField(value: &self.logo)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.role != .issuer {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.logo.isEmpty {
      try visitor.visitSingularBytesField(value: self.logo, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_GetCurrentUserResponse, rhs: Io_Iohk_Atala_Prism_Protos_GetCurrentUserResponse) -> Bool {
    if lhs.role != rhs.role {return false}
    if lhs.name != rhs.name {return false}
    if lhs.logo != rhs.logo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_GetCurrentUserResponse.Role: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "issuer"),
    1: .same(proto: "verifier"),
  ]
}

extension Io_Iohk_Atala_Prism_Protos_RegisterDIDResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterDIDResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "did"),
    2: .same(proto: "transactionInfo"),
  ]

  fileprivate class _StorageClass {
    var _did: String = String()
    var _transactionInfo: Io_Iohk_Atala_Prism_Protos_TransactionInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _did = source._did
      _transactionInfo = source._transactionInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._did)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._transactionInfo)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._did.isEmpty {
        try visitor.visitSingularStringField(value: _storage._did, fieldNumber: 1)
      }
      if let v = _storage._transactionInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_RegisterDIDResponse, rhs: Io_Iohk_Atala_Prism_Protos_RegisterDIDResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._did != rhs_storage._did {return false}
        if _storage._transactionInfo != rhs_storage._transactionInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_ChangeBillingPlanRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChangeBillingPlanRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "billingPlan"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.billingPlan)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.billingPlan != .noPlan {
      try visitor.visitSingularEnumField(value: self.billingPlan, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_ChangeBillingPlanRequest, rhs: Io_Iohk_Atala_Prism_Protos_ChangeBillingPlanRequest) -> Bool {
    if lhs.billingPlan != rhs.billingPlan {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_ChangeBillingPlanResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChangeBillingPlanResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_ChangeBillingPlanResponse, rhs: Io_Iohk_Atala_Prism_Protos_ChangeBillingPlanResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_GetBraintreePaymentsConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBraintreePaymentsConfigRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_GetBraintreePaymentsConfigRequest, rhs: Io_Iohk_Atala_Prism_Protos_GetBraintreePaymentsConfigRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_GetBraintreePaymentsConfigResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBraintreePaymentsConfigResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenizationKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.tokenizationKey)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokenizationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenizationKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_GetBraintreePaymentsConfigResponse, rhs: Io_Iohk_Atala_Prism_Protos_GetBraintreePaymentsConfigResponse) -> Bool {
    if lhs.tokenizationKey != rhs.tokenizationKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_ProcessPaymentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProcessPaymentRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .same(proto: "nonce"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.amount)
      case 2: try decoder.decodeSingularStringField(value: &self.nonce)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 1)
    }
    if !self.nonce.isEmpty {
      try visitor.visitSingularStringField(value: self.nonce, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_ProcessPaymentRequest, rhs: Io_Iohk_Atala_Prism_Protos_ProcessPaymentRequest) -> Bool {
    if lhs.amount != rhs.amount {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_ProcessPaymentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProcessPaymentResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payment"),
  ]

  fileprivate class _StorageClass {
    var _payment: Io_Iohk_Atala_Prism_Protos_Payment? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _payment = source._payment
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._payment)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._payment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_ProcessPaymentResponse, rhs: Io_Iohk_Atala_Prism_Protos_ProcessPaymentResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._payment != rhs_storage._payment {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_GetPaymentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetPaymentsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_GetPaymentsRequest, rhs: Io_Iohk_Atala_Prism_Protos_GetPaymentsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_GetPaymentsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetPaymentsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payments"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.payments)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.payments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.payments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_GetPaymentsResponse, rhs: Io_Iohk_Atala_Prism_Protos_GetPaymentsResponse) -> Bool {
    if lhs.payments != rhs.payments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_GetBuildInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBuildInfoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_GetBuildInfoRequest, rhs: Io_Iohk_Atala_Prism_Protos_GetBuildInfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_GetBuildInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBuildInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "scalaVersion"),
    3: .same(proto: "sbtVersion"),
    4: .same(proto: "buildTime"),
    5: .same(proto: "nodeVersion"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.version)
      case 2: try decoder.decodeSingularStringField(value: &self.scalaVersion)
      case 3: try decoder.decodeSingularStringField(value: &self.sbtVersion)
      case 4: try decoder.decodeSingularStringField(value: &self.buildTime)
      case 5: try decoder.decodeSingularStringField(value: &self.nodeVersion)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    if !self.scalaVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.scalaVersion, fieldNumber: 2)
    }
    if !self.sbtVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.sbtVersion, fieldNumber: 3)
    }
    if !self.buildTime.isEmpty {
      try visitor.visitSingularStringField(value: self.buildTime, fieldNumber: 4)
    }
    if !self.nodeVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.nodeVersion, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_GetBuildInfoResponse, rhs: Io_Iohk_Atala_Prism_Protos_GetBuildInfoResponse) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.scalaVersion != rhs.scalaVersion {return false}
    if lhs.sbtVersion != rhs.sbtVersion {return false}
    if lhs.buildTime != rhs.buildTime {return false}
    if lhs.nodeVersion != rhs.nodeVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_ConnectorPublicKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectorPublicKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.x)
      case 2: try decoder.decodeSingularStringField(value: &self.y)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.x.isEmpty {
      try visitor.visitSingularStringField(value: self.x, fieldNumber: 1)
    }
    if !self.y.isEmpty {
      try visitor.visitSingularStringField(value: self.y, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_ConnectorPublicKey, rhs: Io_Iohk_Atala_Prism_Protos_ConnectorPublicKey) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_EncodedPublicKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EncodedPublicKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.publicKey)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_EncodedPublicKey, rhs: Io_Iohk_Atala_Prism_Protos_EncodedPublicKey) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_IssuerInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IssuerInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "DID"),
    2: .same(proto: "name"),
    3: .same(proto: "logo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.did)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularBytesField(value: &self.logo)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.did.isEmpty {
      try visitor.visitSingularStringField(value: self.did, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.logo.isEmpty {
      try visitor.visitSingularBytesField(value: self.logo, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_IssuerInfo, rhs: Io_Iohk_Atala_Prism_Protos_IssuerInfo) -> Bool {
    if lhs.did != rhs.did {return false}
    if lhs.name != rhs.name {return false}
    if lhs.logo != rhs.logo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_VerifierInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerifierInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "DID"),
    2: .same(proto: "name"),
    3: .same(proto: "logo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.did)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularBytesField(value: &self.logo)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.did.isEmpty {
      try visitor.visitSingularStringField(value: self.did, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.logo.isEmpty {
      try visitor.visitSingularBytesField(value: self.logo, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_VerifierInfo, rhs: Io_Iohk_Atala_Prism_Protos_VerifierInfo) -> Bool {
    if lhs.did != rhs.did {return false}
    if lhs.name != rhs.name {return false}
    if lhs.logo != rhs.logo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_HolderInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HolderInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "DID"),
    2: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.did)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.did.isEmpty {
      try visitor.visitSingularStringField(value: self.did, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_HolderInfo, rhs: Io_Iohk_Atala_Prism_Protos_HolderInfo) -> Bool {
    if lhs.did != rhs.did {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_ParticipantInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ParticipantInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "issuer"),
    2: .same(proto: "holder"),
    3: .same(proto: "verifier"),
  ]

  fileprivate class _StorageClass {
    var _participant: Io_Iohk_Atala_Prism_Protos_ParticipantInfo.OneOf_Participant?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _participant = source._participant
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Io_Iohk_Atala_Prism_Protos_IssuerInfo?
          if let current = _storage._participant {
            try decoder.handleConflictingOneOf()
            if case .issuer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._participant = .issuer(v)}
        case 2:
          var v: Io_Iohk_Atala_Prism_Protos_HolderInfo?
          if let current = _storage._participant {
            try decoder.handleConflictingOneOf()
            if case .holder(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._participant = .holder(v)}
        case 3:
          var v: Io_Iohk_Atala_Prism_Protos_VerifierInfo?
          if let current = _storage._participant {
            try decoder.handleConflictingOneOf()
            if case .verifier(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._participant = .verifier(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._participant {
      case .issuer(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .holder(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .verifier(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_ParticipantInfo, rhs: Io_Iohk_Atala_Prism_Protos_ParticipantInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._participant != rhs_storage._participant {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_Connection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Connection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "connectionToken"),
    2: .same(proto: "connectionId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.connectionToken)
      case 2: try decoder.decodeSingularStringField(value: &self.connectionID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.connectionToken.isEmpty {
      try visitor.visitSingularStringField(value: self.connectionToken, fieldNumber: 1)
    }
    if !self.connectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.connectionID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_Connection, rhs: Io_Iohk_Atala_Prism_Protos_Connection) -> Bool {
    if lhs.connectionToken != rhs.connectionToken {return false}
    if lhs.connectionID != rhs.connectionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_ConnectionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectionInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "connectionId"),
    2: .same(proto: "created"),
    3: .same(proto: "participantInfo"),
    4: .same(proto: "token"),
    5: .same(proto: "participantName"),
    6: .same(proto: "participantLogo"),
    7: .same(proto: "participantDID"),
  ]

  fileprivate class _StorageClass {
    var _connectionID: String = String()
    var _created: Int64 = 0
    var _participantInfo: Io_Iohk_Atala_Prism_Protos_ParticipantInfo? = nil
    var _token: String = String()
    var _participantName: String = String()
    var _participantLogo: Data = SwiftProtobuf.Internal.emptyData
    var _participantDid: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _connectionID = source._connectionID
      _created = source._created
      _participantInfo = source._participantInfo
      _token = source._token
      _participantName = source._participantName
      _participantLogo = source._participantLogo
      _participantDid = source._participantDid
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._connectionID)
        case 2: try decoder.decodeSingularInt64Field(value: &_storage._created)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._participantInfo)
        case 4: try decoder.decodeSingularStringField(value: &_storage._token)
        case 5: try decoder.decodeSingularStringField(value: &_storage._participantName)
        case 6: try decoder.decodeSingularBytesField(value: &_storage._participantLogo)
        case 7: try decoder.decodeSingularStringField(value: &_storage._participantDid)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._connectionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._connectionID, fieldNumber: 1)
      }
      if _storage._created != 0 {
        try visitor.visitSingularInt64Field(value: _storage._created, fieldNumber: 2)
      }
      if let v = _storage._participantInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._token.isEmpty {
        try visitor.visitSingularStringField(value: _storage._token, fieldNumber: 4)
      }
      if !_storage._participantName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._participantName, fieldNumber: 5)
      }
      if !_storage._participantLogo.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._participantLogo, fieldNumber: 6)
      }
      if !_storage._participantDid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._participantDid, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_ConnectionInfo, rhs: Io_Iohk_Atala_Prism_Protos_ConnectionInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._connectionID != rhs_storage._connectionID {return false}
        if _storage._created != rhs_storage._created {return false}
        if _storage._participantInfo != rhs_storage._participantInfo {return false}
        if _storage._token != rhs_storage._token {return false}
        if _storage._participantName != rhs_storage._participantName {return false}
        if _storage._participantLogo != rhs_storage._participantLogo {return false}
        if _storage._participantDid != rhs_storage._participantDid {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_ConnectionKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectionKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keyId"),
    2: .same(proto: "key"),
  ]

  fileprivate class _StorageClass {
    var _keyID: String = String()
    var _key: Io_Iohk_Atala_Prism_Protos_EncodedPublicKey? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _keyID = source._keyID
      _key = source._key
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._keyID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._key)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._keyID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._keyID, fieldNumber: 1)
      }
      if let v = _storage._key {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_ConnectionKey, rhs: Io_Iohk_Atala_Prism_Protos_ConnectionKey) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._keyID != rhs_storage._keyID {return false}
        if _storage._key != rhs_storage._key {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_ReceivedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReceivedMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "received"),
    3: .same(proto: "connectionId"),
    4: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularInt64Field(value: &self.received)
      case 3: try decoder.decodeSingularStringField(value: &self.connectionID)
      case 4: try decoder.decodeSingularBytesField(value: &self.message)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.received != 0 {
      try visitor.visitSingularInt64Field(value: self.received, fieldNumber: 2)
    }
    if !self.connectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.connectionID, fieldNumber: 3)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularBytesField(value: self.message, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_ReceivedMessage, rhs: Io_Iohk_Atala_Prism_Protos_ReceivedMessage) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.received != rhs.received {return false}
    if lhs.connectionID != rhs.connectionID {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_Payment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Payment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "amount"),
    3: .same(proto: "createdOn"),
    4: .same(proto: "status"),
    5: .same(proto: "failureReason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.amount)
      case 3: try decoder.decodeSingularInt64Field(value: &self.createdOn)
      case 4: try decoder.decodeSingularStringField(value: &self.status)
      case 5: try decoder.decodeSingularStringField(value: &self.failureReason)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 2)
    }
    if self.createdOn != 0 {
      try visitor.visitSingularInt64Field(value: self.createdOn, fieldNumber: 3)
    }
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 4)
    }
    if !self.failureReason.isEmpty {
      try visitor.visitSingularStringField(value: self.failureReason, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_Payment, rhs: Io_Iohk_Atala_Prism_Protos_Payment) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.createdOn != rhs.createdOn {return false}
    if lhs.status != rhs.status {return false}
    if lhs.failureReason != rhs.failureReason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_TimestampInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TimestampInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blockTimestamp"),
    2: .same(proto: "blockSequenceNumber"),
    3: .same(proto: "operationSequenceNumber"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.blockTimestamp)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.blockSequenceNumber)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.operationSequenceNumber)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.blockTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.blockTimestamp, fieldNumber: 1)
    }
    if self.blockSequenceNumber != 0 {
      try visitor.visitSingularUInt32Field(value: self.blockSequenceNumber, fieldNumber: 2)
    }
    if self.operationSequenceNumber != 0 {
      try visitor.visitSingularUInt32Field(value: self.operationSequenceNumber, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_TimestampInfo, rhs: Io_Iohk_Atala_Prism_Protos_TimestampInfo) -> Bool {
    if lhs.blockTimestamp != rhs.blockTimestamp {return false}
    if lhs.blockSequenceNumber != rhs.blockSequenceNumber {return false}
    if lhs.operationSequenceNumber != rhs.operationSequenceNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_ECKeyData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ECKeyData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "curve"),
    2: .same(proto: "x"),
    3: .same(proto: "y"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.curve)
      case 2: try decoder.decodeSingularBytesField(value: &self.x)
      case 3: try decoder.decodeSingularBytesField(value: &self.y)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.curve.isEmpty {
      try visitor.visitSingularStringField(value: self.curve, fieldNumber: 1)
    }
    if !self.x.isEmpty {
      try visitor.visitSingularBytesField(value: self.x, fieldNumber: 2)
    }
    if !self.y.isEmpty {
      try visitor.visitSingularBytesField(value: self.y, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_ECKeyData, rhs: Io_Iohk_Atala_Prism_Protos_ECKeyData) -> Bool {
    if lhs.curve != rhs.curve {return false}
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_PublicKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PublicKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "usage"),
    3: .same(proto: "addedOn"),
    4: .same(proto: "revokedOn"),
    8: .same(proto: "ecKeyData"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _usage: Io_Iohk_Atala_Prism_Protos_KeyUsage = .unknownKey
    var _addedOn: Io_Iohk_Atala_Prism_Protos_TimestampInfo? = nil
    var _revokedOn: Io_Iohk_Atala_Prism_Protos_TimestampInfo? = nil
    var _keyData: Io_Iohk_Atala_Prism_Protos_PublicKey.OneOf_KeyData?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _usage = source._usage
      _addedOn = source._addedOn
      _revokedOn = source._revokedOn
      _keyData = source._keyData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._usage)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._addedOn)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._revokedOn)
        case 8:
          var v: Io_Iohk_Atala_Prism_Protos_ECKeyData?
          if let current = _storage._keyData {
            try decoder.handleConflictingOneOf()
            if case .ecKeyData(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._keyData = .ecKeyData(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if _storage._usage != .unknownKey {
        try visitor.visitSingularEnumField(value: _storage._usage, fieldNumber: 2)
      }
      if let v = _storage._addedOn {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._revokedOn {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if case .ecKeyData(let v)? = _storage._keyData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_PublicKey, rhs: Io_Iohk_Atala_Prism_Protos_PublicKey) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._usage != rhs_storage._usage {return false}
        if _storage._addedOn != rhs_storage._addedOn {return false}
        if _storage._revokedOn != rhs_storage._revokedOn {return false}
        if _storage._keyData != rhs_storage._keyData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_DIDData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DIDData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "publicKeys"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.publicKeys)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.publicKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.publicKeys, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_DIDData, rhs: Io_Iohk_Atala_Prism_Protos_DIDData) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.publicKeys != rhs.publicKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_CredentialData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CredentialData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "issuer"),
    3: .same(proto: "contentHash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.issuer)
      case 3: try decoder.decodeSingularBytesField(value: &self.contentHash)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.issuer.isEmpty {
      try visitor.visitSingularStringField(value: self.issuer, fieldNumber: 2)
    }
    if !self.contentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.contentHash, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_CredentialData, rhs: Io_Iohk_Atala_Prism_Protos_CredentialData) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.issuer != rhs.issuer {return false}
    if lhs.contentHash != rhs.contentHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_CreateDIDOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateDIDOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "didData"),
  ]

  fileprivate class _StorageClass {
    var _didData: Io_Iohk_Atala_Prism_Protos_DIDData? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _didData = source._didData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._didData)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._didData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_CreateDIDOperation, rhs: Io_Iohk_Atala_Prism_Protos_CreateDIDOperation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._didData != rhs_storage._didData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_AddKeyAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddKeyAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
  ]

  fileprivate class _StorageClass {
    var _key: Io_Iohk_Atala_Prism_Protos_PublicKey? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _key = source._key
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._key)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._key {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_AddKeyAction, rhs: Io_Iohk_Atala_Prism_Protos_AddKeyAction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._key != rhs_storage._key {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_RemoveKeyAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoveKeyAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keyId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.keyID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyID.isEmpty {
      try visitor.visitSingularStringField(value: self.keyID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_RemoveKeyAction, rhs: Io_Iohk_Atala_Prism_Protos_RemoveKeyAction) -> Bool {
    if lhs.keyID != rhs.keyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_UpdateDIDAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateDIDAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addKey"),
    2: .same(proto: "removeKey"),
  ]

  fileprivate class _StorageClass {
    var _action: Io_Iohk_Atala_Prism_Protos_UpdateDIDAction.OneOf_Action?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _action = source._action
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Io_Iohk_Atala_Prism_Protos_AddKeyAction?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .addKey(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .addKey(v)}
        case 2:
          var v: Io_Iohk_Atala_Prism_Protos_RemoveKeyAction?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .removeKey(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .removeKey(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._action {
      case .addKey(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .removeKey(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_UpdateDIDAction, rhs: Io_Iohk_Atala_Prism_Protos_UpdateDIDAction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._action != rhs_storage._action {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_UpdateDIDOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateDIDOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "previousOperationHash"),
    2: .same(proto: "id"),
    3: .same(proto: "actions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.previousOperationHash)
      case 2: try decoder.decodeSingularStringField(value: &self.id)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.actions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.previousOperationHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.previousOperationHash, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_UpdateDIDOperation, rhs: Io_Iohk_Atala_Prism_Protos_UpdateDIDOperation) -> Bool {
    if lhs.previousOperationHash != rhs.previousOperationHash {return false}
    if lhs.id != rhs.id {return false}
    if lhs.actions != rhs.actions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_IssueCredentialOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IssueCredentialOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "credentialData"),
  ]

  fileprivate class _StorageClass {
    var _credentialData: Io_Iohk_Atala_Prism_Protos_CredentialData? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _credentialData = source._credentialData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._credentialData)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._credentialData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_IssueCredentialOperation, rhs: Io_Iohk_Atala_Prism_Protos_IssueCredentialOperation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._credentialData != rhs_storage._credentialData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_RevokeCredentialOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RevokeCredentialOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "previousOperationHash"),
    2: .same(proto: "credentialId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.previousOperationHash)
      case 2: try decoder.decodeSingularStringField(value: &self.credentialID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.previousOperationHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.previousOperationHash, fieldNumber: 1)
    }
    if !self.credentialID.isEmpty {
      try visitor.visitSingularStringField(value: self.credentialID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_RevokeCredentialOperation, rhs: Io_Iohk_Atala_Prism_Protos_RevokeCredentialOperation) -> Bool {
    if lhs.previousOperationHash != rhs.previousOperationHash {return false}
    if lhs.credentialID != rhs.credentialID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_CredentialBatchData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CredentialBatchData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "issuerDID"),
    2: .same(proto: "merkleRoot"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.issuerDid)
      case 2: try decoder.decodeSingularBytesField(value: &self.merkleRoot)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.issuerDid.isEmpty {
      try visitor.visitSingularStringField(value: self.issuerDid, fieldNumber: 1)
    }
    if !self.merkleRoot.isEmpty {
      try visitor.visitSingularBytesField(value: self.merkleRoot, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_CredentialBatchData, rhs: Io_Iohk_Atala_Prism_Protos_CredentialBatchData) -> Bool {
    if lhs.issuerDid != rhs.issuerDid {return false}
    if lhs.merkleRoot != rhs.merkleRoot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_IssueCredentialBatchOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IssueCredentialBatchOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "credentialBatchData"),
  ]

  fileprivate class _StorageClass {
    var _credentialBatchData: Io_Iohk_Atala_Prism_Protos_CredentialBatchData? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _credentialBatchData = source._credentialBatchData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._credentialBatchData)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._credentialBatchData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_IssueCredentialBatchOperation, rhs: Io_Iohk_Atala_Prism_Protos_IssueCredentialBatchOperation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._credentialBatchData != rhs_storage._credentialBatchData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_RevokeCredentialsOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RevokeCredentialsOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "previousOperationHash"),
    2: .same(proto: "credentialBatchId"),
    3: .same(proto: "credentialsToRevoke"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.previousOperationHash)
      case 2: try decoder.decodeSingularStringField(value: &self.credentialBatchID)
      case 3: try decoder.decodeRepeatedBytesField(value: &self.credentialsToRevoke)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.previousOperationHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.previousOperationHash, fieldNumber: 1)
    }
    if !self.credentialBatchID.isEmpty {
      try visitor.visitSingularStringField(value: self.credentialBatchID, fieldNumber: 2)
    }
    if !self.credentialsToRevoke.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.credentialsToRevoke, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_RevokeCredentialsOperation, rhs: Io_Iohk_Atala_Prism_Protos_RevokeCredentialsOperation) -> Bool {
    if lhs.previousOperationHash != rhs.previousOperationHash {return false}
    if lhs.credentialBatchID != rhs.credentialBatchID {return false}
    if lhs.credentialsToRevoke != rhs.credentialsToRevoke {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_AtalaOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AtalaOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "createDid"),
    2: .same(proto: "updateDid"),
    3: .same(proto: "issueCredential"),
    4: .same(proto: "revokeCredential"),
    5: .same(proto: "issueCredentialBatch"),
    6: .same(proto: "revokeCredentials"),
  ]

  fileprivate class _StorageClass {
    var _operation: Io_Iohk_Atala_Prism_Protos_AtalaOperation.OneOf_Operation?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _operation = source._operation
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Io_Iohk_Atala_Prism_Protos_CreateDIDOperation?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .createDid(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .createDid(v)}
        case 2:
          var v: Io_Iohk_Atala_Prism_Protos_UpdateDIDOperation?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .updateDid(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .updateDid(v)}
        case 3:
          var v: Io_Iohk_Atala_Prism_Protos_IssueCredentialOperation?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .issueCredential(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .issueCredential(v)}
        case 4:
          var v: Io_Iohk_Atala_Prism_Protos_RevokeCredentialOperation?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .revokeCredential(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .revokeCredential(v)}
        case 5:
          var v: Io_Iohk_Atala_Prism_Protos_IssueCredentialBatchOperation?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .issueCredentialBatch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .issueCredentialBatch(v)}
        case 6:
          var v: Io_Iohk_Atala_Prism_Protos_RevokeCredentialsOperation?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .revokeCredentials(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .revokeCredentials(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._operation {
      case .createDid(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .updateDid(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .issueCredential(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .revokeCredential(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .issueCredentialBatch(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .revokeCredentials(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_AtalaOperation, rhs: Io_Iohk_Atala_Prism_Protos_AtalaOperation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._operation != rhs_storage._operation {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_SignedAtalaOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignedAtalaOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signedWith"),
    2: .same(proto: "signature"),
    3: .same(proto: "operation"),
  ]

  fileprivate class _StorageClass {
    var _signedWith: String = String()
    var _signature: Data = SwiftProtobuf.Internal.emptyData
    var _operation: Io_Iohk_Atala_Prism_Protos_AtalaOperation? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _signedWith = source._signedWith
      _signature = source._signature
      _operation = source._operation
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._signedWith)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._signature)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._operation)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._signedWith.isEmpty {
        try visitor.visitSingularStringField(value: _storage._signedWith, fieldNumber: 1)
      }
      if !_storage._signature.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._signature, fieldNumber: 2)
      }
      if let v = _storage._operation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_SignedAtalaOperation, rhs: Io_Iohk_Atala_Prism_Protos_SignedAtalaOperation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._signedWith != rhs_storage._signedWith {return false}
        if _storage._signature != rhs_storage._signature {return false}
        if _storage._operation != rhs_storage._operation {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_HealthCheckRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HealthCheckRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_HealthCheckRequest, rhs: Io_Iohk_Atala_Prism_Protos_HealthCheckRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_HealthCheckResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HealthCheckResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_HealthCheckResponse, rhs: Io_Iohk_Atala_Prism_Protos_HealthCheckResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_Date: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Date"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "year"),
    2: .same(proto: "month"),
    3: .same(proto: "day"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.year)
      case 2: try decoder.decodeSingularInt32Field(value: &self.month)
      case 3: try decoder.decodeSingularInt32Field(value: &self.day)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.year != 0 {
      try visitor.visitSingularInt32Field(value: self.year, fieldNumber: 1)
    }
    if self.month != 0 {
      try visitor.visitSingularInt32Field(value: self.month, fieldNumber: 2)
    }
    if self.day != 0 {
      try visitor.visitSingularInt32Field(value: self.day, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_Date, rhs: Io_Iohk_Atala_Prism_Protos_Date) -> Bool {
    if lhs.year != rhs.year {return false}
    if lhs.month != rhs.month {return false}
    if lhs.day != rhs.day {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_BlockInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "number"),
    2: .same(proto: "timestamp"),
    3: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.number)
      case 2: try decoder.decodeSingularInt64Field(value: &self.timestamp)
      case 3: try decoder.decodeSingularInt32Field(value: &self.index)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.number != 0 {
      try visitor.visitSingularInt32Field(value: self.number, fieldNumber: 1)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    if self.index != 0 {
      try visitor.visitSingularInt32Field(value: self.index, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_BlockInfo, rhs: Io_Iohk_Atala_Prism_Protos_BlockInfo) -> Bool {
    if lhs.number != rhs.number {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_TransactionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactionId"),
    2: .same(proto: "ledger"),
    3: .same(proto: "block"),
  ]

  fileprivate class _StorageClass {
    var _transactionID: String = String()
    var _ledger: Io_Iohk_Atala_Prism_Protos_Ledger = .unknownLedger
    var _block: Io_Iohk_Atala_Prism_Protos_BlockInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _transactionID = source._transactionID
      _ledger = source._ledger
      _block = source._block
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._transactionID)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._ledger)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._block)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._transactionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._transactionID, fieldNumber: 1)
      }
      if _storage._ledger != .unknownLedger {
        try visitor.visitSingularEnumField(value: _storage._ledger, fieldNumber: 2)
      }
      if let v = _storage._block {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_TransactionInfo, rhs: Io_Iohk_Atala_Prism_Protos_TransactionInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._transactionID != rhs_storage._transactionID {return false}
        if _storage._ledger != rhs_storage._ledger {return false}
        if _storage._block != rhs_storage._block {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_AlphaCredential: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AlphaCredential"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "issuerType"),
    2: .same(proto: "subjectData"),
    3: .same(proto: "grantingDecision"),
    4: .same(proto: "signingAuthorities"),
    5: .same(proto: "degreeAwarded"),
    6: .same(proto: "additionalSpeciality"),
    7: .same(proto: "issuedOn"),
    8: .same(proto: "issueNumber"),
    9: .same(proto: "registrationNumber"),
    10: .same(proto: "decisionNumber"),
    15: .same(proto: "yearCompletedByStudent"),
    16: .same(proto: "description"),
    17: .same(proto: "expiresOn"),
    18: .same(proto: "admissionDate"),
    19: .same(proto: "graduationDate"),
    20: .same(proto: "attainmentDate"),
  ]

  fileprivate class _StorageClass {
    var _issuerType: Io_Iohk_Atala_Prism_Protos_IssuerData? = nil
    var _subjectData: Io_Iohk_Atala_Prism_Protos_SubjectData? = nil
    var _grantingDecision: String = String()
    var _signingAuthorities: [Io_Iohk_Atala_Prism_Protos_Signer] = []
    var _degreeAwarded: String = String()
    var _additionalSpeciality: String = String()
    var _issuedOn: Io_Iohk_Atala_Prism_Protos_Date? = nil
    var _issueNumber: String = String()
    var _registrationNumber: String = String()
    var _decisionNumber: String = String()
    var _yearCompletedByStudent: String = String()
    var _description_p: String = String()
    var _expiresOn: Io_Iohk_Atala_Prism_Protos_Date? = nil
    var _admissionDate: Io_Iohk_Atala_Prism_Protos_Date? = nil
    var _graduationDate: Io_Iohk_Atala_Prism_Protos_Date? = nil
    var _attainmentDate: Io_Iohk_Atala_Prism_Protos_Date? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _issuerType = source._issuerType
      _subjectData = source._subjectData
      _grantingDecision = source._grantingDecision
      _signingAuthorities = source._signingAuthorities
      _degreeAwarded = source._degreeAwarded
      _additionalSpeciality = source._additionalSpeciality
      _issuedOn = source._issuedOn
      _issueNumber = source._issueNumber
      _registrationNumber = source._registrationNumber
      _decisionNumber = source._decisionNumber
      _yearCompletedByStudent = source._yearCompletedByStudent
      _description_p = source._description_p
      _expiresOn = source._expiresOn
      _admissionDate = source._admissionDate
      _graduationDate = source._graduationDate
      _attainmentDate = source._attainmentDate
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._issuerType)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._subjectData)
        case 3: try decoder.decodeSingularStringField(value: &_storage._grantingDecision)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._signingAuthorities)
        case 5: try decoder.decodeSingularStringField(value: &_storage._degreeAwarded)
        case 6: try decoder.decodeSingularStringField(value: &_storage._additionalSpeciality)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._issuedOn)
        case 8: try decoder.decodeSingularStringField(value: &_storage._issueNumber)
        case 9: try decoder.decodeSingularStringField(value: &_storage._registrationNumber)
        case 10: try decoder.decodeSingularStringField(value: &_storage._decisionNumber)
        case 15: try decoder.decodeSingularStringField(value: &_storage._yearCompletedByStudent)
        case 16: try decoder.decodeSingularStringField(value: &_storage._description_p)
        case 17: try decoder.decodeSingularMessageField(value: &_storage._expiresOn)
        case 18: try decoder.decodeSingularMessageField(value: &_storage._admissionDate)
        case 19: try decoder.decodeSingularMessageField(value: &_storage._graduationDate)
        case 20: try decoder.decodeSingularMessageField(value: &_storage._attainmentDate)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._issuerType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._subjectData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._grantingDecision.isEmpty {
        try visitor.visitSingularStringField(value: _storage._grantingDecision, fieldNumber: 3)
      }
      if !_storage._signingAuthorities.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._signingAuthorities, fieldNumber: 4)
      }
      if !_storage._degreeAwarded.isEmpty {
        try visitor.visitSingularStringField(value: _storage._degreeAwarded, fieldNumber: 5)
      }
      if !_storage._additionalSpeciality.isEmpty {
        try visitor.visitSingularStringField(value: _storage._additionalSpeciality, fieldNumber: 6)
      }
      if let v = _storage._issuedOn {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._issueNumber.isEmpty {
        try visitor.visitSingularStringField(value: _storage._issueNumber, fieldNumber: 8)
      }
      if !_storage._registrationNumber.isEmpty {
        try visitor.visitSingularStringField(value: _storage._registrationNumber, fieldNumber: 9)
      }
      if !_storage._decisionNumber.isEmpty {
        try visitor.visitSingularStringField(value: _storage._decisionNumber, fieldNumber: 10)
      }
      if !_storage._yearCompletedByStudent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._yearCompletedByStudent, fieldNumber: 15)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 16)
      }
      if let v = _storage._expiresOn {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if let v = _storage._admissionDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }
      if let v = _storage._graduationDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }
      if let v = _storage._attainmentDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_AlphaCredential, rhs: Io_Iohk_Atala_Prism_Protos_AlphaCredential) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._issuerType != rhs_storage._issuerType {return false}
        if _storage._subjectData != rhs_storage._subjectData {return false}
        if _storage._grantingDecision != rhs_storage._grantingDecision {return false}
        if _storage._signingAuthorities != rhs_storage._signingAuthorities {return false}
        if _storage._degreeAwarded != rhs_storage._degreeAwarded {return false}
        if _storage._additionalSpeciality != rhs_storage._additionalSpeciality {return false}
        if _storage._issuedOn != rhs_storage._issuedOn {return false}
        if _storage._issueNumber != rhs_storage._issueNumber {return false}
        if _storage._registrationNumber != rhs_storage._registrationNumber {return false}
        if _storage._decisionNumber != rhs_storage._decisionNumber {return false}
        if _storage._yearCompletedByStudent != rhs_storage._yearCompletedByStudent {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._expiresOn != rhs_storage._expiresOn {return false}
        if _storage._admissionDate != rhs_storage._admissionDate {return false}
        if _storage._graduationDate != rhs_storage._graduationDate {return false}
        if _storage._attainmentDate != rhs_storage._attainmentDate {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_IssuerData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IssuerData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "issuerLegalName"),
    2: .same(proto: "academicAuthority"),
    3: .same(proto: "issuerType"),
    4: .same(proto: "did"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.issuerLegalName)
      case 2: try decoder.decodeSingularStringField(value: &self.academicAuthority)
      case 3: try decoder.decodeSingularEnumField(value: &self.issuerType)
      case 4: try decoder.decodeSingularStringField(value: &self.did)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.issuerLegalName.isEmpty {
      try visitor.visitSingularStringField(value: self.issuerLegalName, fieldNumber: 1)
    }
    if !self.academicAuthority.isEmpty {
      try visitor.visitSingularStringField(value: self.academicAuthority, fieldNumber: 2)
    }
    if self.issuerType != .university {
      try visitor.visitSingularEnumField(value: self.issuerType, fieldNumber: 3)
    }
    if !self.did.isEmpty {
      try visitor.visitSingularStringField(value: self.did, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_IssuerData, rhs: Io_Iohk_Atala_Prism_Protos_IssuerData) -> Bool {
    if lhs.issuerLegalName != rhs.issuerLegalName {return false}
    if lhs.academicAuthority != rhs.academicAuthority {return false}
    if lhs.issuerType != rhs.issuerType {return false}
    if lhs.did != rhs.did {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_Signer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Signer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "names"),
    2: .same(proto: "surnames"),
    3: .same(proto: "role"),
    4: .same(proto: "did"),
    5: .same(proto: "title"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.names)
      case 2: try decoder.decodeRepeatedStringField(value: &self.surnames)
      case 3: try decoder.decodeSingularStringField(value: &self.role)
      case 4: try decoder.decodeSingularStringField(value: &self.did)
      case 5: try decoder.decodeSingularStringField(value: &self.title)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.names.isEmpty {
      try visitor.visitRepeatedStringField(value: self.names, fieldNumber: 1)
    }
    if !self.surnames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.surnames, fieldNumber: 2)
    }
    if !self.role.isEmpty {
      try visitor.visitSingularStringField(value: self.role, fieldNumber: 3)
    }
    if !self.did.isEmpty {
      try visitor.visitSingularStringField(value: self.did, fieldNumber: 4)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_Signer, rhs: Io_Iohk_Atala_Prism_Protos_Signer) -> Bool {
    if lhs.names != rhs.names {return false}
    if lhs.surnames != rhs.surnames {return false}
    if lhs.role != rhs.role {return false}
    if lhs.did != rhs.did {return false}
    if lhs.title != rhs.title {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_SubjectData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubjectData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "names"),
    2: .same(proto: "surnames"),
    3: .same(proto: "dateOfBirth"),
    4: .same(proto: "idDocument"),
  ]

  fileprivate class _StorageClass {
    var _names: [String] = []
    var _surnames: [String] = []
    var _dateOfBirth: Io_Iohk_Atala_Prism_Protos_Date? = nil
    var _idDocument: Io_Iohk_Atala_Prism_Protos_PersonalId? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _names = source._names
      _surnames = source._surnames
      _dateOfBirth = source._dateOfBirth
      _idDocument = source._idDocument
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedStringField(value: &_storage._names)
        case 2: try decoder.decodeRepeatedStringField(value: &_storage._surnames)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._dateOfBirth)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._idDocument)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._names.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._names, fieldNumber: 1)
      }
      if !_storage._surnames.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._surnames, fieldNumber: 2)
      }
      if let v = _storage._dateOfBirth {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._idDocument {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_SubjectData, rhs: Io_Iohk_Atala_Prism_Protos_SubjectData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._names != rhs_storage._names {return false}
        if _storage._surnames != rhs_storage._surnames {return false}
        if _storage._dateOfBirth != rhs_storage._dateOfBirth {return false}
        if _storage._idDocument != rhs_storage._idDocument {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_PersonalId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PersonalId"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "documentType"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularEnumField(value: &self.documentType)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.documentType != .nationalIDCard {
      try visitor.visitSingularEnumField(value: self.documentType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_PersonalId, rhs: Io_Iohk_Atala_Prism_Protos_PersonalId) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.documentType != rhs.documentType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_IssuerSentCredential: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IssuerSentCredential"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alphaCredential"),
    2: .same(proto: "credential"),
  ]

  fileprivate class _StorageClass {
    var _value: Io_Iohk_Atala_Prism_Protos_IssuerSentCredential.OneOf_Value?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _value = source._value
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Io_Iohk_Atala_Prism_Protos_AlphaCredential?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .alphaCredential(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .alphaCredential(v)}
        case 2:
          var v: Io_Iohk_Atala_Prism_Protos_Credential?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .credential(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .credential(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._value {
      case .alphaCredential(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .credential(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_IssuerSentCredential, rhs: Io_Iohk_Atala_Prism_Protos_IssuerSentCredential) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._value != rhs_storage._value {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_Credential: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Credential"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "typeId"),
    2: .same(proto: "credentialDocument"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.typeID)
      case 2: try decoder.decodeSingularStringField(value: &self.credentialDocument)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.typeID.isEmpty {
      try visitor.visitSingularStringField(value: self.typeID, fieldNumber: 1)
    }
    if !self.credentialDocument.isEmpty {
      try visitor.visitSingularStringField(value: self.credentialDocument, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_Credential, rhs: Io_Iohk_Atala_Prism_Protos_Credential) -> Bool {
    if lhs.typeID != rhs.typeID {return false}
    if lhs.credentialDocument != rhs.credentialDocument {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_HolderSentCredential: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HolderSentCredential"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "credential"),
  ]

  fileprivate class _StorageClass {
    var _credential: Io_Iohk_Atala_Prism_Protos_AlphaCredential? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _credential = source._credential
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._credential)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._credential {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_HolderSentCredential, rhs: Io_Iohk_Atala_Prism_Protos_HolderSentCredential) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._credential != rhs_storage._credential {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_ProofRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProofRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "typeIds"),
    2: .same(proto: "connectionToken"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.typeIds)
      case 2: try decoder.decodeSingularStringField(value: &self.connectionToken)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.typeIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.typeIds, fieldNumber: 1)
    }
    if !self.connectionToken.isEmpty {
      try visitor.visitSingularStringField(value: self.connectionToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_ProofRequest, rhs: Io_Iohk_Atala_Prism_Protos_ProofRequest) -> Bool {
    if lhs.typeIds != rhs.typeIds {return false}
    if lhs.connectionToken != rhs.connectionToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_EncryptedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EncryptedMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keyId"),
    2: .same(proto: "encryptedContent"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.keyID)
      case 2: try decoder.decodeSingularBytesField(value: &self.encryptedContent)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyID.isEmpty {
      try visitor.visitSingularStringField(value: self.keyID, fieldNumber: 1)
    }
    if !self.encryptedContent.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptedContent, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_EncryptedMessage, rhs: Io_Iohk_Atala_Prism_Protos_EncryptedMessage) -> Bool {
    if lhs.keyID != rhs.keyID {return false}
    if lhs.encryptedContent != rhs.encryptedContent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_RegisterAddressMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterAddressMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cardanoAddress"),
    2: .same(proto: "cardanoNetwork"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.cardanoAddress)
      case 2: try decoder.decodeSingularStringField(value: &self.cardanoNetwork)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cardanoAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.cardanoAddress, fieldNumber: 1)
    }
    if !self.cardanoNetwork.isEmpty {
      try visitor.visitSingularStringField(value: self.cardanoNetwork, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_RegisterAddressMessage, rhs: Io_Iohk_Atala_Prism_Protos_RegisterAddressMessage) -> Bool {
    if lhs.cardanoAddress != rhs.cardanoAddress {return false}
    if lhs.cardanoNetwork != rhs.cardanoNetwork {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_PayIdMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PayIdMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paymentInformation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.paymentInformation)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.paymentInformation.isEmpty {
      try visitor.visitSingularStringField(value: self.paymentInformation, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_PayIdMessage, rhs: Io_Iohk_Atala_Prism_Protos_PayIdMessage) -> Bool {
    if lhs.paymentInformation != rhs.paymentInformation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_MirrorMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MirrorMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "registerAddressMessage"),
    2: .same(proto: "payIdMessage"),
  ]

  fileprivate class _StorageClass {
    var _message: Io_Iohk_Atala_Prism_Protos_MirrorMessage.OneOf_Message?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _message = source._message
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Io_Iohk_Atala_Prism_Protos_RegisterAddressMessage?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .registerAddressMessage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .registerAddressMessage(v)}
        case 2:
          var v: Io_Iohk_Atala_Prism_Protos_PayIdMessage?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .payIDMessage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .payIDMessage(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._message {
      case .registerAddressMessage(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .payIDMessage(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_MirrorMessage, rhs: Io_Iohk_Atala_Prism_Protos_MirrorMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._message != rhs_storage._message {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_PlainTextCredential: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlainTextCredential"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "encodedCredential"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.encodedCredential)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.encodedCredential.isEmpty {
      try visitor.visitSingularStringField(value: self.encodedCredential, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_PlainTextCredential, rhs: Io_Iohk_Atala_Prism_Protos_PlainTextCredential) -> Bool {
    if lhs.encodedCredential != rhs.encodedCredential {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Atala_Prism_Protos_AtalaMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AtalaMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "issuerSentCredential"),
    2: .same(proto: "holderSentCredential"),
    3: .same(proto: "proofRequest"),
    4: .same(proto: "encryptedMessage"),
    5: .same(proto: "mirrorMessage"),
    6: .same(proto: "plainCredential"),
  ]

  fileprivate class _StorageClass {
    var _message: Io_Iohk_Atala_Prism_Protos_AtalaMessage.OneOf_Message?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _message = source._message
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Io_Iohk_Atala_Prism_Protos_IssuerSentCredential?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .issuerSentCredential(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .issuerSentCredential(v)}
        case 2:
          var v: Io_Iohk_Atala_Prism_Protos_HolderSentCredential?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .holderSentCredential(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .holderSentCredential(v)}
        case 3:
          var v: Io_Iohk_Atala_Prism_Protos_ProofRequest?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .proofRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .proofRequest(v)}
        case 4:
          var v: Io_Iohk_Atala_Prism_Protos_EncryptedMessage?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .encryptedMessage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .encryptedMessage(v)}
        case 5:
          var v: Io_Iohk_Atala_Prism_Protos_MirrorMessage?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .mirrorMessage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .mirrorMessage(v)}
        case 6:
          var v: Io_Iohk_Atala_Prism_Protos_PlainTextCredential?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .plainCredential(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .plainCredential(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._message {
      case .issuerSentCredential(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .holderSentCredential(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .proofRequest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .encryptedMessage(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .mirrorMessage(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .plainCredential(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Atala_Prism_Protos_AtalaMessage, rhs: Io_Iohk_Atala_Prism_Protos_AtalaMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._message != rhs_storage._message {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
