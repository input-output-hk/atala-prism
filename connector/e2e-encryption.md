# End to End Encryption

End to End Encryption is a mechanism that provides security in a way that not even the service provider can decipher the data sent between participants.
In the context of Atala PRISM it means, for example, issuers being able to send credentials to Holders without us (PRISM Connector) learning its contents (including Personally Identifiable Information).

## Man in the middle attack

In cryptographic communication protocols, one attack vector is third party in the middle controlling the communication between participants.
Generally, it is impossible to prevent such attacks without using some information shared between participants or another communication channel.
The attacker can communicate with participant B pretending to be A and communicating with A pretending to be B - with neither of them being able to detect it.

Protocols exist that are generally secure against MITM attack, e.g. TLS which we are using for communication between Issuer and Connector or Holder and Connector - so that part of communication should not be vulnerable.
The only missing link is the Connector itself - if the attacker controls it, they could use such power to run MITM attack.

Another potential problem, similar to MITM attack, is the possibility of the attacker impersonating the Holder using information known to Connector. In such scenario, the attacker uses a connection token stolen from the Connector to instantiate a connection to the issuer and download credentials, including Personally Identifiable Information.
It is slightly different from MITM attack, as the latter involves transparently intercepting communication between parties, while described impersonation attack can be started without any action from the Holder side.

Our solution proposal to these issues is treating a connection QR code as safe one-way communication channel from the Issuer to the Holder. It can be used to share secret bits between both ends, without disclosing them to the Connector.
Such shared secret can be then used to perform a handshake between the Issuer and the Holder at the beginning of connection.

## Phase one: Key exchange

This phase describes the protocol of exchanging a common secret and other information between the Issuer and Holder that are necessary for the next stage - encryption.

### Prerequisites

In the following description of the protocol, when participants need to store EC key pair, they will store key derivation path instead, which will be used to derive the key using [key derivation protocol](../protocol/key-derivation.md). 

Issuer will have an association table in a local database with following fields:

| Column                        | Description                                            |
|-------------------------------|--------------------------------------------------------|
| connection_id                 | Connection id generated by a connector                 |
| key_agreement_derivation_path | Key derivation path to derive a key for e2e encryption |
| recipient_pk                  | Public key sent by the Holder                          |
| secret                        | Secret sent to this specific Holder                    |
| token                         | Connection token used to establish this connection     |

Holder will have an association table in a local database with this fields:

| Column                        | Description                                            |
|-------------------------------|--------------------------------------------------------|
| connection_id                 | Connection id generated by a connector                 |
| key_agreement_derivation_path | Key derivation path to derive a key for e2e encryption |
| recipient_pk                  | Public key sent by the Issuer                          |
| secret                        | Secret received from the issuer                        |
| token                         | Connection token used to establish this connection     |

##### Remark

Holder already has a table where he stores information for every contact, fields are:

* connectionId;
* dateCreated;
* did;
* lastMessageId;
* name;
* token;
* keyDerivationPath;
* logo;
* deleted = false;

We will need to add `key_agreement_derivation_path`, `recipient_pk` and `secret` there as well.

Right now Holder keeps track of a counter that he uses to generate a new key derivation path which then is used to derive the authentication key for the connector,
every new key has an index `m/counter+1'/0'/0'`, `key_agreement_derivation_path` will be generated in a similar way, with path being `m/counter+1'/2'/0'`, 
where `2` indicates a key agreement key type.

private key generated from this path will be used to decrypt messages received from the Issuer, and sign messages sent to the Issuer.
`recipient_pk` is a public key of the Issuer that will be used to encrypt messages intended for the Issuer

The `did` here is a part of `addConnectionFromToken` response, right now when Holder scans the QR code and obtains a token
he sends `addConnectionFromToken` request and the response from this request contains this information. The response is coming
from a connector, so in the context of e2e encryption, this `did` can not be trusted because connector can replace the did.

`keyDerivationPath` is used to generate the authentication key. Requests to the connector will be signed with private key,
unpublished did will be generated which includes the public key, and sent alongside the request in request metadata.
The connector can verify the request using this key, Connector has access to this public key.

It is worth mentioning that `connectionId` is also sent back by the connector, and it could be replaced as well, 
in this case messages won't be delivered to the recipient but if they are encrypted, attacker won't be able to read them anyway.


### Steps

1. Issuer will generate a new key derivation path, and then key pair from it, a random 256 bit secret and a connection token, Issuer creates a record in connector/connection_tokens table.
2. Issuer will create a new record with token, secret and key derivation path generated in step 1 in a database.
3. Issuer will generate a QR code by concatenating newly generated PK, secret and token like this: `<Base64Url(PK)>.<Base64Url(secret)>.<Base64Url(token)>`
4. Holder scans the QR code and obtains the aforementioned information
5. Holder creates an entry for a new contact in his database, stores token, secret and recipients public key, Holder will also generate a new key derivation path association with this contact. After that connection has been established, now parties will communicate with each other via connector.
6. Holder will send a message to an issuer containing a public portion of the key pair he has generated in part 5 and associated with this specific issuer.
   1. this message will also include MAC calculated with the secret sent by the issuer in step 3
7. Issuer will receive the message, since he has the secret he will be able to validate the message authenticity 
   1. He will be able to know which secret to use by messages connectionId, he can get a connection token by knowing a connectionId, and then use the token to retrieve a secret that he stored in step 2
8. Issuer will update a record by secret (which he has extracted in step 7.1) in his database and add received public key and connectionId, 

After successfully completing the protocol, Issuer and Holder have the following information:

Issuer:
* Holders public key
* secret
* key derivation path, which is associated to a particular Holder and will be used for e2e encryption for this contact only

Holder:
* Issuers public key
* secret
* key derivation path, which is associated to a particular Issuer and will be used for e2e encryption for this contact only

##### Remark

In step one "Issuer creates a record in connector/connection_tokens table". This is already happening, other steps need to be implemented.

Right now Holder already has a counter for every new connection, which he will use to generate a unique key derivation path, issuer will need to implement such counter for every contact as well.

Issuers database (mentioned in step 2) in the current implementation is management_console_db/contacts postgress db

## Phase two: encryption

Participants will use [ECIES](https://en.wikipedia.org/wiki/Integrated_Encryption_Scheme) to exchange encrypted messages between each other via connector.

In the following description of steps we are assuming that the Issuer is sending a message to a Holder, steps for a Holder sending a message to the issuer will be identical.
For the purpose of discussion, we will define the following:

* `•` = [Elliptic curve point multiplication](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication)
* `r` = Random integer between 1 and `n`
* `n` = Order of `G` in [Secp256k1](https://en.bitcoin.it/wiki/Secp256k1) Curve
* `G` = Generator point of [Secp256k1](https://en.bitcoin.it/wiki/Secp256k1) Curve
* `S` = Secret key
* `HPK` = Public key of the Holder 
* `HSK` = Private/Secret key of the Holder
* `IPK` = Public key of the Issuer
* `ISK` = Private/Secret key of the Issuer
* `M` = Actual message to be sent

### Steps:

1. Issuer generates a random value `r`, and then calculates `R` where `R = G•r`
2. Issuer generates `S` where `S = HPK•r`. `S` can be used by the issuer as a symmetric encryption key to encrypt the message
3. Issuer generates a new message by wrapping `M`, `IPK` and `HPK` into `UnsignedAtalaMessage` like this `UnsignedAtalaMessage(M, IPK, HPK)`
4. Issuer signs `UnsignedAtalaMessage` with `ISK`, producing a signature `SIG`, and wraps both of them into `SignedAtalaMessage` like this `SignedAtalaMessage(UnsignedAtalaMessage, SIG)`
5. Issuer encrypts `SignedAtalaMessage` with `S` using symmetric encryption provided by ECIES, producing `EM`, and wraps it and `R` into `EncryptedAtalaMessage` like this `EncryptedAtalaMessage(EM, R)`
6. Issuer sends the encrypted message `EncryptedAtalaMessage` to the Holder
7. Holder is able to generate `S` by `S = HSK•R`, since 
   1. `S = HSK•R`
   2. `S = HSK•r•G`
   3. `S = HSK•G•r`
   4. `S = HPK•r` (that is how the Issuer has generated it)
8. Holder decrypts the message `EM` using `S`, yielding `SignedAtalaMessage`, then extracts `UnsignedAtalaMessage` and `SIG` from it
9. Holder will verify the signature `SIG` using `IPK`. `verify(UnsignedAtalaMessage, SIG, IPK)`
10. Holder will retrieve `IPK` and `HPK` from `UnsignedAtalaMessage` and verify that `IPK` is the public key of the issuer he is expecting a message from, and that `HPK` is his public key, thus message is intended to him.
11. Holder will retrieve a message `M` from `UnsignedAtalaMessage`

It is worth noting that at every step of the protocol, whenever a verification or decryption takes place, if one of them fails all the rest of the steps will not be performed and the whole protocol will be aborted.

## GRPC messages

Protocol introduces following GRPC messages to the system:

`AuthenticatedPublicKey` will be added to `oneOf` of `AtalaMessage` for step 6 of Phase 1 - key exchange.
```protobuf
message AuthenticatedPublicKey {
  bytes pk = 1;
  bytes mac = 2;
}
```

`EncryptedMessage` will be added to `oneOf` of `AtalaMessage` for step 6 of phase 2 - encryption.
```protobuf
message UnsignedAtalaMessage {
   AtalaMessage message = 1; 
   PublicKey sender_key = 2;
   PublicKey recipient_key = 3;
}

message SignedAtalaMessage {
   UnsignedAtalaMessage unsigned_atala_message 1;
   bytes signature = 2;
}

message EncryptedAtalaMessage {
  bytes content = 1;
  uint64 rValue = 2;
}
```

## Note on key agreement and signing keys

In the above description of the protocol participants are using the same key pair for signing and generating symmetric key via ECIES, this is a not considered to be a best practice.
In the current implementation we are deciding to go with it, but here is roughly how the protocol will be changed to mitigate this issue in the future:

* In the Phase one - key exchange, Issuer will generate 2 key derivation paths and subsequently 2 key paris. Issuer will send 2 public keys, one that the holder will use to encrypt messages intended for the issuer, and another that holder will use to verify the signature of the message sent from the Issuer.  
* The holder would need to send 2 keys for the same purposes as well
* In the Phase two - encryption, participants will need to include their own and another participants' public keys in `UnsignedAtalaMessage`, Since we will have 2 key paris now, they will include their and another participants signing key.
  * It is worth noting that it does not matter which key to include, key-agreement key could have been used as well.