name: "Main Workflow"
on:
  push:
    tags:
      - "**"
    branches:
      - master
      - develop*
      - test*
      - demo*
      - qa*
      - sandbox*
      - package*
      - '[0-9]+.[0-9]+.[0-9]+'
  pull_request:
    paths:
      - 'prism-backend/**'
      - '!prism-backend/docs/**'

env:
  GITHUB_TOKEN: ${{ secrets.ATALA_GITHUB_TOKEN }}
  JAVA_VERSION: openjdk@1.11
  SCALA_VERSION: "2.13"

jobs:
  set-flag:
    name: "Set flag"
    runs-on: ubuntu-20.04
    outputs:
      package: ${{ steps.set-flag.outputs.package }}
      deploy: ${{ steps.set-flag.outputs.deploy }}
    steps:
      - name: "Set flag"
        id: set-flag
        run: |
          if [[ ${{ github.ref_name }} =~ (package*|master|^[0-9]+\.[0-9]+\.[0-9]+$) ]] ; then
            echo ::set-output name=package::true
          fi
          if [[ ${{ github.ref_name }} =~ (master|develop*|test*|demo*|qa*|sandbox*|^[0-9]+\.[0-9]+\.[0-9]+$) ]] ; then
            echo ::set-output name=deploy::true
          fi

  build-prism-backend:
    name: "Build Prism Backend"
    runs-on: ubuntu-20.04
    needs: set-flag
    defaults:
      run:
        working-directory: prism-backend
    services:
      postgres:
        image: postgres:13.3
        env:
          POSTGRES_USER: postgres
          POSTGRES_DB: postgres
          POSTGRES_PASSWORD: postgres
        # Set health checks to wait until postgres has started
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout
        uses: actions/checkout@v2

      - name: Setup Scala
        uses: olafurpg/setup-scala@v10
        with:
          java-version: ${{ env.JAVA_VERSION }}

      - name: Coursier cache
        uses: coursier/cache-action@v6

      - name: Test Scala code is properly formatted
        run: sbt scalafmtCheckAll

      - name: Test terraform code format
        run: terraform fmt -check -recursive

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_DEFAULT_REGION }}

      - name: Obtain Cardano db sync and wallet endpoints config
        id: cardano
        run: ../.github/generate_cardano_variables.sh

      - name: Compile and test prism-backend components
        run: sbt compile test:compile coverage test pushRemoteCache
        env:
          POSTGRES_TEST_HOST: localhost:5432
          POSTGRES_TEST_DB: postgres
          POSTGRES_TEST_USER: postgres
          POSTGRES_TEST_PASSWORD: postgres
          NODE_CARDANO_DB_SYNC_HOST: ${{ steps.cardano.outputs.db-sync-host }}
          NODE_CARDANO_DB_SYNC_DATABASE: ${{ steps.cardano.outputs.db-sync-database }}
          NODE_CARDANO_DB_SYNC_USERNAME: ${{ steps.cardano.outputs.db-sync-username }}
          NODE_CARDANO_DB_SYNC_PASSWORD: ${{ steps.cardano.outputs.db-sync-password }}
          NODE_CARDANO_WALLET_API_HOST: ${{ steps.cardano.outputs.wallet-api-host }}
          NODE_CARDANO_WALLET_API_PORT: ${{ steps.cardano.outputs.wallet-api-port }}
          NODE_CARDANO_WALLET_ID: ${{ secrets.NODE_CARDANO_WALLET_ID }}
          NODE_CARDANO_WALLET_PASSPHRASE: ${{ secrets.NODE_CARDANO_WALLET_PASSPHRASE }}
          NODE_CARDANO_CONFIRMATION_BLOCKS: ${{ secrets.NODE_CARDANO_CONFIRMATION_BLOCKS }}
          NODE_CARDANO_PAYMENT_ADDRESS: ${{ secrets.NODE_CARDANO_PAYMENT_ADDRESS }}

      - name: Assemble fat JARs
        run: sbt assembly

      - name: Upload SBT remote cache
        uses: actions/upload-artifact@v2
        with:
          name: sbt-backend-remote-cache
          path: /tmp/backend-remote-cache

      - name: Generate code coverage reports
        if: always()
        run: sbt coverageReport coverageAggregate

      - name: Aggregate test reports
        if: always()
        run: |
          for reports in `find -name test-reports`; do
            project=${reports%/target/*}
            dest=target/test-reports/$project
            mkdir -p $dest
            cp $reports/* $dest
          done
      - name: Publish Backend Unit Test Results
        if: always()
        uses: EnricoMi/publish-unit-test-result-action@v1
        with:
          files: "prism-backend/target/test-reports/**/TEST-*.xml"
          check_run_annotations_branch: "*"

  publish-github-packages:
    strategy:
      matrix:
        image: ["node", "connector", "management-console", "vault"]
    name: Publish Github Packages
    needs: build-prism-backend
    runs-on: ubuntu-20.04
    if: needs.set-flag.outputs.package == 'true'
    defaults:
      run:
        working-directory: prism-backend
    steps:
      - name: Checkout the repo
        uses: actions/checkout@v2

      - name: Setup Scala
        uses: olafurpg/setup-scala@v10
        with:
          java-version: ${{ env.JAVA_VERSION }}

      - name: Coursier cache
        uses: coursier/cache-action@v6

      - name: Download SBT remote cache
        uses: actions/download-artifact@v2
        with:
          name: sbt-backend-remote-cache
          path: /tmp

      - name: Pull remote cache from local file
        run: sbt pullRemoteCache

      - name: Setup Github Container registry credentials
        run: docker login ghcr.io -u atala-dev -p $GITHUB_TOKEN

      - name: Build and publish Docker images
        run: |
          GITHUB=1 sbt "${{ matrix.image }}/dockerBuildAndPush"
  deploy-ecr-images:
    strategy:
      matrix:
        image: ["node", "connector", "management-console", "vault", "prism-lb-envoy"]
    name: Deploy ECR Images
    runs-on: ubuntu-20.04
    needs: build-prism-backend
    if: needs.set-flag.outputs.deploy == 'true' || github.ref_type == 'tag'
    permissions:
      packages: write
      contents: read
    outputs:
      tag: ${{ steps.set-tag.outputs.tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v2

      - name: Install protoc
        run: |
          archive=protoc-"3.11.4"-linux-x86_64
          curl -O -L https://github.com/protocolbuffers/protobuf/releases/download/v"3.11.4"/$archive.zip
          sudo unzip -d '/usr/local' $archive.zip 'bin/*' 'include/*'
          rm -rf ${archive}.zip
      - name: Install protoc-gen-grpc-web
        run: |
          archive=protoc-gen-grpc-web-1.0.7-linux-x86_64
          curl -O -L https://github.com/grpc/grpc-web/releases/download/1.0.7/$archive
          chmod +x $archive
          sudo mv $archive /usr/local/bin/protoc-gen-grpc-web
      - name: Restore Cache
        uses: actions/cache@v2
        with:
          key: cv-cache-v5-${{ hashFiles('prism-backend/build.sbt') }}-${{ hashFiles('prism-backend/project/PrismBuild.scala') }}-${{ hashFiles('prism-backend/project/Dependencies.scala') }}-${{ hashFiles('prism-backend/project/plugins.sbt') }}
          path: |
            ~/.cache/coursier
            ~/.ivy2
            ~/.m2
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@13d241b293754004c80624b5567555c4a39ffbe3
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_DEFAULT_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@aaf69d68aa3fb14c1d5a6be9ac61fe15b48453a2

      - name: Set ENV & TAG convention
        id: set-tag
        run: |
          branchPrefix=$(git rev-parse --abbrev-ref HEAD | sed -E 's/(^ATA\-[0-9]+).*/\1/' | tr '[:upper:]' '[:lower:]')
          if [[ ${GITHUB_REF_TYPE} == "tag" ]]
          then
              tag=$(echo $GITHUB_REF_NAME)
              echo "TAG=$tag" >> $GITHUB_ENV
              echo "::set-output name=tag::$tag"
          else
              revCount=$(git rev-list HEAD --count)
              shaShort=$(git rev-parse --short HEAD)
              tag="${branchPrefix}-${revCount}-${shaShort}"
              echo "TAG=$tag" >> $GITHUB_ENV
              echo "::set-output name=tag::$tag"
          fi
          echo "ENV=$branchPrefix" >> $GITHUB_ENV
          . $GITHUB_ENV && echo "Env short name set to $ENV. Image tag set to $TAG"

      - name: Build and publish Docker image
        if: |
          matrix.image == 'node' ||
          matrix.image == 'connector' ||
          matrix.image == 'management-console' ||
          matrix.image == 'vault'
        run: |
          cd prism-backend
          sbt "${{ matrix.image }}/dockerBuildAndPush"
      - name: Build and push prism-lb-envoy
        if: matrix.image == 'prism-lb-envoy'
        run: |
          cd prism-backend/infra/docker/prism-lb-envoy
          ./build.sh -b
          ./build.sh -p

  workflow-dispach:
    name: "Workflow Dispach"
    runs-on: ubuntu-20.04
    if: github.ref_type != 'tag'
    needs: deploy-ecr-images
    steps:
      - name: Workflow Dispatch
        uses: benc-uk/workflow-dispatch@v1
        with:
          workflow: Manual Deploy
          repo: input-output-hk/atala-prism-infra
          token: ${{ secrets.ATALA_GITHUB_TOKEN }}
          inputs: '{"environment": "${{ github.ref_name }}", "tag": "${{ needs.deploy-ecr-images.outputs.tag }}"}'
          ref: "refs/heads/master"

  # TODO: It's probably good idea to move this job to other repo since we are using infra repo for deployment and this job is depending on deployment job in atala-prism-infra repo
  trigger-integration-tests:
    name: "Trigger Integration Tests"
    runs-on: ubuntu-20.04
    needs: workflow-dispach
    if: github.ref_name == 'qa'
    steps:
      - name: Checkout
        uses: actions/checkout@v2

      # TODO: remove this part when https://jira.iohk.io/browse/ATA-3535 is implemented, maybe not needed in GHA?
      - name: wait till environment is fully operable
        run: sleep 9m

      - name: Trigger a job in atala-qa-automation project
        run: python trigger_tests.py

      - name: Slack notification
        uses: bryannice/gitactions-slack-notification@2.0.0
        env:
          SLACK_INCOMING_WEBHOOK: ${{ secrets.SLACK_INCOMING_WEBHOOK }}
          SLACK_MESSAGE: "UFHNXC9RC,UGFJQ5ZBN"
          SLACK_TITLE: "Slack Notification Demo"
