/**
 * Description: Model for authenticated exchange based on a QR code
 * sent via a secure channel.
 *
 * Date: 20210922
 * Authors: Jesus Diaz Vico, IOHK Atala and Research teams.
 */

theory QRdid
begin

/*
 The protocol we want to model is, in Alice and Bob notation, as follows:

 (I stands for Issuer, H for Holder, C for connector)
 ( => is secure channel; -> is normal channel )

 1. I => H: tid, pk_iss, code // Shared via QR, i.e., secure channel
 2. H -> C: <tid, pk_hol>, mac(<tid, pk_hol>, code)
 3. C -> I: <tid, pk_hol> mac(<tid, pk_hol>, code)

 After this, I should trust that H's public key (~ DID Document) is indeed
 pk_hol.

*/

builtins: asymmetric-encryption

functions: mac/2

/* Rule for sending a message through a secure (confidential & authenticated) 
   channel. Used here for QR code sharing. */
rule ChanOut_S:
        [ Out_S($A,$B,x) ]
      --[ ChanOut_S($A,$B,x) ]->
        [ Sec($A,$B,x) ]

/* Rule for sending a message from a secure (confidential & authenticated) 
   channel. Used here for QR code sharing. */
rule ChanIn_S:
        [ Sec($A,$B,x) ]
      --[ ChanIn_S($A,$B,x) ]->
        [ In_S($A,$B,x) ]

/* Rule for generating keypairs. */
rule Register_pk:
  [ Fr(~x) ]
  --> 
  [ !Pk($A, pk(~x)),
    !Ltk($A, ~x) ]

/* Rule for fetching an existing public key. */
rule Get_pk:
  [ !Pk(A, pk) ] 
  --> 
  [ Out(pk) ]

/* Rule for compromising a private key. */
rule Reveal_ltk:
    [ !Ltk(A, ltk) ]
  --[ LtkReveal(A) ]->
    [ Out(ltk) ]

/* Rule for initializing the issuer */
rule Issuer_Init:
     [ Fr(~id), !Ltk($I, ~lkI) ]
     --[ Create($I, ~id), Role('I') ]->
     [ St_Issuer_0($I, ~id, ~lkI) ]

/* Rule for initializing the holder */
rule Holder_Init:
     [ Fr(~id), !Ltk($H, ~lkH) ]
     --[ Create($H, ~id), Role('H') ]->
     [ St_Holder_0($H, ~id, ~lkH) ]

/* The issuer shares the QR code via the secure channel. */
rule Issuer_1:
     [ Fr(~code),
       Fr(~tid),
       St_Issuer_0($I, ~id, ~lkI) ]
     --[ Running_I($I, $H, <'H', 'I', <~tid, ~code, pk(~lkI)>>) ]->
     [ Out_S($I, $H, <~tid, ~code, pk(~lkI)>),
       St_Issuer_1($I, ~id, ~lkI, $H, ~tid, ~code) ]

/* The holder receives the QR code through the secure channel, and responds. */
rule Holder_2:
     let mc = mac(<~tid, pk(~lkH)>, ~code) in
     [ In_S($I, $H, <~tid, ~code, pkI>),
       St_Holder_0($H, ~id, ~lkH) ]
       --[ Secret(~code), Honest($H), Honest($I),
           Commit_H($H, $I, <'H', 'I', <~tid, ~code, pkI>>),
	   Running_H($H, $I, <'H', 'I', <~tid, pk(~lkH), mc>>)]->
     [ Out(<<~tid, pk(~lkH)>, mc>) ]

/* The issuer receives back the MAC'ed QR code, via an insecure channel, 
   plus the Holder's public key. */
rule Issuer_3:
     let mc = mac(<~tid, pkH>, ~code) in    
     [ St_Issuer_1($I, ~id, ~lkI, $H, ~tid, ~code),
       In(<<~tid, pkH>, mc>) ]
     --[ Secret(~code), Honest($H), Honest($I),
         Authentic($H, <'H', 'I', ~tid, pkH, mc>),
	 Commit_I($I, $H, <'H', 'I', <~tid, pkH, mc>>) ]->
     [ ]


/*
 * Note: in the following, we do not consider key compromises
 * because (asymmetric) keys are not used in this protocol.
 */
 
/* Safety check */
lemma executable:
      exists-trace
	"Ex A B m #i #j. Running_H(A, B, m) @i & Commit_I(B, A, m) @j & #i < #j"

/* Secrecy of the code sent by the Issuer and back by the Holder */
lemma code_secrecy:
      "All c #i. Secret(c) @ #i ==> not (Ex #j. K(c) @ #j)"

/* Authenticity of the public key received by the Issuer from the Holder */
lemma pkH_authenticity:
      "All H m #i. Authentic(H, m) @ #i
      	   ==>
	   (Ex I #j. Running_H(H, I, m) @ #j & #j < #i)"

/* Injective agreement for secret code message exchange */
lemma code_injective_agreement:
      "All H I t #i.
      	   Commit_H(H, I, t) @ i
      	   ==>
	   (Ex #j. Running_I(I, H, t) @j
		& j < i
		& not (Ex H2 I2 #i2. Commit_H(H2, I2, t) @i2
		  & not (#i2 = #i)))"

/* Injective agreement for Holder's pk message exchange */
lemma pkH_injective_agreement:
      "All H I t #i.
      	   Commit_I(I, H, t) @ i
      	   ==>
	   (Ex #j. Running_H(H, I, t) @j
		& j < i
		& not (Ex H2 I2 #i2. Commit_I(I2, H2, t) @i2
		  & not (#i2 = #i)))"

end