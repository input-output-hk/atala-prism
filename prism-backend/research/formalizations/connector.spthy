/**
 * Description: Model for e2e based on QR code sharing and ECIES
 * Date: 20210922
 * Authors: Jesus Diaz Vico, IOHK Atala and Research teams.
 */

theory Connector
begin

/*
 The protocol we want to model is, in Alice and Bob notation, as follows:

 (I stands for Issuer, H for Holder, C for connector)
 ( => is secure channel; -> is normal channel )

 1. I => H: tid, pk_iss, code // Shared via QR, i.e., secure channel
 2. H -> C: <tid, pk_hol>, mac(<tid, pk_hol>, code)
 3. C -> I: <tid, pk_hol> mac(<tid, pk_hol>, code)
 4. I:      r = Fresh(Z)
            s = (pk_hol)^r
            k_1 || k_2 = kdf(s)
            c = senc(k_1, cred)
            m = senc(k_2, Hash(c))
 5. I -> C: <c, m, g^r>
 6. C -> H: <c, m, g^r>
 7. H:      s = (g^r)^u
            k_1 || k_2 = kdf(s)
            m' = senc(k_2, Hash(c))
            Assert m = m'
            cred = sdec(k_1, c)

 Steps 1-3 are the QRdid protocol, whereby the Issuer gets assured that 
 the holder's public key is pkH. It needs a secure channel.
 
 Steps 4-7 correspond to an execution of an ECIES protocol, whereby the
 Issuer leverages the holder's public key obtained in the previous steps.

 After this, the holder is assured that the credential s/he received comes
 from the legitimate issuer, whereas the issuer is assured that only the
 intended holder received it. Of course, unless any of them is compromised.

 Note: The connector is not modelled here because it is treated essentially
 as an untrusted party -- hence, it *is* the adversary, which is natively
 modelled by Tamarin as a Dolev-Yao adversary.

*/

builtins: hashing, symmetric-encryption, asymmetric-encryption, signing,
	  diffie-hellman

/* Note: splitL, splitR and merge functions are aimed to be used for
   splitting bitstrings to be used as keys. However, they do not model
   that leaking part of a key *does* leak much information about that
   key. Hence, for this modelling to be valid, we should check that all
   the larger bitstring and its splits are kept secret. */
functions: kdf/1, splitL/1, splitR/1, merge/2, mac/2

equations: merge(splitL(v),splitR(v)) = v

/* Rule for sending a message through a secure (confidential & authenticated) 
   channel. Used here for QR code sharing. */
rule ChanOut_S:
        [ Out_S($A,$B,x) ]
      --[ ChanOut_S($A,$B,x) ]->
        [ !Sec($A,$B,x) ]

/* Rule for sending a message from a secure (confidential & authenticated) 
   channel. Used here for QR code sharing. */
rule ChanIn_S:
        [ !Sec($A,$B,x) ]
      --[ ChanIn_S($A,$B,x) ]->
        [ In_S($A,$B,x) ]

rule Register_pke:
  [ Fr(~x) ] 
  --[ RegisteredE($A) ]-> 
  [ !Pke($A, 'g'^~x),
    !Ltke($A, ~x) ]

rule Register_pks:
  [ Fr(~x) ]
  --[ RegisteredS($A) ]->
  [ !Pks($A, pk(~x)),
    !Ltks($A, ~x) ]

rule Reveal_ltke:
  [ !Ltke(A, ltke) ]
  --[ LtkeReveal(A) ]->
  [ Out(ltke) ]

rule Reveal_ltks:
  [ !Ltks(A, ltks) ]
  --[ LtksReveal(A) ]->
  [ Out(ltks) ]

/* Rule for fetching an existing DH public key. */
rule Get_pke:
  [ !Pke(A, pk) ] 
  --> 
  [ Out(pk) ]

/* Rule for fetching an existing public key for signature verification. */
rule Get_pks:
  [ !Pks(A, pk) ]
  -->
  [ Out(pk) ]

/* The issuer shares the QR code via the secure channel. */
rule Issuer_1:
     [ Fr(~code),
       Fr(~tid),
       !Ltks($I, ~lkIs)]
     -->
     [ Out_S($I, $H, <~tid, ~code, pk(~lkIs)>),
       State_I($I, $H, ~tid, ~code, ~lkIs) ]

/* The holder receives the QR code through the secure channel, and responds. */
rule Holder_2:
     [ In_S($I, $H, <~tid, ~code, pkIs>),
       !Ltke($H, ~lkHe),
       !Pke($H, pkHe)]
     --[ Honest($H),
         SendPkh($H, <~code, pkHe>)]->
     [ State_H($H, $I, ~lkHe),
       Out(<<~tid, pkHe>, mac(<~tid, pkHe>, ~code)>) ]

/* The issuer receives the public key of the holder, authenticate with a MAC, 
   via an insecure channel */
rule Issuer_3:
     let k = kdf(pkHe^~r)
         k1 = splitL(k)
	 k2 = splitR(k)
	 sig = sign(h(~cred), ~lkIs)
 	 mc = mac(h(~cred), k2)	
 	 ccred = senc(~cred, k1)
     in
     [ State_I($I, $H, ~tid, ~code, ~lkIs),
       In(<<~tid, pkHe>, mac(<~tid, pkHe>, ~code)>),
       Fr(~r),
       Fr(~cred) ]
     --[ SecretI($I, $H, ~code),
         RecvPkh($I, <~code, pkHe>),
	 SendI($I, ~cred),
         Gencred($H, ~cred) ]->
     [ Out(<ccred, mc, sig, 'g'^~r>)]     
     

/* The holder receives the ECIES-encrypted message by the issuer, and 
   decrypts it. */
rule Holder_4:
     let k = kdf(R^~lkH)
         k1 = splitL(k)
	 k2 = splitR(k)
	 cred = sdec(ccred, k1)
     in
     [ State_H($H, $I, ~lke),
       !Ltke($H, ~lkH),
       !Pks($I, pkI),
       In(<ccred, mac(h(cred), k2), sig, R>) ]
     --[ RecvH($H, cred),
	 Eq(verify(sig, h(cred), pkI), true),
         SecretH(cred)]->
     []

restriction Equality:
	    "All x y #i. Eq(x,y) @i ==> x = y"

/* Safety check */
lemma executable:
      exists-trace
	"Ex A B m #i #j. SendI(A, m) @i & RecvH(B, m) @j"

/* Code secrecy */
lemma code_secrecy:
      /* It cannot be that an */
      "not(
	/* issuer has shared a code with */
	Ex I H c #i #j #k. SecretI(I, H, c) @ #i
	/* an honest holder */
	& Honest(H) @j
	/* and the adversary knows the code */
	& K(c) @ #k
	/* without having corrupted the issuer */
	& not(Ex #r. LtksReveal(I) @ #r)
      )"

/* Holder PK authenticity */
lemma pkH_auth:

      "(
        /* For all keys received by I associated with c, that come from H */
	All I c H kH #s #t. RecvPkh(I, <c, kH>) @ #s & SendPkh(H, <c, kH>) @ #t & #t < #s 
	==>
	/* the issuer previously shared the code c with H */
	(Ex I H c #i. ChanOut_S(I,H,c) @ #i & i < t)
      )"

/* Credential secrecy  */
lemma cred_secrecy:
      /* It cannot be that a */
      "not(
	/* Holder 'H' has received a credential 'c' generated honestly for him */
	Ex H c #i #j #k. Gencred(H, c) @ #i & RecvH(H, c) @ #j
	/* and the adversary knows 'c' */
	& K(c) @ #k
	/* without having compromised the holder's key. */
	& not(Ex #r. LtkeReveal(H) @ #r)	
      )"

/* Credential authenticity: it comes from the Issuer. */
lemma cred_auth:
      "(
        /* For all credentials 'c' received by a holder 'H' */
	All H c #i. RecvH(H, c) @ #i
      	==>
	/* were sent by an honest issuer 'I', or the adversary compromised 'I''s key */
	((Ex I #j. SendI(I, c) @ #j) | (Ex I #k. LtksReveal(I) @ #k))	
      )"

end