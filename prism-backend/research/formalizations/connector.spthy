/**
 * Description: Model for e2e based on ECIES
 * Date: 20210922
 * Authors: Jesus Diaz Vico, IOHK Atala and Research teams.
 */

theory Connector
begin

/*
 The protocol we want to model is, in Alice and Bob notation, as follows:

 (I stands for Issuer, H for Holder, C for connector)
 ( => is secure channel; -> is normal channel )

 1. I => H: pk_iss, code // Shared via QR, i.e., secure channel
 2. H -> C: aenc(<pk_hol, code>, pk_iss) // pk_iss = g^v, pk_hol = g^u
 3. C -> I: aenc(<pk_hol, code>, pk_iss)
 4. I:      r = Fresh(Z)
            s = (pk_hol)^r
            k_1 || k_2 = kdf(s)
            c = senc(k_1, data)
            m = senc(k_2, Hash(c))
 5. I -> C: <c, m, g^r>
 6. C -> H: <c, m, g^r>
 7. H:      s = (g^r)^u
            k_1 || k_2 = kdf(s)
            m' = senc(k_2, Hash(c))
            Assert m = m'
            data = sdec(k_1, c)
*/

builtins: hashing, symmetric-encryption, asymmetric-encryption, signing, diffie-hellman

/* Note: splitL, splitR and merge functions are aimed to be used for
   splitting bitstrings to be used as keys. However, they do not model
   that leaking part of a key *does* leak much information about that
   key. Hence, for this modelling to be valid, we should check that all
   the larger bitstring and its splits are kept secret. */
functions: kdf/1, splitL/1, splitR/1, merge/2, mac/2

equations: merge(splitL(v),splitR(v)) = v

/* Rule for sending a message through a secure (confidential & authenticated) 
   channel. Used here for QR code sharing. */
rule ChanOut_S:
        [ Out_S($A,$B,x) ]
      --[ ChanOut_S($A,$B,x) ]->
        [ !Sec($A,$B,x) ]

/* Rule for sending a message from a secure (confidential & authenticated) 
   channel.  Used here for QR code sharing. */
rule ChanIn_S:
        [ !Sec($A,$B,x) ]
      --[ ChanIn_S($A,$B,x) ]->
        [ In_S($A,$B,x) ]

/* Rule for generating keypairs. */
rule Register_pk:
  [ Fr(~x) ] 
  --> 
  [ !Pk($A, 'g'^~x),//pk(~x)),
    !Ltk($A, ~x) ]

/* Rule for fetching an existing public key. */
rule Get_pk:
  [ !Pk(A, pk) ] 
  --> 
  [ Out(pk) ]

/* The issuer shares the QR code via the secure channel. */
rule Issuer_1:
     [ Fr(~secret),
       !Ltk($I, ~lkI) ]
     --[ Step('1'),
         Role($I, 'Issuer'),
	 Secret(~secret),
         Send($I, <~secret, pk(~lkI)>) ]->
     [ Out_S($I, $H, <~secret, pk(~lkI)>),
       State_I_1($I, $H, ~secret, ~lkI) ]

/* The holder receives the QR code through the secure channel, and responds. */
rule Holder_2:
     [ In_S($I, $H, <~secret, pkI>),
       !Ltk($H, ~lkH) ]
     --[ Step('2'),
         Role($H, 'Holder'),
	 Recv($H, <~secret, pkI>),         
         Secret(~secret),
	 Send($H, <~secret, pk(~lkH)>) ]->
     [ State_H_2($I, $H, ~lkH, pkI),
       Out(aenc(<~secret, pk(~lkH)>, pkI)) ]

/* The issuer receives the message forwarded by the connector, and initiates the
   ECIES protocol. */
rule Issuer_3:
     let pkH = snd(adec(cIn, ~lkI))
         secretp = fst(adec(cIn, ~lkI))
         k = kdf(pkH^~r)
         k1 = splitL(k)
	 k2 = splitR(k)
	 sig = sign(~mOut, ~lkI)
 	 mc = mac(h(<~mOut, sig, pkH^~r>), k2)	
 	 c = senc(<~mOut, sig>, k1)	 
     in
     [ State_I_1($I, $H, ~secret, ~lkI),
       In(cIn),
       Fr(~r),     
       Fr(~mOut)
     ]
     --[ Step('3'),
         Role($I, 'Issuer'),
         Recv($I, <~secret, pkH>),
         Eq(secretp, ~secret),
	 Secret(~mOut),
	 Send($I, ~mOut) ]->
     [ Out(<c, mc, 'g'^~r>) ]

/* The holder receives the ECIES-encrypted message by the issuer, and 
   decrypts it. */
rule Holder_4:
     let k = kdf(R^~lkH)
         k1 = splitL(k)
	 k2 = splitR(k)
	 mIn = fst(sdec(cIn, k1))
	 sig = snd(sdec(cIn, k1))
     in
     [ State_H_2($I, $H, ~lkH, pkI),
       In(<cIn, mac(h(<mIn,sig, R>), k2), R>) ]
     --[ Step('4'),
         Role($H, 'Holder'),
         Recv($H, mIn),
	 Eq(verify(sig, mIn, pkI), true),
         Secret(mIn),
	 SessionKey($I, $H, R^~lkH)]->
     []

restriction Equality:
	    "All x y #i. Eq(x,y) @i ==> x = y"

/* Safety check */
lemma executable:
      exists-trace
	"Ex A B m #i #j. Send(A,m) @i & Step('3') @i &
	      	    	 Recv(B,m) @j & Step('4') @j"

/* The secret code sent by the Issuer at step 1 is secret w.r.t. the Issuer. */
lemma secret_code_issuer:
     "All n #i #j. Secret(n) @i & Step('1') @i & K(n) @j ==> F"

/* The secret code received by the Holder at step 2 is secret w.r.t. the Holder. */
lemma secret_code_holder:
     "All n #i #j. Secret(n) @i & Step('2') @i & K(n) @j ==> F"

/* The ECIES-protected message sent by the Issuer is secret w.r.t. the Issuer. */
lemma secret_ecies_issuer:
     "All m #i #j. Secret(m) @i & Step('3') @i & K(m) @j ==> F"

/* The ECIES-protected message received by the Holder is secret w.r.t. the Holder. */
lemma secret_ecies_holder:
     "All m #i #j. Secret(m) @i & Step('4') @i & K(m) @j ==> F"
     
end