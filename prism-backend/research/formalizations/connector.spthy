/**
 * Description: Model for e2e based on ECIES
 * Date: 20210922
 * Authors: Jesus Diaz Vico, IOHK Atala and Research teams.
 */

theory Connector
begin

/*
 The protocol we want to model is, in Alice and Bob notation, as follows:

 (I stands for Issuer, H for Holder, C for connector)
 ( => is secure channel; -> is normal channel )

 1. I => H: pk_iss, code // Shared via QR, i.e., secure channel
 2. H -> C: aenc(pk_iss, <pk_hol, code>) // pk_iss = g^v, pk_hol = g^u
 3. C -> I: aenc(pk_iss, <pk_hol, code>)
 4. I:      r = Fresh(Z)
            s = (pk_hol)^r
            k_1 || k_2 = kdf(s)
            c = senc(k_1, data)
            m = senc(k_2, Hash(c))
 5. I -> C: <c, m, g^r>
 6. C -> H: <c, m, g^r>
 7. H:      s = (g^r)^u
            k_1 || k_2 = kdf(s)
            m' = senc(k_2, Hash(c))
            Assert m = m'
            data = sdec(k_1, c)
*/

builtins: hashing, symmetric-encryption, asymmetric-encryption, signing, diffie-hellman

/* Note: splitL, splitR and merge functions are aimed to be used for
   splitting bitstrings to be used as keys. However, they do not model
   that leaking part of a key *does* leak much information about that
   key. Hence, for this modelling to be valid, we should check that all
   the larger bitstring and its splits are kept secret. */
functions: kdf/1, splitL/1, splitR/1, merge/2, mac/2

equations:
	merge(splitL(v),splitR(v)) = v

/* Rule for sending a message through a secure (confidential & authenticated) 
   channel. Used here for QR code sharing. */
rule ChanOut_S:
        [ Out_S($A,$B,x) ]
      --[ ChanOut_S($A,$B,x) ]->
        [ !Sec($A,$B,x) ]

/* Rule for sending a message from a secure (confidential & authenticated) 
   channel.  Used here for QR code sharing. */
rule ChanIn_S:
        [ !Sec($A,$B,x) ]
      --[ ChanIn_S($A,$B,x) ]->
        [ In_S($A,$B,x) ]

/* Rule for generating keypairs of DH type. */
rule Generate_DH_key_pair:
  [ Fr(~x) ] 
  --> 
  [ !Pk($A,'g'^~x),
    Out('g'^~x),
    !Ltk($A,~x) ]

/* The issuer shares the QR code via the secure channel. */
rule Issuer_1:
     [ Fr(~secret),
       !Ltk($I, ~lkI) ]
     --[ Send1($I, ~secret),
         Secret_I(~secret) ]->
     [ Out_S($I, $H, <~secret, $I>),
       State_I_1($I, ~lkI, ~secret) ]

/* The holder receives the QR code through the secure channel, and responds. */
rule Holder_2:
     [ In_S($I, $H, <~secret, $I>),
       !Pk($I, pkI), // Fetch issuer's pk
       !Ltk($H, ~lkH),
       !Pk($H, pkH) ]
     --[ Recv1($H, ~secret),
         Secret_H(~secret),
	 Send2($H, $H) ]->
     [ Out(aenc(<~secret, $H>, pkI)),
       State_H_2($I, $H, pkI, ~lkH, ~secret)
     ]

/* The issuer receives the message forwarded by the connector, and initiates the
   ECIES protocol. */
rule Issuer_3:
     let mIn = adec(c1, ~lkI)
         secretp = fst(mIn)
         k = kdf(pkH^~r)
         k1 = splitL(k)
	 k2 = splitR(k)
     in
     [ State_I_1($I, ~lkI, ~secret),
       In(aenc(<secretp, $H>, 'g'^~lkI)),
       !Pk($H, pkH),
       Fr(~r),     
       Fr(~mOut)
     ]
     --[ Eq(secretp, ~secret),
         Recv2($I, $H),
	 Send3($I, ~mOut),
	 Secret_M_I(~mOut) ]->
     [ Out(<senc(~mOut, k1), mac(h(~mOut), k2), 'g'^~r>) ]

/* The holder receives the ECIES-encrypted message by the issuer, and 
   decrypts it. */
rule Holder_4:
     let k = kdf(R^~lkH)
         k1 = splitL(k)
	 k2 = splitR(k)
	 mIn = sdec(cIn,k1)
     in
     [ In(<cIn, mac(h(mIn), k2), R>),
       State_H_2($I, $H, pkI, ~lkH, ~secret) 
     ]
     --[ Recv3($H, mIn),
         Secret_M_H(mIn) ]->
     []

/* Safety check */
lemma executable:
      exists-trace
	"Ex A B m #i #j. Send3(A,m)@i & Recv3(B,m) @j"

/* The secret value shared by the Issuer is actually secret. */
lemma secret_issuer:
     "All n #i #j. Secret_I(n) @i & K(n) @j ==> F"

/* The secret value received by the Holder is actually secret. */
lemma secret_holder:
     "All n #i #j. Secret_H(n) @i & K(n) @j ==> F"

/* The ECIES-protected message sent by the Issuer is actually secret. */
lemma secret_ecies_issuer:
     "All m #i #j. Secret_M_I(m) @i & K(m) @j ==> F"

/* The ECIES-protected message received by the Holder is actually secret. */
lemma secret_ecies_holder:
     "All m #i #j. Secret_M_H(m) @i & K(m) @j ==> F"
     
end