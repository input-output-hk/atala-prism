/**
 * Description: Model for e2e based on ECIES
 * Date: 20210922
 * Authors: Jesus Diaz Vico, IOHK Atala and Research teams.
 */

theory ECIES
begin

/*
 
 Assumption: Prior to start the protocol, the Issuer has certainty that
 the Holder's public key is pkH, and the Holder has certainty that the
 Issuer's public key is pkI. This is achieved via the QRdid protocol,
 modelled separately.

 The protocol we want to model is, in Alice and Bob notation, as follows:

 1. I:      r = Fresh(Z)
            s = (pk_hol)^r
            k_1 || k_2 = kdf(s)
            c = senc(k_1, data)
            m = senc(k_2, Hash(c))
 2. I -> C: <c, m, g^r>
 3. C -> H: <c, m, g^r>
 4. H:      s = (g^r)^u
            k_1 || k_2 = kdf(s)
            m' = senc(k_2, Hash(c))
            Assert m = m'
            data = sdec(k_1, c)
*/

builtins: hashing, symmetric-encryption, signing, diffie-hellman

/* Note: splitL, splitR and merge functions are aimed to be used for
   splitting bitstrings to be used as keys. However, they do not model
   that leaking part of a key *does* leak much information about that
   key. Hence, for this modelling to be valid, we should check that all
   the larger bitstring and its splits are kept secret. */
functions: kdf/1, splitL/1, splitR/1, merge/2, mac/2

equations: merge(splitL(v),splitR(v)) = v

/* Rule for generating keypairs for key exchange. */
rule Register_pke:
  [ Fr(~x) ] 
  --[ RegisteredE($A) ]-> 
  [ !Pke($A, 'g'^~x),
    !Ltke($A, ~x) ]

rule Register_pks:
  [ Fr(~x) ]
  --[ RegisteredS($A) ]->
  [ !Pks($A, pk(~x)),
    !Ltks($A, ~x) ]

rule Reveal_ltke:
  [ !Ltke(A, ltke) ]
  --[ LtkeReveal(A) ]->
  [ Out(ltke) ]

rule Reveal_ltks:
  [ !Ltks(A, ltks) ]
  --[ LtksReveal(A) ]->
  [ Out(ltks) ]

/* Rule for fetching an existing DH public key. */
rule Get_pke:
  [ !Pke(A, pk) ] 
  --> 
  [ Out(pk) ]

/* Rule for fetching an existing public key for signature verification. */
rule Get_pks:
  [ !Pks(A, pk) ]
  -->
  [ Out(pk) ]

/* The issuer generates the credential and initiates the ECIES protocol. */
rule Issuer_1:
     let k = kdf(pkH^~r)
         k1 = splitL(k)
	 k2 = splitR(k)
	 sig = sign(h(~cred), ~lkIs)
 	 mc = mac(h(~cred), k2)	
 	 ccred = senc(~cred, k1)	 
     in
     [ !Ltks($I, ~lkIs),
       !Pke($H, pkH),
       Fr(~r),
       Fr(~cred)
     ]
     --[ SendI($I, ~cred),
         Gencred($H, ~cred) ]->
     [ Out(<ccred, mc, sig, 'g'^~r>) ]

/* The holder receives the ECIES-encrypted message by the issuer, and 
   decrypts it. */
rule Holder_2:
     let k = kdf(R^~lkH)
         k1 = splitL(k)
	 k2 = splitR(k)
	 cred = sdec(ccred, k1)
     in
     [ !Ltke($H, ~lkH),
       !Pks($I, pkI),
       In(<ccred, mac(h(cred), k2), sig, R>) ]
     --[ RecvH($H, cred),
	 Eq(verify(sig, h(cred), pkI), true),
         Secret(cred)]->
     []

restriction Equality:
	    "All x y #i. Eq(x,y) @i ==> x = y"

/* Safety check */
lemma executable:
      exists-trace
	"Ex A B m #i #j. SendI(A, m) @i & RecvH(B, m) @j"

/* Credential secrecy  */
lemma cred_secrecy:
      /* It cannot be that a */
      "not(
	/* Holder 'H' has received a credential 'c' generated honestly for him */
	Ex H c #i #j #k. Gencred(H, c) @ #i & RecvH(H, c) @ #j
	/* and the adversary knows 'c' */
	& K(c) @ #k
	/* without having compromised the holder's key. */
	& not(Ex #r. LtkeReveal(H) @ #r)	
      )"

/* Credential authenticity: it comes from the Issuer. */
lemma cred_auth:
      "(
        /* For all credentials 'c' received by a holder 'H' */
	All H c #i. RecvH(H, c) @ #i
      	==>
	/* were sent by an honest issuer 'I', or the adversary compromised 'I''s key */
	((Ex I #j. SendI(I, c) @ #j) | (Ex I #k. LtksReveal(I) @ #k))	
      )"
      
end