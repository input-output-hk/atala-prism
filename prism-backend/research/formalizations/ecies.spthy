/**
 * Description: Model for e2e based on ECIES
 * Date: 20210922
 * Authors: Jesus Diaz Vico, IOHK Atala and Research teams.
 */

theory ECIES
begin

/*
 
 Assumption: Prior to start the protocol, the Issuer has certainty that
 the Holder's public key is pkH, and the Holder has certainty that the
 Issuer's public key is pkI. This is achieved via the QRdid protocol,
 modelled separately.

 The protocol we want to model is, in Alice and Bob notation, as follows:

 1. I:      r = Fresh(Z)
            s = (pk_hol)^r
            k_1 || k_2 = kdf(s)
            c = senc(k_1, data)
            m = mac(k_2, c)
 2. I -> C: <c, m, g^r>
 3. C -> H: <c, m, g^r>
 4. H:      s = (g^r)^u
            k_1 || k_2 = kdf(s)
            m' = mac(k_2, c)
            Assert m = m'
            data = sdec(k_1, c)
*/

builtins: hashing, symmetric-encryption, signing, diffie-hellman

/* Note: splitL, splitR and merge functions are aimed to be used for
   splitting bitstrings to be used as keys. However, they do not model
   that leaking part of a key *does* leak much information about that
   key. Hence, for this modelling to be valid, we should check that all
   the larger bitstring and its splits are kept secret. */
functions: kdf/1, splitL/1, splitR/1, merge/2, mac/2

equations: merge(splitL(v),splitR(v)) = v

/* Rule for generating keypairs for key exchange. */
rule Register_pke:
  [ Fr(~x) ] 
  --[ RegisteredE($A) ]-> 
  [ !Pke($A, 'g'^~x),
    !Ltke($A, ~x) ]

rule Register_pks:
  [ Fr(~x) ]
  --[ RegisteredS($A) ]->
  [ !Pks($A, pk(~x)),
    !Ltks($A, ~x) ]

rule Reveal_ltke:
  [ !Ltke(A, ltke) ]
  --[ LtkeReveal(A) ]->
  [ Out(ltke) ]

rule Reveal_ltks:
  [ !Ltks(A, ltks) ]
  --[ LtksReveal(A) ]->
  [ Out(ltks) ]

/* Rule for fetching an existing DH public key. */
rule Get_pke:
  [ !Pke(A, pk) ] 
  --> 
  [ Out(pk) ]

/* Rule for fetching an existing public key for signature verification. */
rule Get_pks:
  [ !Pks(A, pk) ]
  -->
  [ Out(pk) ]

/* Rule for initializing the issuer */
rule Issuer_Init:
     [ Fr(~id), !Ltks($I, ~lkIs) ]
     --[ Create($I, ~id), Role('I') ]->
     [ St_Issuer_0($I, ~id, ~lkIs) ]

/* Rule for initializing the holder */
rule Holder_Init:
    [ Fr(~id), !Ltke($H, ~lkHe) ]
     --[ Create($H, ~id), Role('H') ]->
     [ St_Holder_0($H, ~id, ~lkHe) ]

/* The issuer generates the credential and initiates the ECIES protocol. */
rule Issuer_1:
     let k = kdf(pkHe^~r)
         k1 = splitL(k)
	 k2 = splitR(k)
	 sig = sign(h(~cred), ~lkIs)
 	 ccred = senc(~cred, k1)
 	 mc = mac(ccred, k2)		 
     in
     [ St_Issuer_0($I, ~id, ~lkIs),
       !Pke($H, pkHe),
       Fr(~r),
       Fr(~cred)
     ]
     --[ SendI($I, ~cred),
         Secret(~cred), Role('I'), Honest($H), Honest($I),
	 Running_I($I, $H, <'I', 'H', <ccred, mc, sig, 'g'^~r>>)
	 ]->
     [ Out(<ccred, mc, sig, 'g'^~r>) ]

/* The holder receives the ECIES-encrypted message by the issuer, and 
   decrypts it. */
rule Holder_2:
     let k = kdf(R^~lkHe)
         k1 = splitL(k)
	 k2 = splitR(k)
	 cred = sdec(ccred, k1)
	 mc = mac(ccred, k2)
     in
     [ St_Holder_0($H, ~id, ~lkHe),
       !Pks($I, pkIs),
       In(<ccred, mc, sig, R>) ]
     --[ Eq(verify(sig, h(cred), pkIs), true),
//	 Authentic($H, cred),
	 Authentic($H, <'I', 'H', <ccred, mc, sig, R>>),
         Secret(cred), Role('H'), Honest($H), Honest($I),
	 Commit_H($H, $I, <'I', 'H', <ccred, mc, sig, R>>)]->
     []

restriction Equality:
	    "All x y #i. Eq(x,y) @i ==> x = y"

/* Safety check */
lemma executable:
      exists-trace
	"Ex A B m #i #j. Running_I(A, B, m) @i & Commit_H(B, A, m) @j"

/* Credential secrecy from the point of view of an honest issuer */
lemma cred_secrecy_issuer:
      all-traces
      "(All c #i. Secret(c) @ #i & Role('I') @ #i
      	   ==>
	   (not (Ex #j. K(c) @ #j)) |
	   (Ex H #j. LtkeReveal(H) @ #j & Honest(H) @ #i)
      )"

/* Credential secrecy from the point of view of an honest holder */
lemma cred_secrecy_holder:
      all-traces
      "(All c #i. Secret(c) @ #i & Role('H') @ #i
      	   ==>
	   (not (Ex #j. K(c) @ #j)) |
	   (Ex H #j. LtkeReveal(H) @ #j & Honest(H) @ #i) |
	   (Ex I #j. LtksReveal(I) @ #j & Honest(I) @ #i)
      )"

/* Credential authenticity: it comes from the Issuer. */
lemma cred_auth:
      "All H m #i. Authentic(H, m) @i
      	   ==>
//	   ((Ex I #j. SendI(I, m) @j & j < i) |
	   ((Ex I #j. Running_I(I, H, m) @j & j < i) |
	    (Ex I #j. LtksReveal(I) @j) |
	    (Ex #j. LtkeReveal(H) @j))"

/* Injective agreement for credential  message exchange */
lemma cred_injective_agreement:
      "All H I t #i.
      	   Commit_H(H, I, t) @ i
      	   ==>
	   (Ex #j. Running_I(I, H, t) @j
		& j < i
		& not (Ex H2 I2 #i2. Commit_H(H2, I2, t) @i2
		  & not (#i2 = #i)))"
      
end