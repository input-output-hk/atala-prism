\section{Anonymous Credentials}
\label{sec:ac}

First proposed in \cite{chau85}.
CL signatures (idemix) \cite{cl01,cl04}.
UC formalisation in \cite{cdhk15}.
Brands works (U-prove).
Coconut paper, referenced in \cite[Section 1]{cdl+20}: anonymous credentials with
threshold opening.

\begin{enumerate}
\item Main intuition.
\item Evolution of main security models.
\item Variations concerning functionality.
\item Evolution in efficiency.
\item Main issues.
\item Approx. number of related works in main crypto+security venues: IACR,
  Esorics, CCS, AsiaCCS, SP, EuroSP, Usenix Sec and Privacy, PETs...
\end{enumerate}

Anonymous Credentials (ACs) were first proposed by Chaum \cite{chau85}, and
later formally treated and optimized in a series of papers by Camenisch and
Lysyanskaya \cite{cl01,cl02,cl04}. Roughly speaking, users receive credentials
from an issuing organization, which can then use to authenticate against some
verifier. The main property is that this authentication process can be done
in a privacy-preserving way. This typically means that the verifier cannot
link different authentication processes by that same user. And, usually, in
credentials composed by multiple attributes, that the verifier only learns
the attributes that the user is willing to share (or a function of them).

\subsection{Approaches, Models, and Variations}

\paragraph{Main approaches.} %

\begin{enumerate}
\item[\cite{cl01}:]
  \begin{itemize}
  \item Functionality: FormNym, GrantCred, VerifyCred, VerifyCredOnNym.
  \item Approach: Users create a pseudonym with each organization. For this,
    they have to register first with the organization (associating a key to
    a user name). Whenever the user wants to get a credential from a organization
    in which he registered, he has to authenticate, and then the organization
    decides whether or not to grant the credential. Users can show their
    credentials to organizations in two ways: (1) just proving that they own a
    credential issued by some organization; or (2), proving that they own a
    credential issued by some organization \emph{and} this credential is over
    the same pseudonym that the user holds with the verifying organization.
    Essentially, pseudonyms are the concatenation of two random numbers (one
    provided by the user, and the other by the organization). They get
    associated an authenticating tag, which is a statistically hiding commitment
    to the user secret (computed using randomness provided by both user and
    organization). Organizations keep a database of the generated pseudonyms.
    To get a credential from an organization where the user registered
    previously, the user proves knowledge of the secret involved in the
    pseudonym. The organization then creates a ``random signature'' (by using a
    the inverse of random exponent, with the help of the factorization of an RSA
    modulus chosen by the organization at setup time) over the pseudonym, and
    gives that to the user. Users can show the credentials (in any of the
    previously stated two ways) by creating non-interactive zero-knowledge
    proofs of knowledge of the appropriate secret. Note that, in case (2),
    this means that the proof is over two pseudonyms, which must share the
    same secret.    
  \end{itemize}
\item[\cite{cl02}:]
  \begin{itemize}
  \item Approach: Te paper aims at improving efficiency of AC systems, as
    well as still ensuring that the user can retrieve their credentials in
    a privacy-preserving manner. For this purpose, the core of the paper
    describes a signature scheme that allows signing blocks of messages,
    and later prove, in zero-knowledge, knowledge of such a signature. To
    enable private retrieval of credentials, the authors describe a protocol
    for their signature scheme, whereby the user specifices a commitment to
    a message (or a block of messages, although this is not actually
    formalized), and get a signature of the message in return. While the
    authors do not strictly define an AC system, the application of their
    signature system and related protocols to the AC domain seems direct.
    Indeed, the same functionality as in \cite{cl01} seems straight
    forward given the cryptosystems in \cite{cl02}.
  \end{itemize}
\item[\cite{cl04}:] Follows a similar approach to \cite{cl02}, although
  changing the security assumptions to be based only on problems related
  to the discrete logarithm, and on bilinear maps. Basically, defines a
  signature scheme suitable for signing multiple messages, a protocol to
  obtain a signature on a committed value, and a protocol to prove knowledge
  of a signature. Concerning commitments, they rely on Pedersen commitment
  scheme, for which protocols are known to prove knowledge and equality of
  committed values. This lets them follow the same approach to \cite{cl02},
  which is in turn the one in \cite{cl01}.
\item[\cite{cmz14}:] This work differs from the rest in that they use
  secret key cryptography rather than public key. Namely, they assume a
  setting in which the issuer will also be the verifier (e.g., a
  transportation organization that issues tickets for its travelers). In
  this setting, it is reasonable to assume that both issuer and verifier
  will have access to the same secret. Therefore, they replace signatures
  with (algebraic) MACs. They do not create pseudonyms for end users (like
  \cite{sms+19}). Other than that, the supported functionality is similar
  to the rest: Setup and KeyGen to initialize the cryptographic parameters,
  and produce the issuer's keys, respectively; an interactive protocol for
  end users to blindly receive credentials (MACs) on their attributes; and
  an interactive protocol for showing and verifying a credential. In case
  that issuance does not need to be blinded, it becomes a non-interactive
  protocol (i.e., the issuer just produces the credential and sends it to
  the user). Otherwise, the user has to encrypt the attributes and prove
  they are correct. Presentation only requires one message from the user
  to the verifier.
\item[\cite{cdhk15}:] The approach to build anonymous credentials is roughly
  the same as in the previous works \cite{cl01,cl02,cl04}, although with
  relevant differences that make it more efficient. Basically, users create
  pseudonyms derived from a common secret. Then, any user can request a
  credential. For this, the user needs to prove knowledge of the pseudonym's
  secret. In return, the issuer produces an ``unlinkable redactable signature''
  on a set of attributes, for that pseudonym. A redactable signature is
  essentially a signature over a set (block) of messages, that enables
  subsequent verification that a subset of those messages was signed. This
  is essentially the same as in \cite{cl02,cl04}. However, to achieve
  unlinkability, \cite{cdhk15} incorporates efficient zero-knowledge proofs
  to prove correctness of the subset of the messages that a user wants to
  ``show'' in a credential showing process. This ensures unlinkability (hence,
  privacy). The internal scheme used for this is a vector commitment scheme
  that uses Lagrange interpolation to allow checking that a subset of the
  committed messages are indeed contained within the commitment. Moreover,
  both the vector commitment scheme, and the vector signing scheme, are
  structure preserving. This means that, since all the produced messages,
  commitments, and signatures, are elements of the group (rather than of the
  field), proving knowledge is much more efficient (e.g., it prevents costly
  extraction required for security proofs).
\item[\cite{dmm+18}:] Follows a completely different approach to (most) other
  works. Instead of using randomizable signatures (over committed values) or
  some equivalent building block, it relies on predicate encryption.
  Essentially, a user with attributes $A$ is given a decryption key for a
  predicate $f_A(g)$ which, given a predicate $g$, returns $g(A)$. When
  a verifier wants to check if a user has a set of attributes that meet
  certain policy $h$, challenges the user to decrypt a ciphertext over
  a random message that has been associated to predicate $h$. Then, only
  if the attribute set $A$ of the user meets policy $h$, the user will be
  able to decrypt the random message (since $f_A(h) = h(A) = 1$). This
  protocol is actually augmented with some commitments, to prevent
  misbehaviour from user and from verifier, but the approach is the same.
  \doubt{There is something weird here, or that I do not understand --
    predicate encryption requires a
    set of attributes for encryption, rather than another predicate. I have
    reached out to the authors to see if they can help me clarify this.}
\item[\cite{sms+19}:] The Coconut system follows a similar approach than the previous
  works with respect to the representation and showing protocol for credentials.
  Namely, credentials are randomizable signatures issued blindly. In this case,
  the authors rely on Pointcheval Sanders signatures \cite{ps16} as main
  building block, to which they incorporate techniques from other schemes to
  support threshold issuance.
\end{enumerate}

\paragraph{Main security models.}

\begin{enumerate}
\item[\cite{cl01}:] Security in \cite{cl01} is proven in an ad-hoc way,
  using the ideal-world/real-world paradigm. The authors describe a
  simulator for the operations supported by the system (Setup, FormNym,
  GrantCred, VerifyCred and VerifyCredOnNym), and prove that the output of this
  simulator is indistinguishable from that of the real protocol, under the
  strong RSA and Diffie-Hellman assumptions.  
\item[\cite{cl02}:] No security model is given for the anonymous credential
  application of the signature scheme (reasonably, as it is not the main focus
  of the paper). The signature scheme is proven secure (no specific mention
  to a security model, although I suppose it would be quite straight forward)
  based on the Strong RSA and Diffie-Hellman assumptions.
\item[\cite{cl04}:] Same as in \cite{cl02} (no actual security model for the
  AC system). The custom proofs are based on the DDH and LRSW assumptions.
\item[\cite{cmz14}:] The security properties proven in this work are:
  \begin{itemize}
  \item \emph{Unforgeability}: The adversary cannot produce a valid proof for a
    statement, if none of the attribute sets for which it has received a
    credential meets that statement.
  \item \emph{Anonymity}: The proofs produced in a presentation do not leak
    more information than the statement being proved.
  \item \emph{Blind issuance}: The issuance protocol is a secure two-party
    protocol for generating credentials on th euser's attributes.
  \item \emph{Key-parameter consistency}: no issuer can use different parameters
    to produce credentials of different users such that their anonymity can
    be compromised afterwards. \doubt{This somehow remembers non-frameability in
      group signatures.}
  \end{itemize}
\item[\cite{cdhk15}:] The model (and associated proofs) presented in this paper
  is very comprehensive, and detailed. Specifically, for the main building block
  (Unlinkable Redactable Signatures), the authors give both game-based
  definitions as well as an ideal functionality. This ideal functionality models
  security in a single-issuer setting. However, as it is done in the UC
  framework, it can be composed with itself, so that a scenario with multiple
  issuers, in which users can combine credentials obtained by different users
  into a single showing process (``presentation'') is directly achievable by
  composing multiple instances of the ideal functionality (one per ``proof
  part'').
\item[\cite{dmm+18}:] The authors give a game-based security model, covering
  properties of unforgeability, anonymity, and policy-hiding. The latter
  means that, for delegated verification, the verifier is oblivious to the
  policy being verified.
\item[\cite{sms+19}:] No security model is given nor adopted.
\end{enumerate}

\paragraph{Variations in functionality.}

\begin{enumerate}
\item[\cite{cl01}:] Extensions provided to the main functionality are:
  \begin{itemize}
  \item PKI-based and all-or-nothing non-transferability: Both options
    involve sharing a verifiable encryption of the user secrets. In the
    case of PKI-based non-transferability, the CA receives a verifiable
    encryption, using as key the user's master secret, of some valuable
    piece of information belonging to the user (e.g., the user's secret
    key associated to his public key with that CA). In the all-or-nothing
    case, the user shares with each organization (with which it has a
    pseudonym), a verifiable encryption of his pseudonym secret data, encrypted
    with his master secret. In both cases, if the user shares his master
    secret with someone else, then he automatically gives access to
    other relevant pieces of information (as the verifiable encryptions are
    made public by the corresponding entity).    
  \item One-show credentials: The validating tags over pseudonyms are extended
    to include an extra value in their commitment. Then, users have to reveal
    that value (or, rather, a value deterministically derived from that) in the
    zero-knowledge proofs they create at show time. Since the value is always
    the same, verifiers can check whether they have seen it before, or not.
  \item Revocation: Both local (i.e., within an organization) and global (i.e.,
    referring to an identity of the user in an external CA) is possible by
    extending the pseudonyms of the user, and the credential showing protocols,
    with values that allow subsequent decryption by a trusted party of their
    pseudonym or external identity, given a transcript of the credential
    showing.    
  \item Attributes: The paper also succinctly describes how multiple attributes
    per credential could be included. This would be done by dividing the inverval
    within the exponent used to compute the pseudonym in sub-intervals, and then
    proving that the exponent lies within a sub-interval.
  \end{itemize}
\item[\cite{cmz14}:] The paper mentions ``Credential translation'', which
  basically means being able to prove that two attributes in different
  credentials are actually the same. This is not formalized or detailed,
  though.
\item[\cite{cdhk15}:] The same as in the previous works (\cite{cl01,cl02,cl04}).
\item[\cite{dmm+18}:] The scheme supports delegated verification. Basically,
  to implement delegated verification, the delegatee receives an encryption of
  the policy it has to verify, plus a signature of the encryption. If the
  signature is valid, it re-randomizes the ciphertext for the policy, and
  sends it to the user, who follows the same protocol as in the normal case.
  The paper also mentions how to add more functionality, like delegation of
  credentials and revocation, but they are not modelled. Also interestingly,
  they claim somewhat informally (in Section 2.3) that no scheme satisfying
  anonymity in the presence of an untrustworthy issuer can support delegation
  of verification with policy hiding.
\item[\cite{sms+19}:] It is essentially the same as previous works, although it
  supports threshold issuance. Interestingly, \cite{sms+19} does not make use
  of pseudonyms. I.e., credentials are just signed (blocks of) attributes. This
  probably lets them achieve better efficiency. \doubt{This makes the scheme
    to be practically like a group signature scheme (without revocation...)}
\end{enumerate}

\paragraph{Efficiency.}

\cite{sms+19} seems to be the most efficient one (note: relies on the
Fiat-Shamir heuristic). Credentials are only composed by two G1 elements,
independently on the number of attributes.

\paragraph{Main challenges.}

\subsection{Related Primitives}

Most schemes \cite{cl01,cl02,cl04,cdhk15,sms+19} are based on randomizable
signatures, with the possibility of signing committed values, that also support
efficient proofs of knowledge.

The most recurrent signature schemes are Camenisch-Lysyanskaya \cite{cl02,cl04},
BBS/BBS+ \cite{asm06,cdl16b}, and Pointcheval Sanders \cite{ps16}, with the
exception of \cite{cdhk15} that leverages their own signature scheme, called
Unlinkable Randomizable Signatures.

\subsubsection{Pseudonym Systems}
\label{sssec:pseudonyms}

\doubt{Not sure if this fits here.}

\subsection{Applications}
\label{ssec:acapplication}

\subsubsection{Theory}
\label{sssec:actheoryapp}

Main approaches to build ACs (from ToPS paper I reviewed):

\begin{itemize}
\item Re-randomizable signatures on commitments (also as in DAA):
  \cite{cl02,cl04,lmpy16,ps16}.
\item Equivalence class signatures: \cite{fhs19,hs14}.
\item Redactable signatures \cite{cdhk15,sand20} and malleable signatures
  \cite{ckl14}.
\item Predicate encryption: \cite{dmm+18}.
\end{itemize}

PS: Tokenization.

\subsubsection{Real World Deployments}
\label{sssec:acrwdeploy}

PS: Tokenization.
U-Prove.
Idemix.
Signal's AC \needcite

\subsection{TODO}

\begin{itemize}
\item \cite{bcc+09}: Delegation.
\item \cite{dmm+18}: Functional credentials.
\item \cite{fhs19}: Structure-preserving signatures for AC.
\item \cite{cks10,aks12}: ACs with revocation.
\item \cite{ckl+15}: Formal treatment of privacy-preserving credentials.
\end{itemize}

[ToPS paper I reviewed] refers to a strategy to do threshold issuing in \cite{bbh06}.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "sok-privsig"
%%% End:
