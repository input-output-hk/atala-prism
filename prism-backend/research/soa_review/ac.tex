\section{Anonymous Credentials}
\label{sec:ac}

\paragraph{Main intuition.}
%
Anonymous Credentials (ACs) were first proposed by Chaum \cite{chau85}, and
further studied, formally treated, and optimized, in a series of papers by
Camenisch and Lysyanskaya \cite{cl01,cl02,cl04} and, independently, by Brands
\cite{bran00}\footnote{Camenisch and Lysyanskaya line of work is well known for
  IBM's Idemix system, and Brands's work for Microsoft's U-Prove. More detail
  appears in the sequel.}. In an AC system, roughly speaking, users receive
credentials from an issuing organization, which they can then use to
authenticate against some verifier. The main property is that this
authentication process can be done in a privacy-preserving way. This typically
means that the verifier cannot link different authentication processes by that
same user. Also, usually, credentials are composed by multiple attributes, such
that the verifier only learns the attributes that the user is willing to share
(or a function of them).

\subsection{Approaches, Models, and Variations}
\label{ssec:acapproach}

\subsubsection{Main approaches.}
%
The more fruitful line of work within the AC domain is the one initiated by
Camenisch and Lysyanskaya \cite{cl01,cl02,cl04} (henceforth, CL credentials or,
when referring to the underlying signature schemes defined in \cite{cl02,cl04},
CL signatures). The core idea is simple: in order to build a (basic) AC
system, all that is needed are a commitment scheme, and a signature scheme
with efficient protocols for signing committed values, and proving knowledge
of a signature. From this, a basic AC system can be derived essentially as
follows:

\begin{enumerate}
\item User $A$, with secret value $s_A$, commits to it into $c_A$.
\item User $A$ interacts with issuer $I$ to get a signature on $s_A$. To
  avoid leaking the secret to $I$, $A$ uses $c_A$, proving knowledge of the
  associated secret. The produced signature $\sigma_A$, is $A$'s anonymous
  credential.
\item When $A$ needs to convince a verifier $B$ that she owns a valid credential
  issued by $I$, she just has to create a zero-knowledge proof of knowledge
  of $\sigma_A$.
\end{enumerate}

Usually, the commitment to the user's secret key is known as a pseudonym, or
in short form, \emph{nym}. These nyms have proven to be a useful component to
ensure security and privacy properties -- and are also leveraged in many group
signature and DAA works. Not all anonymous credentials systems use pseudonyms,
though.

A large part of the academic works in the AC domain follow this approach, which
is then extended to support enhanced functionality. For instance, in order to
let a user with two different credentials prove being the owner of both of
them, \cite{cl01,cl02,cl04} require an extra protocol for proving, in
zero-knowledge, equality of two committed and signed values.
This allows user $A$, with credential $\sigma_A^I$ obtained from issuer $I$ and
credential $\sigma_A^J$ obtained from issuer $J$, to prove $J$ that she has a
valid credential from $I$, by issuing a zero-knowledge proof of equality for
both credentials. Furthermore, if each credential is associated with a different
(set of) attribute(s), this also leads to ``naive'' constructions of
multi-attribute AC systems.

For multi-attribute ACs, though, much more efficient variants are possible. To
begin with, CL signatures allow signing blocks of messages (and commitments),
which can be seen as attributes signed by the issuer. BBS+ signatures
\cite{asm06,cdl16b}, and PS16 signatures \cite{ps16} also support similar
functionality, and have been leveraged to build multi-attribute AC systems
too (e.g., \cite{cks10} gives a construction with BBS+ credentials, and
\cite{sms+19,halp20} are based on PS16). These family of signatures on blocks
of messages have yet another very useful property: signatures are easily
randomizable, which can be used (along with the previously mentioned
zero-knowledge proofs) to make unlinkable showings of the same credential.
AC systems achieving the latter property of unlinkable showings are said
to offer \emph{multi-show} credentials.

Most of these systems also have in common that, being based on building blocks
leveraging discrete logarithm structures, they are easily extended to prove
arbitrary statements on the credentials attributes -- such as the usual ``Over
18'' claim. However, while it is certainly doable, the approach does not scale
for complex statements involving multiple attributes \todo{some concrete
  figures?}

Restricting the expressiveness, and focusing on letting the credential holder
reveal only a subset of the attributes in a credential, more efficient schemes
have been proposed, leveraging algebraic tricks such as structure-preserving
signatures on equivalence classes (SPS-EQ), along with vector commitment schemes
\cite{cdhk15}, or set commitment schemes \cite{fhs19}. The former uses Lagrange
interpolation to allow revealing only a subset of the committed messages;
while \cite{fhs19} employs set commitment schemes, mapping the attributes to
be committed to roots of a polynomial, so that opening a specific subset of the
commmitted elements just requires revealing a subset of the roots of the
polynomial.
%
Also improving efficiency, but restricting to the scenario in which the issuer
is the same entity as the verifier (as in ticketing systems for public transport),
\cite{cmz14} replaces signatures with algebraic MACs.

Within this line of credentials from randomizable signatures, we can also find
systems that can achieve high expressiveness, like the (delegatable) credentials
building on signatures with controlled malleability \cite{bcc+09,cklm14},
where \cite{cklm14} is a generalization of \cite{bcc+09}. Here, at a high level,
credentials are signatures, built from non-interactive zero-knowledge proofs of
knowledge, on commitments to the user key, that support \emph{controlled
  malleability}. This malleability means
that both the proof and the statements can be randomized and transformed, but
only for allowed transformatoins. The specific transformation considered for
delegation requires that a credential with depth $L$, can only produce a credential
with level $L+1$. Credential showings are also represented through transformations,
through which the holder proves knowledge, and equality, of the secret in the
``source'' and ``target'' nyms. Although the credentials in these works do not
include multiple attributes (some hint on how to support public attributes is
given in \cite{bcc+09}), it is certainly possible to do so through a proper
transformation -- although, probably, the result won't be very efficient if
done naively \todo{specific figures?} The notion of transformations is interesting,
though, as the authors prove that it is similar (or even more generic) than those
used to achieve expressiveness in related digital singature schemes (such as
policy-based signatures \cite{bf14} and delegatable functional signatures \cite{bms16}).
Thus, it is reasonable to expect that very expressive AC systems could be built
with this approach.

All AC systems mentioned up to this point follow, up to ``small'' variations,
the same approach: randomizable signatures on sets of (committed) messages, with
(somehow) efficient proofs. A completely different approach is described in
\cite{dmm+18}, based on predicate encryption. In predicate encryption, given
a master key pair, decryption keys associated with specific predicates can be
derived. Messages, and attribute sets, are encrypted with the master public key,
such that the resulting ciphertext can only be decrypted with a decryption key
associated with a predicate that is satisfied by the attributes in the
ciphertext. Assume an attribute space that can be represented by binary strings
in a set $\Sigma$. On one hand, policies defined by verifiers in \cite{dmm+18}
are encoded
as binary circuits through strings in $\Sigma$ too\footnote{\todo{This seems
    like an abuse of predicate encryption, as encryption receives a predicate,
    rather than an attribute set.}}, which can thus be associated to
ciphertexts through the predicate encryption process. On the other hand,
credentials received by users are decryption keys on a generic policy $f$, with
a hardcoded set of attributes (the attributes that the user is granted), that
can evaluate circuits. Then, intuitively, in order for a verifier to check
whether a user owns an attribute-based credential meeting certain policy $g$, it
creates a ciphertext, associating as attribute an encoding a circuit for $g$
(that belongs to $\Sigma$). If the user can decrypt this ciphertext, the
verifier accepts, as this means that the decryption key in the user's credential
has a hardcoded set of attributes that makes $g$ evaluate to true. This only
supports public attributes
(i.e., known to the issuer), though. A negative part of this approach is that
credential showings can only be interactive, whereas in the randomizable proofs
approach, they can be made non-interactive too.

\subsubsection{Main Security Models.}
%
All AC systems include \emph{anonymity} and \emph{unforgeability} as main
security properties. Up to minor variations depending on extra functionality,
anonymity typically captures that, concerning a user's credential, nothing
should be learnt by third parties that the user does not explicitly reveal.
E.g., for ACs that support multiple attributes and selectively disclosing
subsets of them, anonymity captures that the information leaked during a showing
of such credential is limited to the subset of attributes voluntarily revealed
by the user. In multi-show credentials, anonymity also captures that two
different showings must be unlinkable.
As mentioned, further variations in the functionality affect anonymity --
e.g., in systems supporting delegation, the delegation chain may be required
to be kept private.
% 
Concerning unforgeability, it basically captures that no adversary can make
a verifier accept a credential that has not been honestly produced by an
issuer of the system. Again, there are variations to this. For instance, when
credentials are composed of attributes that can further be selectively
disclosed. In this case, the adversary should not be able to prove ownership
of a set of attributes not contained within the set of attributes that have
been obtained by the adversary or leaked to it.

Special mention is worth to the model variation in \cite{hs21}, which divides
the user into two entities: core and helper, thus taking anonymous credentials
closer to DAA. This is reflected into the model by adding a property named
\emph{dependability}, which requires that no adversary should be capable to
show an honestly generated credential withouth compromising the core entity.

On the approach to formalize AC security notions, game-based definitions tend to
be more frequent \cite{bcc+09,cks10,cl11,cklm14,cmz14,ckl+15,dmm+18,fhs19,hs21},
also including definitions in the simulation paradigm. The UC framework
has also been used \cite{cdhk15}.

\subsubsection{Variations in functionality.}
%
\paragraph{Attributes, selective disclosure, and expressiveness.} %
Multi-attribute and multi-show credentials are the most frequent
\cite{cks10,cl11,cdhk15,ckl+15,fhs19,sms+19,halp20,hs21}, although one-show
credentials have also been studied \cite{bran00}.
Similarly, selective disclosure has also been more studied
\cite{cks10,cl11,cdhk15,sms+19,halp20,hs21}, when compared to 
more expressive AC systems \cite{bcc+09,cklm14,dmm+18}, while \cite{fhs19}
supports selective disclosure and restricted policies (specifically,
conjunctions), for the sake of efficiency. Probably, the higher attention to
selective disclosure so far is due to the fact that the building blocks enabling
efficient constructions with high expressiveness (such as SNARKs and functional
encryption) are recent in the cryptographic literature.

\paragraph{Security and privacy against issuers.} %
Blind issuance, i.e., letting users include in their credentials attributes that
are kept hidden from issuers, is also frequent (and certainly useful to, e.g.,
include secret keys; or support private attributes in general)
\cite{cklm14,ckl+15}, although it is also frequent to assume (even implicitly)
that the issuer \emph{needs} to learn the attributes it signs, and thus private
attributes are not considered, e.g. as in \cite{dmm+18,fhs19,sms+19}.
%
Threshold issuance is also interesting for decentralized scenarios, as it
protects against misbehaving issuers, but it was only considered recently in
\cite{sms+19} and, consequently, in \cite{halp20} (which actually builds on
\cite{sms+19}). \todo{Blind issuance is formally treated in \cite{bcl04}.}

\paragraph{Delegation.} %
Delegation has gained attention in the last decade \cite{bcc+09,cklm14},
including delegated verification \cite{dmm+18}, as well as supporting more
expressive proofs \cite{cklm14,dmm+18}. While the latter is indeed possible in
the early works (one can use general zero-knowledge proofs on discrete
logarithms given a CL-, BBS- or PS16- based credential) it is worth noting that
the costs are probably too high. An interesting learning, that can be extracted
from \cite{cklm14}, is that we can see delegation as a sort of policy that can
be checked with expressive policies.

\paragraph{Revocation.} %
Perhaps surprisingly, revocation is not a common functionality, although it is
certainly considered by several works, e.g. \cite{cl01,cks10,ckl+15,bran00}, and
for some it is just sketched \cite{hs21}.

\paragraph{Credential aggregation.} %
And, finally, an interesting variation that only one work seems to target,
is that of efficient aggregation of credentials created by different issuers
\cite{cl11}. As in the topic of expressiveness, the conventional approach
can easily be extended to support this: e.g., if the owner of credential A and
credential B wants to use both credentials in the same showing, she just has to
prove that they share the same secret key (although this is only possible in
schemes that embed a user secret within the credential). Still, even if
possible, this process is inefficient. \cite{cl11} leverages aggregatable
signatures, which target precisely that setting.

\subsubsection{Efficiency.}
%
\comment{This section is just a placeholder for now...}

\subsubsection{Main challenges and interesting lines of work.}
%
\comment{This section is just a placeholder for now...}

I find interesting that, given that ACs and group signatures are
essentially the same thing, there is no work (or I have not come across it)
trying to connect both. Specifically, the following questions:

\begin{itemize}
\item Anonymity properties in ACs and GSs are roughly similar. However, concerning
  unforgeability-related properties:
  \begin{itemize}
  \item The notion of traceability in GSs seems incompatible in AC systems that
    do not include a user secret key in the credentials. Even for AC systems that
    do include it, unforgeability in AC is different than traceability, as there
    is no guarantee that a credential can be traced to a ``join'' process. Or
    there is?
  \item The notion of non-frameability of GSs does not seem to have an equivalent
    in ACs. I find this kind of surprising from a practical point of view, as an
    adversary in AC systems can very well aim at impersonating an honest user,
    which may then carry consequences (e.g., legal actions) for the honest user.
    Probably, this is related to ACs not having opening, although it has been
    shown in the GS literature that schemes without opening, but with linking
    can still have a notion of non-frameability \cite{dl21} (and, certainly,
    blacklisting/revocation allows linking, and this has already been done in
    the AC domain.)
  \item Maybe I'm wrong in the two previous points, and we can draw a connection
    between (some basic notion of) unforgeability in ACs, and the usual notions
    of traceability and non-frameability in GSs. If I recall correctly, the
    \cite{bmw03} paper merged non-frameability and traceability into
    unforgeability, and this was later divided again in \cite{bsz05}. Check the
    reasoning again...
  \end{itemize}  
\item I find very surprising that essentially all the body of work in ACs is
  based on what seems to be the sign-randomize-proof approach of GSs, yet there
  is nothing (or I have not seen it) similar to the encrypt-then-prove approach.
  Can we do it? This may be due to the fact that revocation has not been
  considered as a main requirement in ACs (which, IMHO, is a drawback if we want
  systems applicable in the real world).
  \begin{itemize}
  \item Can we come up with a black-box construction of ACs from GSs, or vice
    versa? It should not be hard, and this may open a completely new breed of
    ACs (i.e., those based on the encrypt-then-prove approach).
  \end{itemize}
\item Also, forward security does not seem to have been explored in the AC
  domain (again, I may just overlooked works on it). But it has been studied in
  GSs. Can we leverage that?
\end{itemize}

\subsection{Related Primitives and Systems}
\label{ssec:acrelated}

\comment{This section is just a placeholder for now...}

\begin{itemize}
\item Anonymous Authentication systems in the line of Nymble, BLACR, PEREA...
\end{itemize}

\subsection{Real World Deployments}
\label{ssec:acrealworld}

Anonymous credential systems saw a first phase of real world deployment during
the first years of the 2010s, mostly through IBM's Idemix%
\footnote{\url{https://idemix.wordpress.com/} (last access, January 15th, 2022).}
and Microsoft's U-Prove%
\footnote{\url{https://www.microsoft.com/en-us/research/project/u-prove/} (last
access, January 15th, 2022).}. Idemix is based on the CL line of works, and
thus inherits their security and privacy properties (multi-show, selective
disclosure). U-Prove is based on on Brands's work, and thus it features
one-show credentials with selective disclosure. Both approaches also support
proving, in zero-knowledge, arbitrary predicates on the credentials' attributes
(albeit with linear costs). \todo{Verify the last claim -- they do, but I'm not
  sure if this is specified in their corresponding papers.}

In the late 2010s, anonymous credential systems started receiving increased
attention by the industry, as a consequence of the W3C's Decentralised
Identities%
\footnote{\url{https://www.w3.org/TR/did-core/} (last access, January 15th, 2022).}
and Verifiable Credentials%
\footnote{\url{https://www.w3.org/TR/vc-data-model/} (last access, January 15th,
  2022).} initiatives, associated to the blockchain world. Idemix made its way
into Hyperldedger Fabric%
\footnote{See \url{https://hyperledger-fabric.readthedocs.io/en/release-2.2/idemix.html} (last access, January 15th, 2022).}
, which since version 1.3 allows the distribution of Idemix credentials
(although they have migrated from CL-based credentials to BBS+-based ones).
Also within the umbrella of the Hyperledger consortium, we can find Indy
\needcite, which directly focuses on digital identity (as opposed to Fabric,
which is a general-purpose permissioned blockchain system). Indy is, in turn,
the evolution of Sovrin%
\footnote{\url{https://sovrin.org/} (last access, January 15th, 2022).}, one of
the main proponents of verifiable credentials, building on CL anonymous credentials%
\footnote{Note, as opposed to Idemix, which migrated to BBS+ credentials,
  Indy/Sovrin seems to stick to CL credentials, according to online
  documentation \url{https://hyperledger-indy.readthedocs.io/projects/hipe/en/latest/text/0109-anoncreds-protocol/README.html} (last access, January 15th, 2022).}
Indy has related subprojects Aries%
\footnote{\url{https://www.hyperledger.org/use/aries} (last access, January
  15th, 2022.)} and Ursa%
\footnote{\url{https://www.hyperledger.org/use/ursa} (last access, January 15th,
  2022).}; Aries deals
with other layers of the approach to credential systems defined by the W3C's
VC initiative, and Ursa is the library implementing the underlying cryptographic
primitives (e.g., CL signatures). With respect to W3C's DID and VC initiatives,
the one that is closely related to anonymous credentials is VC. Basically, this
is a set of specifications that define how to represent digital credentials and
their associated processes. Having been heavily influenced by the literature
on anonymous credentials, the specifications include (or are working on)
definitions for CL and BBS+ credentials. Within this community, there seems to
be some controversy as to the appropriate type of credentials to support.
According to a blog post%
\footnote{``Why the Verifiable Credentials Community Should Converge on BBS+'',
  \url{https://www.evernym.com/blog/bbs-verifiable-credentials/} (last
  access, January 15th, 2022).} by a cryptographer in Evernym (the company
that created Sovrin, which led to Indy) the complexity, engineering-wise, of a
verifiable credentials system with support to prove arbitrary claims on the
attributes of the credentials, makes it more desirable to restrict to
credentials supporting only selective disclosure%
\footnote{Interestingly, and confusingly, (parts of) this community equate BBS+
  credentials to selective disclosure, even though using BBS+ credentials does
  not (in theory) restrict the expressiveness of the claims that one can prove.
  This confusion seems to derive from the solution offered by the company MATTR,
  which has become one of the most popular proponents of BBS+ credentials
  restricted to selective disclosure.}
. Note that, related to the Verifiable Credentials effort, there are tens (maybe
even hundreds) of different initiatives that build credential systems claiming
to take into account privacy requirements (e.g., for healthcare use-cases, as a
consequence of the popular health passports originated from the COVID-19
pandemic). However, most of these initiatives lack formal, or even technical,
publicly accessible documentation, or have some public documentation but, as
of the moment of this writing, we are not aware of actual implementations
(like Microsoft's zero-knoweldge credentials%
\footnote{``Zero-knowledge credentials with deferred revocation checks'' white
  paper, available at \url{url{https://github.com/decentralized-identity/snark-credentials/blob/master/whitepaper.pdf}}
  (last access, January 15th, 2022.)}). Hence, we do not cover them here. 

Finally, there are also related works that have seen real world deployments
which, although do not implement an anonymous credential systems, are somehow
influenced by them. Among these, we can find Cloudflare's PrivacyPass \cite{dgs+18},
which uses blind issuance of tokens associated to a secret key, through which
service providers can implement privacy-preserving blacklisting (in this sense,
they are closer to works like PEREA \cite{atk11} or Nymble \cite{tkcs11}, than
to anonymous credentials). A similar approach is followed by Whatsapp's DIT
system \cite{hij+21} (formerly known as PrivateStats), which further supports
the inclusion of attributes in the produced tokens. In this case, DIT is
designed to support privacy-preserving logging. Both in PrivacyPass and DIT, the
produced tokens are one-use, meaning that multiple uses of the same token are
linkable.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "sok-privsig"
%%% End:
