\section{Anonymous Credentials}
\label{sec:ac}

\paragraph{Main intuition.}
%
Anonymous Credentials (ACs) were first proposed by Chaum \cite{chau85}, and
further studied, formally treated, and optimized, in a series of papers by
Camenisch and Lysyanskaya \cite{cl01,cl02,cl04} and, independently, by Brands
\needcite\footnote{Camenisch and Lysyanskaya line of work is well known for
  IBM's Idemix system, and Brands's work for Microsoft's U-Prove. More detail
  appears in the sequel.}. In an AC system, roughly speaking, users receive
credentials from an issuing organization, which they can then use to
authenticate against some verifier. The main property is that this
authentication process can be done in a privacy-preserving way. This typically
means that the verifier cannot link different authentication processes by that
same user. Usually, credentials are composed by multiple attributes, such that
the verifier only learns the attributes that the user is willing to share (or a
function of them).

\subsection{Approaches, Models, and Variations}
\label{ssec:acapproach}

\subsubsection{Main approaches.}
%
The more fruitful line of work within the AC domain is the one initiated by
Camenisch and Lysyanskaya \cite{cl01,cl02,cl04} (henceforth, CL credentials or,
when referring to the underlying signature schemes defined in \cite{cl02,cl04},
CL signatures). The core idea is simple: in order to build a (basic) AC
system, all that is needed are a commitment scheme, and a signature scheme
with efficient protocols for signing committed values, and proving knowledge
of a signature. From this, a basic AC system can be derived essentially as
follows:

\begin{enumerate}
\item User $A$, with secret value $s_A$, commits to it into $c_A$.
\item User $A$ interacts with issuer $I$ to get a signature on $s_A$. To
  avoid leaking the secret to $I$, $A$ uses $c_A$, proving knowledge of the
  associated secret. The produced signature $\sigma_A$, is $A$'s anonymous
  credential.
\item When $A$ needs to convince a verifier $B$ that she owns a valid credential
  issued by $I$, she just has to create a zero-knowledge proof of knowledge
  of $\sigma_A$.
\end{enumerate}

Usually, the commitment to the user's secret key is known as a pseudonym, or
in short form, \emph{nym}. These nyms have proven to be a useful component to
ensure security and privacy properties -- and are also leveraged in many group
signature and DAA works. 

A large part of the academic works in the AC domain follow this approach, which
is then extended to support enhanced functionality. For instance, in order to
support multiple issuers (and, in some sense, multiple attributes)
\cite{cl01,cl02,cl04} \todo{check if the references are correct} require an
extra protocol for proving, in zero-knowledge, equality of two committed and signed values.
This allows user $A$, with credential $\sigma_A^I$ obtained from issuer $I$ and
credential $\sigma_A^J$ obtained from issuer $J$, to prove $J$ that she has a
valid credential from $I$, by issuing a zero-knowledge proof of equality for
both credentials. Now, if each credential is associated with a different set of
attributes, this also lets to ``naively'' build multi-attribute AC systems.

For multi-attribute ACs, though, much more efficient variants are possible. To
begin with, CL signatures allow signing blocks of messages (and commitments),
which can be seen as attributes signed by the issuer. BBS+ signatures
\cite{am06,cdl16b}, and PS16 signatures \cite{ps16} also support similar
functionality, and have been leveraged to build multi-attribute AC systems
too (e.g., \cite{cks10} gives a construction with BBS+ credentials, and
\cite{sms+19,halp20} are based on PS16). These family of signatures on blocks
of messages have yet another very useful property: signatures are easily
randomizable, which can be used (along with the previously mentioned
zero-knowledge proofs) to make unlinkable showings of the same credential.
AC systems achieving the latter property of unlinkable showings are said
to offer \emph{multi-show} credentials.

Most of these systems also have in common that, being based on building blocks
leveraging discrete logarithm structures, they are easily extended to prove
arbitrary statements on the credentials attributes -- such as the usual ``Over
18'' claim. However, while it is certainly doable, the approach does not scale
for complex statements involving multiple attributes \todo{some concrete
  figures?}

Restricting the expressiveness, and focusing on letting the credential holder
reveal only a subset of the attributes in a credential, more efficient schemes
have been proposed, leveraging algebraic tricks such as structure-preserving
signatures on equivalence classes (SPS-EQ), along with vector commitment schemes
\cite{cdhk15}, or set commitment schemes \cite{fhs19}. The former uses Lagrange
interpolation to allow revealing only a subset of the committed messages;
\todo{what was the specific technique of \cite{fhs19}?}. \cite{fhs19}, is more
efficient, as avoids complex zero-knowledge proofs; however it does not support
blind issuance of credentials, as opposed to \cite{cdhk15} \todo{confirm this
  last part, and refine}.
%
Also improving efficiency, but restricting to the scenario in which the issuer
is the same entity as the verifier (as in ticketing systems for public transport),
\cite{cmz14}, replaces signatures with algebraic MACs.

Somewhat similar is the approach to (delegatable) credentials that builds on
signatures with controlled malleability \cite{bcc+09,cklm14}, where \cite{cklm14}
is a generalization of \cite{bcc+09}. Roughly, credentials are signatures, built
from non-interactive zero-knowledge proofs of knowledge, on commitments to the
user key, that support \emph{controlled malleability}. This malleability means
that both the proof and the statements can be randomized and transformed, but
only for allowed transformatoins. The specific transformation considered for
delegation requires that a credential with depth $L$, can only produce a credential
with level $L+1$. Credential showings are also represented through transformations,
through which the holder proves knowledge, and equality, of the secret in the
``source'' and ``target'' nyms. Although the credentials in these works do not
include multiple attributes (some hint on how to support public attributes is
given in \cite{bcc+09}), it is certainly possible to do so through a proper
transformation -- although, probably, the result won't be very efficient if
done naively \todo{specific figures?} The notion of transformations is interesting,
though, as the authors prove that it is similar (or even more generic) than those
used to achieve expresiveness in related digital singature schemes (such as
policy-based signatures \needcite and delegatable functional signatures \needcite).
Thus, it is reasonable to expect that very expressive AC systems could be built
with this approach.

All AC systems mentioned up to this point follow, up to small variations, the
same approach: randomizable signatures on sets of (committed) messages, with
(somehow) efficient proofs. A completely different approach is described in
\cite{dmm+18}, based on predicate encryption. In predicate encryption, given
a master key pair, decryption keys associated with specific predicates can be
derived. Messages, and attribute sets, are encrypted with the master public key,
such that the resulting ciphertext can only be decrypted with a decryption key
associated with a predicate that is satisfied by the attributes in the
ciphertext. Assume an attribute space that can be represented by binary strings
$\Sigma$. On one hand, policies defined by verifiers in \cite{dmm+18} are encoded
as binary circuits through strings in $\Sigma$ too\footnote{\todo{This seems
    like an abuse of predicate encryption, as encryption receives a predicate,
    rather than an attribute set.}}, which can thus be associated to
ciphertexts through the predicate encryption process. On the other hand,
credentials received by users are decryption keys on a generic policy $f$, with
a hardcoded set of attributes (the attributes that the user is granted), that
can evaluate circuits. Then, intuitively, in order for a verifier to check
whether a user owns a attribute-based credential meeting certain policy $g$, it
creates a ciphertext with encoding a circuit for $g$. If the user can decrypt
this ciphertext, the verifier accepts. This only supports public attributes
(i.e., known to the issuer), though. A negative part of this approach is that
credential showings can only be interactive, whereas in the randomizable proofs
approach, they can be made non-interactive too.

\subsubsection{Main Security Models.}
%
All AC systems include \emph{anonymity} and \emph{unforgeability} as main
security properties. Up to minor variations depending on extra functionality,
anonymity typically captures that, concerning a user's credential, nothing
should be learnt by third parties that the user does not explicitly reveal.
E.g., for ACs that support multiple attributes and selectively disclosing
subsets of them, anonymity captures that the information leaked during a showing
of such credential is limited to the subset of attributes voluntarily revealed
by the user. Since multi-show credentials are also the most common type,
anonymity also captures that two different showings must be unlinkable.
As mentioned, further variations in the functionality affect anonymity --
e.g., in systems supporting delegation, the delegation chain may be required
to be kept private.
% 
Concerning unforgeability, it basically captures that no adversary can make
a verifier accept a credential that has not been honestly produced by an
issuer of the system. Again, there are variations to this. For instance, when
credentials are composed of attributes that can further be selectively
disclosed. In this case, the adversary should not be able to prove ownership
of a set of attributes not contained within the set of attributes that have
been leaked.a showing that include attributes not contained in credentials leaked to the
adversary.

Special mention is worth to the model variation in \cite{hs20}, which divides
the user into two entities: core and helper, thus taking anonymous credentials
closer to DAA. This is reflected into the model by adding a property named
\emph{dependability}, which requires that no adversary should be capable to
show an honestly generated credential withouth compromising the core entity.

On the approach to formalize AC security notions, game-based definitions tend
to be more frequent \needcite, also including definitions in the simulation
paradigm. The UC framework has also been used \needcite, even in combination
with game-based definitions \needcite.

\subsubsection{Variations in functionality.}
%
Multi-attribute and multi-show credentials, with selective disclosure, are
the most frequent \needcite.  Blind issuance, i.e., letting users include in
their credentials attributes that are kept hidden from issuers, is also frequent
(and certainly useful to, e.g., include secret keys) \needcite. Delegation has
gained attention in the last decade \needcite, as well as supporting more
expressive proofs. While the latter is indeed possible in the early works
(one can use general zero-knowledge proofs on discrete logarithms given a
CL-, BBS- or PS16- based credential) it is worth noting that the costs are
probably too high, and it also needs to be considered in the model.
%
Perhaps surprisingly, revocation is not a common functionality, although it is
certainly considered by several works \needcite.
%
Threshold issuance is also interesting for decentralized scenarios, but it
was only considered in \cite{sms+19} and, consequently, in \cite{halp20}
(which builds on \cite{sms+19}).
%
And, finally, an interesting variation that only one work seems to target,
is that of efficient aggregation of credentials created by different issuers
\cite{cl11}. As in the topic of expressiveness, this is easily doable with the
conventional approaches: e.g., if the owner of credential A and credential B
wants to use both credentials in the same showing, she just has to prove that
they share the same secret key (although this is only possible in schemes that
embed a user secret within the credential). Still, even if possible and even
supported, this process is inefficient. \cite{cl11} leverages aggregatable
signatures, which target precisely that setting.

\subsubsection{Efficiency.}
%

\subsubsection{Main challenges.}
%

\subsection{Related Primitives}
\label{ssec:acrelated}

\begin{itemize}
\item Anonymous Authentication systems in the line of Nymble, BLACR, PEREA...
\end{itemize}

\subsection{Real World Deployments}
\label{ssec:acrealworld}

\subsection{TODOs}

\begin{itemize}
\item \cite{bckl08}.
\item \cite{sand20}.
\item \cite{kkl+16}: achieves similar results to \cite{cgm16} with a different approach?
\end{itemize}

[ToPS paper I reviewed] refers to a strategy to do threshold issuing in \cite{bbh06}.

Concepts in ACs: multishow, one-show (Brands et al); interactive vs non-interactive
showings (differentiation made in \cite[p.6]{fhs19} but, why would one want interactive,
in the real world?)

Which schemes support comibning credentials from multiple issuers? I think this
is directly obtained in the schemes following the CL approach; but others?

A recurrent claim in schemes avoiding using zero-knowledge proofs of knowledge
of some attributes being included in a credential is that these proofs are costly
(like, linear in the number of attributes). Yet, they resort to other primitives
that may also be costly (e.g., predicate encryption \cite{dmm+18}) or somehow move
the cost to some other place (e.g., \cite{fhs19} uses a vector commitment scheme
that requires a public key with size that grows with the number of attributes
that \emph{can} be committed). It would be nice to have a detailed and complete
(e.g., not skipping the data that makes one scheme look bad, like the size of
the public keys) comparison. And, ideally, with concrete instantiations (not only
theoretical analysis)?

\cite{fhs19} has a nice comparison table.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "sok-privsig"
%%% End:
