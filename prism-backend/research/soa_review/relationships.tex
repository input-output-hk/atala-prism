\section{Relationships Between Primitives}
\label{sec:relationships}

In this section, we explore relationships between Group Signatures and Anonymous
Crednetials. Naturally, the wide range of constructions in both fields (of which
we have given some account in \secref{sec:gs} and \secref{sec:ac}) makes it
hardly possible to give relationships that hold in a universal sense. Therefore,
we begin from what we (possibly arbitrarily) consider the reference scheme of
each type. It is between these reference schemes from which we will then
establish connections.

\subsection{Reference GS Model}
\label{ssec:refgs}

\subsubsection{Partially Dynamic GS.} %
Partially dynamic group signatures where first formally studied in \cite{bsz05}.
There, the authors express a scheme where users can join the group at any point
in time, although some subtle aspects of revocation are not considered. However,
this is a mature enough model, in the sense that it captures the main security
and privacy properties (to the point that most subsequent models build on it);
and also it offers a functionality probably enough for many scenarios.

\paragraph{Syntax.} %
A partially dynamic group signature scheme, PDGS for short, meets the following
syntax:

\begin{description}
\item[$\PDGSparam \leftarrow \PDGSSetup(1^\PDGSsec)$]
\item[$(\PDGSisk, \PDGSipk) \leftarrow \PDGSIKeyGen(\PDGSparam)$]
\item[$(\PDGSosk, \PDGSopk) \leftarrow \PDGSOKeyGen(\PDGSparam)$]
\item[$(\PDGSusk, \PDGSupk) \leftarrow \PDGSUKeyGen(\PDGSparam)$]
\item[$\langle \PDGSucred, \PDGSutrans \rangle \leftarrow
  \langle \PDGSJoin(\PDGSparam, \PDGSusk, \PDGSipk),
  \PDGSIssue(\PDGSparam, \PDGSisk, \PDGSupk) \rangle$]
\item[$\PDGSsig \leftarrow \PDGSSign((\PDGSusk, \PDGSucred),
  (\PDGSparam, \PDGSipk, \PDGSopk), \PDGSmsg)$]
\item[$1/0 \leftarrow \PDGSVerify((\PDGSparam, \PDGSipk, \PDGSopk), \PDGSsig, \PDGSmsg)$]
\item[$(\PDGSupk, \PDGSoproof) \leftarrow \PDGSOpen(\PDGSparam, \PDGSosk, \PDGSalltrans, \PDGSsig, \PDGSmsg)$]
\item[$1/0 \leftarrow \PDGSJudge((\PDGSparam, \PDGSipk, \PDGSopk),
  \PDGSsig, \PDGSmsg, \PDGSupk, \PDGSoproof)$]
\end{description}

\doubt{We may need Link and LinkVerify, which is not in BSZ05 (nor BCC+16)...}

For brevity, we henceforth use \PDGSgpk to denote the pair $(\PDGSipk,\PDGSopk)$,
and assume that it includes the parameters created in \PDGSSetup, which are also
assumed to be included in the issuer's and opener's secret kyes.
Also, since the user credential has to be kept secret, we abuse the previous
notation to include it as part of the user secret key; i.e., we can see the
\PDGSJoin as ``expanding'' the previous user secret key to include the
membership credential. Note that, up to renaming, this is the syntax put forth
in \cite{bsz05} except for two differences: the open algorithm does not return
the index of the user, as what actually carries the identifying information is
the opening proof and the user public key, which we return directly. Also, we
divide the initial configuration (which in \cite{bsz05} is run in one single
setup process) into three steps: one for the creation of the global parameters
(e.g., picking algebraic groups, etc.); and two for creating the issuer and
opener key pairs. This makes notation a bit more verbose, but it is actually
closer to real world requirements. Furthermore, it does not affect the modelling
beyond the necessary syntactic adjustments, as described next.

Correctness of a PDGS scheme basically requires that, the \PDGSVerify algorithm
returns 1 when it is given a signature generated by an honest group member; and,
similarly, that \PDGSJudge accepts an honestly generated opening proof computed
over a valid group signature. More formally, a PDGS scheme is correct if
\PDGSExpCorrect returns 0 with negligible probability.

\begin{figure}[ht!]
  \begin{center}
    \scalebox{0.9}{
      \procedure{$\PDGSExpCorrect(1^\PDGSsec)$}{%
        \PDGSparam \gets \PDGSSetup(1^\PDGSsec) \\
        (\PDGSisk,\PDGSipk) \gets \PDGSIKeyGen(\PDGSparam) \\
        (\PDGSosk,\PDGSopk) \gets \PDGSOKeyGen(\PDGSparam) \\
        \PDGSgpk \gets (\PDGSipk, \PDGSopk) \\
        (\uid, \PDGSmsg) \gets \Adv^{\ADDU}(\PDGSgpk) \\
        \PDGSsig \gets \PDGSSign(\PDGSvusk\lbrack\uid\rbrack,\PDGSgpk,\PDGSmsg) \\
        (\PDGSupk,\PDGSoproof) \gets
        \PDGSOpen(\PDGSosk, \PDGSalltrans, \PDGSsig, \PDGSmsg) \\
        \pcif
        \PDGSVerify(\PDGSgpk,\PDGSsig,\PDGSmsg) = 0 \textrm{~or~}
        \PDGSJudge(\PDGSgpk,\PDGSsig,\PDGSmsg,\PDGSupk,\PDGSoproof) = 0:
        \pcreturn 0 \\
        \pcelse \pcreturn 1
      }
    }
  \end{center}
  \caption{Correctness definition for PDGS schemes.
    \todo{Define oracles and other variables!}}
  \label{fig:pdgscorr}
\end{figure}

\paragraph{Security.} %

The security properties required from a partially dynamic group signature scheme
are anonymity, traceability and non-frameability. Anonymity captures that no
third party observer should be able to distinguish signatures issued by two
honest members. Traceability ensures that, in the presence of an honest issuer
(but possibly corrupt opener), every valid group signature originates from a
member that completed successfully the join process. Finally, non-frameability
requires that, even in the presence of dishonest issuer and opener, no member
can be blamed as having been generated a group signature she did not produce.
Formal definitions follow, adapted from \cite{bsz05} up to the minor variations
due to our slightly different syntax.

\begin{figure}[ht!]
  \begin{center}
    \scalebox{0.9}{
      \procedure{$\PDGSExpAnonb(1^\PDGSsec)$}{%
        \PDGSparam \gets \PDGSSetup(1^\PDGSsec) \\
        (\PDGSisk,\PDGSipk) \gets \PDGSIKeyGen(\PDGSparam) \\
        (\PDGSosk,\PDGSopk) \gets \PDGSOKeyGen(\PDGSparam) \\
        \PDGSgpk \gets (\PDGSipk, \PDGSopk) \\
        (\uid, \PDGSmsg) \gets \Adv^{\ADDU}(\PDGSgpk,\PDGSisk)\\
      }

      \procedure{$\PDGSExpTrace(1^\PDGSsec)$}{%
        \PDGSparam \gets \PDGSSetup(1^\PDGSsec) \\
        (\PDGSisk,\PDGSipk) \gets \PDGSIKeyGen(\PDGSparam) \\
        (\PDGSosk,\PDGSopk) \gets \PDGSOKeyGen(\PDGSparam) \\
        \PDGSgpk \gets (\PDGSipk, \PDGSopk) \\
        (\uid, \PDGSmsg) \gets \Adv^{\ADDU}(\PDGSgpk,\PDGSosk)\\
      }

      \procedure{$\PDGSExpNonframe(1^\PDGSsec)$}{%
        \PDGSparam \gets \PDGSSetup(1^\PDGSsec) \\
        (\PDGSisk,\PDGSipk) \gets \PDGSIKeyGen(\PDGSparam) \\
        (\PDGSosk,\PDGSopk) \gets \PDGSOKeyGen(\PDGSparam) \\
        \PDGSgpk \gets (\PDGSipk, \PDGSopk) \\
        (\uid, \PDGSmsg) \gets \Adv^{\ADDU}(\PDGSgpk,\PDGSisk,\PDGSosk)\\
      }      
    }
  \end{center}
  \caption{Anonymity, traceability, and non-frameability definitions for PDGS
    schemes. \todo{Unfinished!}}
  \label{fig:pdgssec}
\end{figure}


\subsubsection{Fully Dynamic GS.} %
\todo{Can we do this?} \cite{bcc+16}

\subsection{Reference AC Model}
\label{ssec:refac}

As stated in \secref{sec:ac}, multi-show, multi-attribute anonymous credential
schemes are the most frequent ones in the AC domain. While there are variations
in the offered functionality (like those improving expressiveness of the
supported claims) we assume selective disclosure as the base scheme. Also,
we begin by modelling one-show schemes, which will ease our analysis.
\doubt{Not $100\%$ sure of the latter yet, but take it as running hypothesis.}

\subsubsection{One-Show Multi-Attribute AC with Selective Disclosure.} %
We recall that, in an One-Show Multi-Attribute AC Scheme with Selective
Disclosure (OMACSD), if a user shows the same credential more than once, these
multiple showings are linkable across themselves. 

\paragraph{Syntax.} %
An OMACSD scheme offers the following syntax.

\begin{description}
\item[$\OMACSDparam \leftarrow \OMACSDSetup(1^\OMACSDsec,1^\OMACSDnattr)$.]
\item[$(\OMACSDisk,\OMACSDipk) \leftarrow \OMACSDIKeyGen(\OMACSDparam)$.]
\item[$(\OMACSDusk,\OMACSDupk) \leftarrow \OMACSDUKeyGen(\OMACSDparam)$.]
\item[$\langle \OMACSDcred/0, 1/0 \rangle \leftarrow
  \langle \OMACSDObtain(\OMACSDusk,\OMACSDipk,\OMACSDattr),
  \OMACSDIssue(\OMACSDisk,\OMACSDupk,\OMACSDattr) \rangle$.]
\item[$1/0 \leftarrow
  \langle \OMACSDShow(\OMACSDipk,\OMACSDattr,\OMACSDdattr,\OMACSDcred),
  \OMACSDVerify(\OMACSDipk,\OMACSDdattr) \rangle$.]
\end{description}

We note that this syntax is, up to some renaming for consistency with previous
sections, and the addition of the setup process, the one in \cite{fhs19} for
multi-show multi-attribute AC schemes with selective disclosure.

Correctness of an OMACSD scheme ensures that \OMACSDVerify accepts when
presented a credential that has been honestly obtained from a valid issuer, as
long as the subset of revealed attributes \OMACSDdattr is contained in the set
of attributes \OMACSDattr that were included in the credential. This is formally
captured in the \OMACSDExpCorrect game, which must return 1 except with
negligible probatility.

\begin{figure}[ht!]
    \begin{center}
    \scalebox{0.9}{
      \procedure{$\OMACSDExpCorrect(1^\OMACSDsec,1^\OMACSDnattr)$}{%
        \OMACSDparam \gets \OMACSDSetup(1^\OMACSDsec,1^\OMACSDnattr) \\
        (\OMACSDisk,\OMACSDipk) \gets \OMACSDIKeyGen(\OMACSDparam) \\
        (\OMACSDcred,\OMACSDdattr) \gets \Adv^{\ADDU}(\OMACSDipk) \\
        \pcif \OMACSDdattr \subseteq \OMACSDattr: \pcreturn \bot \\
        b \gets \langle \OMACSDShow(\OMACSDipk,\OMACSDattr,\OMACSDdattr, \OMACSDcred),
        \OMACSDVerify(\OMACSDipk,\OMACSDdattr) \rangle \\
        \pcreturn b
      }
    }
  \end{center}
  \caption{Correctness definition in OMACSD schemes.
    \todo{Unfinished!}}
  \label{fig:omacsdcorr}
\end{figure}

\paragraph{Security.} %
In an OMACSD scheme, security is formulated through anonymity and unforgeability
properties, which we define formally as experiments in \figref{fig:omacsdsec}.
Roughly, anonymity ensures that given two users with corresponding credentials,
each revealing the same subset of matching attributes in their respective
show processes, no third party should be able to distinguish which credential
belongs to which user. \doubt{Something like that -- make sure that it fits
  the formal definition.} Unforgeability captures that no adversary should be
able to successfully prove possession of a set of attributes that have not been
included by a legitimate issuer in a credential issued (or leaked) to the
adversary.

\begin{figure}[ht!]
  \begin{center}
    \scalebox{0.9}{
      \procedure{$\OMACSDExpAnonb(1^\OMACSDsec,1^\OMACSDnattr)$}{%
        \OMACSDparam \gets \OMACSDSetup(1^\OMACSDsec,1^\OMACSDnattr) \\
        (\OMACSDisk,\OMACSDipk) \gets \OMACSDIKeyGen(\OMACSDparam) \\
        \OMACSDcred \gets \Adv^{\ADDU}(\OMACSDisk) \\
      }

      \procedure{$\OMACSDExpUnfor(1^\OMACSDsec,1^\OMACSDnattr)$}{%
        \OMACSDparam \gets \OMACSDSetup(1^\OMACSDsec,1^\OMACSDnattr) \\
        (\OMACSDisk,\OMACSDipk) \gets \OMACSDIKeyGen(\OMACSDparam) \\
        \OMACSDcred \gets \Adv^{\ADDU}(\OMACSDipk) \\
      }

    }
  \end{center}
  \caption{Anonymity and unforgeability definitions for OMACSD schemes.
    \todo{Unfinished!}}
  \label{fig:omacsdsec}
\end{figure}

\subsubsection{Multi-Show Multi-Attribute AC with Selective Disclosure.} %
The syntax met by Multi-Show Multi-Attribute AC Systems with Selective
Disclosure (MMACSD) is exactly the same as that of OMACSD systems. Correctness
and unforgeability properties are also the same. The only difference lies on
the anonymity property.

\subsection{From GS to AC schemes; or Not}
\label{ssec:gs2ac}

Next, we describe black-box implications of separations when trying to build
anonymous credential schemes from group signature ones. \todo{Currently, I think
  it is possible to build \OMACSD from \PDGS, but not \MMACSD from \PDGS
  (although it should be possible to build \MMACSD from multi-group
  signatures...)}.

\subsubsection{Black-Box Construction of \OMACSD from \PDGS.} %
\doubt{I guess it is ok to have a black-box construction in which obatin/issue
  requires much more interaction... is it?}

\begin{figure}[ht!]
  \begin{center}
    \scalebox{0.9}{
      \begin{minipage}[t]{0.5\textwidth}
        \procedure{$\OMACSDSetup(1^\OMACSDsec,1^\OMACSDnattr)$} {
          \PDGSparam \gets \PDGSSetup(1^\OMACSDsec) \\
          \pcreturn (1^\OMACSDsec,1^\OMACSDnattr,\PDGSparam) \\
        }

        \procedure{$\OMACSDUKeyGen(\OMACSDparam)$}{
          \textrm{Parse \OMACSDparam as $(1^\OMACSDsec,1^\OMACSDnattr,\PDGSparam)$} \\
          (\PDGSusk,\PDGSupk) \gets \PDGSUKeyGen(\PDGSparam) \\          
          \pcreturn \PDGSusk \\
        }

        \procedure{$\OMACSDShow(\OMACSDipk,\OMACSDattr,\OMACSDdattr,\OMACSDcred),$\\
          $\OMACSDVerify(\OMACSDipk,\OMACSDdattr)$}{
          \textrm{- \underline{Verifier}: Send random nonce $c$ to User} \\
          \textrm{- \underline{User}: } \\
          \pcind \textrm{Parse \OMACSDcred as
            $(\PDGSusk,n,\PDGSsig_n,\lbrace \PDGSsig_i \rbrace_{i \in [\OMACSDattr}])$} \\
          \pcind \PDGSsig_c \gets \PDGSSign(\PDGSusk,\PDGSgpk^u,c) \\
          \pcind \textrm{Send $(\PDGSsig_c,n,
            \PDGSsig_n,\lbrace \PDGSsig_i \rbrace_{i \in [\OMACSDdattr}])$ to Verifier} \\
          \textrm{- \underline{Verifier}:} \pccomment{If any check fails, abort} \\
          \pcind \PDGSVerify(\PDGSgpk^u,\PDGSsig_c,c) \\
          \pcind \pcfor i \in [\OMACSDdattr]: \\
          \pcind \pcind \PDGSVerify(\PDGSgpk^a,) \\
        }
        
      \end{minipage}
    }
    ~
    \scalebox{0.9}{
      \begin{minipage}[t]{0.5\textwidth}
        \procedure{$\OMACSDIKeyGen(\OMACSDparam)$}{
          \textrm{Parse \OMACSDparam as $(1^\OMACSDsec,1^\OMACSDnattr,\PDGSparam)$} \\
          (\PDGSisk^a,\PDGSipk^a) \gets \PDGSIKeyGen(\PDGSparam)
          ~\pccomment{Attributes group} \\
          (\PDGSosk^a,\PDGSopk^a) \gets \PDGSOKeyGen(\PDGSparam) \\
          (\PDGSisk^u,\PDGSipk^u) \gets \PDGSIKeyGen(\PDGSparam) 
          ~\pccomment{Users group} \\
          (\PDGSosk^u,\PDGSopk^u) \gets \PDGSOKeyGen(\PDGSparam) \\
          \PDGSgpk^a \gets (\PDGSipk^a,\PDGSopk^a);
          \PDGSgpk^u \gets (\PDGSipk^u,\PDGSopk^u); \\
          \pcfor i \in [\OMACSDnattr]:
          ~\pccomment{Add one member per attribute} \\
          \pcind (\PDGSusk^a_i,\PDGSupk^a_i) \gets \PDGSUKeyGen(\PDGSparam) \\
          \pcind
          \PDGSucred^a_i \gets \langle \PDGSJoin(\PDGSgpk^a,\PDGSusk^a_i),
          \PDGSIssue(\PDGSgpk^a, \PDGSisk^a, \PDGSupk^a_i) \rangle \\
          \pcind \PDGSusk^a_i \gets (\PDGSusk^a_i, \PDGSucred^a_i) \\
          \pcreturn ((\PDGSisk_a,\PDGSisk_u,\PDGSosk_u,
          \lbrace \PDGSusk^a_i, \PDGSupk^a_i \rbrace_{i \in [\OMACSDnattr]}),
                     (\PDGSgpk_a,\PDGSosk_a,\PDGSgpk_u)) \\
        }

        \procedure{$\OMACSDObtain(\OMACSDusk,\OMACSDipk,\OMACSDattr),
          \OMACSDIssue(\OMACSDisk,\OMACSDupk,\OMACSDattr)$}{
          \pccomment{User and Issuer run the PDGS join/issue protocol}  \\
          \langle \PDGSucred,\PDGSutrans \rangle \gets
          \langle \PDGSJoin(\PDGSgpk^u,\PDGSusk),
          \PDGSIssue(\PDGSgpk^u, \PDGSisk^u, \PDGSupk) \rangle \\
          \PDGSusk \gets (\PDGSusk, \PDGSucred) \\
          \pccomment{User requests an OMAC} \\
          \textrm{- \underline{Issuer}: Send random nonce $n$ to User} \\
          \textrm{- \underline{User}: } \PDGSsig_n \gets \PDGSSign(\PDGSusk,\PDGSgpk,n);
          \textrm{Send $\PDGSsig_n$ to Issuer} \\
          \textrm{- \underline{Issuer}: } \\
          \pcind \pcif \PDGSVerify(\PDGSgpk,\PDGSsig_n,n) = 1~\textrm{and}\\
          \pcind \pcind \PDGSOpen(\PDGSgpk^u,\PDGSosk^u,\PDGSalltrans,\PDGSsig_n,n) = (\PDGSupk, \cdot): \\
          \pcind \pcind \pcfor i \in [\OMACSDattr]:
          \PDGSsig_i \gets \PDGSSign(\PDGSusk^a_i,\PDGSgpk^a,\PDGSsig_n) \\
          \pcind \textrm{Send $\lbrace \PDGSsig_i \rbrace_{i \in [\OMACSDnattr]}$ to User }
          \textrm{and \pcreturn 1} \\
          \textrm{- \underline{User}: } \\
          \pcind \pcfor i \in [\OMACSDattr]:
          \pcif \PDGSVerify(\PDGSgpk^a,\PDGSsig_i,\PDGSsig_n) = 0: \textrm{abort} \\
          \pcind \pcreturn (\PDGSusk, n,\PDGSsig_n,\lbrace \PDGSsig_i \rbrace_{i \in [\OMACSDattr}]) \\
        }
        
      \end{minipage}
    }
  \end{center}
  \caption{Black-box constrction of \OMACSD from \PDGS.
    \todo{In Show/Verify, user/issuer need to get \PDGSgpk from somewhere!}}
\end{figure}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "soa-review"
%%% End:
