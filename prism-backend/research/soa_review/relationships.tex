\section{Relationships Between Primitives}
\label{sec:relationships}

\todo{DISCLAIMER: This section contains a line of work we've put on hold for
  now. Leaving it here just for archival purposes -- the reference definitions
  for GS and AC may be of use (if we refine them!), at least for informational
  purposes..}

In this section, we explore relationships between Group Signatures and Anonymous
Crednetials. Naturally, the wide range of constructions in both fields (of which
we have given some account in \secref{sec:gs} and \secref{sec:ac}) makes it
hardly possible to give relationships that hold in a universal sense. Therefore,
we begin from what we (possibly arbitrarily) consider the reference scheme of
each type. It is between these reference schemes from which we will then
establish connections.

\subsection{Reference GS Model}
\label{ssec:refgs}

\subsubsection{Partially Dynamic GS.} %
Partially dynamic group signatures where first formally studied in \cite{bsz05}.
There, the authors express a scheme where users can join the group at any point
in time, although some subtle aspects of revocation are not considered. However,
this is a mature enough model, in the sense that it captures the main security
and privacy properties (to the point that most subsequent models build on it);
and also it offers a functionality probably enough for many scenarios.

\paragraph{Syntax.} %
A partially dynamic group signature scheme, PDGS for short, meets the following
syntax:

\begin{description}
\item[$\PDGSparam \leftarrow \PDGSSetup(1^\PDGSsec)$]
\item[$(\PDGSisk, \PDGSipk) \leftarrow \PDGSIKeyGen(\PDGSparam)$]
\item[$(\PDGSosk, \PDGSopk) \leftarrow \PDGSOKeyGen(\PDGSparam)$]
\item[$(\PDGSusk, \PDGSupk) \leftarrow \PDGSUKeyGen(\PDGSparam)$]
\item[$\langle \PDGSucred, \PDGSutrans \rangle \leftarrow
  \langle \PDGSJoin(\PDGSparam, \PDGSusk, \PDGSipk),
  \PDGSIssue(\PDGSparam, \PDGSisk, \PDGSupk) \rangle$]
\item[$\PDGSsig \leftarrow \PDGSSign((\PDGSusk, \PDGSucred),
  (\PDGSparam, \PDGSipk, \PDGSopk), \PDGSmsg)$]
\item[$1/0 \leftarrow \PDGSVerify((\PDGSparam, \PDGSipk, \PDGSopk), \PDGSsig, \PDGSmsg)$]
\item[$(\PDGSupk, \PDGSoproof) \leftarrow \PDGSOpen(\PDGSparam, \PDGSosk, \PDGSalltrans, \PDGSsig, \PDGSmsg)$]
\item[$1/0 \leftarrow \PDGSJudge((\PDGSparam, \PDGSipk, \PDGSopk),
  \PDGSsig, \PDGSmsg, \PDGSupk, \PDGSoproof)$]
\end{description}

\doubt{We may need Link and LinkVerify, which is not in BSZ05 (nor BCC+16)...}

For brevity, we henceforth use \PDGSgpk to denote the pair $(\PDGSipk,\PDGSopk)$,
and assume that it includes the parameters created in \PDGSSetup, which are also
assumed to be included in the issuer's and opener's secret kyes.
Also, since the user credential has to be kept secret, we abuse the previous
notation to include it as part of the user secret key; i.e., we can see the
\PDGSJoin as ``expanding'' the previous user secret key to include the
membership credential. Note that, up to renaming, this is the syntax put forth
in \cite{bsz05} except for two differences: the open algorithm does not return
the index of the user, as what actually carries the identifying information is
the opening proof and the user public key, which we return directly. Also, we
divide the initial configuration (which in \cite{bsz05} is run in one single
setup process) into three steps: one for the creation of the global parameters
(e.g., picking algebraic groups, etc.); and two for creating the issuer and
opener key pairs. This makes notation a bit more verbose, but it is actually
closer to real world requirements. Furthermore, it does not affect the modelling
beyond the necessary syntactic adjustments, as described next.

Correctness of a PDGS scheme basically requires that, the \PDGSVerify algorithm
returns 1 when it is given a signature generated by an honest group member; and,
similarly, that \PDGSJudge accepts an honestly generated opening proof computed
over a valid group signature. More formally, a PDGS scheme is correct if
\PDGSExpCorrect returns 0 with negligible probability.

\begin{figure}[ht!]
  \begin{center}
    \scalebox{0.9}{
      \procedure{$\PDGSExpCorrect(1^\PDGSsec)$}{%
        \PDGSparam \gets \PDGSSetup(1^\PDGSsec) \\
        (\PDGSisk,\PDGSipk) \gets \PDGSIKeyGen(\PDGSparam) \\
        (\PDGSosk,\PDGSopk) \gets \PDGSOKeyGen(\PDGSparam) \\
        \PDGSgpk \gets (\PDGSipk, \PDGSopk) \\
        (\uid, \PDGSmsg) \gets \Adv^{\ADDU}(\PDGSgpk) \\
        \PDGSsig \gets \PDGSSign(\PDGSvusk\lbrack\uid\rbrack,\PDGSgpk,\PDGSmsg) \\
        (\PDGSupk,\PDGSoproof) \gets
        \PDGSOpen(\PDGSosk, \PDGSalltrans, \PDGSsig, \PDGSmsg) \\
        \pcif
        \PDGSVerify(\PDGSgpk,\PDGSsig,\PDGSmsg) = 0 \textrm{~or~}
        \PDGSJudge(\PDGSgpk,\PDGSsig,\PDGSmsg,\PDGSupk,\PDGSoproof) = 0:
        \pcreturn 0 \\
        \pcelse \pcreturn 1
      }
    }
  \end{center}
  \caption{Correctness definition for PDGS schemes.
    \todo{Define oracles and other variables!}}
  \label{fig:pdgscorr}
\end{figure}

\paragraph{Security.} %

The security properties required from a partially dynamic group signature scheme
are anonymity, traceability and non-frameability. Anonymity captures that no
third party observer should be able to distinguish signatures issued by two
honest members. Traceability ensures that, in the presence of an honest issuer
(but possibly corrupt opener), every valid group signature originates from a
member that completed successfully the join process. Finally, non-frameability
requires that, even in the presence of dishonest issuer and opener, no member
can be blamed as having been generated a group signature she did not produce.
Formal definitions follow, adapted from \cite{bsz05} up to the minor variations
due to our slightly different syntax.

\begin{figure}[ht!]
  \begin{center}
    \scalebox{0.9}{
      \procedure{$\PDGSExpAnonb(1^\PDGSsec)$}{%
        \PDGSparam \gets \PDGSSetup(1^\PDGSsec) \\
        (\PDGSisk,\PDGSipk) \gets \PDGSIKeyGen(\PDGSparam) \\
        (\PDGSosk,\PDGSopk) \gets \PDGSOKeyGen(\PDGSparam) \\
        \PDGSgpk \gets (\PDGSipk, \PDGSopk) \\
        (\uid, \PDGSmsg) \gets \Adv^{\ADDU}(\PDGSgpk,\PDGSisk)\\
      }

      \procedure{$\PDGSExpTrace(1^\PDGSsec)$}{%
        \PDGSparam \gets \PDGSSetup(1^\PDGSsec) \\
        (\PDGSisk,\PDGSipk) \gets \PDGSIKeyGen(\PDGSparam) \\
        (\PDGSosk,\PDGSopk) \gets \PDGSOKeyGen(\PDGSparam) \\
        \PDGSgpk \gets (\PDGSipk, \PDGSopk) \\
        (\uid, \PDGSmsg) \gets \Adv^{\ADDU}(\PDGSgpk,\PDGSosk)\\
      }

      \procedure{$\PDGSExpNonframe(1^\PDGSsec)$}{%
        \PDGSparam \gets \PDGSSetup(1^\PDGSsec) \\
        (\PDGSisk,\PDGSipk) \gets \PDGSIKeyGen(\PDGSparam) \\
        (\PDGSosk,\PDGSopk) \gets \PDGSOKeyGen(\PDGSparam) \\
        \PDGSgpk \gets (\PDGSipk, \PDGSopk) \\
        (\uid, \PDGSmsg) \gets \Adv^{\ADDU}(\PDGSgpk,\PDGSisk,\PDGSosk)\\
      }      
    }
  \end{center}
  \caption{Anonymity, traceability, and non-frameability definitions for PDGS
    schemes. \todo{Unfinished!}}
  \label{fig:pdgssec}
\end{figure}


\subsubsection{Fully Dynamic GS.} %
\todo{Can we do this?} \cite{bcc+16}

\subsection{Reference AC Model}
\label{ssec:refac}

\subsubsection{One-Show Multi-Attribute AC with Selective Disclosure.} %
We recall that, in an One-Show Multi-Attribute AC Scheme with Selective
Disclosure (OMACSD), if a user shows the same credential more than once, these
multiple showings are linkable across themselves. 

\paragraph{Syntax.} %
An OMACSD scheme offers the following syntax.

\begin{description}
\item[$\OMACSDparam \leftarrow \OMACSDSetup(1^\OMACSDsec,1^\OMACSDnattr)$.]
\item[$(\OMACSDisk,\OMACSDipk) \leftarrow \OMACSDIKeyGen(\OMACSDparam)$.]
\item[$(\OMACSDusk,\OMACSDupk) \leftarrow \OMACSDUKeyGen(\OMACSDparam)$.]
\item[$\langle \OMACSDcred/0, 1/0 \rangle \leftarrow
  \langle \OMACSDObtain(\OMACSDusk,\OMACSDipk,\OMACSDattr),
  \OMACSDIssue(\OMACSDisk,\OMACSDupk,\OMACSDattr) \rangle$.]
\item[$1/0 \leftarrow
  \langle \OMACSDShow(\OMACSDipk,\OMACSDattr,\OMACSDdattr,\OMACSDcred),
  \OMACSDVerify(\OMACSDipk,\OMACSDdattr) \rangle$.]
\end{description}

We note that this syntax is, up to some renaming for consistency with previous
sections, and the addition of the setup process, the one in \cite{fhs19} for
multi-show multi-attribute AC schemes with selective disclosure.

Correctness of an OMACSD scheme ensures that \OMACSDVerify accepts when
presented a credential that has been honestly obtained from a valid issuer, as
long as the subset of revealed attributes \OMACSDdattr is contained in the set
of attributes \OMACSDattr that were included in the credential. This is formally
captured in the \OMACSDExpCorrect game, which must return 1 except with
negligible probatility.

\begin{figure}[ht!]
    \begin{center}
    \scalebox{0.9}{
      \procedure{$\OMACSDExpCorrect(1^\OMACSDsec,1^\OMACSDnattr)$}{%
        \OMACSDparam \gets \OMACSDSetup(1^\OMACSDsec,1^\OMACSDnattr) \\
        (\OMACSDisk,\OMACSDipk) \gets \OMACSDIKeyGen(\OMACSDparam) \\
        (\OMACSDcred,\OMACSDdattr) \gets \Adv^{\ADDU}(\OMACSDipk) \\
        \pcif \OMACSDdattr \subseteq \OMACSDattr: \pcreturn \bot \\
        b \gets \langle \OMACSDShow(\OMACSDipk,\OMACSDattr,\OMACSDdattr, \OMACSDcred),
        \OMACSDVerify(\OMACSDipk,\OMACSDdattr) \rangle \\
        \pcreturn b
      }
    }
  \end{center}
  \caption{Correctness definition in OMACSD schemes.
    \todo{Unfinished!}}
  \label{fig:omacsdcorr}
\end{figure}

\paragraph{Security.} %
In an OMACSD scheme, security is formulated through anonymity and unforgeability
properties, which we define formally as experiments in \figref{fig:omacsdsec}.
Roughly, anonymity ensures that given two users with corresponding credentials,
each revealing the same subset of matching attributes in their respective
show processes, no third party should be able to distinguish which credential
belongs to which user. \doubt{Something like that -- make sure that it fits
  the formal definition.} Unforgeability captures that no adversary should be
able to successfully prove possession of a set of attributes that have not been
included by a legitimate issuer in a credential issued (or leaked) to the
adversary.

\begin{figure}[ht!]
  \begin{center}
    \scalebox{0.9}{
      \procedure{$\OMACSDExpAnonb(1^\OMACSDsec,1^\OMACSDnattr)$}{%
        \OMACSDparam \gets \OMACSDSetup(1^\OMACSDsec,1^\OMACSDnattr) \\
        (\OMACSDisk,\OMACSDipk) \gets \OMACSDIKeyGen(\OMACSDparam) \\
        \OMACSDcred \gets \Adv^{\ADDU}(\OMACSDisk) \\
      }

      \procedure{$\OMACSDExpUnfor(1^\OMACSDsec,1^\OMACSDnattr)$}{%
        \OMACSDparam \gets \OMACSDSetup(1^\OMACSDsec,1^\OMACSDnattr) \\
        (\OMACSDisk,\OMACSDipk) \gets \OMACSDIKeyGen(\OMACSDparam) \\
        \OMACSDcred \gets \Adv^{\ADDU}(\OMACSDipk) \\
      }

    }
  \end{center}
  \caption{Anonymity and unforgeability definitions for OMACSD schemes.
    \todo{Unfinished!}}
  \label{fig:omacsdsec}
\end{figure}

\subsubsection{Multi-Show Multi-Attribute AC with Selective Disclosure.} %
The syntax met by Multi-Show Multi-Attribute AC Systems with Selective
Disclosure (MMACSD) is exactly the same as that of OMACSD systems. Correctness
and unforgeability properties are also the same. The only difference lies on
the anonymity property.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "soa-review"
%%% End:
