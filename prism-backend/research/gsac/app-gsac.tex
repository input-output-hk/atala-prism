\section{GSAC Detailed Formalisation}
\label{app:gsac-formal}

\subsection{Detailed Oracles}
\label{sapp:gsac-oracles}

{%\setlength\intextsep{\sep}
  \begin{figure*}[ht!]
    \centering
    \scalebox{0.9}{

      \begin{minipage}[t]{0.55\textwidth}

        \procedure{$\RREG(i)$}{%
          \pcreturn \trans[i] \\
        }

        \procedure{$\HUGEN(\uid)$}{%
          \pcif \uid \in \HU \lor \uid \in \CU: \pcreturn \bot \\
          (\upk,\usk) \gets \UKeyGen(\parm) \\
          \UK[\uid] \gets (\upk,\usk);
          \HU \gets \HU \cup \lbrace  \uid \rbrace \\
          \pcreturn \top \\
        }        
        
        \procedure{$\CUGEN(\uid,\upk)$}{%
          \pcif \uid \in \CU: \pcreturn \bot \\
          \CU \gets \CU \cup \lbrace \uid \rbrace \\          
          \pcif \uid \in \HU: \\
          \pcind \HU \gets \HU \setminus \lbrace \uid \rbrace; \\
          \pcind \pcreturn (\UK[\uid],\CRED[\uid]) \\
          \pcelse: \UK[\uid] = (\upk,\bot) \\          
          \pcreturn \top \\
        }

        \procedure{$\OBTISS(\uid,\cid,\Attrs)$}{%
          \pcif \uid \in \CU \lor \uid \notin \HU: \pcreturn \bot \\
          \pcif \CRED[\cid] \neq \bot: \pcreturn \bot \\
          \langle \cred, \utrans \rangle \gets
          \langle \Obtain(\gpk,\PRVUK[\uid],\Attrs), \\
          \pcind \pcind \pcind \pcind \pcind \pcind
          \Issue(\gpk,\isk,\Attrs) \rangle \\
          \trans[\cid] \gets \utrans;~\CRED[\cid] \gets (\uid,\cred,\Attrs) \\
          \pcreturn \top \\
        }        

        \procedure{$\OBTAIN(\uid,\cid,\Attrs)$}{%
          \pcif \uid \in \CU \lor \uid \notin \HU: \pcreturn \bot \\
          \pcif \CRED[\cid] \neq \bot: \pcreturn \bot \\
          \langle \cred, \cdot \rangle \gets
          \langle \Obtain(\gpk,\PRVUK[\uid],\Attrs),\adv \rangle \\
          \CRED[\cid] \gets (\uid,\cred,\Attrs) \\
          \pcreturn \top \\
        }
        
      \end{minipage}
    }
    \scalebox{0.9}{
      
      \begin{minipage}[t]{.5\textwidth}

        \procedure{$\WREG(i,\rho)$}{%
          \trans[i] \gets \rho \\
        }        

        \procedure{$\ISSUE(\uid,\cid,\Attrs)$}{%
          \pcif \uid \notin \CU: \pcreturn \bot \\
          \pcif \CRED[\cid] \neq \bot: \pcreturn \bot \\
          \langle \cdot, \utrans \rangle \gets
          \langle \adv, \Issue(\gpk,\isk,\Attrs) \rangle \\
          \trans[\cid] \gets \utrans;~
          \CRED[\cid] \gets (\uid,\cdot,\Attrs) \\
          \pcreturn \top \\          
        }        

        \procedure{$\SIGN(\cid,\DAttrs,\msg)$}{%
          \uid \gets \OWNR[\cid] \\
          \pcif \uid \notin \HU: \pcreturn \bot \\
          \cred \gets \CRED[\cid] \\
          \sig \gets \Sign(\gpk,\PRVUK[\uid],\cred,\DAttrs,\msg) \\
          \SIG[\cid] \gets \SIG[\cid] \cup \lbrace (\sig,\DAttrs,\msg) \rbrace \\
          \pcreturn \sig \\
        }

        \procedure{$\OPEN(\sig)$}{%
          \textrm{Let}~\cid~\textrm{be s.t.}~(\sig,\DAttrs,\msg) \in \SIG[\cid] \\
          \pcif \textrm{no such \cid exists, or there is more than one}: \\
          \pcind \pcreturn \bot \\
          \pcif \sig \in \CSIG: \pcreturn \bot \\
          (\upk,\oproof) \gets \Open(\gpk,\osk,\sig,\DAttrs,\msg) \\
%          \OSIG \gets \OSIG \cup \lbrace (\sig,\upk,\cred) \rbrace \\
%          \CCRED \gets \CCRED \cup \lbrace \cid \rbrace \\
          \pcreturn (\upk,\oproof) \\
        }

        \procedure{$\CHALb(\ccid_0,\ccid_1,\DAttrs,\msg)$}{%
          \pcif \DAttrs \nsubseteq \ATTR[\ccid_0] \cap \ATTR[\ccid_1]:
          \pcreturn \bot \\
          \pcif \cuid_0 \neq \bot \lor \cuid_1 \neq \bot: \pcreturn \bot \\
          \cuid_0 = \OWNR[\ccid_0];~\cuid_1 = \OWNR[\ccid_1] \\
          \pcif \cuid_0 \notin \HU \lor \cuid_1 \notin \HU: \pcreturn \bot \\
 %         \pcif \ccid_0 \in \CCRED \lor \ccid_1 \in \CCRED: \pcreturn \bot \\
          \csig \gets \Sign(\gpk,\PRVUK[\cuid_b],\CRED[\ccid_b],
          \DAttrs,\msg) \\
          \CSIG \gets \CSIG \cup \lbrace \csig \rbrace \\
          \pcreturn \csig
        }
        
      \end{minipage}
      
    }

    \caption{Detailed oracles available in our model for \GSAC schemes.}
    \label{fig:oracles}
  \end{figure*}
}

\subsection{Detailed Proofs}
\label{sapp:gsac-proofs}

\commentwho{Jesus}{Strictly, in our generic construction we require IND-CCA (is
  that a strict requirement? or can it be downgraded to IND-CPA?), but in the
  following concrete instantiation, we use ElGamal, which is IND-CPA. However,
  we actually ``lift'' ElGamal with NIZKs of the encrypted plaintexts, which is
  essentially IND-CCA as far as I know. Still, make sure to mention that.}

\begin{proof}[\thmref{thm:correctness-gsac}]
  \todo{XXX}
\end{proof}

\begin{proof}[\thmref{thm:anonymity-gsac}]
  We prove that the probability of an adversary distinguishing signatures by
  challenge users is negligible. For the proof, we restrict to the case of
  allowing only one query to the challenge oracle. The extension to a polynomial
  number of queries given in \cite{bsz05} applies here, with the corresponding
  security loss.

  We begin with game $G_0=\ExpGSACAnonb$. From it, we build $G_1$, where we
  simply replace the \NIZKSetup functions for $\NIZKRel_{\Sign}$ and
  $\NIZKRel_{\Open}$ within the \Setup algorithm. $G_1$ is indistinguishable
  from $G_0$ due to the zero-knowledge property of the NIZK systems.

  From $G_1$, we build $G_2$, where within the challenge signature produced by
  \CHALb, we replace the \Ccom value encrypted within \Sign with a random
  string of the appropriate length (e.g., the same length of the encrypted
  message in $G_1$). The corresponding proof for $\NIZKRel_{\Sign}$ is thus
  also simulated. The zero-knowledge and simulation-extractability properties
  of the NIZKs for $\NIZKRel_{\Sign}$, and IND-CCA of the encryption
  scheme, ensure that the result is indistinguishable to the adversary.

  Now, observe that in $G_2$, the challenge signature received by the adversary
  is completely independent from the challenge bit $b$. Moreover, as argued,
  $G_2$ is indistinguishable from $G_0$, where the adversary plays the original
  \ExpGSACAnonb game. Thus, our generic construction of \GSAC satisfies
  anonymity, except with negligible probability.
  %
  \qed
\end{proof}

\begin{proof}[\thmref{thm:trace-gsac}]
  Assuming the NIZK systems are sound, we build an adversary against existential
  unforgeability of the signature scheme for blocks of committed messages.
  %
  Consider the following events:

  \begin{description}
  \item[$O$.] The \Open algorithm returns $\bot$.
  \item[$J$.] The \Judge algorithm returns $0$.
  \item[$D$.] No credential owned by a user in \CU contains \DAttrs.
  \end{description}

  Given these events, the adversary wins if:

  \begin{description}
  \item[$W_1 = O$.] \Open returns $\bot$ (line 5 of \ExpGSACTrace).
  \item[$W_2 = \overline{O} \land J$.] \Open does not fail, but \Judge rejects
    the output of \Open (line 7 of \ExpGSACTrace).
  \item[$W_3 = \overline{O} \land \overline{J} \land D$.] \Open does not fail,
    \Judge accepts the output by \Open, but no corrupt user has a credential
    containing \DAttrs (line 8 of \ExpGSACTrace).
  \end{description}

  Clearly, since the group signature is verified at step 4 of the game, if
  verification succeeds, soundness of $\NIZK_{\Sign}$ implies that $(\Ccom_m,
  \Ec,\DAttrs) \in \NIZKLang_{\Sign}$, except with negligible probability
  $2^{-\NIZKsecpar}$. Also, observe that each of the winning events for the
  adversary described above are disjoint. Thus:

  \begin{equation}
    \AdvGSACTrace(\secpar) = \Pr[W_1]+\Pr[W_2]+\Pr[W_3]+\negl(\NIZKsecpar)
  \end{equation}

  $\Pr[W_1]=0$ is directly deduced from the fact that $(\Ccom_m,\Ec,\DAttrs)
  \in \NIZKLang_{\Sign}$ due to soundness of $\NIZKRel_{\Sign}$. Concretely,
  we know that \Open does not abort due to rejection of the signature by
  \Verify (as this is checked in line 4 of \ExpGSACTrace too) and, thus,
  $\Ec = \EEnc(\opk,\Ccom)$ which, by correctness of the encryption algorithm,
  implies that $\Ccom = \EDec(\osk,\Ec)$, where $\upk=\Ccom=\CCommit(\usk;0)$.
  Completeness of $\NIZK_{\Open}$ thus implies that the \Open algorithm can
  compute the opening proof \oproof, and return $(\upk,\oproof)$.
  
  $\Pr[W_2] = 0$ is similarly deduced from soundness of $\NIZK_{\Sign}$ and
  completeness of $\NIZK_{\Open}$, since the opening proof is computed
  honestly in line 6 of \ExpGSACTrace.

  Finally, assume that there is an adversary $\adv$ against \ExpGSACTrace that
  wins by event $W_3$. Then, it is straight forward to build an adversary \advB
  against unforgeability of the signature scheme on blocks of committed
  messages. Namely, \advB creates the parameters with \Setup and the opening
  key pair with \OKeyGen, but instead of running \IKeyGen, sets the verification
  key to the one received in the \ExpSBCMOMF game. In calls by $\adv$ to \OBTISS
  and \ISSUE oracles, \advB replaces the \Issue algorithm with corresponding
  calls to its $\langle \cdot,\SBCMSign \rangle$ oracle. The other oracles are
  unchanged. Without loss of generality, suppose that $\adv$ makes a total of
  $n$ queries to \OBTISS and \ISSUE, combined; which implies that \advB makes
  a total of $n$ queries to its own oracle. If, in such an execution, $\adv$
  wins by event $W_3$, it means that it has produced a signature \sig, revealing
  attribute set \DAttrs, that is accepted by \Verify, for which \Open does not
  fail, and for which an honestly generated open proof is accepted by \Judge,
  but such that no issued credential contains \DAttrs. Soundness of
  $\NIZK_{\Sign}$ implies that \sig is a valid signature over $\Attrs \cup
  \lbrace \usk \rbrace$, and $\DAttrs \subseteq \Attrs$; but \sig has not been
  produced via a call to the $\langle \cdot,\SBCMSign \rangle$ oracle. Thus,
  \advB can output at least $n+1$ valid signatures, which contradicts security
  of \SBCM.
  %
  By assumption of security of \SBCM, $\Pr[W_3]$ must therefore be negligible in
  $\SBCMsecpar$ and, consequently: $\AdvGSACTrace(\secpar) = \negl(\SBCMsecpar)+
  \negl(\NIZKsecpar)$, which is negligible.  
  \qed
\end{proof}

\begin{proof}[\thmref{thm:frame-gsac}]
  We build an adversary \advB who, given an adversary $\adv$ against
  \ExpGSACNonframe, breaks the hiding property of \C.

  To do so, we start with $G_0=\ExpGSACNonframe$. From $G_0$, we build $G_1$
  by replacing $\NIZKSetup^{\NIZKRel_{\Issue}}$ and  $\NIZKSetup^{\NIZKRel_{\Sign}}$
  with $\NIZKSimSetup^{\NIZKRel_{\Issue}}$ and $\NIZKSimSetup^{\NIZKRel_{\Sign}}$,
  within the \Setup algorithm. Due to the zero-knowledge property of both
  $\NIZK^{\NIZKRel_{\Issue}}$ and $\NIZK^{\NIZKRel_{\Sign}}$, $G_1$ is
  indistinguishable from $G_0$.

  We now build \advB from $G_1$. Recall that \advB is an adversary against
  hiding of \C and, thus, receives a commitment \Ccom, committing to one out
  of two possible messages, $\msg_0$ and $\msg_1$, which \advB picks at random
  from $\AttrSpace$. \advB initializes everything as $G_1$ and, in addition,
  chooses a random integer $u \in [q]$, where $q$ will be the maximim number of
  users to let $\adv$ create via calls to the \HUGEN oracle (note though that
  $q$ can be as large as desired, as it remains a polynomial function of the
  security parameter). In the $u$-th call to the \HUGEN oracle, \advB ignores
  sets $(\upk,\usk)$ to $(\Ccom,\bot)$. Calls to the \OBTAIN and \SIGN oracles
  are dealt with as usual, except when $\adv$ requests credentials or signatures
  on behalf of the $u$-th user. In that cases, \advB simulates the corresponding
  NIZK proofs by calling $\NIZKSim^{\NIZKRel_{\Issue}}$ or
  $\NIZKSim^{\NIZKRel_{\Sign}}$, respectively. Due to the
  simulation-extractability property of both NIZK systems, the output produced
  by the oracles is indistinguishable from that in $G_1$ and, consequently, from
  $G_0=\ExpGSACNonframe$.

  Finally, assume that $\adv$ wins \ExpGSACNonframe with non-negligible
  probability. This means that it outputs a $(\sig = (\Ec,\pi_\sig),\DAttrs,
  \msg,\upk,\pi)$, where $(\sig,\DAttrs,\msg)$ are accepted by \Verify, and
  $(\upk,\pi,\sig,\DAttrs,\msg)$ are accepted by \Judge. Thus, after soundness
  of $\NIZK^{\NIZKRel_{\Sign}}$ and $\NIZK^{\NIZKRel_{\Open}}$, we know that
  \upk is the correct public key associated to an honest user \uid, but as per
  the winning condition, \sig has not been produced via a call to the \SIGN
  oracle for a \cid owned by \uid. Therefore, we can extract the \usk
  corresponding to \upk from the $\pi_{\sig}$ proof. Since executions in the
  environment prepared by \advB are indistinguishable to $\adv$ from executions
  of $G_0$, we can assume that the probability that the \uid associated to the
  \sig output by $\adv$ equals $1/q$. In that case, \usk precisely matches
  $\msg_b$, and \advB wins the hiding game against \C. Since we assume \C
  to be hiding, this probability must therefore be negligible.   
  \qed
\end{proof}

\subsection{Concrete Instantiation with BBS+}
\label{sapp:gsac-instantiation}

Intuitively, the credentials that we generate for our \GSAC construction are
Pedersen commitments to $(\usk,\credid,\Attrs)$ tuples; i.e., they have
the following structure: $\gen{h}_0^r\gen{h}_1^{\usk}\prod_{i \in [2,\nattrs+1]}
\gen{h}_i^{\Attrs_i}$, where the exponent in $\gen{h_0}$ is a fresh random value
that ensures hiding, the exponent in $\gen{h_1}$ encodes the user private
key, and the remaining attributes are encoded in different
exponentiations. This will actually be part of a BBS+ signature, which makes it
easy to add subsequent and efficient zero-knowledge proofs. Concretely, we will
be using several \NIZK proof systems, one for the $\langle \Obtain,\Issue
\rangle$ interactive protocol, another for signing, and a third one for opening.
Each will have its own relation, that we define in the corresponding algorithm.
The concrete algorithms are as follows.

\paragraph{$\Setup(\secpar,\nattrs) \rightarrow \parm$.} %
Generates a bilinear group $\BB = (p,\GG_1,\GG_2,\GG_T,\gen{g}_1,\gen{g}_2,e) \gets
\PGen(\secpar)$, $\nattrs+4$ additional generators $\gen{g},\gen{h},\gen{h}_0,...,
\gen{h}_{\nattrs+1}$ of $\GG_1$. Returns $\parm \gets
(\secpar,\nattrs,\BB,\gen{g},\gen{h},\gen{h}_0,...,\gen{h}_{\nattrs+1})$.

\paragraph{$\IKeyGen(\parm) \rightarrow (\ipk,\isk)$.} %
Parses \parm as $(\secpar,\dots)$ and runs $\NIZKcrs \gets \NIZKSetup(\secpar)$.
Outputs $\isk \gets \ZZ^*_p$, and $\ipk \gets (\NIZKcrs,\gen{g}_2^{\isk})$.

\paragraph{$\OKeyGen(\parm) \rightarrow (\opk,\osk)$.} %
Outputs $\osk \gets \ZZ^*_p$, and $\opk \gets \gen{g}^{\osk}$. This is the
opener's ElGamal encryption key pair \needcite.

\paragraph{$\UKeyGen(\parm) \rightarrow (\upk,\usk)$.} %
Outputs $\usk \gets \ZZ^*_p$, and $\upk \gets \gen{h}_1^{\usk}$. \upk will
simply be used to compute Pedersen commitments \needcite to \usk. However,
it is useful to precompute it, and we treat it as a sort of ``public key''.

\paragraph{$\langle \Obtain(\gpk,\usk,\Attrs),\Issue(\gpk,\isk,\Attrs) \rangle
  \rightarrow \langle \cred/\bot,\utrans/\bot \rangle$.} %
This interactive protocol is essentially a BBS+ signing  process. The user
commits to its private key, proves knowledge of the corresponding private
key, and asks the issuer to sign the commitment, along with any other arbitraty
set of revealed attributes \Attrs. For proving knowledge of the private key, we
define relation $\NIZKRel_{\Issue} = \lbrace (r, \usk), \Ccom: \Ccom =
\gen{h}_0^r\gen{h}_1^{\usk}\rbrace$.

\begin{itemize}
\item \underline{User}: Fetch fresh randomness $r \getr \ZZ^*_p,
  \Ccom \gets \gen{h}_0^r\gen{h}_1^{\usk}$, and compute $\NIZKproof \gets
  \NIZKProve^{\NIZKRel_{\Issue}}(\NIZKcrs,(r,\usk),
  \Ccom)$. Send $(\Ccom,\NIZKproof)$ to Issuer.
\item \underline{Issuer}: Run $\NIZKVerify^{\NIZKRel_{\Issue}}(\NIZKcrs,\Ccom,
  \NIZKproof)$ and return $0$ if it fails. Else, compute
  $x,\tilde{s} \getr \ZZ^*_p, A \gets
  (\gen{g}_1\Ccom h_0^{\tilde{s}} \prod_{i \in \Attrs}
  \gen{h}_i^{\Attrs_i})^{1/(\isk+x)}$.
  Send $(A,x,\tilde{s})$ to User, and output $\utrans \gets
  (\Ccom,(A,x,\tilde{s}),\Attrs,\NIZKproof)$.
\item \underline{User}: If $A = 1_{\GG_1}$: return $0$. Else, compute
  $s \gets r + \tilde{s}$. If $e(A,\gen{g}_2)^xe(A,\ipk) \neq
  e(\gen{g}_1\Ccom\gen{h}_0^{\tilde{s}}\prod_{i \in \Attrs}\gen{h}_i^{\Attrs_i},
  \gen{g}_2)$: return $0$. Else, return
  $(A,x,s)$.
\end{itemize}

\paragraph{$\Sign(\gpk,\usk,\cred,\DAttrs,\msg) \rightarrow \sig$.} %
To create a signature, the user first randomizes its BBS+ credential \cred and
encrypts its public key \upk (note that $\upk=\gen{h}_1^{\usk}$ with the
opener's encryption key. Then, we extend the usual NIZK protocol for proving
knowledge of BBS+ signatures \cite{cdl16b} to, in addition to proving knowledge
of a signature (which, for us is the user credential), also prove that the
attribute encoding \usk within the credential match the encrypted value.
Finally, the user commits to \msg, and includes this commitment within the
proof. For this, we define relation
$\NIZKRel_{\Sign}= \lbrace (r,\usk,\Attrs,r_2,r_3,s',\msg),(\DAttrs,c_1,c_2,
\Cmsg): \Cmsg = \gen{h}^\msg \land c_1 = g^r \land c_2 = \opk^r\gen{h}_1^{\usk}
\land \hat{A}/d = (A')^{-x}\gen{h}_0^{r_2} \land
\gen{g}_1 \prod_{i \in \DAttrs} \gen{h}_i^{\Attrs_i} =
d^{r_3}\gen{h}_0^{-s'}\gen{h}_1^{-\usk}
\prod_{i \notin \DAttrs} \gen{h}_i^{-\Attrs_i} \rbrace$.

\begin{itemize}
\item Parse \gpk as $(\ipk,\opk)$, and \cred as $(A,x,s)$.
\item Re-randomize \cred as $r_1,r_2 \getr
  \ZZ^*_p, r_3 \gets r_1^{-1}, s' \gets s - r_2r_3$, $A' \gets A^{r_1},
  \hat{A} \gets (A')^{-x}(\gen{g}_1\gen{h}_0^s\gen{h}_1^{\usk}
  \prod_{i \in \Attrs}\gen{h}_i^{\Attrs_i})^{r_1}$,
  $d \gets (\gen{g}_1\gen{h}_0^s\gen{h}_1^{\usk}
  \prod_{i \in \Attrs}\gen{h}_i^{\Attrs_i})^{r_1}\gen{h}_0^{-r_2}$.
\item Encrypt $\upk=\gen{h}_1^{\usk}$ with ElGamal as $r \getr \ZZ^*_p,
  c \gets (c_1 = \gen{g}^r,c_2 = \opk^r\gen{h}_1^{\usk})$.
\item Compute $\Cmsg \gets \gen{h}^\msg$ and
  $\NIZKproof \gets \NIZKProve^{\NIZKRel_{\Sign}}(\NIZKcrs,
  (r,\usk,\Attrs,r_2,r_3,s',\msg), (\DAttrs,c_1,c_2,\Cmsg))$.
\item Return $\sig \gets (c=(c_1,c_2),(A',\hat{A},d),\NIZKproof)$.
\end{itemize}

\paragraph{$\Verify(\gpk,\sig,\DAttrs,\msg) \rightarrow 1/0$.} %
Parse \gpk as $(\ipk,\opk)$ and $\sig$ as $(c=(c_1,c_2),
(A',\hat{A},d), \NIZKproof)$. Check that $A' \neq 1_{\GG_1}$ and $e(A',\ipk) =
e(\hat{A},\gen{g}_2)$. Compute $\Cmsg \gets \gen{h}^\msg,$ and return
$\NIZKVerify^{\NIZKRel_{\Sign}}(\NIZKcrs,(\DAttrs,c_1,c_2,\Cmsg),
\NIZKproof)$.

\paragraph{$\Open(\gpk,\osk,\sig,\DAttrs,\msg)
  \rightarrow (\upk,\oproof)/\bot$.} %
For open algorithms, we define the following relation for correct decryption of
ElGamal ciphertexts: $\NIZKRel_{\Open} = \lbrace \osk,(c_1,c_2,\msg):
c_2/c_1^{\osk} = \msg \rbrace$. Given $\NIZKRel_{\Open}$, the opener first,
checks that $\Verify$ accepts the signature, and aborts otherwise. If \sig
is accepted, then parses \sig as $(c=(c_1,c_2),\cdot,\cdot)$.
Sets $\upk \gets c_2/c_1^{\osk}$. Finally, computes the proof of correct
decryption by running $\oproof \gets \NIZKProve^{\NIZKRel_{\Open}}(\NIZKcrs,
\osk,(\upk,c_1,c_2))$, and returns $(\upk,\oproof)$.

\paragraph{$\Judge(\gpk,\upk,\oproof,\sig,\DAttrs,\msg)
  \rightarrow 1/0$.} %
First, check that $\Verify$ accepts \sig, and abort otherwise. If the signature
is accepted, then parse \sig as $(c=(c_1,c_2),\cdot,\cdot)$ and return
$\NIZKVerify^{\NIZKRel_{\Open}}(\NIZKcrs,(c_1,c_2,\upk),\oproof)$.

% \commentwho{Jesus}{For consistency with \UAS, maybe remove the need to return
%   \Attrs in \Open, and return \DAttrs instead. Then, we do not need to pass
%   \trans as a parameter to \Open, as \DAttrs is already attested for in the
%   signature being opened. It also makes sense from the point of view that we
%   are already revealing \upk, which would allow tracing; but otherwise don't
%   reveal anything else about the attributes of \upk -- attributes that whoever
%   requested the signature (the verifier) didn't seem to consider necessary, as
%   s/he only requested \DAttrs. Still, if we make this modification, mention the
%   possibility to return \Attrs, and the option to do it via adding \trans as a
%   parameter to \Open (or including an encryption of all attributes in the
%   signature, which is probably unrealistic.)}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "uas"
%%% End:
