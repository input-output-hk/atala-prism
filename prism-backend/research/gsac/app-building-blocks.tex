\section{Cryptographic Building Blocks}
\label{app:crypto-building-blocks}

\iffalse
\subsection{Digital Signatures}
\label{sapp:digital-signatures}

We rely on digital signatures as a core building block. A digital signature
provides the functionality defined by the following syntax:

\begin{description}
\item[$\Sparm \gets \SSetup(\Ssecpar)$.] It produces public parameters for the
  other algorithms, given an input security parameter \Ssecpar.
\item[$(\Svk,\Ssk) \gets \SKeyGen(\Sparm)$.] Generates a verification-signing
  key pair.
\item[$\Ssig \gets \SSign(\Ssk,\msg)$.] Signs message \msg with signing key
  \Ssk, producing signature \Ssig,  
\item[$1/0 \gets \SVerify(\Svk,\Ssig,\msg)$.] Checks whether \Ssig is a valid
  signature over \msg, under verification key \Svk.
\end{description}

A digital signature scheme is correct if honestly generated signatures, using
honestly generated key pairs, are always accepted by \SVerify. 
%
A digital signature scheme \S has existential unforgeability if, for all p.p.t.
adversaries $\adv$, $\Pr[\ExpEUF(\Ssecpar) = 1]$ is a negligible function of the
security parameter.

\begin{figure}[ht!]
  \scalebox{0.9}{  
    \begin{minipage}[t]{\textwidth}
      \centering
      \procedure{$\ExpEUF(\Ssecpar)$}{%
        \Sparm \gets \SSetup(\Ssecpar) \\
        (\Svk,\Ssk) \gets \SKeyGen(\Sparm) \\
        (\Ssig,\msg) \gets \adv^{\SSign(\Ssk,\cdot)}(\Svk) \\
        \pcif \SVerify(\Svk,\Ssig,\msg) = 0: \pcreturn 0 \\
        \pcif \msg~\textrm{was not queried to \SSign}: \pcreturn 1 \\
        \pcreturn 0
      }
    \end{minipage}
  }
  \label{fig:euf-game}
  \caption{Existential Unforgeability Game.}
\end{figure}
\fi

\subsection{Public-Key Encryption}
\label{sapp:pk-encryption}

A public-key encryption scheme is defined by the following algorithms:

\begin{description}
\item[$\Eparm \gets \ESetup(\Esecpar)$.] Produces public parameters \Eparm given
  a security parameter \Esecpar.
\item[$(\Eek,\Edk) \gets \EKeyGen(\Eparm)$.] Given public parameters \Eparm,
  produces an encryption-decryption key pair $(\Eek,\Edk)$.
\item[$\Ec \gets \EEnc(\Eek,\msg)$.] Encrypts message \msg with encryption key
  \Eek, producing ciphertext \Ec.
\item[$\msg \gets \EDec(\Edk,\Ec)$.] Decrypts ciphertext \Ec with decryption key
  \Edk.
\end{description}

A public-key encryption scheme is correct if, given a honestly generated key
pair $(\Eek,\Edk)$, produced with honestly generated parameters \Eparm,
$\Pr[\EDec(\Edk,\EEnc(\Eek,\msg))=\msg] = 1$ with overwhelming probability.

A public-key encryption scheme has IND-CCA2 security if
$\Pr[\ExpINDCCAiio(\Esecpar) = 1] - \Pr[\ExpINDCCAiiz(\Esecpar) = 1]|$ is
a negligible function of \Esecpar, for any p.p.t. adversary \adv, where
\ExpINDCCAiib is as defined in \figref{fig:indcca2-game}.

\begin{figure}[ht!]
  \scalebox{0.9}{  
    \begin{minipage}[t]{\textwidth}
      \centering      
      \procedure{$\ExpINDCCAiib(\Esecpar)$}{%
        \Eparm \gets \ESetup(\Esecpar) \\
        (\Eek,\Edk) \gets \EKeyGen(\Eparm) \\
        b^* \gets \adv^{\ELR(b,\cdot,\cdot),\EDEC(\Edk,\cdot)}(\Eek),
        ~\textrm{where:} \\
        \pcind \ELR(b,\msg_0,\msg_1)~\textrm{returns}~\EEnc(\Eek,\msg_b),
        ~\textrm{and} \\
        \pcind \EDEC(\Edk,\Ec)~\textrm{returns}~\EDec(\Edk,\Ec) \\
        \pcif \EDEC~\textrm{has been called with an output of \ELR, abort} \\
        \pcreturn b^*
      }
    \end{minipage}
  }
  \label{fig:indcca2-game}
  \caption{IND-CCA2 Game.}
\end{figure}

\subsection{Commitments}
\label{sapp:commitments}

Although we don't expose commitments directly in our \UAS scheme or
constructions, they are an essential part of \SBCM schemes. Thus, we overview
them briefly next. In a nutshell, a commitment scheme is defined by the
following algorithms:

\begin{description}
\item[$\Cparm \gets \CSetup(\Csecpar)$.] Given a security parameter \Csecpar,
  returns the public parameters \Cparm to commit messages.
\item[$\Ccom \gets \CCommit(\Cparm,\msg;r)$.] Given the public parameters and
  a message \msg, outputs a commitment \Ccom to \msg, for which randomness $r$
  from some predefined randomness space $\mathcal{R}$ is used.
\end{description}

Opening a commitment \Ccom means revealing the message \msg and randomness $r$
that were used to produce \Ccom. Commitment schemes are required to be binding
and (usually) hiding:

\begin{description}
\item[Binding.] Intuitively, the binding property of commitment schemes means
  that no adversary can change the message that has been committed to. More
  formally, $\Pr[\ExpComBind(\Csecpar) = 1]$ must be a negligible function of
  the security parameter.
\item[Hiding.] The hiding property captures that no adversary should be able to
  learn the message that was committed, when given only the commitment. This is
  formally defined through \ExpComHideb, where $|\Pr[\ExpComHideb(\Csecpar)=1|
  b=1] - \Pr[\ExpComHideb(\Csecpar)=1|b=0]|$ must be a negligible function of
  the security parameter.
\end{description}

\begin{figure}[ht!]
  \scalebox{0.9}{
    \begin{minipage}[t]{0.5\textwidth}
      \procedure{$\ExpComBind(\Csecpar)$}{%
        \Cparm \gets \CSetup(\Csecpar) \\
        (\msg_0,r_0,\msg_1,r_1) \gets \adv(\Cparm) \\
        \Ccom_0 \gets \CCommit(\Cparm,\msg_0,r_0) \\
        \Ccom_1 \gets \CCommit(\Cparm,\msg_1,r_1) \\
        \pcif \msg_0 \neq \msg_1 \land \Ccom_0 = \Ccom_1: \pcreturn 1 \\
        \pcreturn 0
      }
    \end{minipage}
    \begin{minipage}[t]{0.5\textwidth}
      \procedure{$\ExpComHideb(\secpar)$}{%
        \Cparm \gets \CSetup(\secpar) \\
        b' \gets \adv^{COM(\Cparm,\cdot,\cdot)},~\textrm{where}: \\
        \pcind COM(\Cparm,\msg_0,\msg_1): \\
        \pcind \pcind r \getr \mathcal{R};~\pcreturn \CCommit(\Cparm,\msg_b,r) \\
        % (\msg_0,\msg_1,st) \gets \adv(\Cparm) \\
        % r \getr \mathcal{R} \\
        % \Ccom \gets \CCommit(\Cparm,\msg_b,r) \\
        % b' \gets \adv(st,\Ccom) \\
        \pcreturn b'
      }
    \end{minipage}
  }
  \label{fig:com-games}
  \caption{Games for commitment schemes.}
\end{figure}

\paragraph{Commitments on Blocks of Messages.} We also use an extension
of commitment schemes that allows committing to multiple messages at once. The
properties we need are the same, and their definitions are extended in the
natural way. Namely, $\CCommit$ receives a vector/block of messages, \msgset
instead of a single message. In the games, the adversary returns sets of
messages and, in the binding game, the comparison $\msg_0 \neq \msg_1$ now
compares sets $\msgset_0$ and $\msgset_1$, which must differ in at least one
element. This extension is straight-forward, for instance, from Pedersen
commitments \cite{bcc+15}.

\subsection{Simulation-Extractable Non-Interactive Zero-Knowledge
  Proofs of Knowledge}
\label{sapp:nizk}

Let \NIZKRel be an NP relation defined by pairs of elements $(\NIZKx,\NIZKw)$,
where \NIZKx is a statement and \NIZKw a witness proving that $(\NIZKx,\NIZKw)
\in \NIZKRel$. For concrete relations, we write $\NIZKRel = \lbrace (\NIZKx),
(\NIZKw): f(x,w) \rbrace$, where $f(x,w)$ is a Boolean predicate denoting the
concrete conditions that \NIZKx and \NIZKw need to meet. The set of all \NIZKx
such that there exists a \NIZKw for which $(\NIZKx,\NIZKw) \in \NIZKRel$ is the
language, or \NIZKLang, for \NIZKRel. $\NIZKx \notin \NIZKLang$ means that
there is no $\NIZKw$ such that $(\NIZKx,\NIZKw) \in \NIZKRel$.

We use non-interactive zero-knowledge proofs of knowledge (NIZKPoK, or, for
short, NIZK) over NP relations, in the Common Reference String (CRS) model. A
NIZK system is a tuple $(\NIZKSetup,\NIZKProve,\NIZKVerify)$, defined as follows
\cite{gos06}:

\begin{description}
\item[$\NIZKcrs \gets \NIZKSetup(\NIZKsecpar)$.] Generates a CRS \NIZKcrs from
  security parameters \NIZKsecpar.
\item[$\NIZKproof \gets \NIZKProve(\NIZKcrs,\NIZKx,\NIZKw)$.] Given \NIZKcrs,
  statement \NIZKx, and witness \NIZKw, creates a proof \NIZKproof.
\item[$1/0 \gets \NIZKVerify(\NIZKcrs,\NIZKproof,\NIZKx)$.] Checks whether
  \NIZKproof is a valid proof for \NIZKx.
\end{description}

Any zero-knowledge proof of knowledge must meet completeness, soundness and
zero-knowledge,properties. We further need an extra property, called
\emph{simulation-extractability} \cite{cl06}, which amplifies the security
requirements of (simulation-) soundness.
%
To define more formally the properties we need, we have to define three extra
algorithms:

\begin{description}
\item[$(\NIZKcrs,\NIZKtrap) \gets \NIZKSimSetup(\NIZKsecpar)$.] Produces a
  \NIZKcrs as the \NIZKSetup algorithm, along with a trapdoor \NIZKtrap.
\item[$\NIZKproof \gets \NIZKSim(\NIZKcrs,\NIZKtrap,\NIZKx)$.] Given a trapdoor
  \NIZKtrap produced by \NIZKSimSetup, and a statement $\NIZKx \in \NIZKLang$,
  produces a simulated proof \NIZKproof of $\NIZKx \in \NIZKLang$.
\item[$\NIZKw \gets \NIZKExtract(\NIZKcrs,\NIZKtrap,\NIZKx,\NIZKproof)$.] Given
  a trapdoor \NIZKtrap produced by \NIZKSimSetup, and a proof \NIZKproof for
  $\NIZKx \in \NIZKLang$, returns a valid \NIZKw for \NIZKx.
\end{description}

When we want to make explicit the NP relation \NIZKRel to which the previous
algorithms refer to, we use $\NIZKSetup^\NIZKRel,\NIZKProve^\NIZKRel$, 
$\NIZKVerify^\NIZKRel$, etc., and omit the \NIZK prefix and super-index when
clear from context. Altogether, the tuple $(\Setup,\Prove,\Verify,\SimSetup,
\Sim,\Extract)$ needs to meet the following properties:

\paragraph{Completeness.} %
Ensures that, for any $(\NIZKx,\NIZKw) \in \NIZKRel$, any honest prover will be
able to create a proof \NIZKproof that is accepted by any honest verifier, with
overwhelming probability. More precisely, $\Pr\lbrack\ExpNIZKComp(\NIZKsecpar)
\rbrack = 1$ with overwhelming probability, for any p.p.t. \adv, for
\ExpNIZKComp in \figref{fig:nizk-games}.

\paragraph{Soundness.} %
Ensures that no adversary can create proofs accepted by \Verify, for
statements $\NIZKx \notin \NIZKLang$, except with negligible probability. That
is, for \ExpNIZKSound as in \figref{fig:nizk-games}, $\Pr\lbrack\ExpNIZKSound
(\NIZKsecpar)\rbrack=1$ with overwhelming probability. If this holds only
against p.p.t. adversaries, we talk of Non-Interactive \emph{arguments}, while
if soundness holds even against unbounded adversaries, we talks about
Non-Interactive proofs.

\paragraph{Zero-knowledge.} %
Intuitively, captures that no information can be learned from a statement and
proof pair, beyond their validity (or not). This is captured by requiring the
adversary to distinguish between a run in the real world ($b=0$), where the
setup is done with \Setup, and $\adv$ has access to an honest prover
\Prove; and a run in an ideal world ($b=1$), where the setup is replaced by
\SimSetup, and proofs are simulated with the help of the trapdoor produced by
\SimSetup, except when $\adv$ specifies $(\NIZKx,\NIZKw) \notin \NIZKRel$. Note
that, in the context of simulation-extractable NIZK, this property not only
requires that the simulated proofs are indistinguishable to the real ones; it
also requires that \SimSetup is indistinguishable from \Setup. All this is
formalised by requiring that $|\Pr[\ExpNIZKZKb(\NIZKsecpar) = 1 | b = 1] -
\Pr[\ExpNIZKZKb(\NIZKsecpar) = 1 | b = 0]$ be a negligible function of \secpar,
where \ExpNIZKZKb is as defined in \figref{fig:nizk-games}.

\paragraph{Simulation-Extractability.} As stated, simulation-extractability
is an extension to simulation soundness. In a nutshell,
simulation-extractability requires that, even after having received a polynomial
number of simulated proofs of knowledge, no adversary can output a valid proof
of knowledge from which no witness can be extracted. It implies simulation
soundness, which ``just'' requires that no adversary can produce a valid proof
after having seen polynomially many simulated proofs (but does not guarantee
extraction). Formally, for simulation-extractability we require that
$\Pr[\ExpNIZKSimExt(\NIZKsecpar)] = 1$ is a negligible function of \secpar,
where \ExpNIZKSimExt is defined in \figref{fig:nizk-games}.

\begin{figure}[ht!]
  \scalebox{0.9}{
    \begin{minipage}[t]{0.5\textwidth}
      \procedure{$\ExpNIZKComp(\NIZKsecpar)$}{%
        \NIZKcrs \gets \Setup(\NIZKsecpar) \\
        (\NIZKx,\NIZKw) \gets \adv(\NIZKcrs) \\
        \pcif (\NIZKx,\NIZKw) \notin \NIZKRel: \pcreturn 0 \\
        \NIZKproof \gets \Prove(\NIZKcrs,\NIZKx,\NIZKw) \\
        b \gets \Verify(\NIZKcrs,\NIZKproof,\NIZKx) \\
        \pcreturn b \\
      }
      \procedure{$\ExpNIZKSimExt(\NIZKsecpar)$}{%
        (\NIZKcrs,\NIZKtrap) \gets \SimSetup(\NIZKsecpar) \\
        (\NIZKx,\NIZKproof) \gets \adv^{\Sim'(\NIZKcrs,\NIZKtrap,\cdot,\cdot)}
        (\NIZKcrs) \\
        \pcind \textrm{Where}~\Sim'(\NIZKcrs,\NIZKtrap,\NIZKx,\NIZKw)~\textrm{returns} \\
        \pcind \pcind
        \Sim(\NIZKcrs,\NIZKtrap,\NIZKx)~\pcif (\NIZKx,\NIZKw) \in \NIZKRel \\
        \pcind \pcind \bot~\pcif (\NIZKx,\NIZKw) \notin \NIZKRel \\
        \NIZKw' \gets \Extract(\NIZKcrs,\NIZKtrap,\NIZKx,\NIZKproof) \\
        \pcif \Verify(\NIZKcrs,\NIZKproof,\NIZKx) = 1 \land
        (\NIZKx,\NIZKw') \notin \NIZKRel~\land \\
        \pcind \NIZKx~\textrm{was not queried to $\Sim$ via $\Sim'$}: \\
        \pcind \pcreturn 1 \\
        \pcreturn 0
      }    
    \end{minipage}
    \begin{minipage}[t]{0.5\textwidth}
      \procedure{$\ExpNIZKSound(\NIZKsecpar)$}{%
        \NIZKcrs \gets \Setup(\NIZKsecpar) \\
        (\NIZKproof,\NIZKx) \gets \adv(\NIZKcrs) \\
        \pcif \NIZKx \notin \NIZKLang \land
        \Verify(\NIZKcrs,\NIZKproof,\NIZKx): \\
        \pcind \pcreturn 0 \\
        \pcreturn 1 \\
      }
      
      \procedure{$\ExpNIZKZKb(\NIZKsecpar)$}{%
        \pcif b = 0: \\
        \pcind \NIZKcrs \gets \Setup(\NIZKsecpar) \\
        \pcind \pcreturn \adv^{\Prove(\NIZKcrs,\cdot,\cdot)}(\NIZKcrs) \\
        \pcif b = 1: \\
        \pcind (\NIZKcrs,\NIZKtrap) \gets \SimSetup(\secpar) \\
        \pcind \pcreturn \adv^{\Sim'(\NIZKcrs,\NIZKtrap,\cdot,\cdot)}(\NIZKcrs),~
        \textrm{where} \\
        \pcind \Sim'(\NIZKcrs,\NIZKtrap,\NIZKx,\NIZKw)~\textrm{returns} \\
        \pcind \pcind \Sim(\NIZKcrs,\NIZKtrap,\NIZKx)~\pcif (\NIZKx,\NIZKw)
        \in \NIZKRel \\
        \pcind \pcind \bot~\pcif (\NIZKx,\NIZKw) \notin \NIZKRel
      }    
    \end{minipage}
  }
  \label{fig:nizk-games}
  \caption{Games for Simulation-Extractable NIZK schemes.}
\end{figure}

As studied in \cite{cl06}, simulation-extractable NIZKPoKs formalise the concept
of ``signatures of knowledge'' (see, e.g., \cite{cs97}). Which basically means
that, given an $(\NIZKx,\NIZKw)$ pair from an NP relation, we can treat \NIZKx
as a public key, and \NIZKw as its corresponding private key, and leverage them
to build digital signature schemes -- with the advantage of being able to do so
while proving arbitrary claims, as long as they can be represented as an NP
relation. We note that, given a simulation-extractable NIZK system, it is
straightforward to build a signature of knowledge by adding the message to be
signed in the statement of the NIZK.

\iffalse
\subsection{Signatures over Blocks of Messages}
\label{sapp:sbm}

A signature scheme on blocks of messages (\SBM) allows a signer to create a
single signature over a set of messages. The resulting signature is typically
more concise than just creating multiple signatures, and typical schemes
\cite{cl02,asm06,ps16} are additionally compatible with efficient proof
protocols over the signed messages. The functionality offered by an \SBM scheme
is as follow:

\begin{description}
\item[$\SBMparm \gets \SBMSetup(\SBMsecpar)$.] It produces public parameters
  for the other algorithms, given an input security parameter \SBMsecpar.
\item[$(\SBMvk,\SBMsk) \gets \SBMKeyGen(\SBMparm)$.] Generates a
  verification-signing key pair.
\item[$\SBMsig \gets \SBMSign(\SBMsk,\smsg)$.] Produces a signature \sig, over
  a block of messages \smsg, using signing key \SBMsk.
\item[$1/0 \gets \SBMVerify(\SBMvk,\SBMsig,\widetilde{\smsg})$.] Checks
  whether \SBMsig is a valid signature over the set of messages \smsg, under
  verification key \SBMvk.
\end{description}

An \SBM scheme must satisfy correctness and unforgeability properties.

\paragraph{Correctness.} %
Informally, an \SBM scheme is correct if signatures generated between an honest
party running running \SBMSign over \smsg, for honestly generated parameters
and key pairs, results in a signature over $\smsg \cup \overline{\smsg}$ that is
accepted by \SBMVerify.

\paragraph{Unforgeability.} %
It must be unfeasible for an adversary to produce signatures over blocks of
messages that have not been signed by the signer. More formally, an \SBM scheme
is unforgeable if, for all p.p.t. adversaries $\adv$, $\Pr[\ExpSBMEUF
(\SBMsecpar) = 1]$, as defined in \figref{fig:sbm-games}, is a negligible
function of the security parameter. 

\begin{figure}[ht!]
  \scalebox{0.9}{
    \begin{minipage}[t]{\textwidth}
      \centering    
      \procedure{$\ExpSBMEUF(\SBMsecpar)$}{%
        \SBMparm \gets \SBMSetup(\SBMsecpar) \\
        (\SBMvk,\SBMsk) \gets \SBMKeyGen(\SBMparm) \\
        (\SBMsig,\smsg) \gets \adv^{\SSign(\SBMsk,\cdot)}(\SBMvk) \\
        \pcif \SBMVerify(\SBMvk,\SBMsig,\smsg) = 0: \pcreturn 0 \\
        \pcif \smsg~\textrm{was not queried to \SBMSign}: \pcreturn 1 \\
        \pcreturn 0
      }
    \end{minipage}
  }
  \label{fig:sbm-games}
  \caption{Unforgeability game for \SBM schemes.}
\end{figure}
\fi

\subsection{Signatures over Blocks of Committed Messages}
\label{sapp:sbcm}

For our generic constructions, we use interactive signing protocols between a
user and a signer, where the user has a block of messages to sign blindly, and
both receive a common block of messages to be also included in the resulting
signature. This is precisely the case of partially blind signatures, that
collapse to blind signatures when there is no common message between user
and signer; and to conventional signatures when the user does not input a
message to be blindly signed \cite{ao00}. Partially blind signatures, as
blind signatures \cite{ps96}, cannot be modelled with the conventional security
against existential forgeries. Simply because the user is actually expected to
be able to create signatures on messages unknown to the signer, which formally
translates into the impossibility to check whether a signature output by the
adversary is over a message that has been queried to the signing oracle or not.
Thus, instead of using the conventional existential unforgeability property,
(partially) blind signature schemes move to the ``one-more'' paradigm, which
demands that no adversary can produce $n+1$ distinct signatures after having
interacted with the signing oracle at most $n$ times.

To the best of our knowledge, models of existing schemes for signing blocks of
messages like \cite{cl02,asm06,ps16,cdl16b} target the case of signing blocks
of \emph{plain} messages, and are subsequently informally extended to support
signing commitments to blocks of messages via interactive protocols. However,
they do not support signing both committed and plain messages (although the
extension is trivial); and, more importantly, do not give security models of
the resulting construction, nor of course prove its security. While extending
the constructions seems straightforward, the modelling needs to be changed due
to the mentioned nuance of the conventional EUF notion not being compatible with
interactive signing protocols where the signer does not learn (some of) the
signed message(s). As we use this variant as a generic building block,
we briefly model such a scheme for Signatures over Blocks of Committed Messages
(\SBCM).

The syntax for an \SBCM scheme is as follows:

\begin{description}
\item[$\SBCMparm \gets \SBCMSetup(\SBCMsecpar)$.] It produces public parameters
  for the other algorithms, given an input security parameter \SBCMsecpar.
\item[$(\SBCMvk,\SBCMsk) \gets \SBCMKeyGen(\SBCMparm)$.] Generates a
  verification-signing key pair.
\item[$(\SBCMcom,\pi,r) \gets \SBCMBlind(\SBCMvk,\osmsg,\smsg)$.] A user
  computes commitment \SBCMcom to request a signature over messages \osmsg (in
  committed form) and \smsg (in plain form), to signer with verification key
  \SBCMvk. The output is the commitment \SBCMcom, the randomness $r$ used to
  compute it, and a proof $\pi$ proving knowledge of \osmsg and \smsg in
  \SBCMcom.
\item[$\SBCMbsig \gets \SBCMSign(\SBCMsk,\SBCMcom,\pi,\smsg)$.] The
  signer, with signing key \SBCMsk, produces a blind signature \SBCMbsig over
  the messages committed to in commitment \SBCMcom, as well as the messages in
  \smsg, with associated proof $\pi$.
\item[$\SBCMsig \gets \SBCMUnblind(\SBCMvk,\SBCMbsig,\SBCMcom,r,\osmsg,\smsg)$.]
  A user, who requested a signature over \osmsg and \smsg, where \SBCMcom is a
  commitment over \osmsg using randomness $r$, finalises the signature,
  computing \SBCMsig from the signer's partial signature \SBCMbsig.
\item[$1/0 \gets \SBCMVerify(\SBCMvk,\SBCMsig,\osmsg,\smsg)$.] Checks
  whether \SBCMsig is a valid signature over the set of messages \osmsg and
  \smsg, under verification key \SBCMvk.
\end{description}

The correctness and security properties are then defined as follows.

\paragraph{Correctness.} %
Informally, an \SBCM scheme is correct if signatures generated between an honest
party running \SBCMBlind, an honest signer running \SBCMSign fed with the output
of \SBCMBlind and matching \smsg and signing key pair, and the user finally
running \SBCMUnblind over the partial signature by the signer and leveraging
the same randomness as in \SBCMBlind, produces a signature over \osmsg and \smsg
that is accepted by \SBCMVerify. 

\paragraph{Unforgeability.} %
It must be unfeasible for an adversary to produce signatures over blocks of
messages that have not been signed (in plain, or committed shape) by the
signer. More formally, an \SBCM scheme is unforgeable if, for all p.p.t.
adversaries $\adv$, $\Pr[\ExpSBCMOMF(\SBCMsecpar) = 1]$, as defined in
\figref{fig:sbcm-games}, is a negligible function of the security parameter.
Note that this follows the ``one-more-forgery'' type of definition of blind
signatures \cite{bold02}.

\paragraph{Blindness.} %
Finally, the signer must not learn the plaintext values of the messages that are
signed in committed form. Note that this is a weaker notion than the usual
blindness property of (partially) blind signature schemes, where it is
additionally required that the adversary cannot link a signature to the signing
process that produced it. Informally, we capture this basically as the blinding
notion of a commitment scheme -- and formally define it in \ExpSBCMBlindb in
\figref{fig:sbcm-games}.
%
Note that, in the definition, we explicitly do not give back to the adversary
\adv~any full signature (i.e., after running \SBCMUnblind) obtained from values
returned by \adv, as this will allow the adversary to trivially check what
messages (among the ones he chose) was signed. While this may seem a too weak
notion, it is good enough for our needs, as in our \UAS construction we never
share actual signatures, but zero-knowledge proofs of knowledge of such
signatures.

An \SBCM scheme is blind if, for all p.p.t.
adversaries $\adv$, $|\Pr[\ExpSBCMBlindo(\SBCMsecpar) = 1] -
\Pr[\ExpSBCMBlindz(\SBCMsecpar) = 1]|$ is a negligible function of the security
parameter.

\begin{figure}[ht!]
  \scalebox{0.85}{
    \begin{minipage}[t]{0.62\textwidth}
      \centering      
      \procedure[linenumbering]{$\ExpSBCMOMF(\secpar)$}{%
        \parm \gets \Setup(\secpar) \\
        (\vk,\sk) \gets \KeyGen(\parm) \\
        \lbrace(\sig_i,\overline{\smsg}_i, \smsg_i)\rbrace_{i\in[n]} \gets
        \adv^{\Sign(\sk,\cdot,\cdot,\cdot)}(\vk) \\
        \pcif \exists i \in [n]~\st~\Verify(\vk,\sig_i,\osmsg_i,\smsg_i) = 0: \\
        \pcind \pcreturn 0 \\
        \pcif \exists i \neq j \in [n]~\st \\
        \pcind \smsg_i = \smsg_j \land \osmsg_i = \osmsg_j: \pcreturn 0 \\
        \pcif \adv~\textrm{called}~\Sign(\sk,\cdot,\cdot,\cdot)~
        \textrm{more than $n$ times}: \\
        \pcind \pcreturn 0 \\
        \pcreturn 1
      }
      % \procedure[linenumbering]{$\ExpSBCMEUF(\secpar)$}{%
      %   \parm \gets \SBCMSetup(\secpar) \\
      %   (\vk,\sk) \gets \SBCMKeyGen(\parm) \\
      %   (\sig,\overline{\smsg}, \smsg) \gets
      %   \adv^{\langle \cdot, \SBCMSign(\sk,\cdot) \rangle}(\vk) \\
      %   \pcif \SBCMVerify(\vk,\sig,\overline{\smsg},\smsg) = 0: \\
      %   \pcind \pcreturn 0 \\
      %   \overline{\smsg'} \gets \Extract(\sig,\utrans) \\
      %   \pcind \textrm{where \utrans is the signing transcript for \sig} \\
      %   \pcreturn \smsg' \neq \smsg
      % }
    \end{minipage}
      % \vspace*{0.5em}
    \begin{minipage}[t]{0.43\textwidth}
      \procedure[linenumbering]{$\ExpSBCMBlindb(\secpar)$}{%
        \parm \gets \Setup(\secpar) \\
        (\vk,\sk) \gets \KeyGen(\parm) \\
        % (\osmsg_0,\osmsg_1) \getr M \pccomment{$M \coloneqq$ message space} \\
        % (\st,\smsg) \gets \adv(\vk,\sk) \\
        % \pcfor d \in \bin: \\
        % \pcind (\com_d,\pi_d,r_d) \gets \SBCMCom(\vk,\osmsg_d,\smsg) \\
        % \pcind (\st,\bsig_d) \gets \adv(\st,\sk,\com_d,\pi_d,\smsg) \\
        % \pcind \sig_d \gets \SBCMUnblind(\vk,\bsig_d,r_d,\osmsg_d,\smsg) \\
        % b^* \gets \adv(\st,\sig_b,\sig_{1-b}) \\       
        b^* \gets \adv^{BLIND(\cdot,\cdot,\cdot)}(\vk),~\textrm{where:} \\
        \pcind BLIND(\osmsg_0,\osmsg_1,\smsg): \\
        \pcind \pcind (\com,\pi,r) \gets \Blind(\vk,\osmsg_b,\smsg); \\
        \pcind \pcind \pcreturn (\com,\pi) \\
        \pcreturn b = b^*
      }
    \end{minipage}
  }
  \label{fig:sbcm-games}
  \caption{Games for \SBCM schemes.
  }
\end{figure}

\paragraph{Augmented NIZKs.} %
Constructions of \SBCM (e.g. \cite{asm06}), as well as the formalisation we just
described, require that the user proves, in zero-knowledge (via a NIZK),
knowledge of the messages to be signed in committed
form -- and the blinding factor used to hide them. Note that, in such
constructions, it is easy to extend their NIZK so that, instead of simply
proving knowledge of the messages signed in committed form, the party running
\SBCMBlind proves, in zero knowledge, some arbitrary claim over the messages to
be signed (both those in committed or plaintext form). This can be done by
extending the initial NIZK into a more general one. 
%
It is direct that, if the base \SBCM scheme satisfies blindness, then extending
it with an arbitrary zero-knowledge NIZK proof over the signed messages, still
maintains blindness (the adversary cannot distinguish which committed message
set is signed, in the blindness game).
%
We use this extension in our \CUASGen construction. Note that, under this
extension, we may also need to provide extra information to the \SBCMBlind,
\SBCMSign and \SBCMUnblind algorithms, as part of the extended statement being
proven, and new witnesses (even though some may not be part of the messages to
be signed). To make this explicit, we use the following notation to denote
that we use a NIZK for relation $\NIZKRel$, with values $x'$ and $w'$ that are
part of the statement being proven, but are not contained within the actual
\smsg or \osmsg:

\begin{itemize}
\item $(\Ccom,\pi,r) \gets \SBCMBlind^\NIZKRel(\vk,\osmsg,\smsg;x',w')$. Like
  \SBCMBlind, but for relation \NIZKRel, which requires extra values $x'$ and
  $w'$ for its statement and witnesses, beyond what may be included in \smsg and
  \osmsg, respectively.
\item $\SBCMbsig \gets \SBCMSign^\NIZKRel(\sk,\Ccom,\pi,\smsg;x')$. Like
  \SBCMSign, but for relation \NIZKRel, which requires extra values $x'$
  for its statement, beyond what may be included in \smsg.
\item $\SBCMsig \gets \SBCMUnblind^\NIZKRel(\vk,\SBCMbsig,\Ccom,r,\osmsg,\smsg;
  x',w')$. Like \SBCMUnblind, but for relation \NIZKRel, which requires extra
  values $x'$ and $w'$ for its statement and witnesses, beyond what may be
  included in \smsg and \osmsg, respectively.
\end{itemize}

\paragraph{Proofs of knowledge of a \SBCM signature.} %
Finally, in addition, we require that the produced signatures must be compatible
with (efficient) NIZK proofs of knowledge of a signature.

\subsubsection{An Instantiation of \SBCM with BBS+}

Next, we give an instantiation of an \SBCM scheme, based on BBS+ signatures.
We emphasise again that this is essentially equivalent to the protocol for
signing committed block of messages in \cite{asm06} and, also, to the equivalent
ones in \cite{cl02,ps16} (although not for BBS+ signatures). The main difference
being that we allow merging committed blocks of messages and blocks of
(plaintext) messages into the same signature.
%
Note also that, in our instantiation, we just include a generic \NIZK, for some
relation over witness $\overline{\smsg}$ (i.e., the messages to be blindly
signed), and statement $(\Ccom,\smsg)$ (i.e., their block commitment, and the
plainly signed messages). This is intentional, as we want to support cases where
proving arbitrary predicates is possible (as opposed to ``just'' proving that
the commitment is over the messages in $\overline{\smsg}$).
%
When we want to make explicit the relation over which the employed \NIZK is
defined, we add a $\NIZKRel$ superscript to the algorithms.

\paragraph{$\SBCMparm \gets \SBCMSetup(\SBCMsecpar,\nattrs,\tnattrs)$.} %
Generates a bilinear group $\BB = (p,\GG_1,\GG_2,\GG_T,\gen{g}_1,\gen{g}_2,e)
\gets \PGen(\SBCMsecpar)$, and $\nattrs+\tnattrs+1$ additional generators
$\gen{g}$, $\gen{h}_1,...,\gen{h}_{\nattrs}$,$\gen{\th}_1,...,\gen{\th}_{\tnattrs}$
of $\GG_1$. Returns $\SBCMparm \gets (\SBCMsecpar,\nattrs,\tnattrs,\BB,
\gen{g},\gen{h}_1,...,\gen{h}_{\nattrs},\gen{\th}_1,...,\gen{\th}_{\tnattrs})$.
We assume that \SBCMparm is available to all other algorithms, even when not
explicitly passed as an argument.

\paragraph{$(\SBCMvk,\SBCMsk) \gets \SBCMKeyGen(\SBCMparm)$.} %
Parses \SBCMparm as $(\cdot,\cdot,(p,\GG_1,\GG_2,\GG_T,\gen{g}_1,\gen{g}_2,e),
\dots$ $\NIZKcrs \gets \NIZKSetup(\secpar)$. Outputs $\SBCMsk \gets \ZZ^*_p$,
and $\SBCMvk \gets (\NIZKcrs,\gen{g}_2^{\SBCMsk})$.

\paragraph{$(\Ccom,\pi,r) \gets \SBCMBlind(\SBCMvk,\osmsg,\smsg)$.} %
If $|\smsg |>\nattrs$ or $|\osmsg|>\tnattrs$,
abort. Else, fetch fresh randomness $r \getr \ZZ^*_p$, compute $\Ccom \gets
\gen{g}^r\prod_{i \in [|\overline{\smsg}|]}\gen{\th}_i^{\overline{\smsg}_i}$,
and $\NIZKproof \gets \NIZKProve(\NIZKcrs,(r,\overline{\smsg}),\Ccom)$.
Output $(\Ccom,\NIZKproof,r)$.

\paragraph{$\SBCMbsig \gets \SBCMSign(\SBCMsk,\Ccom,\NIZKproof,\smsg)$.} %
If $|\smsg|>\nattrs$, abort. Else, run $\NIZKVerify(\NIZKcrs,\Ccom,\NIZKproof)$
and return $0$ if it fails. Else, compute $x,\tilde{s} \getr \ZZ^*_p, A \gets
(\gen{g}_1\Ccom \gen{g}^{\tilde{s}} \prod_{i \in |\smsg|}
\gen{h}_i^{\smsg_i})^{1/(\SBCMsk+x)}$. Return $\SBCMbsig \gets (A,x,\tilde{s})$.

\paragraph{$\SBCMsig \gets \SBCMUnblind(\SBCMvk,\SBCMbsig,\Ccom,r,
  \osmsg,\smsg)$.} %
Parse \SBCMbsig as $(A,x,\tilde{s})$
If $A = 1_{\GG_1}$: return $0$. Else, compute $s \gets r + \tilde{s}$. If
$e(A,\gen{g}_2)^xe(A,\SBCMvk) \neq e(\gen{g}_1\Ccom\gen{g}^{\tilde{s}}
\prod_{i \in |\smsg|}\gen{h}_i^{\smsg_i},\gen{g}_2)$: return $0$. Else, return
$(A,x,s)$.

% \paragraph{$\SBCMsig/\bot \gets \langle \SBCMCom(\SBCMvk,\overline{\smsg},
%   \smsg), \SBCMSign(\SBCMsk,\smsg) \rangle$.} %

% \begin{itemize}
% \item \underline{User}: If $|\smsg|>\nattrs$ or $|\overline{\smsg}|>\tnattrs$,
%   abort. Else, fetch fresh randomness $r \getr \ZZ^*_p$, compute $\Ccom \gets
%   \gen{g}^r\prod_{i \in [|\overline{\smsg}|]}\gen{\th}_i^{\overline{\smsg}_i}$,
%   and $\NIZKproof \gets \NIZKProve(\NIZKcrs,(r,\overline{\smsg}),\Ccom)$.
%   Send $(\Ccom,\NIZKproof)$ to Issuer.
% \item \underline{Signer}: If $|\smsg|>\nattrs$, abort. Else, run $\NIZKVerify
%   (\NIZKcrs,\Ccom,\NIZKproof)$ and return $0$ if it fails. Else, compute
%   $x,\tilde{s} \getr \ZZ^*_p, A \gets (\gen{g}_1\Ccom \gen{g}^{\tilde{s}}
%   \prod_{i \in |\smsg|}\gen{h}_i^{\smsg_i})^{1/(\SBCMsk+x)}$. Send
%   $(A,x,\tilde{s})$ to User.
% \item \underline{User}: If $A = 1_{\GG_1}$: return $0$. Else, compute
%   $s \gets r + \tilde{s}$. If $e(A,\gen{g}_2)^xe(A,\SBCMvk) \neq
%   e(\gen{g}_1\Ccom\gen{g}^{\tilde{s}}\prod_{i \in |\smsg|}\gen{h}_i^{\smsg_i},
%   \gen{g}_2)$: return $0$. Else, return $(A,x,s)$.
% \end{itemize}

\paragraph{$1/0 \gets \SBCMVerify(\SBCMvk,\SBCMsig,\overline{\smsg},\smsg)$.} %
To verify a signature \SBCMsig, for message set $\overline{\smsg}$ that was
signed as a block commitment, and message set \smsg, signed as plaintext, parse
\SBCMsig as $(A,x,s)$ and check if $e(A,\gen{g}_2^x\SBCMvk) =
e(\gen{g}_1\gen{g}^s\prod_{i \in |\overline{\smsg}|}\gen{h}^{\overline{\smsg}_i}
\prod_{i \in |\smsg|}\gen{h}^{\smsg_i},\gen{g}_2)$

\paragraph{Augmented NIZKs.} %
If needed, it is straightforward to augment the proof \NIZKproof used
in \SBCMBlind, \SBCMSign and \SBCMUnblind  with an extended proof that also
proves that $(x,w) \in \NIZKRel$, for some other relation \NIZKRel (where
$\osmsg$ is part of $w$), thus implementing the augmented interface described
earlier for \SBCM schemes.

\paragraph{Proving Knowledge of Signature.} %
Proving knowledge of a BBS+ signature as produced in our \SBCM variant
is essentially the same as in \cite{asm06,cdl16b}, only needing to account for
the different basis for messages signed in committed and plain form.

\paragraph{Correctness.} Correctness is direct from correctness of the
commitment scheme, the NIZK system, and BBS+.

\paragraph{OMF security.} The proof for OMF security is essentially the
same as that of EUF security for BBS+ signatures \cite{cdl16b}, which gives a
reduction against the $q$-SDH problem. There is only one exception: in the proof
for BBS+ EUF-security, when the adversary against EUF-security queries a
signature, the simulator (the adversary against $q$-SDH) has to simulate the
signature. For this, it requires the $l$ messages in the message set to be
signed, which in plain BBS+ it is not a problem, as they are received in the
clear. In the case of \SBCM, however, some of the messages to be signed are
received as part of a commitment. Note however that, in \SBCM, besides receiving
the commitment, we also receive a NIZK proof of knowledge of the corresponding
messages. Thus, the adversary against $q$-SDH in the OMF case only needs to
extract the witnesses from the proof. This is doable after soundness of the NIZK
and binding of the commitment scheme. %
If the NIZK also has online-extractability, then we do not need to impose
further requirements. If it is not, then the \SBCM scheme should not allow
parallel signing requests, or limit the total number of signatures to be
created to a logarithmic function of the security parameter (which is probably
not reasonable in most cases; although it may be for group signature-like
settings). We refer to \cite[Lemma 1]{cdl16b} for the full details of the proof
of EUF security in BBS+.
%
% \jesus{If needed, do the actual proof. Should essentially be a copy-paste of
%   that in \cite{cdl16b}...}

\paragraph{Blindness.}
Blindness of \SBCM is a direct consequence of the hiding property of the
underlying block commitment scheme. Indeed, assume an adversary $\adv$ against
blindness of \SBCM. Then, $\adv$ can be used by \advB against the hiding
property of the commitment scheme in a straightforward manner. Namely, \advB
sets up the environment for \adv by running the \KeyGen algorithm using the
\vk it receives. Then, for every query that \adv makes to its $BLIND$ oracle,
\advB checks that the length of \smsg is acceptable (i.e., less than the
maximum length allowed by \SBCM), and forwards the query to its own $COM$
oracle using $\osmsg_0$ and $\osmsg_1$. To the output \Ccom of $COM$, \advB
appends a simulated proof $\pi$, and forwards $(\Ccom,\pi)$ to \adv. Finally,
\advB outputs whatever \adv~outputs. The simulation is correct due to the
zero-knowledge property of the underlying NIZK. Thus, \advB wins whenever
\adv~does.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "uas-paper"
%%% End:
