\section{Cryptographic Building Blocks}
\label{app:crypto-building-blocks}

\subsection{Digital Signatures}
\label{sapp:digital-signatures}

Defined as a tuple $(\SSetup,\SKeyGen,\SSign,\SVerify)$. Algorithm $\Sparm \gets
\SSetup(\Ssecpar)$ produces public parameters for the other algorithms.
$(\Svk,\Ssk) \gets \SKeyGen(\Sparm)$ generates the verification-signing key
pair, algorithm $\Ssig \gets \SSign(\Ssk,\msg)$ signs message \msg with
signing key \Ssk, producing signature \Ssig, and $1/0 \gets \SVerify(\Svk,
\Ssig,\msg)$ checks whether \Ssig is a valid signature over \msg, under
verification key \Svk. \todo{Informally define security properties we'll need.}

\subsection{Public-Key Encryption}
\label{sapp:pk-encryption}

Defined as a tuple $(\ESetup,\EKeyGen,\EEnc,\EDec)$. Algorithm $\Eparm \gets
\ESetup(\Esecpar)$ produces public parameters for the other algorithms.
$(\Eek,\Edk) \gets \EKeyGen(\Eparm)$ generates the encryption-decryption key
pair, algorithm $\Ec \gets \EEnc(\Eek,\msg)$ encrypts message \msg with
encryption key \Eek, producing ciphertext \Ec, and $\msg/\bot \gets \EDec(\Edk,
\Ec)$ decrypts ciphertexts using decryption key \Edk. \todo{Informally define
  security properties we'll need.}

\subsection{Vector Commitments}
\label{sapp:vector-commitments}

Defined as a tuple $(\CSetup,\CCommit)$. Algorithm $\Cparm \gets
\CSetup(\Csecpar)$ produces the parameters for committing to values. $\Ccom
\gets \CCommit(\Cparm, \msgset; r)$ produces a commitment \Ccom over a set of
messages \msgset, from which we may omit randomness $r$. \todo{Informally define
  hiding and binding, leaving formal definitions to the appendix.}


\subsection{Signatures on Blocks of Committed Messages}
\label{sapp:sbcm}

We use signature schemes that allow signing messages, or commitments to messages,
in blocks, and are compatible with (efficient) proof systems over the produced
signature and signed (commitments to) messages. For this purpose, we define such
schemes as a tuple $(\SBCMSetup,\SBCMKeyGen,\SBCMSign,\SBCMVerify)$. Algorithm
$\SBCMparm \gets \SBCMSetup(\SBCMsecpar)$ produces the public parameters for the
scheme. $(\SBCMvk,\SBCMsk) \gets \SBCMKeyGen(\SBCMparm)$ produces a
verification-signing key
pair. Algorithm $\SBCMsig \gets \SBCMSign(\SBCMsk,\Ccom,\msgset)$ produces a
signature over a set of committed messages \Ccom and a set of messages
\msgset, where either \Ccom or \msgset may be empty. $1/0 \gets
\SBCMVerify(\SBCMvk,\SBCMsig,\overline{\msgset})$ verifies a signature \SBCMsig
over message set $\overline{\msgset}$, which must contain both the messages that
were signed as commitments as well as those signed in ``the clear''. In
addition, the produced signatures must be compatible with (efficient) NIZK
proofs of knowledge of a signature, and of (arbitrary) claims over the signed
(committed) messages.
\todo{Informally define security properties we'll need.}

\subsection{Non-Interactive Zero-Knowledge Proofs of Knowledge}
\label{sapp:nizk}

Let \NIZKRel be an NP relation defined by pairs of elements $(\NIZKx,\NIZKw)$,
where \NIZKx is a statement and \NIZKw a witness proving that $(\NIZKx,\NIZKw)
\in \NIZKRel$. For concrete relations, we write $\NIZKRel = \lbrace (\NIZKx),
(\NIZKw): f(x,w) \rbrace$, where $f(x,w)$ is a boolean predicate denoting the
concrete conditions that \NIZKx and \NIZKw need to meet. The set of all $(\NIZKx,
\NIZKw) \in \NIZKRel$ is called the language, or \NIZKLang, for \NIZKRel.
$\NIZKx \notin \NIZKLang$ means that there is no $\NIZKw$ such that $(\NIZKx,
\NIZKw) \in \NIZKRel$. \todo{Check this definition.}

We use non-interactive zero-knowledge proofs of knowledge (NIZKPoK, or, for
short, NIZK) over NP relations, in the Common Reference String (CRS) model
\needcite. A NIZK system is a tuple $(\NIZKSetup,\NIZKProve,\NIZKVerify)$,
defined as follows \cite{gos06}:

\begin{description}
\item[$\NIZKcrs \gets \NIZKSetup(\NIZKsecpar)$.] Generates a CRS \NIZKcrs from
  security parameters \NIZKsecpar.
\item[$\NIZKproof \gets \NIZKProve(\NIZKcrs,\NIZKx,\NIZKw)$.] Given \NIZKcrs,
  statement \NIZKx, and witness \NIZKw, creates a proof \NIZKproof.
\item[$1/0 \gets \NIZKVerify(\NIZKcrs,\NIZKproof,\NIZKx)$.] Checks whether
  \NIZKproof is a valid proof for \NIZKx.
\end{description}

Moreover, a NIZK system has additional algorithms $(\NIZKSimI,\NIZKSimII)$ and
$(\NIZKExtI,\NIZKExtII)$ defined as follows:

\begin{description}
\item[$(\NIZKcrs,\NIZKext) \gets \NIZKSimI(\NIZKsecpar)$.] Produces a \NIZKcrs
  as the \NIZKSetup algorithm, along with a \todo{simulation} trapdoor.
  % The output of \NIZKSimI is required to be indistinguishable from that of
  % \NIZKSetup.
\item[$\NIZKproof \gets \NIZKSimII(\NIZKcrs,\NIZKext,\NIZKx)$.] Given a
  \todo{simulation} trapdoor, and a statement $\NIZKx \in \NIZKLang$,
  produces a simulated proof \NIZKproof of $\NIZKx \in \NIZKLang$.
\item[$(\NIZKcrs,\NIZKext) \gets \NIZKExtI(\NIZKsecpar)$.] Produces a \NIZKcrs
  as the \NIZKSetup algorithm, along with an extraction trapdoor \NIZKext.
\item[$\NIZKw \gets \NIZKExtII(\NIZKcrs,\NIZKext,\NIZKx,\NIZKproof)$.] Given
  an extraction trapdoor \NIZKext produced by \NIZKExtI, and a proof \NIZKproof
  for $\NIZKext \in \NIZKLang$, returns a valid \NIZKw for \NIZKx.
\end{description}

When we want to make explicit the NP relation \NIZKRel to which the previous
algorithms refer to, we use $\NIZKSetup^\NIZKRel,\NIZKProve^\NIZKRel$, 
$\NIZKVerify^\NIZKRel$, etc., and omit the \NIZK prefix and subindex when clear
from context. Altogether, the tuple $(\Setup,\Prove,\Verify,\ExtI,\ExtII,\SimI,
\SimII)$ needs to meet the following properties:

\paragraph{Completeness.} %
Ensures that, for any $(\NIZKx,\NIZKw) \in \NIZKRel)$, any honest prover will be
able to create a proof \NIZKproof that is accepted by any honest verifier, with
overwhelming probability. More precisely, $\Pr\lbrack\ExpNIZKComp\rbrack = 1$
with overwhelming probability, for any p.p.t. \adv, for \ExpNIZKComp in
\figref{fig:nizk-games}.

\paragraph{Soundness.} %
Ensures that no adversary can create proofs accepted by \Verify, for
statements $\NIZKx \notin \NIZKLang$, except with negligible probability. That
is, for \ExpNIZKSound as in \figref{fig:nizk-games}, $\Pr\lbrack\ExpNIZKSound\rbrack
= 1$ with overwhelming probability. If this holds only against p.p.t.
adversaries, we talk of Non-Interactive \emph{arguments}, while if soundness
holds even against unbounded adversaries, we talks about Non-Interactive proofs.

\paragraph{Knowledge extraction.} %
For all possible adversaries computing a valid proof \NIZKproof over a statement
$\NIZKx \in \NIZKLang$, computed using a \NIZKcrs produced by \ExtI and given
\NIZKext also produced by \ExtI, \ExtII outputs a witness \NIZKw such that
$(\NIZKx,\NIZKw) \in \NIZKRel$. That is, for all valid statements in the
language and a proof, we can extract a valid witness given some special
knowledge ($\NIZKext$). \todo{Capture either here or in the game that the
  output of \ExtI needs to be indistinguishable to the output of \Setup.}

\paragraph{Zero-knowledge.} %
Intuitively, captures that no information can be learned from an statement and
proof pair, beyond their validity (or not). This is captured by requiring the
adversary to distinguish between a run in the real world ($b=0$), where the
setup is done with \Setup, and $\adv$ has access to an honest prover
\Prove; and a run in an ideal world ($b=1$), where the setup is run by
a simulator \SimI, and proofs are generated by \SimII, except when $\adv$
specifies $(\NIZKx,\NIZKw) \notin \NIZKRel$.

\begin{figure}[ht!]
  \begin{minipage}[t]{0.5\textwidth}
    \procedure{$\ExpNIZKComp(\secpar)$}{%
      \NIZKcrs \gets \Setup(\secpar) \\
      (\NIZKx,\NIZKw) \gets \adv(\NIZKcrs) \\
      \pcif (\NIZKx,\NIZKw) \notin \NIZKRel: \pcreturn 0 \\
      \NIZKproof \gets \Prove(\NIZKcrs,\NIZKx,\NIZKw) \\
      b \gets \Verify(\NIZKcrs,\NIZKproof,\NIZKx) \\
      \pcreturn b \\
    }
    \procedure{$\ExpNIZKExt(\secpar)$}{%
      (\NIZKcrs,\NIZKext) \gets \ExtI(\secpar) \\
      (\NIZKx,\NIZKproof) \gets \adv(\NIZKcrs) \\
      \NIZKw \gets \NIZKExtII(\NIZKcrs,\NIZKext,\NIZKx,\NIZKproof) \\
      \pcif \Verify(\NIZKcrs,\NIZKproof,\NIZKx) = 1 \land
      (\NIZKx,\NIZKw) \notin \NIZKRel: \\
      \pcind \pcreturn 0 \\
      \pcreturn 1
    }    
  \end{minipage}
  \begin{minipage}[t]{0.5\textwidth}
    \procedure{$\ExpNIZKSound(\secpar)$}{%
      \NIZKcrs \gets \Setup(\secpar) \\
      (\NIZKproof,\NIZKx) \gets \adv(\NIZKcrs) \\
      \pcif \NIZKx \notin \NIZKLang \land
      \Verify(\NIZKcrs,\NIZKproof,\NIZKx): \\
      \pcind \pcreturn 0 \\
      \pcreturn 1 \\
    }
    \procedure{$\ExpNIZKZKb(\secpar)$}{%
      \pcif b = 0: \\
      \pcind \NIZKcrs \gets \Setup(\secpar) \\
      \pcind \pcreturn \adv^{\Prove(\NIZKcrs,\cdot,\cdot)}(\NIZKcrs) \\
      \pcif b = 1: \\
      \pcind (\NIZKcrs,\NIZKext) \gets \SimI(\secpar) \\
      \pcind \pcreturn \adv^{\Sim'(\NIZKcrs,\NIZKext,\cdot,\cdot)}(\NIZKcrs),~
      \textrm{where} \\
      \pcind \Sim'(\NIZKcrs,\NIZKext,\NIZKx,\NIZKw)~\textrm{returns} \\
      \pcind \pcind \SimII(\NIZKcrs,\NIZKext,\NIZKx)~\pcif (\NIZKx,\NIZKw)
      \in \NIZKRel \\
      \pcind \pcind \bot~\pcif (\NIZKx,\NIZKw) \notin \NIZKRel
    }    
  \end{minipage}
  \label{fig:nizk-games}
  \caption{Games for NIZK schemes.}
\end{figure}

\iffalse
\paragraph{Simulation Soundness.} %
\fi


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "uas"
%%% End:
