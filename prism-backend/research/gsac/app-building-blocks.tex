\section{Cryptographic Building Blocks}
\label{app:crypto-building-blocks}

\subsection{Digital Signatures}
\label{sapp:digital-signatures}

We rely on digital signatures as a core building block. A digital signature
provides the functionality defined by the following syntax:

\begin{description}
\item[$\Sparm \gets \SSetup(\Ssecpar)$.] It produces public parameters for the
  other algorithms, given an input security parameter \Ssecpar.
\item[$(\Svk,\Ssk) \gets \SKeyGen(\Sparm)$.] Generates a verification-signing
  key pair.
\item[$\Ssig \gets \SSign(\Ssk,\msg)$.] Signs message \msg with signing key
  \Ssk, producing signature \Ssig,  
\item[$1/0 \gets \SVerify(\Svk,\Ssig,\msg)$.] Checks whether \Ssig is a valid
  signature over \msg, under verification key \Svk.
\end{description}

A digital signature scheme is correct if honestly generated signatures, using
honestly generated key pairs, are always accepted by \SVerify. \todo{define more
  formally?}
%
A digital signature scheme \S has existential unforgeability if, for all p.p.t.
adversaries $\adv$, $\Pr[\ExpEUF = 1]$ is a negligible function of the
security parameter.

\begin{figure}[ht!]
  \begin{minipage}[t]{0.5\textwidth}
    \procedure{$\ExpEUF(\Ssecpar)$}{%
      \Sparm \gets \SSetup(\Ssecpar) \\
      (\Svk,\Ssk) \gets \SKeyGen(\Sparm) \\
      (\Ssig,\msg) \gets \adv^{\SSign(\Ssk,\cdot)}(\Svk) \\
      \pcif \SVerify(\Svk,\Ssig,\msg) = 0: \pcreturn 0 \\
      \pcif \msg~\textrm{was not queried to \SSign}: \pcreturn 1 \\
      \pcreturn 0
    }
  \end{minipage}
  \label{fig:euf-game}
  \caption{Existential Unforgeability Game.}
\end{figure}

\subsection{Public-Key Encryption}
\label{sapp:pk-encryption}

Defined as a tuple $(\ESetup,\EKeyGen,\EEnc,\EDec)$. Algorithm $\Eparm \gets
\ESetup(\Esecpar)$ produces public parameters for the other algorithms.
$(\Eek,\Edk) \gets \EKeyGen(\Eparm)$ generates the encryption-decryption key
pair, algorithm $\Ec \gets \EEnc(\Eek,\msg)$ encrypts message \msg with
encryption key \Eek, producing ciphertext \Ec, and $\msg/\bot \gets \EDec(\Edk,
\Ec)$ decrypts ciphertexts using decryption key \Edk. \todo{Informally define
  security properties we'll need.}

\subsection{Commitments}
\label{sapp:commitments}

A commitment scheme is defined by the following algorithms:

\begin{description}
\item[$\Cparm \gets \CSetup(\Csecpar)$.] Given a security parameter \Csecpar,
  returns the public parameters \Cparm to commit messages.
\item[$\Ccom \gets \CCommit(\Cparm,\msg,r)$.] Given the public parameters and
  a message \msg, outputs a commitment \Ccom to \msg, for which randomness $r$
  from some predefind randomness space $\mathcal{R}$ is used.
\end{description}

Opening a commitment \Ccom means revealing the message \msg and randomness $r$
that were used to produce \Ccom. Commitment schemes are required to be binding
and (usually) hiding:

\begin{description}
\item[Binding.] Intuitively, the binding property of commitment schemes means
  that no adversary can change the message that has been committed to. More
  formally, $\Pr[\ExpComBind = 1]$ must be a negligible function of the security
  parameter.
\item[Hiding.] The hiding property captures that no adversary should be able to
  learn the message that was committed, when given only the commitment. This is
  formally defined through \ExpComHideb, where $|\Pr[\ExpComHideb=1|b=1] -
  \Pr[\ExpComHideb=1|b=0]|$ must be a negligible function of the security
  parameter.
\end{description}

\begin{figure}[ht!]
  \begin{minipage}[t]{0.5\textwidth}
    \procedure{$\ExpComBind(\secpar)$}{%
      \Cparm \gets \CSetup(\secpar) \\
      (\msg_0,r_0,\msg_1,r_1) \gets \adv(\Cparm) \\
      \Ccom_0 \gets \CCommit(\Cparm,\msg_0,r_0) \\
      \Ccom_1 \gets \CCommit(\Cparm,\msg_1,r_1) \\
      \pcif \msg_0 \neq \msg_1 \land \Ccom_0 = \Ccom_1: \pcreturn 1 \\
      \pcreturn 0
    }
  \end{minipage}
  \begin{minipage}[t]{0.5\textwidth}
    \procedure{$\ExpComHideb(\secpar)$}{%
      \Cparm \gets \CSetup(\secpar) \\
      (\msg_0,\msg_1,st) \gets \adv(\Cparm) \\
      r \getr \mathcal{R} \\
      \Ccom \gets \CCommit(\Cparm,\msg_b,r) \\
      b' \gets \adv(st,\Ccom) \\
      \pcreturn b'
    }
  \end{minipage}
  \label{fig:com-games}
  \caption{Games for commitment schemes.}
\end{figure}

\paragraph{Commitments on Blocks of Messages.} We also use an extension
of commitment schemes that allows committing to multiple messages at once. The
properties we need are the same, and their definitions are extended in the
natural way. Namely, $\CCommit$ receives a vector/block of messages, \msgset
instead of a single message. In the games, the adversary returns sets of
messages and, in the binding game, the comparison $\msg_0 \neq \msg_1$ now
compares sets $\msgset_0$ and $\msgset_1$, which must differ in at least one
element. This extension is straight-forward, for instance, from Pedersen
commitments \cite{bcc+15}.

\subsection{Signatures on Blocks of Committed Messages}
\label{sapp:sbcm}

We use signature schemes that allow signing messages, or commitments to messages,
in blocks, and are compatible with (efficient) proof systems over the produced
signature and signed (commitments to) messages. For this purpose, we define such
schemes as a tuple $(\SBCMSetup,\SBCMKeyGen,\SBCMSign,\SBCMVerify)$. Algorithm
$\SBCMparm \gets \SBCMSetup(\SBCMsecpar)$ produces the public parameters for the
scheme. $(\SBCMvk,\SBCMsk) \gets \SBCMKeyGen(\SBCMparm)$ produces a
verification-signing key
pair. Algorithm $\SBCMsig \gets \SBCMSign(\SBCMsk,\Ccom,\msgset)$ produces a
signature over a set of committed messages \Ccom and a set of messages
\msgset, where either \Ccom or \msgset may be empty. $1/0 \gets
\SBCMVerify(\SBCMvk,\SBCMsig,\overline{\msgset})$ verifies a signature \SBCMsig
over message set $\overline{\msgset}$, which must contain both the messages that
were signed as commitments as well as those signed in ``the clear''. In
addition, the produced signatures must be compatible with (efficient) NIZK
proofs of knowledge of a signature, and of (arbitrary) claims over the signed
(committed) messages.
\todo{Informally define security properties we'll need.}

\subsection{Simulation-Extractable Non-Interactive Zero-Knowledge
  Proofs of Knowledge}
\label{sapp:nizk}

Let \NIZKRel be an NP relation defined by pairs of elements $(\NIZKx,\NIZKw)$,
where \NIZKx is a statement and \NIZKw a witness proving that $(\NIZKx,\NIZKw)
\in \NIZKRel$. For concrete relations, we write $\NIZKRel = \lbrace (\NIZKx),
(\NIZKw): f(x,w) \rbrace$, where $f(x,w)$ is a boolean predicate denoting the
concrete conditions that \NIZKx and \NIZKw need to meet. The set of all \NIZKx
such that there exists a \NIZKw for which $(\NIZKx,\NIZKw) \in \NIZKRel$ is the
language, or \NIZKLang, for \NIZKRel. $\NIZKx \notin \NIZKLang$ means that
there is no $\NIZKw$ such that $(\NIZKx,\NIZKw) \in \NIZKRel$.

We use non-interactive zero-knowledge proofs of knowledge (NIZKPoK, or, for
short, NIZK) over NP relations, in the Common Reference String (CRS) model
\needcite. A NIZK system is a tuple $(\NIZKSetup,\NIZKProve,\NIZKVerify)$,
defined as follows \cite{gos06}:

\begin{description}
\item[$\NIZKcrs \gets \NIZKSetup(\NIZKsecpar)$.] Generates a CRS \NIZKcrs from
  security parameters \NIZKsecpar.
\item[$\NIZKproof \gets \NIZKProve(\NIZKcrs,\NIZKx,\NIZKw)$.] Given \NIZKcrs,
  statement \NIZKx, and witness \NIZKw, creates a proof \NIZKproof.
\item[$1/0 \gets \NIZKVerify(\NIZKcrs,\NIZKproof,\NIZKx)$.] Checks whether
  \NIZKproof is a valid proof for \NIZKx.
\end{description}

Any zero-knowledge proof of knowledge must meet completeness, soundness and
zero-knowledge,properties. We further need an extra property, called
\emph{simulation-extractability} \cite{cl06}, which amplifies the security
requirements of simulation soundness.
%
To define more formally the properties we need, we have to define three extra
algorithms:

\begin{description}
\item[$(\NIZKcrs,\NIZKtrap) \gets \NIZKSimSetup(\NIZKsecpar)$.] Produces a
  \NIZKcrs as the \NIZKSetup algorithm, along with a trapdoor \NIZKtrap.
\item[$\NIZKproof \gets \NIZKSim(\NIZKcrs,\NIZKtrap,\NIZKx)$.] Given a trapdoor
  \NIZKtrap produced by \NIZKSimSetup, and a statement $\NIZKx \in \NIZKLang$,
  produces a simulated proof \NIZKproof of $\NIZKx \in \NIZKLang$.
\item[$\NIZKw \gets \NIZKExtract(\NIZKcrs,\NIZKtrap,\NIZKx,\NIZKproof)$.] Given
  a trapdoor \NIZKtrap produced by \NIZKSimSetup, and a proof \NIZKproof for
  $\NIZKx \in \NIZKLang$, returns a valid \NIZKw for \NIZKx.
\end{description}

When we want to make explicit the NP relation \NIZKRel to which the previous
algorithms refer to, we use $\NIZKSetup^\NIZKRel,\NIZKProve^\NIZKRel$, 
$\NIZKVerify^\NIZKRel$, etc., and omit the \NIZK prefix and subindex when clear
from context. Altogether, the tuple $(\Setup,\Prove,\Verify,\SimSetup,\Sim,
\Extract)$ needs to meet the following properties:

\paragraph{Completeness.} %
Ensures that, for any $(\NIZKx,\NIZKw) \in \NIZKRel$, any honest prover will be
able to create a proof \NIZKproof that is accepted by any honest verifier, with
overwhelming probability. More precisely, $\Pr\lbrack\ExpNIZKComp\rbrack = 1$
with overwhelming probability, for any p.p.t. \adv, for \ExpNIZKComp in
\figref{fig:nizk-games}.

\paragraph{Soundness.} %
Ensures that no adversary can create proofs accepted by \Verify, for
statements $\NIZKx \notin \NIZKLang$, except with negligible probability. That
is, for \ExpNIZKSound as in \figref{fig:nizk-games}, $\Pr\lbrack\ExpNIZKSound\rbrack
= 1$ with overwhelming probability. If this holds only against p.p.t.
adversaries, we talk of Non-Interactive \emph{arguments}, while if soundness
holds even against unbounded adversaries, we talks about Non-Interactive proofs.

\paragraph{Zero-knowledge.} %
Intuitively, captures that no information can be learned from a statement and
proof pair, beyond their validity (or not). This is captured by requiring the
adversary to distinguish between a run in the real world ($b=0$), where the
setup is done with \Setup, and $\adv$ has access to an honest prover
\Prove; and a run in an ideal world ($b=1$), where the setup is replaced by
\SimSetup, and proofs are simulated with the help of the trapdoor produced by
\SimSetup, except when $\adv$ specifies $(\NIZKx,\NIZKw) \notin \NIZKRel$. Note
that, in the context of simulation-extractable NIZK, this property not only
requires that the simulated proofs are indistinguishable to the real ones; it
also requires that \SimSetup is indistinguishable from \Setup. All this is
formalised by requiring that $|\Pr[\ExpNIZKZKb(\secpar) = 1 | b = 1] -
\Pr[\ExpNIZKZKb(\secpar) = 1 | b = 0]$ be a negligible function of \secpar,
where \ExpNIZKZKb is as defined in \figref{fig:nizk-games}.

\paragraph{Simulation-Extractability.} As stated, simulation-extractability
is an extension to simulation soundness. In a nutshell,
simulation-extractability requires that, even after having received a polynomial
number of simulated proofs of knowledge, no adversary can output a valid proof
of knowledge from which no witness can be extracted. It implies simulation
soundness, which ``just'' requires that no adversary can produce a valid proof
after having seen polynomially many simulated proofs (but does not guarantee
extraction). Formally, for simulation-extractability we require that
$\Pr[\ExpNIZKSimExt] = 1$ is a negligible function of \secpar, where
\ExpNIZKSimExt is defined in \figref{fig:nizk-games}.

\begin{figure}[ht!]
  \begin{minipage}[t]{0.5\textwidth}
    \procedure{$\ExpNIZKComp(\secpar)$}{%
      \NIZKcrs \gets \Setup(\secpar) \\
      (\NIZKx,\NIZKw) \gets \adv(\NIZKcrs) \\
      \pcif (\NIZKx,\NIZKw) \notin \NIZKRel: \pcreturn 0 \\
      \NIZKproof \gets \Prove(\NIZKcrs,\NIZKx,\NIZKw) \\
      b \gets \Verify(\NIZKcrs,\NIZKproof,\NIZKx) \\
      \pcreturn b \\
    }
    \procedure{$\ExpNIZKSimExt(\secpar)$}{%
      (\NIZKcrs,\NIZKtrap) \gets \SimSetup(\secpar) \\
      (\NIZKx,\NIZKproof) \gets \adv^{\Sim'(\NIZKcrs,\NIZKtrap,\cdot,\cdot)}
      (\NIZKcrs) \\
      \pcind \textrm{Where}~\Sim'(\NIZKcrs,\NIZKtrap,\NIZKx,\NIZKw)~\textrm{returns} \\
      \pcind \pcind
      \Sim(\NIZKcrs,\NIZKtrap,\NIZKx)~\pcif (\NIZKx,\NIZKw) \in \NIZKRel \\
      \pcind \pcind \bot~\pcif (\NIZKx,\NIZKw) \notin \NIZKRel \\
      \NIZKw' \gets \Extract(\NIZKcrs,\NIZKtrap,\NIZKx,\NIZKproof) \\
      \pcif \Verify(\NIZKcrs,\NIZKproof,\NIZKx) = 1 \land
      (\NIZKx,\NIZKw') \notin \NIZKRel~\land \\
      \pcind \NIZKx~\textrm{was not queried to $\Sim$ via $\Sim'$}: \\
      \pcind \pcreturn 1 \\
      \pcreturn 0
    }    
  \end{minipage}
  \begin{minipage}[t]{0.5\textwidth}
    \procedure{$\ExpNIZKSound(\secpar)$}{%
      \NIZKcrs \gets \Setup(\secpar) \\
      (\NIZKproof,\NIZKx) \gets \adv(\NIZKcrs) \\
      \pcif \NIZKx \notin \NIZKLang \land
      \Verify(\NIZKcrs,\NIZKproof,\NIZKx): \\
      \pcind \pcreturn 0 \\
      \pcreturn 1 \\
    }
    
    \procedure{$\ExpNIZKZKb(\secpar)$}{%
      \pcif b = 0: \\
      \pcind \NIZKcrs \gets \Setup(\secpar) \\
      \pcind \pcreturn \adv^{\Prove(\NIZKcrs,\cdot,\cdot)}(\NIZKcrs) \\
      \pcif b = 1: \\
      \pcind (\NIZKcrs,\NIZKtrap) \gets \SimSetup(\secpar) \\
      \pcind \pcreturn \adv^{\Sim'(\NIZKcrs,\NIZKtrap,\cdot,\cdot)}(\NIZKcrs),~
      \textrm{where} \\
      \pcind \Sim'(\NIZKcrs,\NIZKtrap,\NIZKx,\NIZKw)~\textrm{returns} \\
      \pcind \pcind \Sim(\NIZKcrs,\NIZKtrap,\NIZKx)~\pcif (\NIZKx,\NIZKw)
      \in \NIZKRel \\
      \pcind \pcind \bot~\pcif (\NIZKx,\NIZKw) \notin \NIZKRel
    }    
  \end{minipage}
  \label{fig:nizk-games}
  \caption{Games for Simulation-Extractable NIZK schemes.}
\end{figure}

As studied in \cite{cl06}, simulation-extractable NIZKPoKs formalize the concept
of ``signatures of knowledge'' (see, e.g., \cite{cs97}). Which basically means
that, given an $(\NIZKx,\NIZKw)$ pair from an NP relation, we can treat \NIZKx
as a public key, and \NIZKw as its corresponding private key, and leverage them
to build digital signature schemes -- with the advantage of being able to do so
while proving arbitrary claims, as long as they can be represented as an NP
relation. We note that, given a simulation-extractable NIZK system, it is
straightforward to build a signature of knowledge by adding the message to be
signed in the statement of the NIZK.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "uas"
%%% End:
