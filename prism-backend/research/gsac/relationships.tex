\section{Relationships with Other Schemes}
\label{sec:relationships}

% [11 pages max]

In the following, to showcase the generality of \UAS and \CUASGen, we reproduce
models of related schemes in the literature.
Then, we give concrete $(\fissue,\feval,\finsp)$-\CUASGen restrictions and prove
that they securely instantiate the models for the presented schemes, if the
corresponding \CUASGen restriction is a secure \UAS construction. Concretely,
we rely on the functions described in \figref{fig:func-restrictions}. Observe
that all the \fissue functions listed in \figref{fig:func-restrictions} are
\UAS-acceptable. Specifically, $\fissue^1$ and $\fissue^{\sring}$ are trivially
\UAS-acceptable (for $\rngfissue = \bin$); whereas $\fissue^{single,F,I}$ is
\UAS-acceptable if $F$ is a secure PRF \needcite.

\begin{figure}[ht!]

  \scalebox{0.9}{
    \begin{minipage}[t]{\textwidth}
      \textbf{Issuance functions:}
      \begin{align}
        & \fissue^1(\cdot,\cdot,\cdot) \coloneqq 1 \nonumber \\
        & \fissue^{single,F,I}(\upk,\cdot,\cdot) \coloneqq \pcreturn
          F(I,\upk)
          \nonumber \\
        & \fissue^{\sring}(\upk,\cdot,\attrs) \coloneqq
          \pcreturn (\attrs = \sring \land \upk \in \attrs) \nonumber
      \end{align}
      
      \textbf{Signature evaluation functions:}
      \begin{align}
        & \feval^0(\cdot,\cdot,\cdot) \coloneqq \pcreturn (0,\ast) \nonumber \\
        & \feval^{\dattrs}(\cdot,(\cdot,\attrs),\cdot)
          \coloneqq \pcreturn (\lbrace \attrs_i \rbrace_{i\in \dattrs},\ast)
          \nonumber \\
        & \feval^{\sring,\dattrs}(\upk,(\cdot,\attrs),\cdot)
          \coloneqq \pcif \upk \in \lbrace \attrs_i \rbrace_{i\in\dattrs}
          \subseteq \sring:
          \pcreturn (\lbrace \attrs_i \rbrace_{i\in\dattrs},\ast);
          \pcelse \pcreturn (0,\ast) \nonumber \\
        & \feval^{\dattrs,F,V,L}(\upk,((\cidi,\cidu),\attrs),\cdot) \coloneqq
          \nonumber \\
        & \hspace*{2em}\pcif F(V,\cidi) \in L \lor F(V,\cidu) \in L:
          \pcreturn (0,\ast) \nonumber \\
        & \hspace*{2em}\pcelse \pcreturn (\lbrace \attrs_i \rbrace_{i\in \dattrs},V)
          \nonumber \\
        & \feval^{g,MPS}(\upk,\lbrace (\cid_i,\attrs_i) \rbrace_{i\in[n]},\msg)
          \coloneqq \nonumber \\
        & \hspace*{2em}\pcif g(\upk,\lbrace (\cid_i,\attrs_i) \rbrace_{i\in[n]},
          \msg) = 0: \pcreturn \bot \nonumber \\
        & \hspace*{2em}\pcelse \pcreturn (\ast,g(\upk,\lbrace
          (\cid_i,\attrs_i) \rbrace_{i\in[n]},\msg)) \nonumber
      \end{align}
    \end{minipage}
  }
  \vspace*{1em}
  
  \scalebox{0.9}{
    \begin{minipage}[t]{\textwidth}
      \textbf{Open functions:}
      \begin{align}
        & \finsp^0(\cdot,\cdot,\cdot,\cdot) \coloneqq 0 \nonumber \\
        & \finsp^{\upk}(\cdot,\upk,\cdot,\cdot) \coloneqq
          \pcreturn \upk % \CCommit(\usk;0)
          \nonumber \\
        & \finsp^{F}((\yeval^0,\yeval^1),\cdot,((\cidi,\cidu),\attrs),\cdot)
          \coloneqq \nonumber \\
        & \hspace*{2em}\pcif \yeval^0 \neq 0:
          \pcreturn (F(\yeval^1,\cidi),F(\yeval^1,\cidu)) \nonumber \\
        & \hspace*{2em}\pcelse \pcreturn 0
          \nonumber \\
        & \finsp^{h,MPS}((\cdot,\yeval^1),\upk,\cid,\attrs,\cdot) \coloneqq
          \pcreturn h(\yeval^1,\upk,\cid,\attrs) \nonumber         
      \end{align}
    \end{minipage}
    \hspace*{5em}
    % \begin{minipage}[t]{0.47\textwidth}
    %   \begin{framed}
    %     $\attrs(\cred)$ returns all attributes in \cred \\
    %     $\dattrs(\cred)$ returns $\dattrs \subseteq \attrs(\cred)$ \\
    %     $\attrs_i(\cred)$ returns $i$-th attribute in \cred \\
    %     $\ast$ means the output is ignored \\
    %     $\bot$ means the function fails
    %   \end{framed}
    % \end{minipage}
  }
  \caption{Functions for the \CUASGen restrictions described next.
    For readability, we use ``$\cdot$'' to denote input arguments that are
    ignored; and ``$\ast$'' to denote output values that can be set to anything
    (but should be ignored). $\bot$ means that the function fails.}
  \label{fig:func-restrictions}
\end{figure}

\subsection{Group Signatures}
\label{ssec:related-models-gs}

We adopt the model in \cite{bsz05}. In this abstraction of group signatures, the
opener returns an index uniquely identifying the group member that created a
signature, along with a correctness proof. For ease of exposition, assume that,
w.l.o.g., this index is just the public key that the group member generates
randomly when joining the group\footnote{The user public key is assumed to be
  accessible from a public table in \cite{bsz05}, so it is easy to translate the
  public key into an index, if needed.}. A group signature scheme, according to
\cite{bsz05}, is composed of $KeyGen$, \UKeyGen, \Sign, \Verify, \Open and
\Judge algorithms, as well as an $\langle\Obtain,\Issue\rangle$ interactive
protocol. Their intuition is similar to that of \UAS, so we refer to
\cite{bsz05} for detailed descriptions. For ease of reference, we replicate the
security games in \figref{fig:model-gs}.

\begin{figure}[ht!]
  \centering
  \scalebox{0.9}{      
    \begin{minipage}[t]{0.45\textwidth}        
      \procedure[linenumbering]{$\Exp^{anon-b}_{\adv,gs}(1^\secpar)$}{%
        (\gpk,\isk,\osk) \gets KeyGen(1^\secpar) \\
        d \gets \adv^{\mathcal{O}^{anon}}(\gpk,\isk) \\
        \pcreturn d 
      }
      
      \vspace*{5em}
      
      \procedure[linenumbering]{$\Exp^{frame}_{\adv,gs}(1^\secpar)$}{%
        (\gpk,\isk,\osk) \gets KeyGen(1^\secpar) \\
        (\msg,\sig,\upk,\tau) \gets \adv^{\mathcal{O}^{frame}}
        (\gpk,\osk,\isk) \\
        \pcif \Verify(\gpk,\msg,\sig) = 0: \pcreturn 0 \\
        \pcreturn (\upk \in \HU \land \PRVUK[\upk] \neq \bot \land
        \Judge(\gpk,\upk,\msg,\sig,\tau) = 1)~\land \\
        \pcind \adv~\textrm{did not query}~USK(\upk)~\textrm{or}~
        GSig(\PRVUK[\upk],\msg)
      }       
    \end{minipage}
  }
  \scalebox{0.9}{      
    \begin{minipage}[t]{.55\textwidth}
      \procedure[linenumbering]{$\Exp^{trace}_{\adv,gs}(1^\secpar)$}{%
        (\gpk,\isk,\osk) \gets KeyGen(1^\secpar) \\
        (\msg,\sig) \gets \adv^{\mathcal{O}^{trace}}(\gpk,\osk) \\
        \pcif \Verify(\gpk,\msg,\sig) = 0: \pcreturn 0 \\
        (\upk, \tau) \gets \Open(\gpk,\osk,\trans,\msg,\sig) \\
        \pcif \upk \notin \HU \cup \CU \lor \Judge(\gpk,\upk,\msg,\sig,\tau)
        = 0: \\ 
        \pcind \pcreturn 1 \\
        \pcreturn 0
      }       
    \end{minipage}      
  }
  \caption{Security games for group signatures \cite{bsz05}, only with minor    
    ``harmless'' edits to compare easier with \CUASGS. Concretely, since we
    output {\upk}s instead of indexes, $i=0$ in the traceability game now reads
    $\upk \notin \HU \cup \CU$. For the oracles' definitions, check the
    referenced paper.
    $\mathcal{O}^{anon} \gets \lbrace Ch,Open,SndToU,WReg,USK,CrptU \rbrace$,
    $\mathcal{O}^{trace} \gets \lbrace SndToI,AddU,RReg,GSig,USK,CrptU \rbrace$,
    and $\mathcal{O}^{frame} \gets \lbrace SndToU,WReg,GSig,USK,CrptU \rbrace$.
  }
  \label{fig:model-gs}  
\end{figure}

\subsubsection{\CUASGS construction.} %
We show that the $(\fissue^{single,F,I},\feval^0,\finsp^{\upk})$-\CUASGen
restriction, is a secure group signature scheme according to \cite{bsz05}.
As stated, the $\fissue^{single,F,I}$ is an \UAS-acceptable function if $F$ is a
PRF. In that case, its output is a random-looking string that depends on the
user public key \upk, and a string $I$ uniquely identifying the user. Thus, it
will be the same per $(\upk,I)$ pair, and can be used by issuer $I$ to prevent
issuing more than one credential per user. Basically, the issuer maintains a
list of received $\yissue = F(\upk,I)$ values, and rejects issuing a credential
for already existing \yissue values. From this, the GS algorithms are as
follows:

\begin{description}
\item[$(\gpk,\isk,\osk) \gets KeyGen(1^\secpar)$.] Runs \Setup from \CUASGen,
  and one instance of \KeyGen and \ISet with $\fissue^{single,F,I}$ (both for
  the same user, who will be the only issuer in the GS scheme) and \OKeyGen.
  Assigns the public keys to \gpk.
\item[$(\upk,\usk) \gets \UKeyGen(1^\secpar)$.] Runs \KeyGen from \CUASGen.
\item[$\langle \cred,\utrans \rangle \gets
  \langle\Obtain(\usk,\ipk),\Issue(\isk,\upk)\rangle$.] Runs $\langle\Obtain,
  \Issue\rangle$ as in \CUASGen, with $\attrs \gets \emptyset$. Upon receiving
  the \yissue value, the issuer checks if it already exists in a list $L$
  (initially set to $\emptyset$); if it exists, aborts issuance. Otherwise, it
  completes the protocol and adds $\yissue$ to $L$. It is responsibility of the
  issuer to maintain $L$.
\item[$\sig \gets \Sign(\gpk,\cred,\msg)$.] Parses \gpk as $(\ipk,\opk)$, and
  runs $(\sig,0) \gets \Sign(\usk,\opk,\cred,\msg,\feval^0)$ from \CUASGen,
  where $\yeval = 0$ is the constant output of $\feval^0$.
\item[$1/0 \gets \Verify(\gpk,\sig,\msg)$.] Parses \gpk as $(\ipk,\opk)$, and
  returns whatever $\Verify(\opk,\ipk,\sig,0,\msg,\feval^0)$ from \CUASGen
  outputs.
\item[$(\upk,\pi) \gets \Open(\gpk,\osk,\trans,\sig,\msg)$.] Parses \gpk as
  $(\ipk,\opk)$, and returns whatever \CUASGen outputs in $\Open(\osk,\ipk,\sig,
  0,\msg,\feval^0)$. Internally, the call to \Open runs $\finsp^{\upk}$.
\item[$1/0 \gets \Judge(\gpk,\pi,\upk,\sig,\msg)$.] Parses \gpk as $(\ipk,
  \opk)$, and returns whatever \CUASGen outputs in $\Judge(\opk,\upk,\pi,\sig,
  0,\msg)$.
\end{description}

\paragraph{Security of \CUASGS.} %
We state next the theorems for the security of \CUASGS. The proofs are available
in \appref{app:related-proofs}.

\begin{theorem}[Anonymity of \CUASGS]
  If the base \CUASGen construction has signature anonymity according to
  \defref{def:sign-anonymity-uas}, then \CUASGS is an anonymous group signature
  scheme.
\end{theorem}

\begin{theorem}[Traceability of \CUASGS]
  If the base \CUASGen construction is unforgeable according to
  \defref{def:forge-uas}, then \CUASGS is a traceable group signature scheme.
\end{theorem}

\begin{theorem}[Non-frameability of \CUASGS]
  If the base \CUASGen construction is non-frameable according to
  \defref{def:frame-uas}, then \CUASGS is a non-frameable group signature
  scheme.
\end{theorem}

\subsection{Ring Signatures}
\label{ssec:related-models-rs}

We adopt the model in \cite{bkm06}, where security of ring signatures is
defined according to the games in \figref{fig:model-rs}. A ring signature
scheme consists of three algorithms $(KeyGen,Sign,Verify)$. Roughly,
$((\pk_1,\sk_1),\dots,(\pk_n,\sk_n)) \gets KeyGen(1^\secpar)$ produces $n$
signing key pairs, $\sig \gets Sign(\sk_i,R,\msg)$ creates a signature for
anonymity set $R \subseteq \lbrace \pk_1, \dots, \pk_t \rbrace$, using secret
key $\sk_i$, associated to some $\pk_i \in R$; and $1/0 \gets Verify(R,\sig,
\msg)$ checks if \sig is a valid signature over \msg for ring $R$. We refer
to \cite{bkm06} for details on the syntax and definitions.

\begin{figure}[ht!]
  \centering
  \scalebox{0.9}{      
    \begin{minipage}[t]{0.55\textwidth}        
      \procedure[linenumbering]{$\Exp^{anon-b}_{\adv,rs}(1^\secpar)$}{%
        ((\pk_1,\sk_1),\dots,(\pk_n,\sk_n)) \gets KeyGen(1^\secpar) \\
        (i_0,i_1,R,\msg,\st) \gets \adv^{SIGN}(\pk_1,\dots,\pk_n) \\
        \pcif R \not\subseteq \lbrace \pk_i \rbrace_{i\in[n]} \lor
        \lbrace \pk_{i_0},\pk_{i_1} \rbrace \not\subseteq R~\lor \\ %\\
        \pcind i_0 = i_1: \pcreturn \bot \\
        \sig \gets Sign(\sk_{i_b},R,\msg) \\
        b^* \gets \adv(\sig,\st) \\
        \pcreturn b^*
      }        
    \end{minipage}
  }
  \scalebox{0.9}{      
    \begin{minipage}[t]{.5\textwidth}
      \procedure[linenumbering]{$\Exp^{forge}_{\adv,rs}(1^\secpar)$}{%
        ((\pk_1,\sk_1),\dots,(\pk_n,\sk_n)) \gets KeyGen(1^\secpar) \\
        (R,\sig,\msg) \gets \adv^{SIGN,CORR}(\pk_1,\dots,\pk_n) \\
        \pcif Verify(R,\sig,\msg) = 0: \pcreturn 0 \\
        \pcreturn (R \subseteq \lbrace \pk_i \rbrace_{i\in[n]} \setminus
        CU~\land \\
        \pcind \adv~\textrm{never queried}~SIGN(\cdot,R,\msg))
      }       
    \end{minipage}      
  }
  \caption{Security games for ring signatures \cite{bkm06}. The $SIGN$ oracle
    accepts $(i,R,\msg)$ tuples, with $pk_i \in R$, adds the tuple to a list of
    queries, and returns $\sig \gets Sign(\sk_i,R,\msg)$. $CORR$
    accepts an index $i$, and leaks $\sk_i$ to $\adv$. Corrupted users are added
    to $CU$.}
  \label{fig:model-rs}  
\end{figure}


\subsubsection{\CUASRing Construction.} %
Building a ring signature scheme according to the model in \figref{fig:model-rs}
is essentially a $(\fissue^{\sring},\feval^{\sring,\dattrs},\finsp^0)$-restriction
of our $\CUASGen^{hide-iss}$ construction. In a nutshell, we let users self-issue
credentials where the attributes are (a subset of encodings of) the public keys
of the users in the system -- including their own public key. Then, a ring
signature is just a $\CUASGen^{hide-iss}$ signature that reveals a subset of
the attributes -- i.e., a subset of the keys of the users in the system. In more
detail, the construction is as follows:

% \begin{align}
%   & \NIZKRel_{\Sign}^{prv} \coloneqq \lbrace (\usk,\cred,\yeval^1,\yinsp,r,r',
%     \ipk),(\msg,\feval,\yeval^0,\ceval,\cinsp,\Eek,\widetilde{\Eek},\sring): \nonumber \\
%   & \hspace*{6.405em}\ceval = \EEnc(\widetilde{\Eek},\yeval^1;r) \land
%     \cinsp = \EEnc(\Eek,\yinsp;r') \land \nonumber \\
%   & \hspace*{6.40em}(\yeval^0,\yeval^1) = \feval(\usk,\cred,\msg) \land
%     \yinsp = \finsp((\yeval^0,\yeval^1),\usk,\cred,\msg) \nonumber \\
%   & \hspace*{6.40em}\exists \ipk \in \sring~\suchthat~\SBCMVerify(\ipk,\cred,\usk,
%     \sring) = 1) \rbrace \label{eq:sign-prv}
% \end{align}

% From it, we show that the $(\fissue^{\sring},\feval^{\attrs},\finsp^0)$-
% $\CUASGen^{\Sign-prv}$ restriction, is a secure ring signature scheme. We
% restrict to one credential per signature.

\begin{description}
%\item[$\parm \gets \Setup(\secpar,\AttrSpace)$.] As in $\CUASGen^{hide-iss}$.
\item[$((\pk_1,\sk_1),...,(\pk_n,\sk_n)) \gets KeyGen(\secpar)$.] Runs
  $\parm \gets \Setup(\secpar)$ from $\CUASGen^{hide-iss}$. Then, for each of
  the $i \in [n]$ users to generate, run $(\upk_i,\usk_i) \gets \KeyGen(\parm)$,
  and $\ipk_i \gets \ISet((\upk_i,\usk_i),\fissue^{\sring})$, where $\sring =
  \lbrace \upk_i \rbrace_{i\in[n]}$. Run also $(\opk,\osk) \gets \OKeyGen(\parm,
  \finsp^0)$. Set $\pk_i \gets (\ipk_i,\opk)$ and $\sk_i \gets \usk_i$, for
  $i\in[n]$.
\item[$\Sig \gets \Sign(\sk_i,R,\msg).$]
  The signing user, with $\sk_i=\usk$ and $\pk_i=(\ipk_i,\opk)$ for some $i \in
  [n]$, where $\pk_i \in R$, first acts both as user and issuer to self-issue a
  credential \Cred over an attribute set \attrs such that $\attrs \subseteq
  \sring$. The user picks some \dattrs such that $\dattrs \subseteq [|\attrs|]$,
  and computes the ring signature by running $\Sig = (\sig,\yeval) \gets
  \Sign(\usk,\opk,\Cred,\msg,\feval^{\sring,\dattrs})$ from
  $\CUASGen^{hide-iss}$. Note that \dattrs defines the public keys within
  $\attrs \subseteq \sring$ to be revealed through \yeval.
\item[$1/0 \gets Verify(R,\Sig,\msg)$.] Parses \Sig as $(\sig,\yeval)$ and
  runs $\Verify(\opk,\yeval,\Sig,\msg,\feval^{\sring,\dattrs})$ as in
  $\CUASGen^{hide-iss}$. Note that, in valid signatures, $\yeval = \lbrace
  \ipk_i\rbrace_{i\in\dattrs}$.
\end{description}

%Note that by using, e.g., $\finsp^{\upk}$, we essentially get a ring signature
%scheme with linkability via an opener.

\paragraph{Security of \CUASRing.} %
We state next the theorems for the security of \CUASRing. The proofs are
available in \appref{app:related-proofs}.

\begin{theorem}[Anonymity of \CUASRing]
  If the base $\CUASGen^{hide-iss}$ construction has signature anonymity
  according to \defref{def:sign-anonymity-uas}, then \CUASRing is an anonymous
  ring signature scheme.
\end{theorem}

\begin{theorem}[Unforgeability of \CUASRing]
  If the base $\CUASGen^{hide-iss}$ construction is non-frameable according to
  \defref{def:frame-uas}, then \CUASRing is an unforgeable ring signature
  scheme.
\end{theorem}

\subsection{Anonymous Credentials}
\label{ssec:related-models-ac}

We adopt the model in \cite{fhs19}, for anonymous credentials with selective
disclosure. Therein, an anonymous credential scheme is defined via $OrgKeyGen$
(which we rename to $IssKeyGen$), and $UserKeyGen$ algorithms, and $Obtain,
Issue$ and $Show,Verify$ interactive protocols. The security definitions rely on
$HU, CU, ObtIss, Obtain, Issue, Show$, and $LoR$ oracles. We refer to
\cite{fhs19} for the full details. For ease of reference, we summarize the
security definitions in \figref{fig:model-ac}.% , with inocuous
% adaptations to make them more suitable for comparison with our definitions --
% namely, we explicitly add a common setup process which is part of $IssKeyGen$
% in \cite{fhs19}.

\begin{figure}[ht!]
  \centering
  \scalebox{0.9}{      
    \begin{minipage}[t]{0.5\textwidth}        
      \procedure[linenumbering]{$\Exp^{anon-b}_{\adv,ac}(1^\secpar)$}{%
 %       \parm \gets \Setup(1^\secpar) \\
        (\ipk,\isk) \gets IssKeyGen(1^\secpar) \\        
        b^* \gets \adv^{HU,CU,Obtain,Show,LoR}(\isk) \\
        \pcreturn b^*
      }        
    \end{minipage}
  }
  \scalebox{0.9}{      
    \begin{minipage}[t]{.5\textwidth}
      \procedure[linenumbering]{$\Exp^{forge}_{\adv,ac}(1^\secpar)$}{%
%        \parm \gets \Setup(1^\secpar) \\
        (\ipk,\isk) \gets IssKeyGen(1^\secpar) \\        
        (D,\st) \gets \adv^{HU,CU,ObtIss,Issue,Show}(\ipk) \\
        \langle \cdot,(b,\utrans) \rangle
        \gets \langle \adv(\st),\Verify(\ipk,D) \rangle \\
        \pcreturn (b = 1 \land \nexists j~\suchthat \\
        \pcind (\OWNR[j] \in \CU
        \land D \subseteq \ATTR[j])) % \forall j, \OWNR[j] \in \CU
        % \implies D \not\subseteq \ATTR[j]: \\
        %\pcind \pcreturn 1 \\
        %\pcreturn 0
      }       
    \end{minipage}      
  }
  \caption{Security games for anonymous credentials with selective disclosure
    \cite{fhs19}. \OWNR and \ATTR tables are essentially as in \UAS. \adv~wins
    the unforgeability game if it authenticates successfully while revealing
    attributes not contained in adversarially controlled credentials. All
    oracles in this model have a direct equivalent in \UAS.
  }
  \label{fig:model-ac}  
\end{figure}

\subsubsection{\CUASAC Construction.} %
We show that a $(\fissue^1,\feval^{\dattrs},\finsp^0)$-$\CUASGen^{int}$
restriction, is a secure anonymous credential scheme according to the model in
\cite{fhs19}. We first quickly define the algorithms, and then prove security.

\begin{description}
% \item[$\parm \gets \Setup(1^\secpar)$.] Runs $\parm' \gets \Setup(1^\secpar,
%   \AttrSpace)$ and $(\opk,\osk) \gets \OKeyGen(\parm',\finsp^0)$ from our
%   \CUASGen construction. Returns $\parm \gets (\parm',\opk)$.
\item[$(\ipk,\isk) \gets IssKeyGen(\parm)$.] From $\CUASGen^{int}$, run $\parm'
  \gets \Setup(1^\secpar)$ and $(\opk,\osk) \gets \OKeyGen(\parm',
  \finsp^0)$, and set $\parm \gets (\parm',\opk)$. Run $(\upk,\usk) \gets
  \KeyGen(\parm')$ and $\ipk \gets \ISet(\upk,\usk,\fissue^1)$. Set $\isk \gets
  \usk$.
\item[$(\upk,\usk) \gets UserKeyGen(\ipk)$.] Runs \KeyGen from $\CUASGen^{int}$.
\item[$\langle \cred/\bot,\top/\bot \rangle \gets
  \langle \Obtain(\usk,\ipk,\attrs),\Issue(\isk,\upk,\attrs) \rangle$.]
  Runs $\langle \Obtain,\Issue \rangle$ from $\CUASGen^{int}$.
\item[$\langle 1/0,((1,\utrans)/(0,\utrans)\rangle
  \gets \langle Show(\ipk,\attrs,\dattrs,
  \cred),\Verify(\ipk,\dattrs) \rangle$.]
  Runs the interactive transform of \Sign and \Verify of $\CUASGen^{int}$, using
  $\feval^{\dattrs}$ as signature evaluation function, and $\finsp^0$ as open
  function, with \opk from \parm as opener public key.
\end{description}

\paragraph{Security of \CUASAC.} %
We state next the theorems for the security of \CUASAC. The proofs are
available in \appref{app:related-proofs}.

\begin{theorem}[Anonymity of \CUASAC]
  \label{thm:anon-cuasac}
  If the base $\CUASGen^{int}$ construction has signature anonymity according to
  \defref{def:sign-anonymity-uas}, then \CUASAC is an anonymous AC scheme
  according to \cite{fhs19}.
\end{theorem}

\begin{theorem}[Unforgeability of \CUASAC]
  \label{thm:forge-cuasac}
  If the base $\CUASGen^{int}$ construction is unforgeabile according to
  \defref{def:forge-uas}, then \CUASAC is an unforgeable AC scheme.
\end{theorem}

\subsection{Revocable Anonymous Credentials}
\label{ssec:related-models-rac}

In \cite{cks10}, revocable anonymous credentials are proposed. From \CUASGen, it
is straightforward to build an AC system with verifier local revocation, like in
\cite{bs04}. Basically, we leverage the $\cid=(\cidi,\cidu)$ identifiers,
encoded as attributes, to define a $(\feval,\finsp)$ function pair that: (1)
ensures that opening outputs the evaluation of a PRF of the {\cid}s concatenated
with the verifier name; and (2) ensures that, if some {\cid} of the credentials
used to produce a signature have been added to a revocation list by the
verifier, the verifier will know it -- and hence will be able to reject the
signature. We first give a simple model in
\figref{fig:model-rac}, extending that in \secref{ssec:related-models-ac}.
Concretely, to the functionality in \secref{ssec:related-models-ac}, we now
explicitly add
the $OKeyGen$ function (equivalent to \OKeyGen, with a fixed \finsp function),
which generates the opener key pair, extend $Verify$ to receive also a list $L$
of revoked credential identifiers, and we add a function (and corresponding
oracle) $cid/\bot \gets RetrieveCredId(\osk,\utrans)$ that can extract an
identifier of the credential used in a presentation transcript \utrans -- and
which is essentially equivalent to \Open in \UAS. For simplicity, we do not
include the equivalent to verifiable openings, but this would be
straightforward.

\begin{figure}[ht!]
  \centering
  \scalebox{0.9}{      
    \begin{minipage}[t]{0.45\textwidth}
      \procedure[linenumbering]{$\Exp^{anon-b}_{\adv,rac}(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        (\opk,\osk) \gets \OKeyGen(\parm) \\        
        (\ipk,\isk) \gets IssKeyGen(\parm) \\        
        b^* \gets \adv^{\mathcal{O}_{anon}}(\parm,\ipk,\opk) \\
        \pcreturn b^*
      }        
    \end{minipage}
  }
  \scalebox{0.9}{      
    \begin{minipage}[t]{.55\textwidth}
      \procedure[linenumbering]{$\Exp^{forge}_{\adv,rac}(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        (\opk,\osk) \gets \OKeyGen(\parm) \\        
        (\ipk,\isk) \gets IssKeyGen(\parm) \\
        (D,L,\st) \gets
        \adv^{\mathcal{O}_{forge}}(\parm,\ipk) \\
        \langle \cdot,(b,\utrans)\rangle
        \gets \langle \adv(\st),\Verify(\ipk,D,L)\rangle \\
        \pcif b = 0: \pcreturn 0 \\
        \pcif \nexists j~\suchthat~(\OWNR[j] \in \CU
        \land D \subseteq \ATTR[j]): \pcreturn 1 \\    
        h \gets RetrieveCredHandle(\osk,\utrans) \\
        \pcif h \in L \lor h = \bot: \pcreturn 1 \\
        \pcreturn 0
      }       
    \end{minipage}      
  }
  \caption{Security games for revocable anonymous credentials with selective
    disclosure based on \cite{fhs19}. 
    $\mathcal{O}_{anon} \gets \lbrace HU,CU,Obtain,Issue,ObtIss,Show,
    ReqCredHandle,LoR\rbrace$. $\mathcal{O}_{forge} \gets \lbrace HU,CU,
    Obtain,ObtIss,Issue,Show,ReqCredHandle \rbrace$. $ReqCredHandle$ is
    equivalent to \OPEN, operating on transcripts \utrans instead of signatures.
    In particular, this implies that it rejects queries for transcripts related
    to challenge users. Also, \OWNR and \ATTR tables are essentially as in
    \secref{ssec:model-uas}.}
  \label{fig:model-rac}  
\end{figure}

\subsubsection{\CUASRAC Construction.} %
Briefly, we build a revocable anonymous credential as a $(\fissue^1,
\feval^{\dattrs,F,V,L},\finsp^{F})$-\CUASGen restriction. \feval is
parameterized with a PRF $F$, a string identifying the verifier $V$ and a
list $L$ of ``revocation handles'' by $V$. Note that these can be hardcoded,
though: $F$ can be common to all verifiers, $V$ is also fixed (per verifier),
and $L$ can be updated with some reasonable frequency -- e.g., daily -- so that
the cost of recomputing $\feval^{\dattrs,F,V,L}$ is not high.
%
Since credentials in \CUASGen have two identifiers (\cidi, chosen by the issuer;
and \cidu, chosen by the user), $\feval^{\dattrs,F,V,L}$ internally computes
$F(V,\cidi)$ and $F(V,\cidu)$. If either appears in $L$, \feval sets $\yeval^0$
to $0$, which the verifier interprets as ``revoked credential''. Otherwise,
it sets $\yeval^0 \gets \lbrace \attrs_i \rbrace_{i\in\dattrs}$ and
$\yeval^1 \gets V$. $\yeval^1$ is
then used by $\finsp^F$ to compute $\yinsp \gets (F(\yeval^1,\cidi),
F(\yeval^1,\cidu))$. Thus, if the verifier $V$ wants to revoke a credential, all
it has to do is ask the opener to decrypt $\yinsp$, via $RetrieveCredHandle$.
%
In more detail, the algorithms are as follows:

\begin{description}
\item[$\parm \gets \Setup(1^\secpar)$.] Runs $\Setup(1^\secpar)$ as in
  \CUASGen.
\item[$(\ipk,\isk) \gets IssKeyGen(\parm)$.] Runs \KeyGen+\ISet from our
  \CUASGen construction, setting $\fissue^1$ as issuance function.
\item[$(\ipk,\isk) \gets OKeyGen(\parm)$.] Runs \OKeyGen from our
  \CUASGen construction, setting $\finsp^F$ as opening function.
\item[$(\upk,\usk) \gets UserKeyGen(\ipk)$.] Runs \KeyGen from the
  \CUASGen construction.
\item[$\langle \cred/\bot,\top/\bot \rangle \gets
  \langle \Obtain(\usk,\ipk,\attrs),\Issue(\isk,\upk,\attrs) \rangle$.]
  Runs the $\langle \Obtain,\Issue \rangle$ protocol from \CUASGen, using
  $\fissue^1$ as issuance function.
\item[$\langle 1/0,(1,\utrans)/(0,\utrans)\rangle \gets \langle Show(\ipk,
  \attrs,\dattrs,\cred),
  \Verify(\ipk,\dattrs) \rangle$.]
  Runs the interactive extension of \Sign and \Verify of the \CUASGen protocol,
  using $\feval^{\dattrs,F,V,L}$ as signature evaluation function, and
  $\finsp^F$ as open function. If $\yeval^0 = 0$, the signature is rejected.
\item[$h/\bot \gets RetrieveCredHandle(\osk,\utrans)$.]
  Gets $(\sig,\yeval^0)$ from the $\langle Show,\Verify\rangle$ transcript
  \utrans, and runs \Open from \CUASGen. If $\yeval^0 \neq 0$ (i.e., the
  signature was created by a non-revoked credential), this returns $(F(V,\cidi),
  F(V,\cidu))$, which the verifier can add to its revocation list $L$.
\end{description}

\paragraph{Security of \CUASRAC.} %
We state next the theorems for the security of \CUASRAC. The proofs are
available in \appref{app:related-proofs}.

\begin{theorem}[Anonymity of \CUASRAC]
  If the base \CUASGen construction has signature anonymity according to
  \defref{def:sign-anonymity-uas}, and $F$ is one-way, then \CUASRAC is an
  anonymous AC scheme according to \cite{fhs19}.  
\end{theorem}

\begin{theorem}[Unforgeability of \CUASRAC]
  If the base \CUASGen construction is unforgeable according to
  \defref{def:forge-uas}, and $F$ is one-way, then \CUASRAC is an unforgeable
  RAC scheme.
\end{theorem}

Note that, if we aim at global credential (resp. user) revocation rather than
verifier-local revocation, we can have \finsp just output the $(\cidi,\cidu)$
pair (resp., \upk), and no assumption regarding $F$ is needed.

\subsection{Multimodal Private Signatures}
\label{ssec:related-models-mps}

Multimodal Private Signatures (or, rather, a close relative, see next) are
directly implementable as a $(\fissue^{single,F,I},\feval^{\yeval^1},
\finsp^{\ast})$-\CUASGen restriction, where $\feval^{\yeval^1}$ is any signature
evaluation function that ignores the $\yeval^0$ output, and $\finsp^{\ast}$ is
any open function. Concretely, this restricts to a system with one issuer and
one opener, one credential per user, no attributes in the credentials.

There are some differences, though. On the one hand, our signature anonymity
property is somehow in the middle of MPS's privacy-1 and privacy-2 variants.
Their privacy-1 variant is the traditional anonymity property of group
signatures, in which the opener is honest and the adversary can call the opening
oracle except for challenge signatures. In their privacy-2 variant, the opener
is fully corrupt (i.e., \adv~ receives \osk), but the adversary can only be
challenged with signatures that produce the same \yinsp value ($G_{j_b}(id_b)$
in MPS). In our \UAS model, we allow the adversary to corrupt openers at will
(getting ther \osk), but the challenge signatures must have been generated using
the key of an uncorrupted opener; still, \adv~can call the open oracle for
challenge signatures, as long as they have the same \yinsp value. We believe
that these differences are mostly of theoretical interest, though. In practice,
what matters is that any variant of \feval and \finsp functions ($F$ and $G_j$
in MPS) that has too much granularity in their ranges, will lead to a barely
private system. This is a known issue, for instance, in functional encryption
\needcite.

On the other hand, anonymous issuance, and the capability to customize issuance
policies are unachievable by MPS. Anonymous issuance simply does not make sense
in MPS, as it only supports one credential (without attributes) per user.
Customized issuance is achieved in \UAS via the \fissue functions, with no
equivalent in MPS -- instead, MPS has the fixed policy of
``proving knowledge of a user secret key''. These extensions are not trivial
from a theoretical point of view, and also have a big impact in the practicality
of the resulting system. Also, MPS does not include verifiable openings. While
this is easy to add, we consider it to be essential, given that the proposed
generalization of opening allows the opener to output ``any value''. Hence, the
need to ensure that the produced value is the legitimate one, seems to be more
necessary than ever. Finally, our \feval function is a generalization of $F$ in
MPS, as it allows two outputs: one will be returned in the clear along with the
signature, and the other will be encrypted. Still both computations are proved
correct. Making part of the output unencrypted allows implementing very useful
variants such as anonymous credentials, as shown before.

For the model of MPS schemes, we refer to the original paper \cite{ngsy22}.

\subsubsection{\CUASMPS construction.} %
As mentioned, any $(\fissue^{single,F,I},\feval^{\yeval^1},
\finsp^\ast)$-restriction implements an MPS scheme where $F=\feval^{\yeval^1}$
and $G=\finsp^\ast$. With these functions, the construction is direct.
\CUASMPS's setup runs \CUASGen's \Setup, \OKeyGen, and generates the issuer key
pair by running \KeyGen and \ISet (with $\fissue^1$). For MPS's join, \CUASMPS
runs first \KeyGen to generate the user key pair, and then proceeds as in
\CUASGen. \Sign, \Verify and \Open, are as in \CUASGen.
%
Finally, note that, in MPS, $G$ is further parameterized with a value $j$, which
essentially is the result of applying $F$ to the message and signer identity,
and is not leaked to the opener nor any other third party. The equivalent in
\UAS is the $\yeval^1$ value which, in \CUASGen, is encrypted with a single-use
key pair, and is an input of \yinsp.

\paragraph{Security of \CUASMPS.} %
We state next the theorems for the security of \CUASMPS. The proofs are
available in \appref{app:related-proofs}.

\begin{theorem}[Privacy-1 of \CUASMPS]
  If the base \CUASGen construction has signature anonymity according to
  \defref{def:sign-anonymity-uas}, then \CUASMPS satisfies privacy-1
  according to \cite{ngsy22}.
\end{theorem}

\begin{theorem}[Extractability of \CUASMPS]
  If the base \CUASGen construction is unforgeable according to
  \defref{def:forge-uas}, then it is an extractable MPS scheme.
\end{theorem}

\begin{theorem}[Unforgeability-1 of \CUASMPS]
  If the base \CUASGen construction is unforgeable according to
  \defref{def:sign-forge-uas}, then \CUASMPS satisfies unforgeability-1 as
  defined in \cite{ngsy22}.
\end{theorem}

\begin{theorem}[Unforgeability-2 of \CUASMPS]
  If the base \CUASGen construction has non-frameability according to
  \defref{def:frame-uas}, then \CUASMPS satisfies unforgeability-2 as
  defined in \cite{ngsy22}.
\end{theorem}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "uas-paper"
%%% End:
