\section{Relationships with Other Schemes}
\label{sec:relationships}

% [11 pages max]

In the following, to showcase the generality of \UAS and \CUASGen, we reproduce
models of related schemes in the literature -- some of them slightly adapted.
Then, we give concrete $(\fissue,\feval,\finsp)$-\CUASGen restrictions and prove
that they securely instantiate the models for the presented schemes, if the
corresponding \CUASGen restriction is a secure \UAS construction. Concretely,
we rely on the functions described in \figref{fig:func-restrictions}.

\begin{figure}[ht!]

  \scalebox{0.9}{
    \begin{minipage}[t]{\textwidth}
      \textbf{Issuance functions:}
      \begin{align}
        & \fissue^1(\cdot,\cdot,\cdot) \coloneqq 1 \nonumber \\
        & \fissue^{single,F,I,L}(\upk,\cdot,\cdot) \coloneqq
          \pcif F(I||\upk) \in L~\pcreturn 0;~\pcelse \pcreturn F(I||\upk)
          \nonumber \\
        & \fissue^{\sring}(\upk,\attrs,\cdot) \coloneqq
          \pcreturn (\attrs = \sring \land \upk \in \attrs) \nonumber \\
        & \fissue^{l,\dattrs}(\cdot,\attrs,(\cid,\cattrs)) \coloneqq
          \pcreturn (\attrs_1 = l+1 \land \attrs \subseteq
          \cup_{i\in\dattrs} \cattrs_i) \nonumber
      \end{align}
      
      \textbf{Signature evaluation functions:}
      \begin{align}
        & \feval^0(\cdot,\cdot,\cdot) \coloneqq \pcreturn (0,\ast) \nonumber \\
        & \feval^{\dattrs}(\cdot,(\cid,\attrs),\cdot)
          \coloneqq \pcreturn (\lbrace \attrs_i \rbrace_{i\in \dattrs},\ast)
          \nonumber \\
        & \feval^{\sring,\dattrs}(\upk,(\cid,\attrs),\cdot)
          \coloneqq \pcif \upk \in \lbrace \attrs_i \rbrace_{i\in\dattrs}
          \subseteq \sring:
          \pcreturn (\lbrace \attrs_i \rbrace_{i\in\dattrs},\ast);
          \pcelse \pcreturn \bot \nonumber \\
        & \feval^{l,\dattrs}(\cdot,(\cid,\attrs),\cdot) \coloneqq
          \pcreturn((\attrs_1,\lbrace\attrs_i\rbrace_{i\in\dattrs}),\ast)
          \nonumber
      \end{align}
    \end{minipage}
  }
  \vspace*{1em}
  
  \scalebox{0.9}{
    \begin{minipage}[t]{\textwidth}
      \textbf{Open functions:}
      \begin{align}
        & \finsp^0(\cdot,\cdot,\cdot,\cdot) \coloneqq 0 \nonumber \\
        & \finsp^{\upk}(\cdot,\upk,\cdot,\cdot) \coloneqq
          \pcreturn \upk % \CCommit(\usk;0)
          \nonumber
      \end{align}
    \end{minipage}
    \hspace*{5em}
    % \begin{minipage}[t]{0.47\textwidth}
    %   \begin{framed}
    %     $\attrs(\cred)$ returns all attributes in \cred \\
    %     $\dattrs(\cred)$ returns $\dattrs \subseteq \attrs(\cred)$ \\
    %     $\attrs_i(\cred)$ returns $i$-th attribute in \cred \\
    %     $\ast$ means the output is ignored \\
    %     $\bot$ means the function fails
    %   \end{framed}
    % \end{minipage}
  }
  \caption{Functions for the \CUASGen restrictions described next.
    For readability, we use ``$\cdot$'' to denote input arguments that are
    ignored; and ``$\ast$'' to denote output values that can be set to anything
    (but should be ignored). $\bot$ means the function fails.}
    % $\attrs(\cred)$ returns all attributes in \cred. $\dattrs(\cred)$ returns
    % $\dattrs \subseteq \attrs(\cred)$. $\attrs_i(\cred)$ returns $i$-th
    % attribute in \cred. $\ast$ means the output is ignored (in these examples,
    % we use this to mean that $\yeval^1$ is unused. $\bot$ means the function
    % fails.}
  \label{fig:func-restrictions}
\end{figure}

\subsection{Group Signatures}
\label{ssec:related-models-gs}

We adopt the model in \cite{bsz05}. In this abstraction
of group signatures, the opener returns an index uniquely identifying the group
member that created a signature, along with a correctness proof. For ease of
exposition, assume that, w.l.o.g., this index is just the public key that the
group member chooses\markulf{can he choose an existing public key?} when joining the group\footnote{The user public key is
  assumed to be accessible from a public table in \cite{bsz05}, so it is easy
  to translate the public key into an index, if needed.}. A group signature
scheme, according to \cite{bsz05}, is composed of $KeyGen$, \UKeyGen, \Sign,
\Verify, \Open and \Judge algorithms, as well as an $\langle\Obtain,\Issue
\rangle$ interactive protocol. Their intuition is similar to that of
\UAS, so we refer to \cite{bsz05} for detailed descriptions. For ease of
reference, we replicate the security games in \figref{fig:model-gs}.

\begin{figure}[ht!]
  \centering
  \scalebox{0.9}{      
    \begin{minipage}[t]{0.45\textwidth}        
      \procedure[linenumbering]{$\Exp^{anon-b}_{\adv,gs}(1^\secpar)$}{%
        (\gpk,\isk,\osk) \gets KeyGen(1^\secpar) \\
        d \gets \adv^{\mathcal{O}^{anon}}(\gpk,\isk) \\
        \pcreturn d 
      }
      
      \vspace*{5em}
      
      \procedure[linenumbering]{$\Exp^{frame}_{\adv,gs}(1^\secpar)$}{%
        (\gpk,\isk,\osk) \gets KeyGen(1^\secpar) \\
        (\msg,\sig,\upk,\tau) \gets \adv^{\mathcal{O}^{frame}}
        (\gpk,\osk,\isk) \\
        \pcif \Verify(\gpk,\msg,\sig) = 0: \pcreturn 0 \\
        \pcreturn 1~\pcif \upk \in \HU \land \PRVUK[\upk] \neq \bot \land
        \Judge(\gpk,\upk,\msg,\sig,\tau) = 1~\land \\
        \pcind \adv~\textrm{did not query}~USK(\upk)~\textrm{or}~
        GSig(\PRVUK[\upk],\msg) \\
        \pcreturn 0
      }       
    \end{minipage}
  }
  \scalebox{0.9}{      
    \begin{minipage}[t]{.55\textwidth}
      \procedure[linenumbering]{$\Exp^{trace}_{\adv,gs}(1^\secpar)$}{%
        (\gpk,\isk,\osk) \gets KeyGen(1^\secpar) \\
        (\msg,\sig) \gets \adv^{\mathcal{O}^{trace}}(\gpk,\osk) \\
        \pcif \Verify(\gpk,\msg,\sig) = 0: \pcreturn 0 \\
        (\upk, \tau) \gets \Open(\gpk,\osk,\trans,\msg,\sig) \\
        \pcif \upk \notin \HU \cup \CU \lor \Judge(\gpk,\upk,\msg,\sig,\tau)
        = 0: \\ 
        \pcind \pcreturn 1 \\
        \pcreturn 0
      }       
    \end{minipage}      
  }
  \caption{Security games for group signatures \cite{bsz05}, only with minor    
    ``harmless'' edits to compare easier with \CUASGS. Concretely, since we
    output {\upk}s instead of indexes, $i=0$ in the traceability game now reads
    $\upk \notin \HU \cup \CU$. For the oracles' definitions, check the
    referenced paper.
    $\mathcal{O}^{anon} \gets \lbrace Ch,Open,SndToU,WReg,USK,CrptU \rbrace$,
    $\mathcal{O}^{trace} \gets \lbrace SndToI,AddU,RReg,GSig,USK,CrptU \rbrace$,
    and $\mathcal{O}^{frame} \gets \lbrace SndToU,WReg,GSig,USK,CrptU \rbrace$.
  }
  \label{fig:model-gs}  
\end{figure}

\subsubsection{\CUASGS construction.} %
We show that the $(\fissue^{single,L},\feval^0,\finsp^{\upk})$-\CUASGen
restriction, is a secure group signature scheme according to \cite{bsz05}.
Observe that the $\fissue^{single,F,I,L}$ function is further parameterized with
a list $L$ maintained by the issuer and must be fetched by users prior to
joining. It restricts that any user can have at most one credential (associated
to a same user key pair). We first quickly define the algorithms, and then
prove security.

\begin{description}
\item[$(\gpk,\isk,\osk) \gets KeyGen(1^\secpar)$.] Runs the \Setup algorithm
  of \CUASGen, and one instance of \KeyGen and \ISet with
  $\fissue^{single,F,I,L}$ (both for the same user, who will be the only issuer
  in the GS scheme) and \OKeyGen. Assigns the public keys to \gpk.
\item[$(\upk,\usk) \gets \UKeyGen(1^\secpar)$.] Runs \KeyGen from \CUASGen.
\item[$\langle \cred,\utrans \rangle \gets
  \langle\Obtain(\usk,\ipk),\Issue(\isk,\upk)\rangle$.] Runs $\langle\Obtain,
  \Issue\rangle$ as in \CUASGen, with $\attrs \gets \emptyset$.
\item[$\sig \gets \Sign(\gpk,\cred,\msg)$.] Parses \gpk as $(\ipk,\opk)$, and
  runs $(\sig,0) \gets \Sign(\usk,\opk,\cred,\msg,\feval^0)$ from \CUASGen,
  where $\yeval = 0$ is the constant output of $\feval^0$.
\item[$1/0 \gets \Verify(\gpk,\sig,\msg)$.] Parses \gpk as $(\ipk,\opk)$, and
  returns whatever $\Verify(\opk,\ipk,\sig,0,\msg,\feval^0)$ from \CUASGen
  outputs.
\item[$(\upk,\pi) \gets \Open(\gpk,\osk,\trans,\sig,\msg)$.] Parses \gpk as
  $(\ipk,\opk)$, and returns whatever \CUASGen outputs in $\Open(\osk,\ipk,\sig,
  0,\msg,\feval^0)$. Internally, the call to \Open runs $\finsp^{\upk}$.
\item[$1/0 \gets \Judge(\gpk,\pi,\upk,\sig,\msg)$.] Parses \gpk as $(\ipk,
  \opk)$, and returns whatever \CUASGen outputs in $\Judge(\opk,\upk,\pi,\sig,
  0,\msg)$.
\end{description}

\paragraph{Security of \CUASGS.} %
We state next the theorems for the security of \CUASGS. The proofs are available
in \appref{app:related-proofs}.

\begin{theorem}[Anonymity of \CUASGS]
  If the base \CUASGen construction has signature anonymity according to
  \defref{def:sign-anonymity-uas}, then \CUASGS is an anonymous group signature
  scheme.
\end{theorem}

\begin{theorem}[Traceability of \CUASGS]
  If the base \CUASGen construction has unforgeable signing according to
  \defref{def:sign-forge-uas}, then \CUASGS is a traceable group signature
  scheme.\markulf{Hiding of $Com(\usk;0)$?}
\end{theorem}

\begin{theorem}[Non-frameability of \CUASGS]
  If the base \CUASGen construction is non-frameable according to
  \defref{def:frame-uas}, then \CUASGS is a non-frameable group signature
  scheme.
\end{theorem}

\subsection{Ring Signatures}
\label{ssec:related-models-rs}

We adopt the model in \cite{bkm06}, where security of ring signatures is
defined according to the games in \figref{fig:model-rs}. A ring signature
scheme consists of three algorithms $(KeyGen,Sign,Verify)$. Roughly,
$((\pk_1,\sk_1),\dots,(\pk_n,\sk_n)) \gets KeyGen(1^\secpar)$ produces $n$
signing key pairs, $\sig \gets Sign(\sk_i,R,\msg)$ creates a signature for
anonymity set $R \subseteq \lbrace \pk_1, \dots, \pk_t \rbrace$, using secret
key $\sk_i$, associated to some $\pk_i \in R$; and $1/0 \gets Verify(R,\sig,
\msg)$ checks if \sig is a valid signature over \msg for ring $R$. We refer
to \cite{bkm06} for details on the syntax and definitions.

\begin{figure}[ht!]
  \centering
  \scalebox{0.9}{      
    \begin{minipage}[t]{0.55\textwidth}        
      \procedure[linenumbering]{$\Exp^{anon-b}_{\adv,rs}(1^\secpar)$}{%
        ((\pk_1,\sk_1),\dots,(\pk_n,\sk_n)) \gets KeyGen(1^\secpar) \\
        (i_0,i_1,R,\msg,\st) \gets \adv^{SIGN}(\pk_1,\dots,\pk_n) \\
        \pcif R \not\subseteq \lbrace \pk_i \rbrace_{i\in[n]} \lor
        \lbrace \pk_{i_0},\pk_{i_1} \rbrace \not\subseteq R~\lor \\ %\\
        \pcind i_0 = i_1: \pcreturn \bot \\
        \sig \gets Sign(\sk_{i_b},R,\msg) \\
        b^* \gets \adv(\sig,\st) \\
        \pcreturn b^*
      }        
    \end{minipage}
  }
  \scalebox{0.9}{      
    \begin{minipage}[t]{.5\textwidth}
      \procedure[linenumbering]{$\Exp^{forge}_{\adv,rs}(1^\secpar)$}{%
        ((\pk_1,\sk_1),\dots,(\pk_n,\sk_n)) \gets KeyGen(1^\secpar) \\
        (R,\sig,\msg) \gets \adv^{SIGN,CORR}(\pk_1,\dots,\pk_n) \\
        \pcif Verify(R,\sig,\msg) = 0: \pcreturn 0 \\
        \pcreturn (R \subseteq \lbrace \pk_i \rbrace_{i\in[n]} \setminus
        CU~\land \\
        \pcind \adv~\textrm{never queried}~SIGN(\cdot,R,\msg))
      }       
    \end{minipage}      
  }
  \caption{Security games for ring signatures \cite{bkm06}. The $SIGN$ oracle
    accepts $(i,R,\msg)$ tuples, with $pk_i \in R$, adds the tuple to a list of
    queries, and returns $\sig \gets Sign(\sk_i,R,\msg)$. $CORR$
    accepts an index $i$, and leaks $\sk_i$ to $\adv$. Corrupted users are added
    to $CU$.}
  \label{fig:model-rs}  
\end{figure}


\subsubsection{\CUASRing Construction.} %
Building a ring signature scheme according to the model in \figref{fig:model-rs}
is essentially a $(\fissue^{\sring},\feval^{\sring,\dattrs},\finsp^0)$-restriction
of our $\CUASGen^{hide-iss}$ construction. In a nutshell, we let users self-issue
credentials where the attributes are (a subset of encodings of) the public keys
of the users in the system -- including their own public key. Then, a ring
signature is just a $\CUASGen^{hide-iss}$ signature that reveals a subset of
the attributes -- i.e., a subset of the keys of the users in the system. In more
detail, the construction is as follows:

% \begin{align}
%   & \NIZKRel_{\Sign}^{prv} \coloneqq \lbrace (\usk,\cred,\yeval^1,\yinsp,r,r',
%     \ipk),(\msg,\feval,\yeval^0,\ceval,\cinsp,\Eek,\widetilde{\Eek},\sring): \nonumber \\
%   & \hspace*{6.405em}\ceval = \EEnc(\widetilde{\Eek},\yeval^1;r) \land
%     \cinsp = \EEnc(\Eek,\yinsp;r') \land \nonumber \\
%   & \hspace*{6.40em}(\yeval^0,\yeval^1) = \feval(\usk,\cred,\msg) \land
%     \yinsp = \finsp((\yeval^0,\yeval^1),\usk,\cred,\msg) \nonumber \\
%   & \hspace*{6.40em}\exists \ipk \in \sring~\suchthat~\SBCMVerify(\ipk,\cred,\usk,
%     \sring) = 1) \rbrace \label{eq:sign-prv}
% \end{align}

% From it, we show that the $(\fissue^{\sring},\feval^{\attrs},\finsp^0)$-
% $\CUASGen^{\Sign-prv}$ restriction, is a secure ring signature scheme. We
% restrict to one credential per signature.

\begin{description}
%\item[$\parm \gets \Setup(\secpar,\AttrSpace)$.] As in $\CUASGen^{hide-iss}$.
\item[$((\pk_1,\sk_1),...,(\pk_n,\sk_n)) \gets KeyGen(\secpar)$.] Runs
  $\parm \gets \Setup(\secpar)$ from $\CUASGen^{hide-iss}$. Then, for each of
  the $i \in [n]$ users to generate, run $(\upk_i,\usk_i) \gets \KeyGen(\parm)$,
  and $\ipk_i \gets \ISet((\upk_i,\usk_i),\fissue^{\sring})$, where $\sring =
  \lbrace \upk_i \rbrace_{i\in[n]}$. Run also $(\opk,\osk) \gets \OKeyGen(\parm,
  \finsp^0)$. Set $\pk_i \gets (\ipk_i,\opk)$ and $\sk_i \gets \usk_i$, for
  $i\in[n]$.
\item[$\Sig \gets \Sign(\sk_i,R,\msg).$]
  The signing user, with $\sk_i=\usk$ and $\pk_i=(\ipk_i,\opk)$ for some $i \in
  [n]$, where $\pk_i \in R$, first acts both as user and issuer to self-issue a
  credential \Cred over an attribute set \attrs such that $\attrs \subseteq
  \sring$. The user picks some \dattrs such that $\dattrs \subseteq [|\attrs|]$,
  and computes the ring signature by running $\Sig = (\sig,\yeval) \gets
  \Sign(\usk,\opk,\Cred,\msg,\feval^{\sring,\dattrs})$ from
  $\CUASGen^{hide-iss}$. Note that \dattrs defines the public keys within
  $\attrs \subseteq \sring$ to be revealed through \yeval.
\item[$1/0 \gets Verify(R,\Sig,\msg)$.] Parses \Sig as $(\sig,\yeval)$ and
  runs $\Verify(\opk,\yeval=\lbrace \ipk_i\rbrace_{i\in\dattrs},\sig,\yeval,
  \msg,\feval^{\sring,\dattrs})$ as in $\CUASGen^{hide-iss}$.
\end{description}

%Note that by using, e.g., $\finsp^{\upk}$, we essentially get a ring signature
%scheme with linkability via an opener.

\paragraph{Security of \CUASRing.} %
We state next the theorems for the security of \CUASRing. The proofs are
available in \appref{app:related-proofs}.

\begin{theorem}[Anonymity of \CUASRing]
  If the base \CUASGen construction has signature anonymity according to
  \defref{def:sign-anonymity-uas}, then \CUASRing is an anonymous ring signature
  scheme.
\end{theorem}

\begin{theorem}[Unforgeability of \CUASRing]
  If the base \CUASGen construction is non-frameable according to
  \defref{def:frame-uas}, then \CUASRing is an unforgeable ring signature
  scheme.
\end{theorem}

\subsection{Anonymous Credentials}
\label{ssec:related-models-ac}

We adopt the model in \cite{fhs19}, for anonymous credentials with selective
disclosure. Therein, an anonymous credential scheme is
defined via $OrgKeyGen$ (which we rename to $IssKeyGen$), and $UserKeyGen$
algorithms (roughly equivalent to
\IKeyGen and \UKeyGen for \UAS), and $Obtain,Issue$ and $Show,Verify$
interactive protocols. The issuance interactive protocol corresponds to
the issuance protocol in \UAS. Similarly, $Show,Verify$ corresponds to
the interactive extension of \Sign and \Verify in \UAS, which we show how
to build in \appref{app:interactive-uas}. The security definitions rely on
$HU, CU, ObtIss, Obtain, Issue,Show$, and $LoR$ oracles, which are essentially
equivalent to our \HUGEN, \CUGEN, \OBTISS, \OBTAIN, \ISSUE, \SIGN, and \CHALb
oracles. We refer to \cite{fhs19} for the full details. For ease of reference,
we summarize the security definitions in \figref{fig:model-ac}.% , with inocuous
% adaptations to make them more suitable for comparison with our definitions --
% namely, we explicitly add a common setup process which is part of $IssKeyGen$
% in \cite{fhs19}.

\begin{figure}[ht!]
  \centering
  \scalebox{0.9}{      
    \begin{minipage}[t]{0.5\textwidth}        
      \procedure[linenumbering]{$\Exp^{anon-b}_{\adv,ac}(1^\secpar)$}{%
 %       \parm \gets \Setup(1^\secpar) \\
        (\ipk,\isk) \gets IssKeyGen(1^\secpar) \\        
        b^* \gets \adv^{HU,CU,Obtain,Show,LoR}(\isk) \\
        \pcreturn b^*
      }        
    \end{minipage}
  }
  \scalebox{0.9}{      
    \begin{minipage}[t]{.5\textwidth}
      \procedure[linenumbering]{$\Exp^{forge}_{\adv,ac}(1^\secpar)$}{%
%        \parm \gets \Setup(1^\secpar) \\
        (\ipk,\isk) \gets IssKeyGen(1^\secpar) \\        
        (D,\st) \gets \adv^{HU,CU,ObtIss,Issue,Show}(\ipk) \\
        \langle \cdot,(b,\utrans) \rangle
        \gets \langle \adv(\st),\Verify(\ipk,D) \rangle \\
        \pcreturn (b = 1 \land \nexists j~\suchthat \\
        \pcind (\OWNR[j] \in \CU
        \land D \subseteq \ATTR[j])) % \forall j, \OWNR[j] \in \CU
        % \implies D \not\subseteq \ATTR[j]: \\
        %\pcind \pcreturn 1 \\
        %\pcreturn 0
      }       
    \end{minipage}      
  }
  \caption{Security games for anonymous credentials with selective disclosure
    \cite{fhs19}. \OWNR and \ATTR tables are essentially as in \UAS. \adv~wins
    the unforgeability game if it authenticates successfully while revealing
    attributes not contained in adversarially controlled credentials.}
  \label{fig:model-ac}  
\end{figure}

\subsubsection{\CUASAC Construction.} %
We show that a $(\fissue^1,\feval^{\dattrs},\finsp^0)$-\CUASGen restriction, is
a secure anonymous credential scheme according to the model in \cite{fhs19}. We
first quickly define the algorithms, and then prove security.

\begin{description}
% \item[$\parm \gets \Setup(1^\secpar)$.] Runs $\parm' \gets \Setup(1^\secpar,
%   \AttrSpace)$ and $(\opk,\osk) \gets \OKeyGen(\parm',\finsp^0)$ from our
%   \CUASGen construction. Returns $\parm \gets (\parm',\opk)$.
\item[$(\ipk,\isk) \gets IssKeyGen(\parm)$.] $\parm' \gets
  \Setup(1^\secpar)$ and $(\opk,\osk) \gets \OKeyGen(\parm',
  \finsp^0)$ from \CUASGen, and sets $\parm \gets (\parm',\opk)$. Then,
  runs \IKeyGen, also from \CUASGen, setting $\fissue^1$ as issuance function.
\item[$(\upk,\usk) \gets UserKeyGen(\ipk)$.] Runs \UKeyGen from \CUASGen.
\item[$\langle \cred/\bot,\top/\bot \rangle \gets
  \langle \Obtain(\usk,\ipk,\attrs),\Issue(\isk,\upk,\attrs) \rangle$.]
  Runs the $\langle \Obtain,\Issue \rangle$ protocol from \CUASGen, using
  $\fissue^1$ as issuance function.
\item[$\langle 1/0,((1,\utrans)/(0,\utrans)\rangle
  \gets \langle Show(\ipk,\attrs,\dattrs,
  \cred),\Verify(\ipk,\dattrs) \rangle$.]
  Runs the interactive extension of \Sign and \Verify of the \CUASGen protocol,
  using $\feval^{\dattrs}$ as signature evaluation function, and $\finsp^0$ as
  open function, with \opk from \parm as opener public key.
\end{description}

\paragraph{Security of \CUASAC.} %
We state next the theorems for the security of \CUASAC. The proofs are
available in \appref{app:related-proofs}.

\begin{theorem}[Anonymity of \CUASAC]
  \label{thm:anon-cuasac}
  If the base \CUASGen construction has signature anonymity according to
  \defref{def:sign-anonymity-uas}, then \CUASAC is an anonymous AC scheme
  according to \cite{fhs19}.
\end{theorem}

\begin{theorem}[Unforgeability of \CUASAC]
  \label{thm:forge-cuasac}
  If the base \CUASGen construction has signature unforgeability according to
  \defref{def:sign-forge-uas}, then \CUASAC is an unforgeable AC scheme.
  \markulf{Hiding of $pk_U$?}
\end{theorem}

\subsection{Delegatable Anonymous Credentials}
\label{ssec:related-models-dac}

We give a simple definition for a Delegatable Anonymous Credentials (DAC)
scheme, extending \cite{fhs19} and inspired by \cite{bcc+09}. Unlike the latter,
our simple scheme built from $\CUASGen^{usr-iss}$ does not ensure privacy of the
delegation chain -- which could be achieved by making \feval output projective
proofs like in \cite{bcc+09}, but since our goal is to showcase the feasibility
of building DAC from \UAS, we leave that out for brevity. Our simple scheme
does, however, ensure that a (not top-level) issuer can only delegate attributes
contained in a credential it owns. Also, for simplicity, we restrict to the case
of using one credential per signature/interactive credential presentation, and
assume that all parties use the same opener and \finsp function.
%
The functionality is thus defined almost as in \secref{ssec:related-models-ac},
i.e., we have $Setup$, $IssKeyGen$ algorithms, and $\langle Obtain,Issue\rangle$
and $\langle Show,Verify \rangle$ interactive protocols; but we do not have
$UserKeyGen$, as this collapses with $IssKeyGen$.
%
In the model for this setting, since there are multiple issuers, in addition
to the oracles in \secref{ssec:related-models-ac}, we use $HI$ and $CI$ oracles,
equivalent to \IGEN and \ICORR in our \UAS model, which allow adding honest
issuers, and corrupt existing ones, respectively. The issuance and sign
anonymity properties are direct, constraining the adversary to output challenge
credentials and signatures with the same delegation chain. For unforgeability,
we still require that no adversary can authenticate using a set of attributes
that have not been issued to a corrupt user. In addition, we require that for
any successful authentication using a level-$l$ credential, we
can extract a chain of credentials of length $l$ such that each level-$i$
credential can be used successfully to authenticate a level-$(i+1)$ credential
down to the level-$l$ credential, and the attributes revealed in the
level-$l$ authentication are contained in all the credentials up the chain.

\begin{figure}[ht!]
  \centering
  \scalebox{0.9}{      
    \begin{minipage}[t]{0.45\textwidth}
      \procedure[linenumbering]{$\Exp^{iss-anon-b}_{\adv,dac}(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        b^* \gets \adv^{\mathcal{O}_{iss-anon}}(\parm) \\
        \pccomment{Abort if challenge creds belong to} \\
        \pccomment{users with different delegation chains} \\
        \pcreturn b^*
      }
      \vspace*{0.5em}

      \procedure[linenumbering]{$\Exp^{sig-anon-b}_{\adv,dac}(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        b^* \gets \adv^{\mathcal{O}_{sig-anon}}(\parm) \\
        \pccomment{Abort if challenge sigs belong to} \\
        \pccomment{users with different delegation chains} \\
        \pcreturn b^*
      }        
    \end{minipage}
  }
  \scalebox{0.9}{      
    \begin{minipage}[t]{.55\textwidth}
      \procedure[linenumbering]{$\Exp^{forge}_{\adv,dac}(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        (D=(l,D'),\ipk_l,\st) \gets
        \adv^{\mathcal{O}_{forge}}(\parm) \\
        \langle\cdot,(b,\utrans)\rangle \gets
        \langle \adv(\st),\Verify(\ipk_l,D)\rangle \\
        \pcif b = 0: \pcreturn 0 \\
        \pcif \nexists j~\suchthat~(\OWNR[j] \in \CU
        \land D \subseteq \ATTR[j]): \pcreturn 1 \\        
        (ipk_0, \lbrace (\ipk_i,\cred_i) \rbrace_{i \in [1,l]})
        \gets ExtractChain(\utrans) \\ 
        \pcif \exists i \in [1,l]~\suchthat~
        \iid = \ISR[\ipk_{i-1}] \notin \CI~\land \\
        \pcind D' \not\subseteq \ATTR[\iid]) \land
        D' \subseteq \ATTR[\ISR[\ipk_i]]: \\
        \pcind \pcreturn 1 \\
        \pcreturn 0
      }       
    \end{minipage}      
  }
  \caption{Security games for delegatable anonymous credentials with selective
    disclosure based on \cite{fhs19}. $\mathcal{O}_{iss-anon} \gets \lbrace HI,
    CI,Obtain,Issue,ObtIss,Show,IssLoR\rbrace$, $\mathcal{O}_{sig-anon} \gets
    \lbrace HI,CI,Obtain,Issue,ObtIss,Show,SigLoR\rbrace$. $\mathcal{O}_{forge}
    \gets \lbrace HI,CI,Obtain,ObtIss,Issue,Show\rbrace$. $IssLor$ corresponds
    to \OBTCHALb in \UAS, whereas $SigLor$ corresponds to \CHALb. Also, \OWNR
    and \ATTR tables are essentially as in \secref{ssec:model-uas}.
    $\ISR[\ipk]$, in this case, returns the identifier of the issuer with public
    key \ipk. With $D = (l,D')$ we mean that the first attribute in the revealed
    set $D$ is $l$, which denotes the level of the credential used for
    authentication.}
  \label{fig:model-dac}  
\end{figure}

\subsubsection{\CUASDAC Construction.} %
We next give a construction of a delegatable AC (DAC) scheme, in the shape of
a $(\fissue^{l,\dattrs},\feval^{l,\dattrs},\finsp^0)$-$\CUASGen^{usr-iss}$
restriction. In a DAC scheme, all users are (or may be) also issuers. We only
distinguish between top-level issuers, who have level $l=0$, and lower-level
issuers, who have level $l>0$. In our \CUASDAC scheme, we assume that the first
attribute (after the user's secret key) encodes the level of the credential.
That is, $\attrs_1=l$, for a credential of level $l$. In addition, all users
(i.e., with $l>0$) who want to delegate have to publicly list:

\begin{enumerate}
\item The level $l$ of the credential they delegate.
\item Their public key \ipk.
\item An \UAS signature proving knowledge of a credential of level $l$, and over
  the attributes that this level-$l$ issuer is delegating.
\item The \ipk of the parent issuer.
\item The $\fissue^{l,\dattrs}$ function they will require for delegating.
\item An $\feval^{l,\dattrs}$ function used to produce the signature at item 3.
\end{enumerate}

We assume that, from an \ipk, it is possible to find the corresponding issuer
(e.g., using the previously mentioned public list). The mentioned
$\fissue^{l,\dattrs}$ functions must follow the pattern in \figref{fig:func-restrictions}.
Namely, the issuance function checks that the first requested attribute equals
$l+1$, and that all requested attributes are a subset of the attribute set
\dattrs being delegated by the level-$l$ issuer. In addition, signature
evaluation functions $\feval^{l,\dattrs}$, also shown in \figref{fig:func-restrictions},
must reveal the level of the credential used to produce the \UAS signature at
item 2, as well as the set of attributes \dattrs that the level-$l$ issuer
delegates. Verifiers can then trivially check if the set of revealed attributes
are contained within the attributes delegatable by the parent issuer%
\footnote{Additional checks may be added in both functions, but this is
  the bare minimum.}.
%
From this high-level description, we define the algorithms of \CUASDAC:

\begin{description}
\item[$\parm \gets \Setup(1^\secpar)$.]  Runs $\parm' \gets \Setup(1^\secpar)$
  and $(\opk,\osk) \gets \OKeyGen(\parm',\finsp^0)$ from our
  $\CUASGen^{usr-iss}$ construction. Returns $\parm \gets (\parm',\opk)$. Note
  that $\finsp^0$ can be replaced by any desired opening function.
\item[$(\ipk,\isk) \gets IssKeyGen(\parm)$.] If $l=0$, simply run \IKeyGen as
  in $\CUASGen^{usr-iss}$. If $l>0$, this level-$l$ issuer picks a random
  message $r$ and computes $\Sig = (\sig,\yeval) \gets \Sign(\usk,\opk,\cred,r,
  \feval^{l,\dattrs})$, for the \dattrs set it wants to reveal -- which must
  include the attributes to delegate, and the credential level. It then
  publishes $(l,\ipk,\Sig,\ipk^{l-1},\fissue^{l,\dattrs},\feval^{l,\dattrs})$,
  where $\ipk^{l-1}$ is the public key of the parent issuer,
  $\fissue^{l,\dattrs}$ is an issuance function as described in
  \figref{fig:func-restrictions}, and $\feval^{l,\dattrs}$ is also as in
  \figref{fig:func-restrictions}, revealing the attributes that the issuer is
  willing to delegate.
% \item[$(\upk,\usk) \gets UserKeyGen(\opk)$.] All users in this scheme are
%   also issuers. Thus, a new user runs first \IKeyGen as in \CUASGen. Then, sets
%   $\usk \gets \isk$ and stores \ipk, which may be needed to delegate obtained
%   credentials. Note that this does not affect security, as long as
%   $\isk \getr \AttrSpace$.
\item[$\langle \cred/\bot,\top/\bot \rangle \gets
  \langle \Obtain(\usk,\ipk,\attrs),\Issue(\isk,\upk,\attrs) \rangle$.]
  If $l>0$, the user first finds the corresponding $(l,\ipk,\Sig,\ipk^{n-1},
  \fissue^{l,\dattrs},\feval^{l,\dattrs})$ tuple, and checks \Sig running
  \Verify as in $\CUASGen^{usr-iss}$ (with the retrieved $\feval^{l,\dattrs}$).
  Then, user and level-$l$ issuer run $\langle\Obtain,\Issue\rangle$ as in
  $\CUASGen^{usr-iss}$, using $\fissue^{l,\dattrs}$ as issuance function. If
  $l=0$, then both run $\langle\Obtain,\Issue\rangle$ as in
  $\CUASGen^{usr-iss}$, using the \fissue function required by the issuer.
\item[$\langle 1/0,(1,\utrans)/(0,\utrans)\rangle
  \gets \langle Show(\opk,\attrs,\dattrs,\cred),
  \Verify(\opk,\dattrs) \rangle$.] As in the interactive variant of
  $\CUASGen^{usr-iss}$.  
\end{description}

\paragraph{Security of \CUASDAC.} %
We state next the theorems for the security of \CUASDAC. The proofs are
available in \appref{app:related-proofs}.

\begin{theorem}[Issuance anonymity of \CUASDAC]
  If the base \CUASGen construction has issuance anonymity according to
  \defref{def:issue-anonymity-uas}, then \CUASDAC also has issuance anonymity.
\end{theorem}

\begin{theorem}[Signature anonymity of \CUASDAC]
  If the base \CUASGen construction has signature anonymity according to
  \defref{def:sign-anonymity-uas}, then \CUASDAC also has signature anonymity.
\end{theorem}

\begin{theorem}[Unforgeability of \CUASAC]
  If the base \CUASGen construction has issuance and signature unforgeability
  according to \defref{def:issue-forge-uas} and \defref{def:sign-forge-uas}, and
  non-frameability according to \defref{def:frame-uas}, then \CUASAC is an
  unforgeable AC scheme.
\end{theorem}

\subsection{Multimodal Private Signatures}
\label{ssec:related-models-mps}

Multimodal Private Signatures (or, rather, a close relative, see next) are
directly implementable as a $(\fissue^1,\feval^{\yeval^1},
\finsp^{\ast})$-\CUASGen restriction, where $\feval^{\yeval^1}$ is any signature
evaluation function that ignores the $\yeval^0$ output, and $\finsp^{\ast}$ is
any open function. Concretely, by restricting to a system with one issuer and
one opener, one credential per user, one attribute per credential (the user
secret key)% , $\fissue^1$ issuance functions, and
% \feval functions that only use the $\yeval^1$ output -- which we denote with
% $\feval^{\yeval^1}$
.

There are some differences, though. On the one hand, our signature anonymity
property is somehow in the middle of MPS's privacy-1 and privacy-2 variants.
Their privacy-1 variant is the traditional anonymity property of group
signatures, in which the opener is honest and the adversary can call the opening
oracle except for challenge signatures. In their privacy-2 variant, the opener
is fully corrupt (i.e., \adv~ receives \osk), but the adversary can only be
challenged with signatures that produce the same \yinsp value ($G_{j_b}(id_b)$
in MPS). In our \UAS model, we allow the adversary to corrupt openers at will
(getting ther \osk), but the challenge signatures must have been generated using
the key of an uncorrupted opener; still, \adv~can call the open oracle for
challenge signatures, as long as they have the same \yinsp value. We believe
that these differences are mostly of theoretical interest, though. In practice,
what matters is that any variant of \feval and \finsp functions ($F$ and $G_j$
in MPS) that has too much granularity in their ranges, will lead to a barely
private system. This is a known issue, for instance, in functional encryption
\needcite.

On the other hand, our issuance-related properties (issuance anonymity and
issuance unforgeability) are unachievable by MPS. Issuance anonymity simply does
not make sense in MPS, as it only supports one credential (without attributes)
per user. Issuance unforgeability does not make sense either, since there are no
configurable issuance policies in MPS -- instead, they have the fixed policy of
``proving knowledge of a user secret key''. These extensions are not trivial
from a theoretical point of view, and also have a big impact in the practicality
of the resulting system. Also, MPS does not include verifiable openings. While
this is easy to add, we consider it to be essential, given that the proposed
generalization of opening allows the opener to output ``any value''. Hence, the
need to ensure that the produced value is the legitimate one, seems to be more
necessary than ever. Finally, our \feval function is a generalization of $F$ in
MPS, as it allows two outputs: one will be returned in the clear along with the
signature, and the other will be encrypted. Still both computations are proved
correct. Making part of the output unencrypted allows implementing very useful
variants such as anonymous credentials, as shown before.

For the model of MPS schemes, we refer to the original paper \needcite.

\subsubsection{\CUASMPS construction.} %
As mentioned, any $(\fissue^1,\feval^{\yeval^1},\finsp^\ast)$-restriction of
\CUASGen with only one issuer and opener, one credential per user, and one
attribute per credential (the user secret key), implements an MPS scheme where
$F=\feval^{\yeval^1}$ and $G=\finsp^\ast$. The restriction to one credential per
user, and one attribute per credential, can be done as in
\appref{sapp:related-models-gs}. Finally, note that, in MPS, $G$ is further
parameterized with a value $j$, which essentially is the result of applying $F$
to the message and signer identity, and is not leaked to the opener nor any
other third party. The equivalent in \UAS is the $\yeval^1$ value, which is
encrypted with a single-use key pair, and is an input of \yinsp.

\paragraph{Security of \CUASMPS.} %
We state next the theorems for the security of \CUASMPS. The proofs are
available in \appref{app:related-proofs}.

\begin{theorem}[Privacy-1 of \CUASMPS]
  If the base \CUASGen construction has signature anonymity according to
  \defref{def:sign-anonymity-uas}, then \CUASMPS satisfies privacy-1
  according to \needcite.
\end{theorem}

\begin{theorem}[Extractability of \CUASMPS]
  If the base \CUASGen construction has signature unforgeability according to
  \defref{def:sign-forge-uas}, then it is an extractable MPS scheme.
\end{theorem}

\begin{theorem}[Unforgeability-1 of \CUASMPS]
  If the base \CUASGen construction has signature unforgeability according to
  \defref{def:sign-forge-uas}, then \CUASMPS satisfies unforgeability-1 as
  defined in \needcite.
\end{theorem}

\begin{theorem}[Unforgeability-2 of \CUASMPS]
  If the base \CUASGen construction has non-frameability according to
  \defref{def:frame-uas}, then \CUASMPS satisfies unforgeability-2 as
  defined in \needcite.
\end{theorem}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "uas-paper"
%%% End:
