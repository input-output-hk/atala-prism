\section{Relationships with Other Schemes}
\label{sec:relationships}

% [11 pages max]

In the following, to showcase the generality of \UAS and \CUASGen, we reproduce
models of related schemes in the literature.
Then, we give concrete $(\fissue,\feval,\finsp)$-\CUASGen restrictions and prove
that they securely instantiate the models for the presented schemes, if the
corresponding \CUASGen restriction is a secure \UAS construction. Concretely,
we rely on the functions described in \figref{fig:func-restrictions}. Observe
that all the \fissue functions listed in \figref{fig:func-restrictions} are
\UAS-acceptable. Specifically, $\fissue^1$ and $\fissue^{\sring}$ are trivially
\UAS-acceptable (for $\rngfissue = \bin$); whereas $\fissue^{single,F,I}$ is
\UAS-acceptable if $F$ is a secure PRF \cite{kl14}.

\begin{figure}[ht!]
  \input{figures/functions.tex}
  \caption{Functions for the \CUASGen restrictions described next.
    For readability, we use ``$\cdot$'' to denote input arguments that are
    ignored; and ``$\ast$'' to denote output values that can be set to anything
    (but should be ignored). $\bot$ means that the function fails.}
  \label{fig:func-restrictions}
\end{figure}

\subsection{Group Signatures}
\label{ssec:related-models-gs}

We adopt the model in \cite{bsz05}. In this abstraction of group signatures, the
opener returns an index uniquely identifying the group member that created a
signature, along with a correctness proof. For ease of exposition, assume that,
w.l.o.g., this index is just the public key that the group member generates
randomly when joining the group\footnote{The user public key is assumed to be
  accessible from a public table in \cite{bsz05}, so it is easy to translate the
  public key into an index, if needed.}. A group signature scheme, according to
\cite{bsz05}, is composed of $KeyGen$, \UKeyGen, \Sign, \Verify, \Open and
\Judge algorithms, as well as an $\langle\Obtain,\Issue\rangle$ interactive
protocol. Their intuition is similar to that of \UAS, so we refer to
\cite{bsz05} for detailed descriptions. For ease of reference, we replicate the
security games in \figref{fig:model-gs}.

\begin{figure}[ht!]
  \centering
  \scalebox{0.9}{      
    \begin{minipage}[t]{0.45\textwidth}        
      \procedure[linenumbering]{$\Exp^{anon-b}_{\adv,gs}(1^\secpar)$}{%
        (\gpk,\isk,\osk) \gets KeyGen(1^\secpar) \\
        d \gets \adv^{\mathcal{O}_{anon}}(\gpk,\isk) \\
        \pcreturn d 
      }
      
      \vspace*{5em}
      
      \procedure[linenumbering]{$\Exp^{frame}_{\adv,gs}(1^\secpar)$}{%
        (\gpk,\isk,\osk) \gets KeyGen(1^\secpar) \\
        (\msg,\sig,\upk,\tau) \gets \adv^{\mathcal{O}_{frame}}
        (\gpk,\osk,\isk) \\
        \pcif \Verify(\gpk,\msg,\sig) = 0: \pcreturn 0 \\
        \pcreturn (\upk \in \HU \land \PRVUK[\upk] \neq \bot \land
        \Judge(\gpk,\upk,\msg,\sig,\tau) = 1)~\land \\
        \pcind \adv~\textrm{did not query}~USK(\upk)~\textrm{or}~
        GSig(\PRVUK[\upk],\msg)
      }       
    \end{minipage}
  }
  \scalebox{0.9}{      
    \begin{minipage}[t]{.55\textwidth}
      \procedure[linenumbering]{$\Exp^{trace}_{\adv,gs}(1^\secpar)$}{%
        (\gpk,\isk,\osk) \gets KeyGen(1^\secpar) \\
        (\msg,\sig) \gets \adv^{\mathcal{O}_{trace}}(\gpk,\osk) \\
        \pcif \Verify(\gpk,\msg,\sig) = 0: \pcreturn 0 \\
        (\upk, \tau) \gets \Open(\gpk,\osk,\trans,\msg,\sig) \\
        \pcif \upk \notin \HU \cup \CU \lor \Judge(\gpk,\upk,\msg,\sig,\tau)
        = 0: \\ 
        \pcind \pcreturn 1 \\
        \pcreturn 0
      }       
    \end{minipage}      
  }
  \caption{Security games for group signatures \cite{bsz05}, only with minor    
    ``harmless'' edits to compare easier with \CUASGS. Concretely, since we
    output {\upk}s instead of indexes, $i=0$ in the traceability game now reads
    $\upk \notin \HU \cup \CU$. For the oracles' definitions, check the
    referenced paper.
    $\mathcal{O}_{anon} \gets \lbrace \oracle{Ch},\oracle{Open},\oracle{SndToU},
    \oracle{WReg},\oracle{USK},\oracle{CrptU} \rbrace$,
    $\mathcal{O}_{trace} \gets \lbrace \oracle{SndToI},\oracle{AddU},
    \oracle{RReg},\oracle{GSig},\oracle{USK},\oracle{CrptU} \rbrace$,
    and $\mathcal{O}_{frame} \gets \lbrace \oracle{SndToU},\oracle{WReg},
    \oracle{GSig},\oracle{USK},\oracle{CrptU} \rbrace$.
  }
  \label{fig:model-gs}  
\end{figure}

\subsubsection{\CUASGS construction.} %
We show that the $(\fissue^{single,F,I},\feval^0,\finsp^{\upk})$-\CUASGen
restriction, is a secure group signature scheme according to \cite{bsz05}.
As stated, the $\fissue^{single,F,I}$ is an \UAS-acceptable function if $F$ is a
PRF. In that case, its output is a random-looking string that depends on the
user public key \upk, and a string $I$ uniquely identifying the issuer. Thus, it
will be the same per $(\upk,I)$ pair, and can be used by issuer $I$ to prevent
issuing more than one credential per user. Basically, the issuer maintains a
list of received $\yissue = F(\upk,I)$ values, and rejects issuing a credential
for already existing \yissue values. From this, the GS algorithms are as
follows:

\begin{description}
\item[$(\gpk,\isk,\osk) \gets KeyGen(1^\secpar)$.] Runs \Setup from \CUASGen,
  and one instance of \KeyGen and \ISet with $\fissue^{single,F,I}$ (both for
  the same user, who will be the only issuer in the GS scheme) and \OKeyGen.
  Assigns the public keys to \gpk.
\item[$(\upk,\usk) \gets \UKeyGen(1^\secpar)$.] Runs \KeyGen from \CUASGen.
\item[$\langle \cred,\utrans \rangle \gets
  \langle\Obtain(\usk,\ipk),\Issue(\isk,\upk)\rangle$.] Runs $\langle\Obtain,
  \Issue\rangle$ as in \CUASGen, with $\attrs \gets \emptyset$. Upon receiving
  the \yissue value, the issuer checks if it already exists in a list $L$
  (initially set to $\emptyset$); if it exists, aborts issuance. Otherwise, it
  completes the protocol and adds $\yissue$ to $L$. It is responsibility of the
  issuer to maintain $L$.
\item[$\sig \gets \Sign(\gpk,\cred,\msg)$.] Parses \gpk as $(\ipk,\opk)$, and
  runs $(\sig,0) \gets \Sign(\usk,\opk,\cred,\msg,\feval^0)$ from \CUASGen,
  where $\yeval = 0$ is the constant output of $\feval^0$.
\item[$1/0 \gets \Verify(\gpk,\sig,\msg)$.] Parses \gpk as $(\ipk,\opk)$, and
  returns whatever $\Verify(\opk,\ipk,\sig,0,\msg,\feval^0)$ from \CUASGen
  outputs.
\item[$(\upk,\pi) \gets \Open(\gpk,\osk,\trans,\sig,\msg)$.] Parses \gpk as
  $(\ipk,\opk)$, and returns whatever \CUASGen outputs in $\Open(\osk,\ipk,\sig,
  0,\msg,\feval^0)$. Internally, the call to \Open runs $\finsp^{\upk}$.
\item[$1/0 \gets \Judge(\gpk,\pi,\upk,\sig,\msg)$.] Parses \gpk as $(\ipk,
  \opk)$, and returns whatever \CUASGen outputs in $\Judge(\opk,\upk,\pi,\sig,
  0,\msg)$.
\end{description}

\paragraph{Security of \CUASGS.} %
Our \CUASGS construction is an anonymous, traceable, and non-frameable group
signature scheme, according to the model in \cite{bsz05}. For space constraints,
proofs are deferred to \appref{app:related-proofs}.

% \begin{theorem}[Anonymity of \CUASGS]
%   If the base \CUASGen construction has signature anonymity according to
%   \defref{def:sign-anonymity-uas}, then \CUASGS is an anonymous group signature
%   scheme.
% \end{theorem}

% \begin{theorem}[Traceability of \CUASGS]
%   If the base \CUASGen construction is unforgeable according to
%   \defref{def:forge-uas}, then \CUASGS is a traceable group signature scheme.
% \end{theorem}

% \begin{theorem}[Non-frameability of \CUASGS]
%   If the base \CUASGen construction is non-frameable according to
%   \defref{def:frame-uas}, then \CUASGS is a non-frameable group signature
%   scheme.
% \end{theorem}

\subsection{Ring Signatures}
\label{ssec:related-models-rs}

We adopt the model in \cite{bkm06}, where security of ring signatures is
defined according to the games in \figref{fig:model-rs}. A ring signature
scheme consists of three algorithms $(KeyGen,Sign,Verify)$. Roughly,
$((\pk_1,\sk_1),\dots,(\pk_n,\sk_n)) \gets KeyGen(1^\secpar)$ produces $n$
signing key pairs, $\sig \gets Sign(\sk_i,R,\msg)$ creates a signature for
anonymity set $R \subseteq \lbrace \pk_1, \dots, \pk_t \rbrace$, using secret
key $\sk_i$, associated to some $\pk_i \in R$; and $1/0 \gets Verify(R,\sig,
\msg)$ checks if \sig is a valid signature over \msg for ring $R$. We refer
to \cite{bkm06} for details on the syntax and definitions.

\begin{figure}[ht!]
  \centering
  \scalebox{0.9}{      
    \begin{minipage}[t]{0.55\textwidth}        
      \procedure[linenumbering]{$\Exp^{anon-b}_{\adv,rs}(1^\secpar)$}{%
        ((\pk_1,\sk_1),\dots,(\pk_n,\sk_n)) \gets KeyGen(1^\secpar) \\
        (i_0,i_1,R,\msg,\st) \gets \adv^{\oracle{SIGN}}(\pk_1,\dots,\pk_n) \\
        \pcif R \not\subseteq \lbrace \pk_i \rbrace_{i\in[n]} \lor
        \lbrace \pk_{i_0},\pk_{i_1} \rbrace \not\subseteq R~\lor \\ %\\
        \pcind i_0 = i_1: \pcreturn \bot \\
        \sig \gets Sign(\sk_{i_b},R,\msg) \\
        b^* \gets \adv(\sig,\st) \\
        \pcreturn b^*
      }        
    \end{minipage}
  }
  \scalebox{0.9}{      
    \begin{minipage}[t]{.5\textwidth}
      \procedure[linenumbering]{$\Exp^{forge}_{\adv,rs}(1^\secpar)$}{%
        ((\pk_1,\sk_1),\dots,(\pk_n,\sk_n)) \gets KeyGen(1^\secpar) \\
        (R,\sig,\msg) \gets \adv^{\oracle{SIGN},\oracle{CORR}}
        (\pk_1,\dots,\pk_n) \\
        \pcif Verify(R,\sig,\msg) = 0: \pcreturn 0 \\
        \pcreturn (R \subseteq \lbrace \pk_i \rbrace_{i\in[n]} \setminus
        CU~\land \\
        \pcind \adv~\textrm{never queried}~SIGN(\cdot,R,\msg))
      }       
    \end{minipage}      
  }
  \caption{Security games for ring signatures \cite{bkm06}. The $\oracle{SIGN}$
    oracle accepts $(i,R,\msg)$ tuples, with $pk_i \in R$, adds the tuple to a
    list of queries, and returns $\sig \gets Sign(\sk_i,R,\msg)$.
    $\oracle{CORR}$ accepts an index $i$, and leaks $\sk_i$. Corrupted users are
    added to $CU$.}
  \label{fig:model-rs}  
\end{figure}


\subsubsection{\CUASRing Construction.} %
Building a ring signature scheme according to the model in \figref{fig:model-rs}
is essentially a $(\fissue^{\sring},\feval^{\sring,\dattrs},\finsp^0)$-restriction
of our \CUASGenHideIss construction. In a nutshell, we let users self-issue
credentials where the attributes are (a subset of encodings of) the public keys
of the users in the system -- including their own public key. Then, a ring
signature is just a \CUASGenHideIss signature that reveals a subset of
the attributes -- i.e., a subset of the keys of the users in the system. In more
detail, the construction is as follows:

% \begin{align}
%   & \NIZKRel_{\Sign}^{prv} \coloneqq \lbrace (\usk,\cred,\yeval^1,\yinsp,r,r',
%     \ipk),(\msg,\feval,\yeval^0,\ceval,\cinsp,\Eek,\widetilde{\Eek},\sring): \nonumber \\
%   & \hspace*{6.405em}\ceval = \EEnc(\widetilde{\Eek},\yeval^1;r) \land
%     \cinsp = \EEnc(\Eek,\yinsp;r') \land \nonumber \\
%   & \hspace*{6.40em}(\yeval^0,\yeval^1) = \feval(\usk,\cred,\msg) \land
%     \yinsp = \finsp((\yeval^0,\yeval^1),\usk,\cred,\msg) \nonumber \\
%   & \hspace*{6.40em}\exists \ipk \in \sring~\suchthat~\SBCMVerify(\ipk,\cred,\usk,
%     \sring) = 1) \rbrace \label{eq:sign-prv}
% \end{align}

% From it, we show that the $(\fissue^{\sring},\feval^{\attrs},\finsp^0)$-
% $\CUASGen^{\Sign-prv}$ restriction, is a secure ring signature scheme. We
% restrict to one credential per signature.

\begin{description}
%\item[$\parm \gets \Setup(\secpar,\AttrSpace)$.] As in \CUASGenHideIss.
\item[$((\pk_1,\sk_1),...,(\pk_n,\sk_n)) \gets KeyGen(\secpar)$.] Runs
  $\parm \gets \Setup(\secpar)$ from \CUASGenHideIss. Then, for each of
  the $i \in [n]$ users to generate, run $(\upk_i,\usk_i) \gets \KeyGen(\parm)$,
  and $\ipk_i \gets \ISet((\upk_i,\usk_i),\fissue^{\sring})$, where $\sring =
  \lbrace \upk_i \rbrace_{i\in[n]}$. Run also $(\opk,\osk) \gets \OKeyGen(\parm,
  \finsp^0)$. Set $\pk_i \gets (\ipk_i,\opk)$ and $\sk_i \gets \usk_i$, for
  $i\in[n]$.
\item[$\Sig \gets \Sign(\sk_i,R,\msg).$]
  The signing user, with $\sk_i=\usk$ and $\pk_i=(\ipk_i,\opk)$ for some $i \in
  [n]$, where $\pk_i \in R$, first acts both as user and issuer to self-issue a
  credential \Cred over an attribute set \attrs such that $\attrs \subseteq
  \sring$. The user picks some \dattrs such that $\dattrs \subseteq [|\attrs|]$,
  and computes the ring signature by running $\Sig = (\sig,\yeval) \gets
  \Sign(\usk,\opk,\Cred,\msg,\feval^{\sring,\dattrs})$ from
  \CUASGenHideIss. Note that \dattrs defines the public keys within
  $\attrs \subseteq \sring$ to be revealed through \yeval.
\item[$1/0 \gets Verify(R,\Sig,\msg)$.] Parses \Sig as $(\sig,\yeval)$ and
  runs $\Verify(\opk,\yeval,\Sig,\msg,\feval^{\sring,\dattrs})$ as in
  \CUASGenHideIss. Note that, in valid signatures, $\yeval = \lbrace
  \ipk_i\rbrace_{i\in\dattrs}$.
\end{description}

%Note that by using, e.g., $\finsp^{\upk}$, we essentially get a ring signature
%scheme with linkability via an opener.

\paragraph{Security of \CUASRing.} %
Our \CUASRing construction is an anonymous and unforgeable ring signature
scheme, according to the model in \cite{bkm06}. For space constraints,
proofs are deferred to \appref{app:related-proofs}.

% \begin{theorem}[Anonymity of \CUASRing]
%   If the base \CUASGenHideIss construction has signature anonymity
%   according to \defref{def:sign-anonymity-uas}, then \CUASRing is an anonymous
%   ring signature scheme.
% \end{theorem}

% \begin{theorem}[Unforgeability of \CUASRing]
%   If the base \CUASGenHideIss construction is non-frameable according to
%   \defref{def:frame-uas}, then \CUASRing is an unforgeable ring signature
%   scheme.
% \end{theorem}

\subsection{Anonymous Credentials}
\label{ssec:related-models-ac}

We adopt the model in \cite{fhs19}, for anonymous credentials with selective
disclosure, which restricts to one credential per presentation. Therein, an
anonymous credential scheme is defined via $OrgKeyGen$ (which we rename to
$IssKeyGen$), and $UserKeyGen$ algorithms, and $\langle Obtain,Issue\rangle$
and $\langle Show,Verify \rangle$ interactive protocols. We
refer to \cite{fhs19} for the full details. For ease of reference, we summarize
the security definitions in \figref{fig:model-ac}.% , with inocuous
% adaptations to make them more suitable for comparison with our definitions --
% namely, we explicitly add a common setup process which is part of $IssKeyGen$
% in \cite{fhs19}.

\begin{figure}[ht!]
  \centering
  \scalebox{0.9}{      
    \begin{minipage}[t]{0.5\textwidth}        
      \procedure[linenumbering]{$\Exp^{anon-b}_{\adv,ac}(1^\secpar)$}{%
 %       \parm \gets \Setup(1^\secpar) \\
        (\ipk,\isk) \gets IssKeyGen(1^\secpar) \\        
        b^* \gets \adv^{\oracle{HU},\oracle{CU},\oracle{Obtain},
          \oracle{Show},\oracle{LoR}}(\isk) \\
        \pcreturn b^*
      }        
    \end{minipage}
  }
  \scalebox{0.9}{      
    \begin{minipage}[t]{.5\textwidth}
      \procedure[linenumbering]{$\Exp^{forge}_{\adv,ac}(1^\secpar)$}{%
%        \parm \gets \Setup(1^\secpar) \\
        (\ipk,\isk) \gets IssKeyGen(1^\secpar) \\        
        (D,\st) \gets \adv^{\oracle{HU},\oracle{CU},\oracle{ObtIss},
          \oracle{Issue},\oracle{Show}}(\ipk) \\
        \langle \cdot,(b,\utrans) \rangle
        \gets \langle \adv(\st),\Verify(\ipk,D) \rangle \\
        \pcreturn (b = 1 \land \nexists j~\suchthat \\
        \pcind (\OWNR[j] \in \CU
        \land D \subseteq \ATTR[j])) % \forall j, \OWNR[j] \in \CU
        % \implies D \not\subseteq \ATTR[j]: \\
        %\pcind \pcreturn 1 \\
        %\pcreturn 0
      }       
    \end{minipage}      
  }
  \caption{Games for anonymous credentials with selective disclosure
    \cite{fhs19}. \OWNR, \ATTR, and the oracles, are essentially as in
    \UAS. \adv~wins $\Exp^{forge}_{\adv,ac}$ if it authenticates successfully
    while revealing attributes not contained in adversarially controlled
    credentials.}
  \label{fig:model-ac}  
\end{figure}

\subsubsection{\CUASAC Construction.} %
We show that a $(\fissue^1,\feval^{\dattrs},\finsp^0)$-\CUASGenInt
restriction, is a secure anonymous credential scheme according to the model in
\cite{fhs19}. We first quickly define the algorithms, and then prove security.

\begin{description}
% \item[$\parm \gets \Setup(1^\secpar)$.] Runs $\parm' \gets \Setup(1^\secpar,
%   \AttrSpace)$ and $(\opk,\osk) \gets \OKeyGen(\parm',\finsp^0)$ from our
%   \CUASGen construction. Returns $\parm \gets (\parm',\opk)$.
\item[$(\ipk,\isk) \gets IssKeyGen(\parm)$.] From \CUASGenInt, run $\parm'
  \gets \Setup(1^\secpar)$ and $(\opk,\osk) \gets \OKeyGen(\parm',
  \finsp^0)$, and set $\parm \gets (\parm',\opk)$. Run $(\upk,\usk) \gets
  \KeyGen(\parm')$ and $\ipk \gets \ISet(\upk,\usk,\fissue^1)$. Set $\isk \gets
  \usk$.
\item[$(\upk,\usk) \gets UserKeyGen(\ipk)$.] Runs \KeyGen from \CUASGenInt.
\item[$\langle \cred/\bot,\top/\bot \rangle \gets
  \langle \Obtain(\usk,\ipk,\attrs),\Issue(\isk,\upk,\attrs) \rangle$.]
  Runs $\langle \Obtain,\Issue \rangle$ from \CUASGenInt.
\item[$\langle 1/0,((\yeval,\utrans)/(0,\utrans)\rangle
  \gets \langle Show(\ipk,\attrs,\dattrs,
  \cred),\Verify(\ipk,\dattrs) \rangle$.]
  Runs the interactive $\langle \Sign, \Verify\rangle$ of  \CUASGenInt,
  using $\feval^{\dattrs}$ as signature evaluation function, and $\finsp^0$ as
  open function, with \opk from \parm as opener public key. The \yeval value
  output by the verifier, when it accepts, is the $\yeval^0$ value produced by
  \Sign in \CUASGenInt.
\end{description}

\paragraph{Security of \CUASAC.} %
Our \CUASAC construction is an anonymous and unforgeable anonymous credential
scheme, according to the model in \cite{fhs19}. For space constraints,
proofs are deferred to \appref{app:related-proofs}.

% \begin{theorem}[Anonymity of \CUASAC]
%   \label{thm:anon-cuasac}
%   If the base \CUASGenInt construction has signature anonymity according to
%   \defref{def:sign-anonymity-uas}, then \CUASAC is an anonymous AC scheme
%   according to \cite{fhs19}.
% \end{theorem}

% \begin{theorem}[Unforgeability of \CUASAC]
%   \label{thm:forge-cuasac}
%   If the base \CUASGenInt construction is unforgeabile according to
%   \defref{def:forge-uas}, then \CUASAC is an unforgeable AC scheme.
% \end{theorem}

\subsection{Revocable Anonymous Credentials}
\label{ssec:related-models-rac}

In \cite{cks10,ckl+15}, revocable anonymous credentials are proposed. We first
give a simple model in \figref{fig:model-rac}, extending that in
\secref{ssec:related-models-ac}. Concretely, to the functionality in
\secref{ssec:related-models-ac}, we now explicitly add the $OKeyGen$ function,
which generates the opener key pair, extend $Verify$ to receive also a list $L$
of revoked credential identifiers, and we add a function (and corresponding
oracle) $cid/\bot \gets RetrieveCredId(\osk,\utrans)$ that can extract an
identifier of the credential used in a presentation transcript \utrans. For
simplicity, we do not include the equivalent to verifiable openings, but this
would be straightforward.

\begin{figure}[ht!]
  \centering
  \scalebox{0.9}{      
    \begin{minipage}[t]{0.43\textwidth}
      \procedure[linenumbering]{$\Exp^{anon-b}_{\adv,rac}(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        (\opk,\osk) \gets \OKeyGen(\parm) \\        
        (\ipk,\isk) \gets IssKeyGen(\parm) \\        
        b^* \gets \adv^{\mathcal{O}_{rac},\oracle{LoR}}(\parm,\ipk,\opk) \\
        \pcreturn b^*
      }
    \end{minipage}
  }
  \scalebox{0.9}{      
    \begin{minipage}[t]{.57\textwidth}
      \procedure[linenumbering]{$\Exp^{forge}_{\adv,rac}(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        (\opk,\osk) \gets \OKeyGen(\parm) \\        
        (\ipk,\isk) \gets IssKeyGen(\parm) \\
        (\cid,D,L,\st) \gets
        \adv^{\mathcal{O}_{rac}}(\parm,\ipk,\opk) \\
        \langle \cdot,(b_0,\utrans_0)\rangle
        \gets \langle \adv(\st),\Verify(\ipk,D,L)\rangle \\
        \langle \cdot,(b_1,\utrans_1)\rangle
        \gets \langle Show(\ipk,\ATTR[\cid],D,\CRED[\cid]), \\
        \hspace*{7.25em}\Verify(\ipk,D,L)\rangle \\
        \pcif \OWNR[\cid] \notin \HU \lor
        D \not\subseteq \ATTR[\cid]: \pcreturn 0 \\
        \pcif b_0 = 1 \land \nexists j~\suchthat~(\OWNR[j] \in \CU
        \land D \subseteq \ATTR[j]): \\
        \pcind \pcreturn 1 \\
        h_{\bin} \gets RetrieveCredHandle(\osk,\utrans_{\bin}) \\
        \pcif h_0 \in L \lor (h_1 \notin L \land b_1 = 0): \pcreturn 1 \\
        \pcreturn 0
      }       
    \end{minipage}      
  }
  \caption{Security games for revocable anonymous credentials with selective
    disclosure based on \cite{fhs19}. 
    $\mathcal{O}_{rac} \gets \lbrace \oracle{HU},\oracle{CU},\oracle{Obtain},
    \oracle{Issue},\oracle{ObtIss},\oracle{Show},\oracle{ReqCredHandle}\rbrace$.
    $\oracle{ReqCredHandle}$ is
    equivalent to \OPEN, operating on transcripts \utrans instead of signatures
    but, in addition, keeps a list of revoked users (per verifier), based on the
    queries it receives. In $\Exp^{forge}_{\adv,rac}$, \adv~wins if it
    authenticates using a revoked credential or despite not having the required
    attributes, or if it prevents an honest user from authenticating using a
    non-revoked credential.}
  \label{fig:model-rac}  
\end{figure}

\subsubsection{\CUASRAC Construction.} %
Briefly, this is achieved via a $(\fissue^1,\feval^{\dattrs,F,V,L},
\finsp^{F})$-\CUASGenInt restriction. \feval is defined via a set of
attributes \dattrs to reveal (e.g., age, etc.), a PRF $F$, a string identifying
the verifier $V$ and a list $L$ of revocation handles by $V$. Note that,
these ``extra parameters'' can be hardcoded, though: $F$ can be a fixed PRF for
all verifiers, \dattrs and $V$ are also fixed (per verifier), and $L$ can be
updated per verifier with some reasonable frequency -- e.g., daily -- so that
the cost of recomputing $\feval^{\dattrs,F,V,L}$ is not high.
%
Since credentials in \CUASGenInt have two identifiers (\cidi, chosen by the
issuer; and \cidu, chosen by the user), $\feval^{\dattrs,F,V,L}$ internally
computes $F(V,\cidi)$ and $F(V,\cidu)$. If either appears in $L$, \feval aborts.
Otherwise, it sets $\yeval^0 \gets \lbrace \attrs_i \rbrace_{i\in\dattrs}$ and
$\yeval^1 \gets V$. $\yeval^1$ is
then used by $\finsp^F$ to compute $\yinsp \gets (F(\yeval^1,\cidi),
F(\yeval^1,\cidu))$. Thus, if the verifier $V$ wants to revoke a credential, all
it has to do is ask the opener to decrypt $\yinsp$, via $RetrieveCredHandle$.
%
In more detail, the algorithms are as follows:

\begin{description}
\item[$\parm \gets \Setup(1^\secpar)$.] Runs $\Setup(1^\secpar)$ as in
  \CUASGenInt.
\item[$(\ipk,\isk) \gets IssKeyGen(\parm)$.] Runs \KeyGen+\ISet from
  \CUASGenInt, setting $\fissue^1$ as issuance function.
\item[$(\ipk,\isk) \gets OKeyGen(\parm)$.] Runs \OKeyGen from \CUASGenInt,
  setting $\finsp^F$ as opening function.
\item[$(\upk,\usk) \gets UserKeyGen(\ipk)$.] Runs \KeyGen from \CUASGenInt.
\item[$\langle \cred/\bot,\top/\bot \rangle \gets
  \langle \Obtain(\usk,\ipk,\attrs),\Issue(\isk,\upk,\attrs) \rangle$.]
  Runs the $\langle \Obtain,\Issue \rangle$ protocol from \CUASGenInt, using
  $\fissue^1$ as issuance function.
\item[$\langle 1/0,(\yeval,\utrans)/(0,\utrans)\rangle \gets \langle Show(\ipk,
  \attrs,\dattrs,\cred),
  \Verify(\ipk,\dattrs) \rangle$.]
  Runs the interactive $\langle\Sign,\Verify\rangle$ of \CUASGenInt,
  using $\feval^{\dattrs,F,V,L}$ as signature evaluation function, and
  $\finsp^F$ as open function. The \yeval value output by the verifier, when
  it accepts, is the $\yeval^0$ value produced by \Sign in \CUASGenInt.
\item[$h/\bot \gets RetrieveCredHandle(\osk,\utrans)$.]
  Gets $(\sig,\yeval^0)$ from the $\langle Show,\Verify\rangle$ transcript
  \utrans, and runs \Open from \CUASGenInt. This returns $(F(V,\cidi),
  F(V,\cidu))$, which the verifier can add to its revocation list $L$.
\end{description}

\paragraph{Security of \CUASRAC.} %
Our \CUASRAC construction is an anonymous and unforgeable revocable anonymous
credential scheme, according to the model in \figref{fig:model-rac}. For space
constraints, proofs are deferred to \appref{app:related-proofs}.

% \begin{theorem}[Anonymity of \CUASRAC]
%   If the base \CUASGenInt construction has signature anonymity according to
%   \defref{def:sign-anonymity-uas}, then \CUASRAC is an anonymous AC scheme
%   according to \cite{fhs19}.  
% \end{theorem}

% \begin{theorem}[Unforgeability of \CUASRAC]
%   If the base \CUASGenInt construction is unforgeable according to
%   \defref{def:forge-uas}, and $F$ is a one-way function, then \CUASRAC is an
%   unforgeable RAC scheme.
% \end{theorem}

\subsection{Multimodal Private Signatures}
\label{ssec:related-models-mps}

Multimodal Private Signatures (or, rather, a close relative, see next) are
directly implementable as a $(\fissue^{single,F,I},\feval^{g,MPS},
\finsp^{h,MPS})$-\CUASGen restriction. Concretely, this restricts to a system
with one credential per user and no attributes in the credentials.

There are some differences, though. On the one hand, our signature anonymity
property is somehow in the middle of MPS's privacy-1 and privacy-2 variants.
Their privacy-1 variant is the traditional anonymity property of group
signatures, in which the opener is honest and the adversary can call the opening
oracle except for challenge signatures. In their privacy-2 variant, the opener
is fully corrupt (i.e., \adv~ receives \osk), but the adversary can only be
challenged with signatures that produce the same \yinsp value ($G_{j_b}(id_b)$
in MPS). In our \UAS model, we allow the adversary to corrupt openers at will
(getting ther \osk), but the challenge signatures must have been generated using
the key of an uncorrupted opener; still, \adv~can call the open oracle for
challenge signatures, as long as they have the same \yinsp value. We believe
that these differences are mostly of theoretical interest, though. In practice,
what matters is that any variant of \feval and \finsp functions ($F$ and $G_j$
in MPS) that has too much granularity in their ranges, will lead to a barely
private system. This is a known issue, for instance, in functional encryption
\cite{bsw11}.

On the other hand, anonymous issuance and the capability to customize issuance
policies are unachievable by MPS. Anonymous issuance simply does not make sense
in MPS, as it only supports one credential (without attributes) per user, and
customized issuance is achieved in \UAS via the \fissue functions, with no
equivalent in MPS -- instead, MPS can be seen as having the fixed policy of
``proving knowledge of a user secret key''. These extensions are not trivial
from a modelling point of view, and also have a big impact in the practicality
of the resulting system. Also, MPS does not include verifiable openings. While
this is easy to add, we consider it to be essential, given that the proposed
generalization of opening allows the opener to output ``any value''. Hence, the
need to ensure that the produced value is the legitimate one, seems to be more
necessary than ever. Finally, our \feval function is a generalization of $F$ in
MPS, as it allows two outputs: one will be returned in the clear along with the
signature, and the other will be encrypted. Indeed, making part of the output
unencrypted allows implementing very useful variants such as anonymous
credentials with selective disclosure, as shown before.

For the model of MPS schemes, we refer to the original paper \cite{ngsy22}.

\subsubsection{\CUASMPS construction.} %
As mentioned, a $(\fissue^{single,F,I},\feval^{g,MPS},
\finsp^{h,MPS})$-restriction implements an MPS scheme where $F=\feval^{g,MPS}$
and $G=\finsp^{h,MPS}$. With these functions, the construction is direct.
\CUASMPS's setup runs \CUASGen's \Setup, \OKeyGen, and generates the issuer key
pair by running \KeyGen and \ISet (with $\fissue^{single,F,I}$). For MPS's join,
\CUASMPS runs first \KeyGen to generate the user key pair, and then proceeds as
in \CUASGen. \Sign, \Verify and \Open, are as in \CUASGen.
%
Finally, note that, in MPS, $G$ is further parameterized with a value $j$, which
essentially is the result of applying $F$ to the message and signer identity,
and is not leaked to the opener nor any other third party. The equivalent in
\UAS is the $\yeval^1$ value which, in \CUASGen, is encrypted with a single-use
key pair, and is an input of \finsp.

\paragraph{Security of \CUASMPS.} %
Our \CUASMPS construction satisfies the privacy-1, extractability,
unforgeability-1 and unforgeability-2 definitions of an MPS system, as modelled
in \cite{ngsy22}. For space constraints, proofs are deferred to
\appref{app:related-proofs}.

% \begin{theorem}[Privacy-1 of \CUASMPS]
%   If the base \CUASGen construction has signature anonymity according to
%   \defref{def:sign-anonymity-uas}, then \CUASMPS satisfies privacy-1
%   according to \cite{ngsy22}.
% \end{theorem}

% \begin{theorem}[Extractability of \CUASMPS]
%   If the base \CUASGen construction is unforgeable according to
%   \defref{def:forge-uas}, then it is an extractable MPS scheme.
% \end{theorem}

% \begin{theorem}[Unforgeability-1 of \CUASMPS]
%   If the base \CUASGen construction is unforgeable according to
%   \defref{def:forge-uas}, then \CUASMPS satisfies unforgeability-1 as
%   defined in \cite{ngsy22}.
% \end{theorem}

% \begin{theorem}[Unforgeability-2 of \CUASMPS]
%   If the base \CUASGen construction has non-frameability according to
%   \defref{def:frame-uas}, then \CUASMPS satisfies unforgeability-2 as
%   defined in \cite{ngsy22}.
% \end{theorem}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "uas-paper"
%%% End:
