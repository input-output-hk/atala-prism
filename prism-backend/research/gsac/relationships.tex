\section{Relationships with Other Schemes}
\label{sec:relationships}

% [11 pages max]

In the following, to showcase the generality of \UAS and \CUASGen, we reproduce
models of related schemes in the literature.
Then, we give concrete $(\fissue,\feval,\finsp)$-\CUASGen restrictions and prove
that they securely instantiate the models for the presented schemes, if the
corresponding \CUASGen restriction is a secure \UAS construction. For lack of
space, security proofs are deferred to \appref{app:related-proofs}.

For the described \CUASGen restrictions, we rely on the functions described in
\figref{fig:func-restrictions}. Observe that all the \fissue functions listed in
\figref{fig:func-restrictions} are \UAS-acceptable. Specifically, $\fissue^1$
and $\fissue^{\sring}$ are trivially \UAS-acceptable (for $\rngfissue = \bin$);
whereas $\fissue^{single,H,I}$ is \UAS-acceptable if $H$ is a secure PRF
\cite{kl14}.

\begin{figure}[ht!]
  \centering
  \scalebox{0.85}{
    \input{figures/functions.tex}
  }
  \caption{Functions for the \CUASGen restrictions described next.
    For readability, we use ``$\cdot$'' to denote input arguments that are
    ignored; and ``$\ast$'' to denote output values that can be set to anything
    (but should be ignored). $\bot$ means that the function fails.}
  \label{fig:func-restrictions}
\end{figure}

\subsection{Group Signatures}
\label{ssec:related-models-gs}

We adopt the model in \cite{bsz05}. In this abstraction, the opener returns an
index uniquely identifying the group member who created a signature, along with
a correctness proof. To ease exposition, we assume without loss of generality
that this index is just the public key that group members generate randomly
when joining the group\footnote{The user public key is
  assumed to be
  accessible from a public table in \cite{bsz05}, so it is easy to translate the
  public key into an index, if needed.}. A group signature scheme in
\cite{bsz05} is composed of $KeyGen$, \UKeyGen, \Sign, \Verify, \Open and
\Judge algorithms, and an $\langle\Obtain,\Issue\rangle$ interactive
protocol. Their intuition is similar to that of \UAS, so we refer to
\cite{bsz05} for detailed descriptions. For ease of reference, we replicate the
security games in \figref{fig:model-gs}.

\begin{figure}[ht!]
  \centering
  \scalebox{0.85}{      
    \begin{minipage}[t]{0.45\textwidth}        
      \procedure[linenumbering]{$\Exp^{anon-b}_{\adv,gs}(1^\secpar)$}{%
        (\gpk,\isk,\osk) \gets KeyGen(1^\secpar) \\
        d \gets \adv^{\mathcal{O}_{anon}}(\gpk,\isk) \\
        \pcreturn d 
      }
      
      \vspace*{3em}
      
      \procedure[linenumbering]{$\Exp^{frame}_{\adv,gs}(1^\secpar)$}{%
        (\gpk,\isk,\osk) \gets KeyGen(1^\secpar) \\
        (\msg,\sig,\upk,\tau) \gets \adv^{\mathcal{O}_{frame}}
        (\gpk,\osk,\isk) \\
        \pcif \Verify(\gpk,\msg,\sig) = 0: \pcreturn 0 \\
        \pcreturn \upk \in \HU \land \PRVUK[\upk] \neq \bot \land
        \Judge(\gpk,\upk,\msg,\sig,\tau) = 1~\land \\
        \pcind \adv~\textrm{did not query}~USK(\upk)~\textrm{or}~
        GSig(\PRVUK[\upk],\msg)
      }       
    \end{minipage}
  }
  \scalebox{0.85}{      
    \begin{minipage}[t]{.55\textwidth}
      \procedure[linenumbering]{$\Exp^{trace}_{\adv,gs}(1^\secpar)$}{%
        (\gpk,\isk,\osk) \gets KeyGen(1^\secpar) \\
        (\msg,\sig) \gets \adv^{\mathcal{O}_{trace}}(\gpk,\osk) \\
        \pcif \Verify(\gpk,\msg,\sig) = 0: \pcreturn 0 \\
        (\upk, \tau) \gets \Open(\gpk,\osk,\trans,\msg,\sig) \\
        \pcreturn \upk \notin \HU \cup \CU \lor \Judge(\gpk,\upk,\msg,\sig,\tau)
        = 0
      }       
    \end{minipage}      
  }
  \caption{Security games for group signatures \cite{bsz05}, only with minor    
    ``harmless'' edits to ease comparison with \CUASGS. Concretely, since we
    output {\upk}s instead of indexes, $i=0$ in the traceability game now reads
    $\upk \notin \HU \cup \CU$. For the oracles' definitions, check the
    referenced paper.
    $\mathcal{O}_{anon} \gets \lbrace \oracle{Ch},\oracle{Open},\oracle{SndToU},
    \oracle{WReg},\oracle{USK},\oracle{CrptU} \rbrace$,
    $\mathcal{O}_{trace} \gets \lbrace \oracle{SndToI},\oracle{AddU},
    \oracle{RReg},\oracle{GSig},\oracle{USK},\oracle{CrptU} \rbrace$,
    and $\mathcal{O}_{frame} \gets \lbrace \oracle{SndToU},\oracle{WReg},
    \oracle{GSig},\oracle{USK},\oracle{CrptU} \rbrace$.
  }
  \label{fig:model-gs}  
\end{figure}

\subsubsection{\CUASGS construction.} %
We show that a $(\fissue^{single,H,I},\feval^0,\finsp^{\upk})$-\CUASGen
restriction is a secure group signature scheme according to \cite{bsz05}.
As stated, $\fissue^{single,H,I}$ is an \UAS-acceptable function if $H$ is a
PRF, as its output is a random-looking string that depends on the user public
key \upk, and a string $I$ uniquely identifying the issuer. Thus, it is the same
per $(I,\upk)$ pair, and can be used by issuer $I$ to prevent issuing more than
one credential per user. Basically, the issuer keeps a list of received
$\yissue = H(I,\upk)$ values, and rejects issuing a credential for already
existing ones. From this, the GS algorithms are as follows:

\begin{description}
\item[$(\gpk,\isk,\osk) \gets KeyGen(1^\secpar)$.] Runs \Setup from \CUASGen,
  and two instances of \KeyGen. One followed by \ISet with $\fissue^{single,H,
    I}$ for the same user, who will be the issuer; and another for a different
  user, who will be the opener, followed with \OKeyGen with $\finsp^{\upk}$.
  Assigns the public keys to \gpk.
\item[$(\upk,\usk) \gets \UKeyGen(1^\secpar)$.] Runs \KeyGen from \CUASGen.
\item[$\langle \cred,\utrans \rangle \gets
  \langle\Obtain(\usk,\ipk),\Issue(\isk,\upk)\rangle$.] Runs $\langle\Obtain,
  \Issue\rangle$ as in \CUASGen, with $\attrs \gets \emptyset$. Upon receiving
  the \yissue value, the issuer checks if it already exists in a list $L$
  (initially set to $\emptyset$); if it exists, aborts issuance. Otherwise, it
  completes the protocol and adds $\yissue$ to $L$. It is responsibility of the
  issuer to maintain $L$.
\item[$\sig \gets \Sign(\gpk,\cred,\msg)$.] Parses \gpk as $(\ipk,\opk)$, and
  runs $(\sig,0) \gets \Sign(\usk,\opk,\cred,\msg,\feval^0)$ from \CUASGen,
  where $\yeval = 0$ is the constant output of $\feval^0$.
\item[$1/0 \gets \Verify(\gpk,\sig,\msg)$.] Parses \gpk as $(\ipk,\opk)$, and
  returns whatever $\Verify(\opk,\ipk,\sig,0,\msg,\feval^0)$ from \CUASGen
  outputs.
\item[$(\upk,\pi) \gets \Open(\gpk,\osk,\trans,\sig,\msg)$.] Parses \gpk as
  $(\ipk,\opk)$, and returns whatever \CUASGen outputs in $\Open(\osk,\ipk,\sig,
  0,\msg,\feval^0)$, which internally runs $\finsp^{\upk}$.
\item[$1/0 \gets \Judge(\gpk,\pi,\upk,\sig,\msg)$.] Parses \gpk as $(\ipk,
  \opk)$, and returns whatever \CUASGen outputs in $\Judge(\opk,\upk,\pi,\sig,
  0,\msg)$.
\end{description}

% \paragraph{Security of \CUASGS.} %
% Our \CUASGS construction is an anonymous, traceable, and non-frameable group
% signature scheme, according to the model in \cite{bsz05}. For space constraints,
% proofs are deferred to \appref{app:related-proofs}.

% \begin{theorem}[Anonymity of \CUASGS]
%   If the base \CUASGen construction has signature anonymity according to
%   \defref{def:sign-anonymity-uas}, then \CUASGS is an anonymous group signature
%   scheme.
% \end{theorem}

% \begin{theorem}[Traceability of \CUASGS]
%   If the base \CUASGen construction is unforgeable according to
%   \defref{def:forge-uas}, then \CUASGS is a traceable group signature scheme.
% \end{theorem}

% \begin{theorem}[Non-frameability of \CUASGS]
%   If the base \CUASGen construction is non-frameable according to
%   \defref{def:frame-uas}, then \CUASGS is a non-frameable group signature
%   scheme.
% \end{theorem}

\subsection{Ring Signatures}
\label{ssec:related-models-rs}

We adopt the model in \cite{bkm06}, where security of ring signatures is
defined according to the games in \figref{fig:model-rs}. A ring signature
scheme consists of three algorithms $(KeyGen,Sign,Verify)$. Roughly,
$((\pk_1,\sk_1),\dots,(\pk_n,\sk_n)) \gets KeyGen(1^\secpar)$ produces $n$
signing key pairs, $\sig \gets Sign(\sk_i,R,\msg)$ creates a signature for
anonymity set $R \subseteq \lbrace \pk_1, \dots, \pk_t \rbrace$, using secret
key $\sk_i$, associated to some $\pk_i \in R$; and $1/0 \gets Verify(R,\sig,
\msg)$ checks if \sig is a valid signature over \msg for ring $R$. We refer
to \cite{bkm06} for details on the syntax and definitions.

\begin{figure}[ht!]
  \centering
  \scalebox{0.85}{      
    \begin{minipage}[t]{0.55\textwidth}        
      \procedure[linenumbering]{$\Exp^{anon-b}_{\adv,rs}(1^\secpar)$}{%
        ((\pk_1,\sk_1),\dots,(\pk_n,\sk_n)) \gets KeyGen(1^\secpar) \\
        (i_0,i_1,R,\msg,\st) \gets \adv^{\oracle{Sign}}(\pk_1,\dots,\pk_n) \\
        \pcif R \not\subseteq \lbrace \pk_i \rbrace_{i\in[n]} \lor
        \lbrace \pk_{i_0},\pk_{i_1} \rbrace \not\subseteq R~\lor \\ %\\
        \pcind i_0 = i_1: \pcreturn \bot \\
        \sig \gets Sign(\sk_{i_b},R,\msg) \\
        b^* \gets \adv(\sig,\st) \\
        \pcreturn b^*
      }        
    \end{minipage}
  }
  \scalebox{0.85}{      
    \begin{minipage}[t]{.5\textwidth}
      \procedure[linenumbering]{$\Exp^{forge}_{\adv,rs}(1^\secpar)$}{%
        ((\pk_1,\sk_1),\dots,(\pk_n,\sk_n)) \gets KeyGen(1^\secpar) \\
        (R,\sig,\msg) \gets \adv^{\oracle{Sign},\oracle{Corr}}
        (\pk_1,\dots,\pk_n) \\
        \pcif Verify(R,\sig,\msg) = 0: \pcreturn 0 \\
        \pcreturn (R \subseteq \lbrace \pk_i \rbrace_{i\in[n]} \setminus
        CU~\land \\
        \pcind \adv~\textrm{never queried}~\oracle{Sign}(\cdot,R,\msg))
      }       
    \end{minipage}      
  }
  \caption{Security games for ring signatures \cite{bkm06}. The $\oracle{Sign}$
    oracle accepts $(i,R,\msg)$ tuples, with $pk_i \in R$, adds the tuple to a
    list of queries, and returns $\sig \gets Sign(\sk_i,R,\msg)$.
    $\oracle{Corr}$ accepts an index $i$, and leaks $\sk_i$. Corrupted users are
    added to $CU$.}
  \label{fig:model-rs}  
\end{figure}


\subsubsection{\CUASRing Construction.} %
We use a $(\fissue^{\sring},\feval^{\sring,\dattrs},\finsp^0)$-restriction
of \CUASGenHideIss to build a ring signature scheme in the model given in
\figref{fig:model-rs}. Briefly, users self-issue credentials where the
attributes are (encodings of) the public keys of the users in the system --
including their own public key. Then, a ring signature is just a
\CUASGenHideIss signature that reveals a subset of the attributes -- i.e., a
subset of the keys of the users in the system. The construction
is as follows:

% \begin{align}
%   & \NIZKRel_{\Sign}^{prv} \coloneqq \lbrace (\usk,\cred,\yeval^1,\yinsp,r,r',
%     \ipk),(\msg,\feval,\yeval^0,\ceval,\cinsp,\Eek,\widetilde{\Eek},\sring): \nonumber \\
%   & \hspace*{6.405em}\ceval = \EEnc(\widetilde{\Eek},\yeval^1;r) \land
%     \cinsp = \EEnc(\Eek,\yinsp;r') \land \nonumber \\
%   & \hspace*{6.40em}(\yeval^0,\yeval^1) = \feval(\usk,\cred,\msg) \land
%     \yinsp = \finsp((\yeval^0,\yeval^1),\usk,\cred,\msg) \nonumber \\
%   & \hspace*{6.40em}\exists \ipk \in \sring~\suchthat~\SBCMVerify(\ipk,\cred,\usk,
%     \sring) = 1) \rbrace \label{eq:sign-prv}
% \end{align}

% From it, we show that the $(\fissue^{\sring},\feval^{\attrs},\finsp^0)$-
% $\CUASGen^{\Sign-prv}$ restriction, is a secure ring signature scheme. We
% restrict to one credential per signature.

\begin{description}
%\item[$\parm \gets \Setup(\secpar,\AttrSpace)$.] As in \CUASGenHideIss.
\item[$((\pk_1,\sk_1),...,(\pk_n,\sk_n)) \gets KeyGen(\secpar)$.] Runs
  $\parm \gets \Setup(\secpar)$ from \CUASGenHideIss. For each of
  the $i \in [n]$ users to generate, run $(\upk_i,\usk_i) \gets \KeyGen(\parm)$,
  and $\ipk_i \gets \ISet((\upk_i,\usk_i),\fissue^{\sring})$, where $\sring =
  \lbrace \upk_i \rbrace_{i\in[n]}$. Run also $(\opk,\osk) \gets \OKeyGen(\parm,
  \finsp^0)$. Set $\pk_i \gets (\ipk_i,\opk)$ and $\sk_i \gets \usk_i$, for
  $i\in[n]$.
\item[$\Sig \gets \Sign(\sk_i,R,\msg).$]
  The signing user, with $\sk_i=\usk$ and $\pk_i=(\ipk_i,\opk)$ for some $i \in
  [n]$ where $\pk_i \in R$, first acts both as user and issuer to self-issue a
  credential \Cred over an attribute set \attrs such that $\attrs = \sring$. The
  user picks some \dattrs such that $\dattrs \subseteq [|\attrs|]$, and computes
  the ring signature by running $\Sig = (\sig,\yeval) \gets
  \Sign(\usk,\opk,\Cred,\msg,\feval^{\sring,\dattrs})$ from
  \CUASGenHideIss. Note that \dattrs defines the public keys within
  $\attrs = \sring$ to be revealed through \yeval.
\item[$1/0 \gets Verify(R,\Sig,\msg)$.] Parses \Sig as $(\sig,\yeval)$ and
  runs $\Verify(\opk,\yeval,\Sig,\msg,\feval^{\sring,\dattrs})$ as in
  \CUASGenHideIss. Note that, in valid signatures, $\yeval = \lbrace
  \ipk_i\rbrace_{i\in\dattrs}$.
\end{description}

%Note that by using, e.g., $\finsp^{\upk}$, we essentially get a ring signature
%scheme with linkability via an opener.

% \paragraph{Security of \CUASRing.} %
% Our \CUASRing construction is an anonymous and unforgeable ring signature
% scheme, according to the model in \cite{bkm06}. For space constraints,
% proofs are deferred to \appref{app:related-proofs}.

% \begin{theorem}[Anonymity of \CUASRing]
%   If the base \CUASGenHideIss construction has signature anonymity
%   according to \defref{def:sign-anonymity-uas}, then \CUASRing is an anonymous
%   ring signature scheme.
% \end{theorem}

% \begin{theorem}[Unforgeability of \CUASRing]
%   If the base \CUASGenHideIss construction is non-frameable according to
%   \defref{def:frame-uas}, then \CUASRing is an unforgeable ring signature
%   scheme.
% \end{theorem}

\subsection{Anonymous Credentials}
\label{ssec:related-models-ac}

We adopt the model in \cite{fhs19} for anonymous credentials with selective
disclosure, which restricts to one credential per presentation. Therein, an
anonymous credential scheme is defined via $OrgKeyGen$ (which we rename to
$IssKeyGen$), and $UserKeyGen$ algorithms, and $\langle Obtain,Issue\rangle$
and $\langle Show,Verify \rangle$ interactive protocols. We
refer to \cite{fhs19} for the full details. For readability, we give
the security definitions in \figref{fig:model-ac}.% , with inocuous
% adaptations to make them more suitable for comparison with our definitions --
% namely, we explicitly add a common setup process which is part of $IssKeyGen$
% in \cite{fhs19}.

\begin{figure}[ht!]
  \centering
  \scalebox{0.85}{      
    \begin{minipage}[t]{0.5\textwidth}        
      \procedure[linenumbering]{$\Exp^{anon-b}_{\adv,ac}(1^\secpar)$}{%
 %       \parm \gets \Setup(1^\secpar) \\
        (\ipk,\isk) \gets IssKeyGen(1^\secpar) \\        
        b^* \gets \adv^{\oracle{HU},\oracle{CU},\oracle{Obtain},
          \oracle{Show},\oracle{LoR}}(\isk) \\
        \pcreturn b^*
      }        
    \end{minipage}
  }
  \scalebox{0.85}{      
    \begin{minipage}[t]{.5\textwidth}
      \procedure[linenumbering]{$\Exp^{forge}_{\adv,ac}(1^\secpar)$}{%
%        \parm \gets \Setup(1^\secpar) \\
        (\ipk,\isk) \gets IssKeyGen(1^\secpar) \\        
        (D,\st) \gets \adv^{\oracle{HU},\oracle{CU},\oracle{ObtIss},
          \oracle{Issue},\oracle{Show}}(\ipk) \\
        \langle \cdot,(b,\utrans) \rangle
        \gets \langle \adv(\st),\Verify(\ipk,D) \rangle \\
        \pcreturn (b = 1 \land \nexists j~\suchthat \\
        \pcind (\OWNR[j] \in \CU
        \land D \subseteq \ATTR[j])) % \forall j, \OWNR[j] \in \CU
        % \implies D \not\subseteq \ATTR[j]: \\
        %\pcind \pcreturn 1 \\
        %\pcreturn 0
      }       
    \end{minipage}      
  }
  \caption{Games for anonymous credentials with selective disclosure
    \cite{fhs19}. \OWNR, \ATTR, and the oracles, are essentially as in
    \UAS. \adv~wins $\Exp^{forge}_{\adv,ac}$ if it authenticates successfully
    while revealing attributes not contained in adversarially controlled
    credentials.}
  \label{fig:model-ac}  
\end{figure}

\subsubsection{\CUASAC Construction.} %
We build a secure anonymous credential scheme directly from a
$(\fissue^1,\feval^{\dattrs},\finsp^0)$-\CUASGenInt restriction.

\begin{description}
% \item[$\parm \gets \Setup(1^\secpar)$.] Runs $\parm' \gets \Setup(1^\secpar,
%   \AttrSpace)$ and $(\opk,\osk) \gets \OKeyGen(\parm',\finsp^0)$ from our
%   \CUASGen construction. Returns $\parm \gets (\parm',\opk)$.
\item[$(\ipk,\isk) \gets IssKeyGen(\parm)$.] From \CUASGenInt, run $\parm'
  \gets \Setup(1^\secpar)$ and $(\opk,\osk) \gets \OKeyGen(\parm',
  \finsp^0)$, and set $\parm \gets (\parm',\opk)$. Run $(\upk,\usk) \gets
  \KeyGen(\parm')$ and $\ipk \gets \ISet(\upk,\usk,\fissue^1)$. Set $\isk \gets
  \usk$.
\item[$(\upk,\usk) \gets UserKeyGen(\ipk)$.] Runs \KeyGen from \CUASGenInt.
\item[$\langle \cred/\bot,\top/\bot \rangle \gets
  \langle \Obtain(\usk,\ipk,\attrs),\Issue(\isk,\upk,\attrs) \rangle$.]
  Runs $\langle \Obtain,\Issue \rangle$ from \CUASGenInt.
\item[$\langle 1/0,((\yeval,\utrans)/(0,\utrans)\rangle
  \gets \langle Show(\ipk,\attrs,\dattrs,
  \cred),\Verify(\ipk,\dattrs) \rangle$.]
  Runs the interactive $\langle \Sign, \Verify\rangle$ of  \CUASGenInt,
  using $\feval^{\dattrs}$ as evaluation function, and $\finsp^0$ as
  open function, with \opk from \parm as opener public key. The \yeval value
  output by \Verify, when it accepts, is the $\yeval^0$ value output by
  \Sign in \CUASGenInt.
\end{description}

% \paragraph{Security of \CUASAC.} %
% Our \CUASAC construction is an anonymous and unforgeable anonymous credential
% scheme, according to the model in \cite{fhs19}. For space constraints,
% proofs are deferred to \appref{app:related-proofs}.

% \begin{theorem}[Anonymity of \CUASAC]
%   \label{thm:anon-cuasac}
%   If the base \CUASGenInt construction has signature anonymity according to
%   \defref{def:sign-anonymity-uas}, then \CUASAC is an anonymous AC scheme
%   according to \cite{fhs19}.
% \end{theorem}

% \begin{theorem}[Unforgeability of \CUASAC]
%   \label{thm:forge-cuasac}
%   If the base \CUASGenInt construction is unforgeabile according to
%   \defref{def:forge-uas}, then \CUASAC is an unforgeable AC scheme.
% \end{theorem}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "uas-paper"
%%% End:
