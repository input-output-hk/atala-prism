\section{Preliminaries}
\label{sec:preliminaries}

% [3 pages max; 1.5 prelim, 1.5 GSAC]

%\subsection{Cryptographic Building Blocks}
%\label{ssec:cryptobblocks}

Next we introduce the main building blocks we use in our constructions. More
detailed definitions and references appear in
\appref{app:crypto-building-blocks}.

% \paragraph{Digital Signatures.} %
% Defined as a tuple (\SSetup,\SKeyGen,\SSign,\SVerify). Algorithm $\parm \gets
% \SSetup(\secpar)$ produces public parameters for the other algorithms.
% $(\vk,\sk) \gets \SKeyGen(\parm)$ generates the verification-signing key
% pair, algorithm $\sig \gets \SSign(\sk,\msg)$ signs message \msg with
% signing key \Ssk, producing signature \Ssig, and $1/0 \gets \SVerify(\vk,
% \sig,\msg)$ checks whether \Ssig is a valid signature over \msg, under
% verification key \Svk. We rely on existentially unforgeable digital signature
% schemes.

\paragraph{Public-Key Encryption.} %
Defined as a tuple (\ESetup,\EKeyGen,\EEnc,\EDec). Algorithm $\parm \gets
\ESetup(\secpar)$ produces public parameters for the other algorithms.
$(\ek,\dk) \gets \EKeyGen(\parm)$ generates the encryption-decryption key
pair, algorithm $\Ec \gets \EEnc(\ek,\msg)$ encrypts message \msg with
encryption key \ek, producing ciphertext \Ec, and $\msg/\bot \gets \EDec(\dk,
\Ec)$ decrypts ciphertexts using decryption key \Edk. We rely on IND-CCA
public-key encryption schemes.

% \paragraph{(Block) Commitment Schemes.} %
% Defined as a tuple (\CSetup,\CCommit). Algorithm $\parm \gets
% \CSetup(\secpar)$ produces the parameters for committing to values. $\Ccom
% \gets \CCommit(\parm, \smsg; r)$ produces a commitment \Ccom over a set of
% messages \smsg, using randomness $r$ (which we may omit when explicitly
% stating it is not necessary). We will further use commitment schemes that
% allow committing to vectors of messages. Therein, the \CCommit algorithm simply
% receives a block of messages. In both cases, we require hiding and binding
% (block) commitment schemes.

\paragraph{Non-Interactive Zero-Knowledge.} %
We use non-interactive zero-knowledge proofs of knowledge (NIZK), in the CRS
model. Informally, a NIZK scheme over an NP relation \NIZKRel is defined as a
tuple ($\NIZKSetupRel$,$\NIZKProveRel$,$\NIZKVerify^\NIZKRel$).
Algorithm $\NIZKcrs \gets \NIZKSetupRel(\secpar)$ produces the common
reference string \NIZKcrs. $\NIZKproof/\bot \gets \NIZKProveRel(\NIZKcrs,
\NIZKx,\NIZKw)$ creates a NIZK proof of knowledge of witness \NIZKw for \NIZKx
such that $(\NIZKw,\NIZKx) \in \NIZKRel$. $1/0 \gets \NIZKVerifyRel
(\NIZKcrs,\NIZKx,\NIZKproof)$ verifies the proof. Within NIZK systems, we
further need schemes that provide simulation-extractability, which in a nutshell
means that no adversary can produce a proof from which we cannot extract a
witness, even after seeing polynomially many simulated proofs. To model
simulation-extractable NIZKs, we further need algorithms \NIZKSimSetup,
\NIZKSim, and \NIZKExtract, that allow simulating proofs and extracting
witnesses. The properties we build on are completeness, soundness,
zero-knowledgeness, and simulation-extractability.

\paragraph{Signatures over Blocks of Committed Messages, with proofs.} %
We use signature schemes that allow signing blocks of messages, and commitments
to blocks of messages, and which are furthermore compatible with (efficient)
proof systems over the produced signature and signed (commitments to) messages.
We define such schemes as a tuple (\SBCMSetup, \SBCMKeyGen,
\SBCMBlind, \SBCMSign, \SBCMUnblind, \SBCMVerify).
%
Algorithm $\parm \gets \SBCMSetup(\secpar)$ produces the public parameters for
the scheme.
% 
$(\vk,\sk) \gets \SBCMKeyGen(\parm)$ produces a verification-signing key pair.
%
$(\Ccom,\pi,r) \gets \SBCMBlind^{\NIZKRel}(\vk,\osmsg,\smsg;x',w')$ is run by a
user to request a signature over $\osmsg \cup \smsg$, where \smsg are revealed
to the signer, but \osmsg are signed in committed form.
Moreover, \osmsg (and, possibly, $w'$) are witnesses to some statement defined
over \smsg (and, possibly, $x'$), for a relationship \NIZKRel.
%
$\bsig \gets \SBCMSign^{\NIZKRel}(\sk,\Ccom,\pi,\smsg; x')$ is run by the
signer, to produce a partial signature \bsig over a set of committed
messages \osmsg and set \smsg, satisfying relation \NIZKRel.
%
$\sig \gets \SBCMUnblind^{\NIZKRel}(\vk,\bsig,\Ccom,r,\osmsg,\smsg)$ is
run by the user to complete a partial signature \bsig received by the
signer.
%
Finally, algorithm $1/0 \gets \SBCMVerify(\vk,\sig,\osmsg,\smsg)$ verifies a
signature \sig over message vector $\osmsg \cup \smsg$.
%
In addition, the produced signatures must be compatible with (efficient) NIZK
proofs of knowledge of a signature, and of (arbitrary) claims over the signed
(committed) messages. An \SBCM scheme must provide one-more-forgery type of
security.

\subsection{Notation}
\label{ssec:notation}

We follow common notation habits. $y \gets A(x)$ means that algorithm $A$, on
input $x$, produces output $y$. When $A$ is a probabilistic process, and we want
to make explicit the randomness $r$, we use $y \gets A(x;r)$. $\langle y_A,y_B
\rangle \gets \langle A(x_A),B(x_B)\rangle$ denotes algorithms $A$ and $B$,
running an interactive protocol, where $A$ receives $x_A$ as input and produces
$y_A$ as output, and $B$ receives $x_B$ and produces $y_B$.
%
Our generic constructions rely on the previously defined building blocks, which
share common (but different)
tokens: e.g., we resort to several NIZK proofs instances. To distinguish
them, we may use subscripts or superscripts: e.g., $\NIZKRel_A$ denotes the
NP relation used within some algorithm $A$, $\NIZKSetupRel$ means that
the setup algorithm of an underlying NIZK system is performed associated to
relation $\NIZKRel$; $\parm_X$ are the public parameters for scheme $X$, etc.
Similarly, schemes algorithms are prefixed with acronyms identifying the scheme
(e.g., \ESetup, \NIZKSetup), which we may omit when clear from context.
Variables written in bold font denote sets, e.g., while we use \ipk to denote a
single issuer public key, \sipk denotes a set of issuer's public keys --
although, when needed, we use explicit notation $\lbrace \ipk_i
\rbrace_{i\in[n]}$.
%
We also assume the existence of a well defined attribute space over which
issuers in our schemes can issue credentials on. We denote this set with
\AttrSpace.
%
$0(p)$ returns $True$ if $p=0$, or $False$ otherwise.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "uas-paper"
%%% End:
