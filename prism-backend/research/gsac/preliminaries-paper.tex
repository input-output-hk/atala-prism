\section{Preliminaries}
\label{sec:preliminaries}

% [3 pages max; 1.5 prelim, 1.5 GSAC]

%\subsection{Cryptographic Building Blocks}
%\label{ssec:cryptobblocks}

Next we introduce the main building blocks we will be using in our
constructions. More detailed definitions and references appear in
\appref{app:crypto-building-blocks}.

\paragraph{Digital Signatures.} %
Defined as a tuple (\SSetup,\SKeyGen,\SSign,\SVerify). Algorithm $\parm \gets
\SSetup(\secpar)$ produces public parameters for the other algorithms.
$(\vk,\sk) \gets \SKeyGen(\parm)$ generates the verification-signing key
pair, algorithm $\sig \gets \SSign(\sk,\msg)$ signs message \msg with
signing key \Ssk, producing signature \Ssig, and $1/0 \gets \SVerify(\vk,
\sig,\msg)$ checks whether \Ssig is a valid signature over \msg, under
verification key \Svk. We rely on existentially unforgeable digital signature
schemes.

\paragraph{Public-Key Encryption.} %
Defined as a tuple (\ESetup,\EKeyGen,\EEnc,\EDec). Algorithm $\parm \gets
\ESetup(\secpar)$ produces public parameters for the other algorithms.
$(\ek,\dk) \gets \EKeyGen(\parm)$ generates the encryption-decryption key
pair, algorithm $\Ec \gets \EEnc(\ek,\msg)$ encrypts message \msg with
encryption key \Eek, producing ciphertext \Ec, and $\msg/\bot \gets \EDec(\dk,
\Ec)$ decrypts ciphertexts using decryption key \Edk. We rely on IND-CCA
public-key encryption schemes.

\paragraph{(Block) Commitment Schemes.} %
Defined as a tuple (\CSetup,\CCommit). Algorithm $\parm \gets
\CSetup(\secpar)$ produces the parameters for committing to values. $\Ccom
\gets \CCommit(\parm, \smsg; r)$ produces a commitment \Ccom over a set of
messages \smsg, using randomness $r$ (which we may omit when explicitly
stating it is not necessary). We will further use commitment schemes that
allow committing to vectors of messages. Therein, the \CCommit algorithm simply
receives a block of messages. In both cases, we require hiding and binding
(block) commitment schemes.

\paragraph{Non-Interactive Zero-Knowledge.} %
We use non-interactive zero-knowledge proofs of knowledge (NIZK), in the CRS
model. Informally, a NIZK scheme over an NP relation \NIZKRel is defined as a
tuple ($\NIZKSetupRel$,$\NIZKProveRel$,$\NIZKVerify^\NIZKRel$).
Algorithm $\NIZKcrs \gets \NIZKSetupRel(\secpar)$ produces the common
reference string \NIZKcrs. $\NIZKproof/\bot \gets \NIZKProveRel(\NIZKcrs,
\NIZKx,\NIZKw)$ creates a NIZK proof of knowledge of witness \NIZKw for \NIZKx
such that $(\NIZKw,\NIZKx) \in \NIZKRel$. $1/0 \gets \NIZKVerifyRel
(\NIZKcrs,\NIZKx,\NIZKproof)$ verifies the proof. Within NIZK systems, we
further need schemes that provide simulation-extractability, which in a nutshell
means that no adversary can produce a proof from which we cannot extract a
witness, even after seeing polynomially many simulated proofs. To model
simulation-extractable NIZKs, we further need algorithms \NIZKSimSetup,
\NIZKSim, and \NIZKExtract, that allow simulating proofs and extracting
witnesses. The properties we build on are completeness, soundness,
zero-knowledgeness, and simulation-extractability.

\paragraph{Signatures over Blocks of Committed Messages, with proofs.} %
We use signature schemes that allow signing blocks of messages, or commitments
to blocks of messages, and which are furthermore compatible with (efficient)
proof systems over the produced signature and signed (commitments to) messages.
For this purpose, we define such schemes as a tuple (\SBCMSetup,\SBCMKeyGen,
\SBCMCom,\SBCMSign,\SBCMVerify). Algorithm $\parm \gets \SBCMSetup(\secpar)$
produces the public parameters for the scheme. %
$(\vk,\sk) \gets \SBCMKeyGen(\parm)$ produces a verification-signing
key pair. $\sig/\bot \gets\langle \SBCMCom^{\NIZKRel}(\vk,\overline{\smsg},
\smsg,(x,w)),\SBCMSign^\NIZKRel(\sk,\smsg,x) \rangle$ is an interactive protocol
between a user, who runs \SBCMCom and has a set of messages $\overline{\smsg}$
to be block-committed, and a signer, who owns signing key \sk; both also receive
common input a block of messages \smsg. In addition, the user knows a pair
$(x,w) \in \NIZKRel$, and proves (in zero-knowledge) knowledge of $w$ to the
signer. The output of the protocol is a signature over
$\overline{\smsg} \cup \smsg$. Algorithm $1/0 \gets \SBCMVerify(\vk,
\sig,\overline{\smsg},\smsg)$ verifies a signature \sig over message vector
$\overline{\smsg} \cup \smsg$. In addition, the
produced signatures must be compatible with (efficient) NIZK proofs of knowledge
of a signature, and of (arbitrary) claims over the signed (committed) messages.
An \SBCM scheme must provide one-more-forgery type of security.

\subsection{Notation}
\label{ssec:notation}

We follow common notation habits. $y \gets A(x)$ means that algorithm $A$, on
input $x$, produces output $y$. When $A$ is a probabilistic process, and we want
to make explicit the randomness $r$, we use $y \gets A(x;r)$. $\langle y_A,y_B
\rangle \gets \langle A(x_A),B(x_B)\rangle$ denotes algorithms $A$ and $B$,
running an interactive protocol, where $A$ receives $x_A$ as input and produces
$y_A$ as output, and $B$ receives $x_B$ and produces $y_B$.
%
Our generic constructions rely on the previously defined building blocks, which
share common (but different)
tokens: e.g., we will resort to several NIZK proofs instances. To distinguish
them, we may use subscripts or superscripts: e.g., $\NIZKRel_A$ denotes the
NP relation used within some algorithm $A$, $\NIZKSetupRel$ means that
the setup algorithm of an underlying NIZK system is performed associated to
relation $\NIZKRel$; $\SBCMparm$ are the public parameters for an \SBCM scheme,
and $\Eparm$ are the public parameters for an encryption scheme, etc. Variables
written in bold font denote sets, e.g., while we use \ipk to denote a single
issuer public key, \sipk denotes a set of issuer's public keys. To refer to
a specific element of a set, we use sub-indexes, e.g., $\sipk_i$ is the $i$-th
\ipk within \sipk.
%
We also assume the existence of a well defined attribute space over which
issuers in our schemes can issue credentials on. We denote this set with
\AttrSpace.
%
Except when otherwise stated, we assume that, given a credential \cred, the
public key of its issuer, $\ipk_{\cred}$ can be retrieved. Similarly, the
attribute set contained in a credential \cred is denoted $\attrs_{\cred}$.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "uas-paper"
%%% End:
