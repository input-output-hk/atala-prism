\section{\UAS-Based Instantiations of Related Schemes}
\label{app:related-models}

In the following subsections we reproduce models of related schemes in the
literature. Then, we give concrete \fissue, \feval and \finsp functions that
make \UAS mimic their functionality. Finally, we prove for each case that
\UAS -- restricted with the corresponding functions -- indeed meets their
security models, thus proving that \UAS is a generalization of all of them.

\subsection{Group Signatures}
\label{sapp:related-models-gs}

We adopt the model in \cite{bsz05}. In this abstraction
of group signatures, the opener returns an index uniquely identifying the group
member that created a signature, along with a correctness proof. For ease of
exposition, assume that, w.l.o.g., this index is just the public key that the
group member chooses when joining the group\footnote{The user public key is
  assumed to be accessible from a public table in \cite{bsz05}, so it is direct
  to translate the public key into an index, if needed.}. A group signature
scheme, according to \cite{bsz05}, is composed of $KeyGen$, \UKeyGen, \Sign,
\Verify, \Open and \Judge algorithms, as well as an $\langle\Obtain,\Issue
\rangle$ interactive protocol. Their description is very similar to that of
\GSAC, so we refer to \cite{bsz05} for detailed descriptions. For ease of
reference, we replicate the security games in \figref{fig:model-gs}.

\begin{figure}[ht!]
  \centering
  \scalebox{0.9}{      
    \begin{minipage}[t]{0.45\textwidth}        
      \procedure[linenumbering]{$\Exp^{anon-b}_{\adv,gs}(1^\secpar)$}{%
        (\gpk,\isk,\osk) \gets KeyGen(1^\secpar) \\
        d \gets \adv^{\mathcal{O}^{anon}}(\gpk,\isk) \\
        \pcreturn d 
      }
      
      \vspace*{5em}
      
      \procedure[linenumbering]{$\Exp^{frame}_{\adv,gs}(1^\secpar)$}{%
        (\gpk,\isk,\osk) \gets KeyGen(1^\secpar) \\
        (\msg,\sig,\upk,\tau) \gets \adv^{\mathcal{O}^{frame}}
        (\gpk,\osk,\isk) \\
        \pcif \Verify(\gpk,\msg,\sig) = 0: \pcreturn 0 \\
        \pcreturn 1~\pcif \upk \in \HU \land \PRVUK[\upk] \neq \bot \land
        \Judge(\gpk,\upk,\msg,\sig,\tau) = 1~\land \\
        \pcind \adv~\textrm{did not query}~USK(\upk)~\textrm{or}~
        GSig(\PRVUK[\upk],\msg) \\
        \pcreturn 0
      }       
    \end{minipage}
  }
  \scalebox{0.9}{      
    \begin{minipage}[t]{.55\textwidth}
      \procedure[linenumbering]{$\Exp^{trace}_{\adv,gs}(1^\secpar)$}{%
        (\gpk,\isk,\osk) \gets KeyGen(1^\secpar) \\
        (\msg,\sig) \gets \adv^{\mathcal{O}^{trace}}(\gpk,\osk) \\
        \pcif \Verify(\gpk,\msg,\sig) = 0: \pcreturn 0 \\
        (\upk, \tau) \gets \Open(\gpk,\osk,\trans,\msg,\sig) \\
        \pcif \upk \notin \HU \cup \CU \lor \Judge(\gpk,\upk,\msg,\sig,\tau)
        = 0: \\ 
        \pcind \pcreturn 1 \\
        \pcreturn 0
      }       
    \end{minipage}      
  }
  \caption{Security games for group signatures \cite{bsz05}, only with minor    
    ``harmless'' edits to compare easier with \CUASGS. Concretely, since we
    output {\upk}s instead of indexes, $i=0$ in the traceability game now reads
    $\upk \notin \HU \cup \CU$. For the oracles' definitions, check the
    referenced paper.
    $\mathcal{O}^{anon} \gets \lbrace Ch,Open,SndToU,WReg,USK,CrptU \rbrace$,
    $\mathcal{O}^{trace} \gets \lbrace SndToI,AddU,RReg,GSig,USK,CrptU \rbrace$,
    and $\mathcal{O}^{frame} \gets \lbrace SndToU,WReg,GSig,USK,CrptU \rbrace$.
  }
  \label{fig:model-gs}  
\end{figure}

\subsubsection{\CUASGS construction.} %
We show that, as specified in \tabref{tab:uas-alt-funcs}, our \CUASGen
construction for \UAS, restricted to $\fissue^1$ as issuance function,
$\feval^0$ as signature evaluation function, and $\finsp^{\upk}$ as opening
function, is a secure group signature scheme according to the \cite{bsz05}
model. We first quickly define the algorithms, and then prove security.

\begin{description}
\item[$(\gpk,\isk,\osk) \gets KeyGen(1^\secpar)$.] Runs the \Setup algorithm
  of \CUASGen, and one instance of \IKeyGen and \OKeyGen. Assigns the public
  keys to \gpk.
\item[$(\upk,\usk) \gets \UKeyGen(1^\secpar)$.] Runs \UKeyGen from \CUASGen, and
  computes $\CCommit(\usk;0)$ as \upk.
\item[$\langle \cred,\utrans \rangle \gets
  \langle\Obtain(\usk,\ipk),\Issue(\isk,\upk)\rangle$.] Runs $\langle\Obtain,
  \Issue\rangle$ as in \CUASGen, with $\attrs \gets \emptyset$. Note that, to
  constraint to only one credential per user, it suffices to require the user
  to prove that the ``randomness'' it uses when committing to its private key
  is actually $0$, and check whether the received commitment has been seen
  before. For details, see the BBS+ instantiation of the underlying \SBCM
  building block in \secref{sapp:sbcm}.
\item[$\sig \gets \Sign(\gpk,\cred,\msg)$.] Parses \gpk as $(\ipk,\opk)$, and
  runs $(\sig,0) \gets \Sign(\usk,\opk,\cred,\msg,\feval^0)$ from \CUASGen.
  Simply returns \sig.
\item[$1/0 \gets \Verify(\gpk,\sig,\msg)$.] Parses \gpk as $(\ipk,\opk)$, and
  returns whatever $\Verify(\opk,\ipk,\sig,0,\msg,\feval^0)$ from \CUASGen
  outputs.
\item[$(\upk,\pi) \gets \Open(\gpk,\osk,\trans,\sig,\msg)$.] Parses \gpk as
  $(\ipk,\opk)$, and returns whatever \CUASGen outputs in $\Open(\osk,\ipk,\sig,
  0,\msg,\feval^0)$. Note that, internally, the latter call to \Open runs
  $\finsp^{\upk}$, where $\upk = \CCommit(\usk;0)$, just as proved in $\langle
  \Obtain,\Issue\rangle$.
\item[$1/0 \gets \Judge(\gpk,\pi,\upk,\sig,\msg)$.] Parses \gpk as $(\ipk,
  \opk)$, and returns whatever \CUASGen outputs in $\Judge(\opk,\upk,\pi,\sig,
  0,\msg)$.
\end{description}

\paragraph{Security of \CUASGS.} %
We prove that our \CUASGS construction is a secure group signature scheme,
according to \cite{bsz05}, if the underlying \CUASGen construction is secure.

\begin{theorem}[Anonymity of \CUASGS]
  If the base \CUASGen construction is anonymous according to
  \defref{def:anonymity-uas}, then \CUASRing is an anonymous group signature
  scheme.
\end{theorem}

\todo{Introducing $(f,g,h)-\CUASGen$ naming convention. Describe it elsewhere.}

\begin{proof}
  Assume an adversary \adv~ against anonymity in \CUASGS. This directly leads
  to an adverary \advB against anonymity of the $(\fissue^1,\feval^0,
  \finsp^{\upk})-\CUASGen$ instance.

  Concretely, observe that calls to \adv's $Ch,Open,SndToU,WReg,USK,CrptU$
  oracles can be directly simulated by calls to \advB's oracles $\CHALb,
  \OPEN,\HUGEN,\WREG,\CUGEN$ oracles. Thus, if \adv~ guesses its bit $b$
  with non-negligible probability, this directly leads to a non-negligible
  probability of guessing \advB's challenge bit.
  \qed
\end{proof}

\begin{theorem}[Traceability of \CUASGS]
  If the base \CUASGen construction has unforgeable signing according to
  \defref{def:sign-forge-uas}, then \CUASGS is a traceable group signature
  scheme.
\end{theorem}

\begin{proof}
  Assume an adversary \adv~ against traceability in \CUASGS. We build an
  adversary \advB against sign unforgeability of the $(\fissue^1,\feval^0,
  \finsp^{\upk})-\CUASGen$ instance.

  \advB's simulation of \adv~ environment is as in the proof for anonymity
  of \CUASGS. \advB simply outputs whatever \adv~ outputs in line 2 of its
  traceability game. Note that, as \CUASGS is a specific instantiation of
  \CUASGen, whenever \CUASGS accepts a signature, so does \CUASGen. Concretely,
  assume that \adv~ wins the traceability game in \figref{fig:model-gs} with
  $\upk \notin \HU \cup \CU$ at line 5. This implies that the check at line 11
  of the sign unforgeability game (\figref{fig:exp-uas-unfor-sign}) for \CUASGen
  outputs $0$ for all known {\uid}s. Similarly, if \adv~ wins the traceability
  game with condition $\Judge(\dots)=0$ at line 5, then \advB wins its sign
  unforgeability game with the corresponding check at line 6 in
  \figref{fig:exp-uas-unfor-sign}.
  %
  \qed
\end{proof}

\begin{theorem}[Non-frameability of \CUASGS]
  If the base \CUASGen construction is non-frameable according to
  \defref{def:frame-uas}, then \CUASGS is a non-frameable group signature
  scheme.
\end{theorem}

\begin{proof}
  Assume an adversary \adv~ against non-frameability in \CUASGS. We build an
  adversary \advB against non-frameability of the $(\fissue^1,\feval^0,
  \finsp^{\upk})-\CUASGen$ instance.

  \advB's simulation of \adv~ environment is as in the proof for anonymity
  of \CUASGS. \advB simply outputs whatever \adv~ outputs at line 2 of its
  game. Observe that a winning condition for \adv~ directly implies a winning
  condition for \advB. Concretely, if $\upk \in \HU \land \PRVUK[\upk] \neq
  \bot$ in \adv's game, then $\exists \uid \in \HU~\suchthat~\UK[\uid]=\usk$
  for \advB (line 6 of its game). Similarly, if \Judge returns $1$ in \adv's
  game, \advB's \Judge also returns $1$ at line 4. Finally, if \adv~ does not
  corrupt the owner of \upk, then $\uid \in \HU$ in \advB's game, and if \adv
  does not query its $SIGN$ oracle, then there does not exist a matching entry
  in $\SIG[\uid]$ for \advB either. Consequently, as stated, \advB wins its
  non-frameability every time that \adv does.
  \qed
\end{proof}

\subsection{Group Signatures with Message Dependent Opening}
\label{sapp:related-models-gsmdo}

We cannot build the exact same functionality, nor follow the exact same security
model as in the group signatures with message dependent opening (GS-MDO) scheme
described in \cite{ehk+19}. Simply because, therein, the opening functionality
is divided in two authorities: the admitter, who decides which messages are
subject to be opened or not, and generates a token that enables opening
signatures over such messages; and the opener, who performs the actual opening,
but cannot do it without the tokens generated by the admitter. Intuitively, this
can be seen as a sort of ``distribution'' of the opening capability. We define
a variant of this model in which the admitter and opener are combined back into
one entity (the opener), who can only open signatures over predefined messages,
but cannot open any other signature. Moreover, our variant directly supports the
scenario of multiple such openers, each being able to open only signatures
over different messages. Note that it would not be hard to apply thresholding
techniques to extend this case so that our ``unified'' opener role is shared
across multiple entities, who have to cooperate in order to open a signature
\needcite, thus achieving something very close ``in spirit'' to the scheme in
\cite{ehk+19}. In addition, while \cite{ehk+19} follows the static group
signature setting, we move to the dynamic one. Informally, our variant of GS-MDO
is composed of the following algorithms: \Setup,
\IKeyGen, \OKeyGen, \UKeyGen, \Sign, \Verify, \Open; as well as the $\langle
\Obtain, \Issue \rangle$ interactive protocol. \OKeyGen generates an opening
key pair which is already configured to open signatures only over some fixed
(but arbitrary) set of messages. The remaining algorithms are as usual, so we
defer a more detailed description to the construction. The oracles are the same
as in \UAS. The resulting security model is given in \figref{fig:model-gsmdo},
which we adapt from \cite{ehk+19}.

\begin{figure}[ht!]
  \centering
  \scalebox{0.9}{      
    \begin{minipage}[t]{0.45\textwidth}        
      \procedure[linenumbering]{$\Exp^{anon-b}_{\adv,gsmdo}(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        (\ipk,\isk) \gets \IKeyGen(\parm) \\
        b^* \gets \adv^{\mathcal{O}^{anon}}(\parm,\ipk) \\
        \pcreturn b^*
      }
      
      \vspace*{5em}
      
      \procedure[linenumbering]{$\Exp^{frame}_{\adv,gsmdo}(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        (\ipk,\isk) \gets \IKeyGen(\parm) \\
        (\msg,\sig,\upk,\tau) \gets \adv^{\mathcal{O}^{frame}}
        (\ipk,\isk) \\
        \pcif \Verify(\gpk,\msg,\sig) = 0: \pcreturn 0 \\
        \pcreturn 1~\pcif \upk \in \HU \land \PRVUK[\upk] \neq \bot \land
        \Judge(\gpk,\upk,\msg,\sig,\tau) = 1~\land \\
        \pcind \adv~\textrm{did not query}~USK(\upk)~\textrm{or}~
        GSig(\PRVUK[\upk],\msg) \\
        \pcreturn 0
      }       
    \end{minipage}
  }
  \scalebox{0.9}{      
    \begin{minipage}[t]{.55\textwidth}
      \procedure[linenumbering]{$\Exp^{trace}_{\adv,gsmdo}(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        (\ipk,\isk) \gets \IKeyGen(\parm) \\
        (\msg,\sig,\upk,\tau) \gets \adv^{\mathcal{O}^{trace}}
        (\ipk,\opk,\osk) \\
        \pcif \Verify(\gpk,\msg,\sig) = 0: \pcreturn 0 \\
        (\upk, \tau) \gets \Open(\gpk,\osk,\trans,\msg,\sig) \\
        \pcif \upk \notin \HU \cup \CU \lor \Judge(\gpk,\upk,\msg,\sig,\tau)
        = 0: \\ 
        \pcind \pcreturn 1 \\
        \pcreturn 0
      }       
    \end{minipage}      
  }
  \caption{Security games for our GS-MDO variant.
    $\mathcal{O}^{anon} \gets \lbrace \OGEN^{\smsg},\HUGEN,\CUGEN,\WREG,
    \OBTAIN,\SIGN,\OPEN,\CHALb \rbrace$; $\mathcal{O}^{trace} \gets \lbrace
    \OGEN,\HUGEN,\CUGEN,\ISSUE,\OBTISS,\RREG,\SIGN \rbrace$;
    $\mathcal{O}^{frame} \gets \lbrace \OGEN,\HUGEN,\CUGEN,\WREG,
    \OBTAIN,\SIGN \rbrace$. $\OGEN^{\smsg}$ is like \OGEN, but only accepting
    functions of type $\finsp^{\smsg}$.
  }
  \label{fig:model-gsmdo}  
\end{figure}

\subsubsection{\CUASGSMDO construction.} %
We show that, as specified in \tabref{tab:uas-alt-funcs}, our \CUASGen
construction for \UAS, restricted to $\fissue^1$ as issuance function,
$\feval^0$ as signature evaluation function, and $\finsp^{\smsg}$ as opening
function, is a secure group signature scheme with message dependent opening
as modelled in \figref{fig:model-gsmdo}. We first quickly define the algorithms,
and then prove security.

\begin{description}
\item[$\parm \gets \Setup(1^\secpar)$.] Like in vanilla \CUASGen.
\item[$(\upk,\usk) \gets \UKeyGen(1^\secpar)$.] Like the \UKeyGen function for
  \CUASGS, in \secref{sapp:related-models-gs}.
\item[$\langle \cred,\utrans \rangle \gets
  \langle\Obtain(\usk,\ipk),\Issue(\isk,\upk)\rangle$.] Like the corresponding
  protocol in in vanilla \CUASGS, \secref{sapp:related-model-gs}.
\item[$\sig \gets \Sign(\gpk,\cred,\msg)$.] Like in vanilla \CUASGen, limited
  on evaluation functions $\feval^0$ and opening functions $\finsp^{\smsg}$.
\item[$1/0 \gets \Verify(\gpk,\sig,\msg)$.] Like in vanilla \CUASGen.
\item[$(\upk,\pi) \gets \Open(\gpk,\osk,\trans,\sig,\msg)$.] Like in vanilla
  \CUASGen.
\item[$1/0 \gets \Judge(\gpk,\pi,\upk,\sig,\msg)$.] Like in vanilla \CUASGen.
\end{description}

\paragraph{Security of \CUASGSMDO.} %
Our \CUASGSMDO construction is a secure group signature scheme,
according to the model in \figref{fig:model-gsmdo}, if the underlying \CUASGen
construction is secure.

Note that both  model construction are essentially restrictions to the model
and construction of \CUASGen. Thus, security directly follows from security of
\CUASGen.

% \begin{theorem}[Anonymity of \CUASGSMDO]
%   If the base \CUASGen construction is anonymous according to
%   \defref{def:anonymity-uas}, then \CUASGSMDO is an anonymous group signature
%   scheme.
% \end{theorem}

% \begin{proof}
  
%   \qed
% \end{proof}

% \begin{theorem}[Traceability of \CUASGSMDO]
%   If the base \CUASGen construction has unforgeable signing according to
%   \defref{def:sign-forge-uas}, then \CUASGSMDO is a traceable group signature
%   scheme.
% \end{theorem}

% \begin{proof}
%   Traceability follows directly from the corresponding proof for \CUASGS.
%   \qed
% \end{proof}

% \begin{theorem}[Non-frameability of \CUASGSMDO]
%   If the base \CUASGen construction is non-frameable according to
%   \defref{def:frame-uas}, then \CUASGSMDO is a non-frameable group signature
%   scheme.
% \end{theorem}

% \begin{proof}
%   Non-frameability follows directly from the corresponding proof for \CUASGS.
%   \qed
% \end{proof}

\subsection{Ring Signatures}
\label{sapp:related-models-rs}

We adopt the model in \cite{bkm06}, where security of ring signatures is
defined according to the games in \figref{fig:model-rs}. A ring signature
scheme consists of three algorithms $(KeyGen,Sign,Verify)$. Roughly,
$((\pk_1,\sk_1),\dots,(\pk_n,\sk_n)) \gets KeyGen(1^\secpar)$ produces $n$
signing key pairs, $\sig \gets Sign(\sk_i,R,\msg)$ creates a signature for
anonymity set $R \subseteq \lbrace \pk_1, \dots, \pk_t \rbrace$, using secret
key $\sk_i$, associated to some $\pk_i \in R$; and $1/0 \gets Verify(R,\sig,
\msg)$ checks if \sig is a valid signature over \msg for ring $R$.

\begin{figure}[ht!]
  \centering
  \scalebox{0.9}{      
    \begin{minipage}[t]{0.55\textwidth}        
      \procedure[linenumbering]{$\Exp^{anon-b}_{\adv,rs}(1^\secpar)$}{%
        ((\pk_1,\sk_1),\dots,(\pk_n,\sk_n)) \gets KeyGen(1^\secpar) \\
        (i_0,i_1,R,\msg,\st) \gets \adv^{SIGN}(\pk_1,\dots,\pk_n) \\
        \pcif % R \not\subseteq \lbrace [n] \rbrace \lor
        \lbrace \pk_{i_0},\pk_{i_1} \rbrace \notin R \lor %\\
        i_0 = i_1: \pcreturn \bot \\
        \sig \gets Sign(\sk_{i_b},R,\msg)) \\
        b^* \gets \adv(\sig,\st) \\
        \pcreturn b^*
      }        
    \end{minipage}
  }
  \scalebox{0.9}{      
    \begin{minipage}[t]{.5\textwidth}
      \procedure[linenumbering]{$\Exp^{forge}_{\adv,rs}(1^\secpar)$}{%
        ((\pk_1,\sk_1),\dots,(\pk_n,\sk_n)) \gets KeyGen(1^\secpar) \\
        (R,\sig,\msg) \gets \adv^{SIGN,CORR}(\pk_1,\dots,\pk_n) \\
        \pcif Verify(R,\sig,\msg) = 0: \pcreturn 0 \\
        \pcreturn 1~\pcif R \subseteq [n] \setminus CU = \emptyset~\land \\
        \pcind \adv~\textrm{never queried}~SIGN(\cdot,R,\msg) \\
        \pcreturn 0
      }       
    \end{minipage}      
  }
  \caption{Security games for ring signatures \cite{bkm06}. The SIGN oracle
    accepts a $(i,R,\msg)$ tuple, where $pk_i$ must be part of $R$, and
    returns $\sig \gets Sign(\sk_i,R,\msg)$. The oracle $CORR$ accepts an
    index $i$, and lets $\adv$ learn $\sk_i$. Corrupted user indexes are
    added to list $CU$.}
  \label{fig:model-rs}  
\end{figure}

Intuitively, a ring signature scheme $rs$ is anonymous if, for every p.p.t.
\adv, $|\Pr[\Exp^{anon-1}_{\adv,rs}(1^\secpar)] = 1| -
|\Pr[\Exp^{anon-1}_{\adv,rs}(1^\secpar)] = 0|$ is a negligible function of
$1^\secpar$; and a ring signature scheme $rs$ is unforgeable if, for every
p.p.t. \adv, the probability that $\Exp^{forge}_{\adv,rs}(1^\secpar)$ returns
$1$ is also negligible in $1^\secpar$. For short, we say that a ring signature
scheme meeting both anonymity and unforgeability as specified above, is a secure
ring signature scheme.

\subsubsection{\CUASRing Construction.} %
We show that, as specified in \secref{ssec:uas-ring}, our \CUASGen construction
for \UAS, with alternative NIZK relationship $\NIZKRel_{\Sign-prv}$ for signing,
issuance function $\fissue^{\sring}$, signature evaluation function
$\feval^{\attrs}$, and inspection function $\finsp^0$, is a secure ring
signature scheme. Thus, in this section, when we write \CUASGen, we refer to
its specific variant built from the previous modifications.

\begin{description}  
\item[$\parm \gets \Setup(\secpar,\AttrSpace)$.] As in \CUASGen, but using
  $\NIZKRel_{\Sign-prv}$ instead of $\NIZKRel_{\Sign}$.  
\item[$(\ipk,\isk) \gets \IKeyGen(\parm,\fissue)$.] As in \CUASGen, using
  $\fissue^{\sring}$.  
\item[$(\opk,\osk) \gets \OKeyGen(\parm,\finsp).$] As in \CUASGen, where every
  opener that wants to be a valid opener in \CUASRing, needs to set \finsp to
  $\finsp^0$.  
\item[$\usk \gets \UKeyGen(\parm).$] Can only be run after \IKeyGen. Let 
  $\usk \gets \isk$.
\item[$\langle \cred,\bot,\utrans,\bot \rangle \gets
  \langle \Obtain(\usk,\scred,\attrs),\Issue(\isk,\sipk,\attrs)\rangle.$]
  The user picks a ring from an (publicly) available list of issuers (users),
  i.e. $\sring \gets \lbrace \ipk_i \rbrace_{i \in [t]}$, for some $t$. Then,
  runs the $\langle \Obtain,\Issue \rangle$ protocol as in \CUASGen, acting both
  as user and as issuer, and using $\fissue^{\sring}$ as issuance function.
  \attrs are the public keys of the users (issuers) to be included in the ring.
\item[$(\sig,\yeval) \gets \Sign(\usk,\opk,\scred,\msg,\feval).$] As in
  \CUASGen, using $\feval^{\attrs}$ as sign evaluation function, using
  as credential for signing the credential obtained in the desired $\langle
  \Obtain,\Issue \rangle$ session and, as \opk, any previously registered \opk
  (i.e., such that $\finsp=\finsp^0$).
\item[$1/0 \gets \Verify(\opk,\sipk,\sig,\yeval,\msg,\feval).$] As in \CUASGen.
  Note that $\sipk = \sring$, and $\feval=\feval^{\attrs}$.
\item[$\Open$ and $\Judge$.] As in \CUASGen. Note that $\finsp=\finsp^0$.
\end{description}

\todo{I guess we need to show that changing the NIZK for signing does not affect
  security. This leads to ``What are the conditions that need to be checked/cannot
  be altered in the default NIZK sign, that make \CUASGen secure?'' }

\paragraph{Security of \CUASRing.} %
We prove that our \CUASRing construction is anonymous and unforgeable, if
the underlying \CUASGen construction is secure.

\begin{theorem}[Anonymity of \CUASRing]
  If the base \CUASGen construction is anonymous according to
  \defref{def:anonymity-uas}, then \CUASRing is an anonymous ring signature
  scheme.
\end{theorem}

\begin{proof}
  Assume $\adv$ is an adversary against ring signature anonymity for \CUASRing.
  Then, we build \advB against anonymity of \CUASGen. Concretely, \advB first
  generates $n$ keypairs by running its \IGEN (with $\fissue^{\sring}$) and
  \HUGEN oracles, and runs \OGEN at least once (with $\finsp^0$). Then, invokes
  $\adv$ passing as public keys the public keys of the $n$ generated issuers
  (users in \CUASRing). $\adv$'s $SIGN(i,R,\msg)$ queries are processed as
  follows. If user $i$ has not yet produced a credential for ring $R$, \advB
  makes a call to its \OBTAIN oracle, using $R$ as attribute set. If such a
  credential was already produced, then reuse it. Then, \advB uses the
  corresponding user and credential identifiers as parameters to a query to its
  own \SIGN oracle (specifying $\feval^{\attrs}$ as signature evaluation
  function). Eventually, $\adv$ outputs two user indexes, a ring $R$, and
  message \msg. If the checks at line 4 of \figref{fig:model-rs} pass, \advB
  generates the challenge signature by calling its own \CHALb oracle, and passes
  the result to $\adv$. Finally, \advB outputs whatever $\adv$ outputs.
  %
  \qed
\end{proof}

\begin{theorem}[Unforgeability of \CUASRing]
  If the base \CUASGen construction is non-frameable according to
  \defref{def:frame-uas}, then \CUASRing is an unforgeable ring signature
  scheme.
\end{theorem}

\begin{proof}
  Assume $\adv$ against unforgeability of \CUASRing wins the game. We build
  \advB winning the non-frameability game of \CUASGen with the same probability.
  %
  \advB prepares the environment as the adversary \advB against anonymity,
  and answers \adv's queries to the $SIGN$ oracle also as in the anonymity
  proof. To answer \adv's queries to its $CORR$ oracle, \advB leverages the
  \ICORR oracle in the non-frameability game for \UAS. Finally, \advB outputs
  whatever $\adv$ outputs.

  Note that, if $\adv$ wins its game, it means that the public keys of the
  issuers in $R$ all belong to uncorrupted users. Since the signature is
  accepted by $Verify$ at line 3 of the ring signature unforgeability game,
  there exists some \uid with an \usk matching the check at line 6 in the
  non-frameability game. Moreover, since $\adv$ never queried its $SIGN$
  oracle, then by construction there cannot exist a matching entry in the
  $\SIG[\uid]$ table. Thus, \advB wins the non-frameability game whenever
  $\adv$ wins its unforgeability game. Since \CUASGen is non-frameable, then
  this probability must be negligible.
  %
  \qed
\end{proof}

\subsection{Anonymous Credentials}
\label{sapp:related-models-ac}

We adopt the model in \cite{fhs19}, where security of anonymous credentials
(with selective disclosure). Therein, an anonymous credential scheme is
defined via $OrgKeyGen$ (which we rename to $IssKeyGen$, and $UserKeyGen$
algorithms (roughly equivalent to
\IKeyGen and \UKeyGen for \UAS), and $Obtain,Issue$ and $Show,Verify$
interactive protocols. The issuance interactive protocol is equivalent to
the issuance protocol in \UAS. Similarly, $Show,Verify$ is equivalent to
the interactive extension of \Sign and \Verify in \UAS, which we show how
to build in \secref{ssec:variants-gsac} (for \GSAC, but the case for \UAS is
equivalent). The security definitions rely on $HU, CU, ObtIss, Obtain, Issue,
Show$, and $LoR$ oracles, which are essentially equivalent to our \HUGEN,
\CUGEN, \OBTISS, \OBTAIN, \ISSUE, \SIGN, and \CHALb oracles. We refer to
\cite{fhs19} for the full details. For ease of reference, we summarize the
security definitions in \cite{fig:model-ac}, with inocuous adaptations to
make them more suitable for comparison with our definitions.

\begin{figure}[ht!]
  \centering
  \scalebox{0.9}{      
    \begin{minipage}[t]{0.5\textwidth}        
      \procedure[linenumbering]{$\Exp^{anon-b}_{\adv,ac}(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        (\ipk,\isk) \gets IssKeyGen(\parm) \\        
        b^* \gets \adv^{HU,CU,Obtain,Show,LoR}(\isk) \\
        \pcreturn b^*
      }        
    \end{minipage}
  }
  \scalebox{0.9}{      
    \begin{minipage}[t]{.5\textwidth}
      \procedure[linenumbering]{$\Exp^{forge}_{\adv,ac}(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        (\ipk,\isk) \gets IssKeyGen(\parm) \\        
        (D,\st) \gets \adv^{HU,CU,ObtIss,Issue,Show}(\ipk) \\
        \langle \cdot,(b,\utrans) \rangle
        \gets \langle \adv(\st),\Verify(\ipk,D) \rangle \\
        \pcif b = 1 \land \nexists j~\suchthat~(\OWNR[j] \in \CU
        \land D \subseteq \ATTR[j]): \\% \forall j, \OWNR[j] \in \CU
        % \implies D \not\subseteq \ATTR[j]: \\
        \pcind \pcreturn 1 \\
        \pcreturn 0
      }       
    \end{minipage}      
  }
  \caption{Security games for anonymous credentials with selective disclosure
    \cite{fhs19}. \OWNR and \ATTR tables are essentially as in
    \secref{ssec:model-uas}.}
  \label{fig:model-ac}  
\end{figure}

\subsubsection{\CUASAC Construction.} %
We show that, as specified in \tabref{tab:uas-alt-funcs}, our \CUASGen
construction for \UAS, restricted to $\fissue^1$ as issuance function,
$\feval^{\dattrs}$ as signature evaluation function, and $\finsp^0$ as opening
function, is a secure anonymous credential scheme according to the \cite{fhs19}
model. We first quickly define the algorithms, and then prove security. Note
that, for better alignment with \UAS, we add a common setup process which is
part of $IssKeyGen$ in \cite{fhs19}. The change is inocuous functionality- and
security-wise, though.

\begin{description}
\item[$\parm \gets \Setup(1^\secpar)$.] Runs $\parm' \gets \Setup(1^\secpar)$
    and $(\opk,\osk) \gets \OKeyGen(\parm',\finsp^0)$ from our \CUASGen
    construction. Returns $\parm \gets (\parm',\opk)$.
\item[$(\ipk,\isk) \gets IssKeyGen(\parm)$.] Runs \IKeyGen from our
  \CUASGen construction, setting $\fissue^1$ as issuance function.
\item[$(\upk,\usk) \gets UserKeyGen(\ipk)$.] Runs \UKeyGen from the
  \CUASGen construction, and computes $\CCommit(\usk;0)$ as \upk.
\item[$\langle \cred/\bot,\top/\bot \rangle \gets
  \langle \Obtain(\usk,\ipk,\attrs),\Issue(\isk,\upk,\attrs) \rangle$.]
  Runs the $\langle \Obtain,\Issue \rangle$ protocol from \CUASGen, using
  $\fissue^1$ as issuance function.
\item[$\langle 1/0,((1,\utrans)/(0,\utrans)\rangle
  \gets \langle Show(\ipk,\attrs,\dattrs,
  \cred),\Verify(\ipk,\dattrs) \rangle$.]
  Runs the interactive extension of \Sign and \Verify of the \CUASGen protocol,
  using $\feval^{\dattrs}$ as signature evaluation function, and $\finsp^0$ as
  open function, with \opk from \parm as opener public key.
\end{description}

\paragraph{Security of \CUASAC.} %
We prove that \CUASAC is an anonymous and unforgeable anonymous credential
scheme, according to \cite{fhs19}, if the underlying \CUASGen construction
is anonymous and has unforgeable signing. Note that issuance unforgeability
of \CUASGen is not needed, as the model in \cite{fhs19} does not allow
leveraging other credentials not any fixed custom issuance policy. Thus,
signature unforgeability from \UAS is enough. Note that AC schemes modelled
as in \cite{fhs19} do not have issuance anonymity, as the user public key
is passed to the issuer.

\begin{theorem}[Anonymity of \CUASAC]
  \label{thm:anon-cuasac}
  If the base \CUASGen construction has signature anonymity according to
  \defref{def:sign-anonymity-uas}, then \CUASAC is an anonymous AC scheme
  according to \cite{fhs19}.
\end{theorem}

\begin{proof}
  Given \adv~ against anonymity of \CUASAC as defined in \cite{fhs19}, we build
  an adversary \advB against anonymity of \CUASGen as defined in
  \defref{def:sign-anonymity-uas}.

  To simulate oracle calls by \adv, \advB simply redirects to its corresponding
  oracle, i.e.: for calls to $HU,CU,Obtain,Show,LoR$, \advB redirects to
  \HUGEN,\CUGEN,\OBTAIN,\SIGN,\CHALb, respectively. Note that ``translating''
  the inputs from the former into inputs for the latter is trivial.
  Obviously, if \adv~ wins in its anonymity game, then so does \advB with the
  same probability.
  % 
  \qed
\end{proof}

\begin{theorem}[Unforgeability of \CUASAC]
  \label{thm:forge-cuasac}
  If the base \CUASGen construction has sign unforgeability according to
  \defref{def:sign-forge-uas}, then \CUASAC is an unforgeable AC scheme.
\end{theorem}

\begin{proof}
  Given \adv~ against unforgeability of \CUASAC as defined in \cite{fhs19}, we
  build an adversary \advB against sign unforgeability of \CUASGen as defined in
  \defref{def:sign-forge-uas}.

  To simulate oracle calls by \adv, \advB acts as in the anonymity proof. Assume
  that \adv~ wins its game. Note that, since $b=1$ in line 5 of the
  unforgeability game of \figref{fig:model-ac}, then by construction, \Verify
  also returns $1$ in the sign unforgeability game of \UAS. In addition, if
  there is no corrupt user with a credential containing $D$, then this leads to
  \advB winning at line 9 in \figref{fig:exp-uas-unfor-sign}, as no credential
  owned by a corrupt user that can be extracted can make the $\feval^{\dattrs}$
  function output $\yeval^0=D$. Thus, \advB wins with the same probability as
  \adv~ does.  
  %
  \qed
\end{proof}

\subsection{Delegatable Anonymous Credentials}
\label{sapp:related-models-dac}

We give a simple definition for a Delegatable Anonymous Credentials (DAC)
scheme, extending \cite{fhs19} and inspired by \cite{bcc+09}. Unlike the latter,
our simple scheme built from \CUASGen does not ensure privacy of the delegation
chain -- which could be achieved by making \feval output projective proofs like
in \cite{bcc+09}, but since our goal is to showcase the feasibility of building
DAC from \UAS, we leave that out for brevity. Our simple scheme does, however,
ensure that a (not top-level) issuer can only delegate attributes contained in a
credential it owns. Also, for simplicity, we restrict to the case of using one
credential per signature/interactive credential presentation, and assume that
all parties use the same opener and \finsp function.
%
The functionality is thus defined as in \appref{sapp:related-models-ac}, i.e.,
we have $Setup$, $IssKeyGen$ and $UserKeyGen$ algorithms, and $\langle Obtain,
Issue \rangle$ and $\langle Show,Verify \rangle$ interactive protocols.
%
In the modelling for this setting, since there are multiple issuers, in addition
to the oracles in \appref{sapp:related-models-ac}, we use $HI$ and $CI$ oracles,
equivalent to \IGEN and \ICORR in our \UAS model, which allow adding honest
issuers, and corrupt existing ones, respectively. The issuance and sign
anonymity properties are as before. For unforgeability, we still require
that no adversary can authenticate using a set of attributes that have not been
issued to a corrupt user. In addition, we require that for any possible
successful authentication protocol using a level-$n$ credential, we can extract
a chain of credentials of length $n$ such that each level-$i$ credential can
be used successfully to authenticate a level-$(i+1)$ credential up to the
level-$n$ credential, and that the attributes revealed in the level-$n$
authentication are contained in all the credentials up the chain.

\begin{figure}[ht!]
  \centering
  \scalebox{0.9}{      
    \begin{minipage}[t]{0.45\textwidth}
      \procedure[linenumbering]{$\Exp^{iss-anon-b}_{\adv,dac}(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        b^* \gets \adv^{\mathcal{O}_{iss-anon}}(\parm) \\
        \pccomment{Abort if challenge creds belong to} \\
        \pccomment{users with different delegation chains} \\
        \pcreturn b^*
      }
      \vspace*{0.5em}

      \procedure[linenumbering]{$\Exp^{sig-anon-b}_{\adv,dac}(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        b^* \gets \adv^{\mathcal{O}_{sig-anon}}(\parm) \\
        \pccomment{Abort if challenge sigs belong to} \\
        \pccomment{users with different delegation chains} \\
        \pcreturn b^*
      }        
    \end{minipage}
  }
  \scalebox{0.9}{      
    \begin{minipage}[t]{.55\textwidth}
      \procedure[linenumbering]{$\Exp^{forge}_{\adv,dac}(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        (D=(n,D'),\ipk_n,\st) \gets
        \adv^{\mathcal{O}_{forge}}(\parm) \\
        \langle\cdot,(b,\utrans)\rangle \gets
        \langle \adv(\st),\Verify(\ipk_n,D)\rangle \\
        \pcif b = 0: \pcreturn 0 \\
        \pcif \nexists j~\suchthat~(\OWNR[j] \in \CU
        \land D \subseteq \ATTR[j]): \pcreturn 1 \\        
        (ipk_0, \lbrace (\ipk_i,\cred_i) \rbrace_{i \in [1,n]})
        \gets ExtractChain(\utrans) \\ 
        \pcif \exists i \in [1,n]~\suchthat~
        \iid = \ISR[\ipk_{i-1}] \notin \CI~\land \\
        \pcind D' \not\subseteq \ATTR[\iid]) \land
        D' \subseteq \ATTR[\ISR[\ipk_i]]: \\
        \pcind \pcreturn 1 \\
        \pcreturn 0
      }       
    \end{minipage}      
  }
  \caption{Security games for delegatable anonymous credentials with selective
    disclosure based on \cite{fhs19}. $\mathcal{O}_{iss-anon} \gets \lbrace HU,
    CU,HI,CI,Obtain,Issue,ObtIss,Show,IssLoR\rbrace$, $\mathcal{O}_{sig-anon}
    \gets \lbrace HU,CU,HI,CI,Obtain,Issue,ObtIss,Show,SigLoR\rbrace$.
    $\mathcal{O}_{forge} \gets \lbrace HU,CU,HI,CI,Obtain,ObtIss,Issue,Show
    \rbrace$. $IssLor$ is equivalent to \OBTCHALb in \UAS, whereas $SigLor$ is
    equivalent to \CHALb. Also, \OWNR and \ATTR tables are essentially as in
    \secref{ssec:model-uas}. $\ISR[\ipk]$, in this case, returns the identifier
    of the issuer with public key \ipk. With $D =
    (n,D')$ we mean that the first attribute in the revealed set $D$ is $n$,
    which denotes the level of the credential used for authentication.}
  \label{fig:model-dac}  
\end{figure}

\subsubsection{\CUASDAC Construction.} %
In a delegatable AC (DAC) scheme, all users are (or may be) also issuers. We
only distinguish between top-level issuers, who have level $n=0$, and
lower-level issuers, who have level $n>0$. In our \CUASDAC scheme, we assume
that the first attribute (after the user's secret key) encodes the level of
the credential. That is, $\attrs_1=n$, for a credential of level $n$. In
addition, all users (i.e., with $n>0$) who want to delegate have to publicly
list:

\begin{enumerate}
\item The level $n$ of the credential they delegate.
\item Their public key \ipk.
\item An \UAS signature proving knowledge of a credential of level $n$, and over
  the attributes that this level-$n$ issuer is delegating.
\item The \ipk of the parent issuer.
\item The $\fissue^{n,\dattrs}$ function they will require for delegating.
\item An $\feval^{n,\dattrs}$ function used to produce the signature at item 2.
\end{enumerate}

We assume that, from an \ipk, it is possible to find the corresponding issuer
(e.g., using the previously mentioned public list). The mentioned
$\fissue^{n,\dattrs}$ functions must follow the pattern in \esref{eq:funcs-dac}.
Namely, the issuance function checks that the first requested attribute equals
$n+1$, and that all requested attributes are a subset of the attribute set
\dattrs being delegated by the level-$n$ issuer. In addition, signature
evaluation functions $\feval^{n,\dattrs}$, also shown in \esref{eq:funcs-dac},
must reveal the level of the credential used to produce the \UAS signature at
item 2, as well as the set of attributes \dattrs that the level-$n$ issuer
delegates. Verifiers can then trivially check if the set of revealed attributes
are contained within the attributes delegatable by the parent issuer%
\footnote{Additional checks may be added in both functions, but this is
  the bare minimum.}. \figref{fig:XXX} depicts a sample of the delegation chain
that this structure creates.
 
\begin{align}
  & \fissue^{n,\dattrs}(\usk,\cred,\attrs) \coloneqq \lbrace
    \pcif \attrs_1 = n+1 \land \attrs \subseteq \dattrs: \pcreturn 1; \pcelse \pcreturn 0
    \rbrace \nonumber \\
  & \feval^{n,\dattrs}(\usk,\cred,\msg) \coloneqq \lbrace
    \pcreturn (\attrs_1(\cred),\dattrs(\cred)) \rbrace
  \label{eq:funcs-dac}
\end{align}

From this high-level description, we define the algorithms of \CUASDAC:

\begin{description}
\item[$\parm \gets \Setup(1^\secpar)$.]  Runs $\parm' \gets \Setup(1^\secpar)$
    and $(\opk,\osk) \gets \OKeyGen(\parm',\finsp^0)$ from our \CUASGen
    construction. Returns $\parm \gets (\parm',\opk)$. Note that $\finsp^0$ can
    be replaced by any desired opening function.
\item[$(\ipk,\isk) \gets IssKeyGen(\parm)$.] If $n=0$, simply run \IKeyGen as
  in \CUASAC. If $n>0$, note that this is a user who wants to delegate a
  previously obtained credential \cred. Thus, it has already run $UserKeyGen$
  below, which internally also runs \IKeyGen as in \CUASGen and sets $\usk \gets
  \isk$. In addition, the level-$n$ issuer picks a random message $r$ and
  computes $\Sig = (\sig,\yeval) \gets \Sign(\usk,\opk,\cred,r,
  \feval^{n,\dattrs})$, for the \dattrs set it wants to reveal -- which must
  include the attributes to delegate, and the credential level. It then
  publishes $(n,\ipk,\Sig,\ipk^{n-1},\fissue^{n,\dattrs},\feval^{n,\dattrs})$,
  where $\ipk^{n-1}$ is the public key of the parent issuer,
  $\fissue^{n,\dattrs}$ is an issuance function as described in
  \esref{eq:funcs-dac}, and $\feval^{n,\dattrs}$ is also as in
  \esref{eq:funcs-dac}, revealing the attributes that the issuer is willing to
  delegate..
\item[$(\upk,\usk) \gets UserKeyGen(\opk)$.] All users in this scheme are
  also issuers. Thus, a new user runs first \IKeyGen as in \CUASGen. Then, sets
  $\usk \gets \isk$ and stores \ipk, which may be needed to delegate obtained
  credentials.
\item[$\langle \cred/\bot,\top/\bot \rangle \gets
  \langle \Obtain(\usk,\ipk,\attrs),\Issue(\isk,\upk,\attrs) \rangle$.]
  If $n>0$, the user first finds the corresponding $(n,\ipk,\Sig,\ipk^{n-1},
  \fissue^{n,\dattrs},\feval^{n,\dattrs})$ tuple, and checks \Sig running
  \Verify as in \CUASGen (with the retrieved $\feval^{n,\dattrs}$). Then,
  user and level-$n$ issuer run $\langle\Obtain,\Issue\rangle$ as in \CUASGen,
  using $\fissue^{n,\dattrs}$ as issuance function. If $n=0$, then both run
  $\langle\Obtain,\Issue\rangle$ as in \CUASGen, using the \fissue function
  required by the issuer.
\item[$\langle 1/0,(1,\utrans)/(0,\utrans)\rangle
  \gets \langle Show(\opk,\attrs,\dattrs,\cred),
  \Verify(\opk,\dattrs) \rangle$.] As in the interactive variant of \CUASGen.  
\end{description}

\paragraph{Security of \CUASDAC.} %
We prove that \CUASDAC is an anonymous and unforgeable DAC scheme, according to
the model in \figref{fig:model-dac}, if the underlying \CUASGen construction has
anonymous issuance and signing, and has unforgeable issuance and signing. 

\begin{theorem}[Issuance anonymity of \CUASDAC]
  If the base \CUASGen construction has issuance anonymity according to
  \defref{def:issue-anonymity-uas}, then \CUASDAC also has issuance anonymity.
\end{theorem}

\begin{proof}
  Given \adv~ against issuance anonymity of \CUASDAC as defined in
  $\Exp^{iss-anon-b}_{\adv,dac}(1^\secpar)$, we build an adversary \advB against
  issuance anonymity of \CUASGen as defined in \defref{def:issue-anonymity-uas}.

  To simulate oracle calls by \adv, \advB simply redirects to its corresponding
  oracle, i.e.: for calls to $HU,CU,HI,CI,Obtain,Show,IssLoR$, \advB redirects
  to \HUGEN,\CUGEN,\IGEN,\ICORR,\OBTAIN,\SIGN,\OBTCHALb, respectively. Note that
  ``translating'' the inputs from the former into inputs for the latter is
  trivial. Obviously, if \adv~ wins in its issuance anonymity game, then so does
  \advB with the  same probability.
  % 
  \qed
\end{proof}

\begin{theorem}[Signature anonymity of \CUASDAC]
  If the base \CUASGen construction has signature anonymity according to
  \defref{def:sign-anonymity-uas}, then \CUASDAC also has signature anonymity.
\end{theorem}

\begin{proof}
  This is the same as in \thmref{thm:anon-cuasac}.
  % 
  \qed
\end{proof}

\begin{theorem}[Unforgeability of \CUASAC]
  If the base \CUASGen construction has issuance and signature unforgeability
  according to \defref{def:issue-forge-uas} and \defref{def:sign-forge-uas}, and
  non-frameability according to \defref{def:frame-uas}, then \CUASAC is an
  unforgeable AC scheme.
\end{theorem}

\begin{proof}
  First, we define the $ExtractChain(\utrans)$ function for our construction.
  Note that \utrans is a tuple $(r,\Sig)$\footnote{This follows for the approach
    to transform non-interactive signature and verification in \UAS to interactive
    presentations, as described in \secref{ssec:variants-gsac}.}, where $r$ is a
  fresh random number produced by the environment (acting as honest verifier),
  and \Sig is a \CUASGen signature over $r$. Thus, $ExtractChain$ leverages
  \ExtractSign from \CUASGen (see \secref{ssec:security-uas}) to get the
  credential and associated \ipk used to produce \Sig. Note that, for this
  \ipk, $\ipk = \ipk_{n-1}$ in $\Exp^{forge}_{\adv,dac}$. In \CUASDAC, we can
  leverage $\ipk_{n-1}$ to fetch from the public list a signature $\Sig_{n-1}$
  generated by the issuer owner of $\ipk_{n-1}$. Again, we apply \ExtractSign
  from \CUASGen, to get the credential one layer up in the chain.
  $ExtractChain$ repeats this step, until reaching the top level credential,
  issued by $\ipk_0$.

  For the proof, we first replace within $Setup$ the $\NIZKSetup$ algorithms for
  issuance and signing with their corresponding $\NIZKSetup$. Due to their
  zero-knowledge property, the resulting game is indistinguishable. Also, note
  that $ExtractChain$ succeeds to extract the corresponding credential chain,
  due to simulation extractability of the NIZKs. 

  From the previous, the same reasoning as in \thmref{thm:forge-cuasac} applies
  to an adversary \adv~winning at line 5 of $\Exp^{forge}_{\adv,dac}$. Next,
  suppose that, from \utrans obtained at line 6, $ExtractChain$ outputs a
  delegation chain that makes \adv~win at line 10. This means that an
  uncorrupted issuer at position $i-1$ of the chain did not own a credential
  containing $D'$, but the issuer at position $i$ does. Then, either of the
  following must happen:

  \begin{itemize}
  \item The credential of the issuer at position $i$ is a forgery, meaning that
    it is a valid signature by the issuer at position $i-1$, who did not produce
    it. This can be used to break signature non-frameability of \CUASGen.
  \item The credential of the issuer at position $i$ is not a forgery, meaning
    that it is a valid signature by the issuer at position $i-1$, who produced
    it. But this contradicts the conditions required by $\fissue^{n,\dattrs}$,
    and therefore breaks issuance unforgeability of \CUASGen.
  \end{itemize}
  %
  \qed
\end{proof}

\subsection{Revocable Anonymous Credentials}
\label{sapp:related-models-rac}

In \cite{cks10}, revocable anonymous credentials are proposed. From \CUASGen, it
is straightforward to build an AC system with verifier local revocation, like in
\cite{bs04}. Basically, all credentials get an identifier as first attribute,
and \feval functions prove that the opener can retrieve that identifier. Then,
in case of needing to revoke a concrete credential, any verifier can interact
with the opener to add an identifier to its own revocation list (alternatively,
there can be a public list of revoked credentials). Having \feval functions
prove that the credential identifier does not belong to that list thus directly
implements privacy-preserving revocation. We first give a simple model in
\figref{fig:model-rac}, extending that in \appref{sapp:related-models-ac}. As
before, for simplicity we assume only one credential is used per authentication
(the extension being direct). To the functionality in
\appref{sapp:related-models-ac}, we now explicitly add the $OKeyGen$ function
(equivalent to \OKeyGen, with a fixed \finsp function),
which generates the opener key pair, extend $Verify$ to receive also a list $L$
of revoked identifiers, and we add a function (and corresponding oracle) $id/\bot
\gets RetrieveCredId(\osk,\utrans)$ that can extract the identifier of the
credential used in a presentation transcript \utrans -- and which is essentially
equivalent to \Open in \UAS. For simplicity, we do not include the equivalent to
verifiable openings, but this would be straightforward.

\begin{figure}[ht!]
  \centering
  \scalebox{0.9}{      
    \begin{minipage}[t]{0.45\textwidth}
      \procedure[linenumbering]{$\Exp^{anon-b}_{\adv,rac}(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        (\opk,\osk) \gets \OKeyGen(\parm) \\        
        (\ipk,\isk) \gets IssKeyGen(\parm) \\        
        b^* \gets \adv^{\mathcal{O}_{anon}}(\parm,\ipk,\opk) \\
        \pcreturn b^*
      }        
    \end{minipage}
  }
  \scalebox{0.9}{      
    \begin{minipage}[t]{.55\textwidth}
      \procedure[linenumbering]{$\Exp^{forge}_{\adv,rac}(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        (\opk,\osk) \gets \OKeyGen(\parm) \\        
        (\ipk,\isk) \gets IssKeyGen(\parm) \\
        (D,L,\st) \gets
        \adv^{\mathcal{O}_{forge}}(\parm,\ipk) \\
        \langle \cdot,(b,\utrans)\rangle
        \gets \langle \adv(\st),\Verify(\ipk,D,L)\rangle \\
        \pcif b = 0: \pcreturn 0 \\
        \pcif \nexists j~\suchthat~(\OWNR[j] \in \CU
        \land D \subseteq \ATTR[j]): \pcreturn 1 \\    
        h \gets RetrieveCredHandle(\osk,\utrans) \\
        \pcif h \in L \lor h = \bot: \pcreturn 1 \\
        \pcreturn 0
      }       
    \end{minipage}      
  }
  \caption{Security games for revocable anonymous credentials with selective
    disclosure based on \cite{fhs19}. 
    $\mathcal{O}_{anon} \gets \lbrace HU,CU,Obtain,Issue,ObtIss,Show,
    ReqCredHandle,LoR\rbrace$. $\mathcal{O}_{forge} \gets \lbrace HU,CU,
    Obtain,ObtIss,Issue,Show,ReqCredHandle \rbrace$. $ReqCredHandle$ is
    equivalent to \OPEN, operating on transcripts \utrans instead of signatures.
    Also, \OWNR and \ATTR tables are essentially as in \secref{ssec:model-uas}.}
  \label{fig:model-rac}  
\end{figure}

\subsubsection{\CUASRAC Construction.} %

For our RAC construction, we define signature evaluation and opening functions
as follows:

\begin{align}
  & \feval^{\dattrs,F,V,L}(\usk,\cred,\msg) \coloneqq
    \lbrace
    \pcif F(V,\attrs_1(\cred)) \in L: \pcreturn (0,0);
    \pcelse \pcreturn (\dattrs(\cred),V)
    \rbrace \nonumber \\
  & \finsp^{F}((\yeval^0,\yeval^1),\usk,\cred,\msg) \coloneqq
    \lbrace
    \pcif \yeval^0 \neq 0: \pcreturn F(\yeval^1,\attrs_1(\cred));
    \pcelse \pcreturn 0
     \rbrace
  \label{eq:funcs-rac}
\end{align}

Where, $\feval^{\dattrs,F,V,L}$ is parameterized with a one-way function $F$
(e.g., a cryptographic hash), some constant subset \dattrs of attributes to be
selectively disclosed by signers, a string identifying the verifier $V$ and a
list $L$ of ``revocation handles'' by this verifier. If the credential used for
signing has been revoked (i.e., if $F(V,id) \in L$), then \feval returns $0$, as
an indication that the signature should be rejected by the verifier. Otherwise,
it sets $\yeval^0 \gets \dattrs(\cred)$, and $\yeval^1 \gets V$ -- note that
$\yeval^1$ will be encrypted with a single-use key pair.
%
On the other hand, $\finsp^{F}$ outputs $F(\yeval^1,\attrs_1(\cred))$, allowing
valid signatures to be locally revocable by $V$ at a later stage, since
$\yeval^1=V$.

\begin{description}
\item[$\parm \gets \Setup(1^\secpar)$.] Runs $\Setup(1^\secpar)$ as in
  \CUASGen.
\item[$(\ipk,\isk) \gets IssKeyGen(\parm)$.] Runs \IKeyGen from our
  \CUASGen construction, setting $\fissue^1$ as issuance function.
\item[$(\ipk,\isk) \gets OKeyGen(\parm)$.] Runs \OKeyGen from our
  \CUASGen construction, setting $\finsp^F$ as opening function.
\item[$(\upk,\usk) \gets UserKeyGen(\ipk)$.] Runs \UKeyGen from the
  \CUASGen construction, and computes $\CCommit(\usk;0)$ as \upk.
\item[$\langle \cred/\bot,\top/\bot \rangle \gets
  \langle \Obtain(\usk,\ipk,\attrs),\Issue(\isk,\upk,\attrs) \rangle$.]
  Runs the $\langle \Obtain,\Issue \rangle$ protocol from \CUASGen, using
  $\fissue^1$ as issuance function.
\item[$\langle 1/0,(1,\utrans)/(0,\utrans)\rangle \gets \langle Show(\ipk,\attrs,\dattrs,\cred),
  \Verify(\ipk,\dattrs) \rangle$.]
  Runs the interactive extension of \Sign and \Verify of the \CUASGen protocol,
  using $\feval^{\dattrs,F,V,L}$ as signature evaluation function, and
  $\finsp^F$ as open function.
\item[$h/\bot \gets RetrieveCredHandle(\osk,\utrans)$.]
  Outputs the revocation handle $h$ for the credential used in the interactive
  presentation associated to \utrans. Note that $h$ is verifier-dependent.
\end{description}

\paragraph{Security of \CUASRAC.} %
We prove that \CUASRAC is an anonymous and unforgeable anonymous credential
scheme, according to \cite{fhs19}, if the underlying \CUASGen construction
is anonymous and has unforgeable signing. Note that issuance unforgeability
of \CUASGen is not needed, as the model in \cite{fhs19} does not allow
leveraging other credentials not any fixed custom issuance policy. Thus,
signature unforgeability from \UAS is enough. Note that AC schemes modelled
as in \cite{fhs19} do not have issuance anonymity, as the user public key
is passed to the issuer.

\begin{theorem}[Anonymity of \CUASRAC]
  \label{thm:anon-cuasac}
  If the base \CUASGen construction has signature anonymity according to
  \defref{def:sign-anonymity-uas}, and $F$ is one-way, then \CUASAC is an
  anonymous AC scheme according to \cite{fhs19}.
\end{theorem}

\begin{proof}
  Given \adv~ against anonymity of \CUASRAC as defined in
  \figref{fig:model-rac}, we build an adversary \advB against anonymity of
  \CUASGen as defined in \defref{def:sign-anonymity-uas}.

  First observe that, given a revocation handle $F(V,id)$ extracted from any
  credential showing, it is not possible to extract $id$, as $F$ is one-way.
  
  To simulate oracle calls by \adv, \advB simply redirects to its corresponding
  oracle, i.e.: for calls to $HU,CU,Obtain,Show,LoR,ReqCredHandle$, \advB
  redirects to \HUGEN, \CUGEN, \OBTAIN, \SIGN, \CHALb, of \OPEN respectively.
  Note that ``translating'' the inputs from the former into inputs for the
  latter is trivial. Also, observe that $ReqCredHandle$ essentially refuses to
  open transcripts from challenge users (signatures, in the non-interactive
  equivalent), as $F(V,\attrs_1(\ccid_0) \neq F(V,\attrs_1(\ccid_1)$ with
  overwhelming probability (see the $\tyinsp \neq \yinsp$) check in
  \figref{fig:oracles2}. Obviously, if \adv~ wins in its anonymity game, then
  so does \advB with the same probability.
  % 
  \qed
\end{proof}

\begin{theorem}[Unforgeability of \CUASRAC]
  If the base \CUASGen construction has sign unforgeability according to
  \defref{def:sign-forge-uas}, and $F$ is one-way, then \CUASRAC is an
  unforgeable RAC scheme.
\end{theorem}

\begin{proof}
  Given \adv~ against unforgeability of \CUASRAC as defined in
  \figref{fig:model-rac}, we build an adversary \advB against sign
  unforgeability of \CUASGen as defined in \defref{def:sign-forge-uas}.

  To simulate oracle calls by \adv, \advB acts as in the anonymity proof. Assume
  that \adv~ wins its game via the winning condition of line 6 in the RAC
  unforgeability game. The same reasoning as in \CUASAC applies here. Next, note
  that the probability of \adv~ winning its game via the winning condition at
  line 9 is negligible, due to soundness of the NIZK scheme used for signing,
  and the one-wayness of $F$ in $\feval^{\dattrs,F,V,L}$ and $\finsp^{F}$.  
  %
  \qed
\end{proof}


\subsection{Multimodal Private Signatures}
\label{sapp:related-models-mps}

Multimodal Private Signatures (or, rather, a close relative, see next) are
directly implementable with a restriction of \UAS. Concretely, by restricting to
a system with one issuer and one opener, one credential per user, one attribute
per credential (the user secret key), $\fissue^1$ issuance functions, and
\feval functions that only use the $\yeval^1$ output -- which we denote with
$\feval^{\yeval^1}$.

There are some differences, though. On the one hand, our signature anonymity
property is somehow in the middle of MPS's privacy-1 and privacy-2 variants.
Their privacy-1 variant is the traditional anonymity property of group
signatures, in which the opener is honest and the adversary can call the opening
oracle except for challenge signatures. In their privacy-2 variant, the opener
is fully corrupt (i.e., \adv~ receives \osk), but the adversary can only be
challenged with signatures that produce the same \yinsp value ($G_{j_b}(id_b)$
in MPS). In our \UAS model, we allow the adversary to corrupt openers at will
(getting ther \osk), but the challenge signatures must have been generated using
the key of an uncorrupted opener; still, \adv~can call the open oracle for
challenge signatures, as long as they have the same \yinsp value. We believe
that these differences are mostly of theoretical interest, though, and it does
not seem hard to move from one to the other \todo{check}. In practice,
what matters is that any variant of \feval and \finsp functions ($F$ and $G_j$
in MPS) that has too much granularity in their ranges, will lead to a barely
private system. This is a known issue, for instance, in functional encryption
\needcite.

On the other hand, our issuance-related properties (issuance anonymity and
issuance unforgeability) are unachievable by MPS. Issuance anonymity simply does
not make sense in MPS, as it only supports one credential (without attributes)
per user. Issuance unforgeability does not make sense either, since there are no
configurable issuance policies in MPS -- instead, they have the fixed policy of
``proving knowledge of a user secret key''. These extensions are not trivial
from a theoretical point of view, and also have a big impact in the practicality
of the resulting system. Also, MPS does not include verifiable openings. While
this is easy to add, we consider it to be essential, given that the proposed
generalization of opening allows the opener to output ``any value''. Hence, the
need to ensure that the produced value is the legitimate one, seems to be more
necessary than ever. Finally, our \feval function is a generalization of $F$ in
MPS, as it allows two outputs: one will be returned in the clear along with the
signature, and the other will be encrypted. Still both computations are proved
correct. Making part of the output unencrypted allows implementing very useful
variants such as anonymous credentials with selective disclosure -- as shown
before.

For the model of MPS schemes, we refer to the original paper \needcite.

\subsubsection{\CUASMPS construction.} %
As mentioned, any $(\fissue^1,\feval^{\yeval^1},\finsp^\ast)$-restriction of
\CUASGen with only one issuer and opener, one credential per user, and one
attribute per credential (the user secret key), implements an MPS scheme where
$F=\feval^{\yeval^1}$ and $G=\finsp^\ast$. The restriction to one credential per
user, and one attribute per credential, can be done as in
\appref{sapp:related-models-gs}. Finally, note that, in MPS, $G$ is further
parameterized with a value $j$, which essentially is the result of applying $F$
to the message and signer identity, and is not leaked to the opener nor any
other third party. The equivalent in \UAS is the $\yeval^1$ value, which is
encrypted with a single-use key pair, and is an input of \yinsp.

\paragraph{Security of \CUASMPS.} %
As stated, we restrict to privacy-1 of MPS. Unforgeability-1 in MPS is
equivalent to sign unforgeability in \UAS. Unforgeability-2 in MPS is
equivalent to non-frameability in \UAS. Finally note that, in UAS, we do not
explicitly model extractability, but rather make it an inherent requirement in
the unforgeability and non-frameability definitions. Thus, our \CUASMPS
construction also ensures MPS-extractability.

\begin{theorem}[Privacy-1 of \CUASMPS]
  If the base \CUASGen construction has signature anonymity according to
  \defref{def:sign-anonymity-uas}, then \CUASMPS satisfies privacy-1
  according to \needcite.
\end{theorem}

\begin{proof}
  The proof is direct, by observing that the models are equivalent.
  
  First, note that, in MPS the adversary is required to output a function $F$,
  challenge message, and a pair of user secret keys and witnesses (in \UAS, the
  witnesses are the credentials). This is precisely what \CHALb requires as
  input in our \UAS modelling.

  Next, in MPS, validity of the output of $F$ is checked. In MPS, this
  translates to checking that $F$ does not ouptut $0$. In UAS, this is checked
  in the \SIGN and \CHALb oracles, which abort if the output produced by \feval
  does not belong in \rngfeval -- a well defined set of acceptable outputs by
  the chosen \feval.

  The MPS adversary is then allowed to make more oracle queries, and outputs a
  response bit. Just as in \UAS. Thus, if \CUASMPS satisfies signature
  anonymity, it is also an MPS scheme satisfying privacy-1.  
  % 
  \qed
\end{proof}

\begin{theorem}[Extractability of \CUASMPS]
  If the base \CUASGen construction has signature unforgeability according to
  \defref{def:sign-forge-uas}, then it is an extractable MPS scheme.
\end{theorem}

\begin{proof}
  The proof is direct, as the conditions checked in the extractability
  experiment in MPS are also checked in the signature unforgeability experiment
  for \UAS.

  Concretely, \Verify must accept the signature, and the ouptut of \feval and
  \finsp, computed with the values extracted by \ExtractSign, must respectively
  match those output by the adversary (for \feval), and computed honestly by the
  signature unforgeability (for \finsp).  
  \qed
\end{proof}

\begin{theorem}[Unforgeability-1 of \CUASMPS]
  If the base \CUASGen construction has signature unforgeability according to
  \defref{def:sign-forge-uas}, then \CUASMPS satisfies unforgeability-1 as
  defined in \needcite.
\end{theorem}

\begin{proof}
  For an MPS scheme to satisfy type-1 unforgeability, it has to be extractable.
  This is directly satisfied by signature unforgeability in \UAS.
  %
  Next, the adversary wins in the unforgeability-1 MPS experiment if it manages
  to produce a signature that has not been produced via a call to their \SIGN
  oracle, nor it can be associated to an corrupt user. Indeed, if that happens,
  then such adversary can be used to build an adversary winning the signature
  unforgeability game against \CUASMPS, through winning condition at line 12 --
  as \IdentifyUK does not return 1 for any known \uid. Thus, if \CUASMPS has
  signature unforgeability, it also satisfies unforgeability-1 of MPS schemes.
  %
  \qed
\end{proof}

\begin{theorem}[Unforgeability-2 of \CUASMPS]
  If the base \CUASGen construction has non-frameability according to
  \defref{def:frame-uas}, then \CUASMPS satisfies unforgeability-2 as
  defined in \needcite.
\end{theorem}

\begin{proof}
  For an MPS scheme to have type-2 unforgeability, it has to be extractable.
  This is directly satisfied by non-frameability in UAS (a similar reasoning
  as for signature unforgeability and extractability applies here).
  %
  Next, in MPS, the adversary wins if the produced signature has not been
  output by the \SIGN oracle, but Extract outputs the identifier of an honest
  user. This is the same check done in lines 9 and 10 of the non-frameability
  game in \UAS. Therefore, if \CUASMPS satisfies non-frameability as defined in
  \defref{def:frame-uas}, it also satisfies type-2 unforgeability in MPS.
  \qed
\end{proof}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "uas"
%%% End:
