\subsection{\CUASGen: A Generic \UAS Construction}
\label{ssec:generic-construction-uas}

In this section, we give a generic construction of an \UAS scheme, based on
generic building blocks. We use three different NP relations in our generic
construction. Namely:

\begin{description}
\item[$\NIZKRel_{\Issue}$:] Set by issuers, governs via \fissue the rules for
  issuing new credentials. It is defined as $\NIZKRel_{\Issue} = \lbrace
  (\usk,\scred,\attrs_{\scred},r), (\Ccom,\attrs,\sipk_{\scred}): \Ccom =
  \CCommit(usk;r) \land \fissue(\usk,\scred,\attrs) = 1 \land \forall \cred \in
  \scred, \SBCMVerify(\ipk_{\cred},\cred,\usk,\attrs_{\cred}) = 1 \rbrace$,
  where for readability we write $\attrs_{\scred}$ as abbreviation for $\lbrace
  \attrs_{\cred} \rbrace_{\cred \in \scred}$, and similarly for $\sipk_{\scred}$.
  Basically, this relation requires that, in order to issue a credential with
  attribtes \attr, and bound to \usk, the requester has to commit to \usk and
  prove knowledge of it, as well as prove that all additional credentials needed
  for the issuing to be granted, meet some defined policy \fissue.
\item[$\NIZKRel_{\Sign}$:] Can be set by anyone but, for simplicity, assume
  verifiers define them. Governs via \feval and \finsp what utility
  information is directly revealed by signatures, or extracted by openers.
  It is defined as $\NIZKRel_{\Sign} = \lbrace (\usk,\scred,
  \attrs_{\scred},\yeval^1,\yinsp,r,r'),(\msg,\feval,\yeval^0,\ceval,\cinsp,
  \sipk_{\scred},\Eek,\widetilde{\Eek}): \ceval = \EEnc(\widetilde{\Eek},\yeval^1;r)
  \land \cinsp= \EEnc (\Eek,\yinsp;r') \land (\yeval^0,\yeval^1) = \feval(\usk,
  \scred,\msg) \land \yinsp = \finsp((\yeval^0,\yeval^1),\usk,\scred,\msg) \land
  \forall \cred \in \scred, \SBCMVerify(\ipk_{\cred},\cred,\usk,\attrs_{\cred})
  = 1) \rbrace$, with $\attrs_{\scred}$ and $\sipk_{\scred}$ as in
  $\NIZKRel_{\Issue}$. In a
  nutshell, this relation ensures that signatures will produce the correct
  signature evaluation and opening values, and that any credential used to
  create the signature is bound to the same \usk key.
\item[$\NIZKRel_{\Open}$:] Ensures that the utility information extracted by
  the \Open algorithm is correct. It is defined as $\NIZKRel_{\Open} =
  \lbrace (\osk),(\Ec,\yinsp): \yinsp = \EDec(\osk,\Ec) \rbrace$.
\end{description}

\paragraph{$\parm \gets \Setup(\secpar,\AttrSpace)$.} %
The setup process essentially consists on generating the public parameters
for all the building blocks. In detail, it parses \secpar as $(\Csecpar,
\NIZKsecpar,\SBCMsecpar,\Esecpar)$. Then, run $\Cparm \gets
\CSetup(\Csecpar)$, $\SBCMparm \gets  \SBCMSetup(\SBCMsecpar)$, $\Sparm \gets
\SSetup(\Ssecpar)$, $\Eparm \gets \ESetup(\Esecpar)$, $\NIZKcrs_{\Issue} \gets
\NIZKSetup^{\NIZKRel_{\Issue}}(\NIZKsecpar)$, $\NIZKcrs_{\Sign} \gets
\NIZKSetup^{\NIZKRel_{\Sign}}(\NIZKsecpar)$, and $\NIZKcrs_{\Open} \gets
\NIZKSetup^{\NIZKRel_{\Open}}(\NIZKsecpar)$. Return $(\Cparm,\SBCMparm,
\Sparm,\Eparm,\NIZKcrs_{\Issue},\NIZKcrs_{\Sign},\NIZKcrs_{\Open},
\AttrSpace)$. Note that many of these parameter setup algorithms can
actually be run by separate entities (respecting some commonalities like,
e.g., same pairing-friendly curves). For instance, each opener could
run its own \ESetup algorithm, or each verifier its
$\NIZKSetup^{\NIZKRel_{\Sign}}$, to advertise the signing evaluation functions
it accepts. For simplicity of exposition, we bundle them together here.

\paragraph{$(\ipk,\isk) \gets \IKeyGen(\parm,\fissue)$.} %
To generate its key pair, each issuer first parses \parm as $(\cdot,\SBCMparm,
\Sparm,\cdot,\cdot,\cdot,\cdot,\cdot)$. Then, runs $(\Svk,\Ssk) \gets
\SKeyGen(\Sparm)$, $(\SBCMvk,\SBCMsk) \gets \SBCMKeyGen(\SBCMparm)$,
$\sig_{\fissue} \gets \SSign(\Ssk,\fissue)$, $\ipk \gets (\Svk,\fissue,
\sig_{\fissue})$, $\isk \gets \Ssk$ and return $(\ipk,\isk)$.

\paragraph{$(\opk,\osk) \gets \OKeyGen(\parm,\finsp)$.} %
To generate its key pair, each opener first parses \parm as $(\cdot,\cdot,
\cdot,\Eparm,\cdot,\cdot,\cdot,\cdot)$. Then, runs $(\Svk,\Ssk) \gets \SKeyGen
(\Sparm)$, $(\Eek,\Edk) \gets \EKeyGen(\Eparm)$, $\sig_{\finsp} \gets \SSign
(\Ssk,\finsp)$, $\opk \gets (\Svk,\Eek,\finsp,\sig_{\finsp})$, and $\osk \gets
(\Ssk,\Edk)$.

\paragraph{$\usk \gets \UKeyGen(\parm)$.} %
Each user, prior to requesting credentials, generates his secret key by parsing
\parm as $(\cdot,\cdot,\cdot,\cdot,\cdot,\AttrSpace)$, and picking randomly
$\usk \getr \AttrSpace$.

\paragraph{$\langle \cred/\bot,\utrans/\bot \rangle \gets
  \langle\Obtain(\usk,\ipk,\scred,\attrs),\Issue(\isk,\sipk,\attrs)\rangle$.} %
The protocol is run between an issuer with key pair $(\ipk,\isk)$, and a user
with secret key \usk and credentials \scred, where each $\cred \in \scred$ is
issued by an issuer with
public key $\ipk_{\cred}$ (which we assume that the user can easily retrieve,
e.g., from secure storage, given \cred), and attests attributes
$\attrs_{\cred}$. The user requests a signature on a commitment to the user key,
as well as on the attributes in \attrs. In addition, the user proves that the
issuance function \fissue established by the issuer is satisfied by the
credentials in $\scred$
and its user secret key. For this, we use relation $\NIZKRel_{\Issue}$, as
defined above. The interactive protocol for a user to obtain a credential from
an issuer of the system is then simply an execution of the interactive signing
protocol of an \SBCM scheme, where the user runs $\SBCMCom(\ipk,\usk,\attrs)$,
and the issuer runs $\SBCMSign(\isk,\attrs)$; in both cases, using
$\NIZKRel_{\Issue}$ as \NIZK relation. The credential \cred produced by the user
is the result of the interactive signing protocol, and the \utrans entry for
the issuer is its transcript which is a $(\Ccom,\attrs,\sipk,\cred,\pi)$ tuple.

\iffalse
\begin{itemize}
\item \uline{User}: Commit to the user secret key with $\Ccom \gets
  \CCommit(\usk)$. Compute proof $\NIZKproof \gets
  \NIZKProve^{\NIZKRel_{\Issue}}(\NIZKcrs_{\Issue},(\usk,\scred,\attrs_{\scred}),
  (\Ccom,\attrs,\sipk_{\scred}))$. Send $(\Ccom,\NIZKproof)$ to Issuer.
\item \uline{Issuer}: Verify \NIZKproof with $\NIZKVerify^{\NIZKRel_{\Issue}}
  (\NIZKcrs_{\Issue},\NIZKproof,(\Ccom,\attrs,\sipk))$, and abort if it fails. Then,
  compute the credential by running $\cred \gets \SBCMSign(\SBCMsk,\Ccom,
  \attrs)$. Send \cred to User. Output $\utrans \gets (\Ccom,\attrs,\sipk,
  \cred,\NIZKproof)$.
\item \uline{User}: Verify the credential with $\SBCMVerify(\SBCMvk,\cred,
  \attrs \cup \lbrace \usk \rbrace)$. Reject if verification fails.
  Otherwise, return \cred.
\end{itemize}
\fi

\paragraph{$\Sig \gets \Sign(\usk,\opk,\scred,\msg,\feval)$.} %
In the signing algorithm, we make use of relation $\NIZKRel_{\Sign}$.
% 
From this, in order to produce a valid signature, the user first evaluates
$(\yeval^0,\yeval^1) \gets \feval (\usk,\scred,\msg)$, and decides whether or
not to continue with the signing process -- this may depend, e.g., on the
opening policy of \opk, as the output of \feval may influence whether the user
will be de-anonymizable or not, depending on the \finsp function in \opk.
%
The user also computes a random encryption key pair with $(\widetilde{\Eek},
\widetilde{\Edk}) \gets \EKeyGen(\Eparm)$. Then, the user parses \opk as $(\Svk,\Eek,
\finsp,\sig_{\finsp})$ and checks that $\Verify(\Svk,\sig_{\finsp},\finsp) = 1$
(note that this step may be cached), to compute $\yinsp \gets \finsp((\yeval^0,
\yeval^1),\usk,\scred,\msg)$, and separately encrypts both $\yeval^1$ and
\yinsp by running $\ceval \gets \EEnc(\widetilde{\Eek},\yeval^1;r)$ and $\cinsp \gets
\EEnc(\Eek,\yinsp; r')$ for some fresh randomness $r,r'$. Finally, the user
computes $\NIZKproof \gets \NIZKProve^{\NIZKRel_{\Sign}}(\NIZKcrs_{\Sign},(\usk,
\scred, \attrs_{\scred},\yeval^1,\yinsp,r,r'),(\msg,\feval,\yeval^0,\ceval,\cinsp,
\sipk_{\scred},\Eek,\widetilde{\Eek}))$ and outputs $(\sig = (\NIZKproof,\ceval,
\cinsp),\yeval^0)$.

\paragraph{$1/0 \gets \Verify(\opk,\sipk,\Sig,\msg,\feval)$.} %
The ``cryptographic'' side of the verification essentially consists on checking
the NIZK proof. That is, parse \Sig as $(\sig = (\NIZKproof,\cinsp),\yeval,
\ceval)$ and check whether $\NIZKVerify(\NIZKcrs,\NIZKproof,(\msg,\feval,\yeval,
\ceval,\cinsp,\sipk,\opk)) = 1$. In addition, the verifier may further check
whether \yeval meets its needs.

\paragraph{$(\yinsp,\NIZKproof)/\bot \gets
  \Open(\osk,\sipk,\Sig,\msg,\feval)$.} %
Here we leverage relation $\NIZKRel_{\Open}$.
%
To open a signature, the opener first verifies the signature by running $\Verify
(\opk,\sipk, \Sig,\msg,\feval)$. If verification succeeds, it parses
\Sig as $(\sig=(\NIZKproof,\cinsp),\yeval,\ceval)$, decrypts \Ec by running $\yinsp
\gets \EDec(\osk,\cinsp)$, and computes $\NIZKproof_{\Open} \gets
\NIZKProve^{\NIZKRel_{\Open}}(\NIZKcrs_{\Open},\osk,(\cinsp,\yinsp))$. It
returns $(\yinsp,\NIZKproof_{\Open})$.

\paragraph{$1/0 \gets \Judge(\opk,\yinsp,\NIZKproof,\Sig,\msg)$.} %
To assess the validity of an opening proof, first check the signature
by running $\Verify(\opk,\sipk,\Sig,\msg,\feval)$. If the check succeeds,
parse \Sig as $((\cdot,\cinsp),\cdot,\cdot)$ and verify \NIZKproof with
$\NIZKVerify(\NIZKcrs_{\Open},\NIZKproof,(\cinsp,\yinsp))$. Accept it the NIZK
verification passes, and reject otherwise.

%\input{security-uas.tex}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "uas"
%%% End:
