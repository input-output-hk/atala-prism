\section{\CUASGen: A Generic \UAS Construction}
\label{sec:gen-construction}

In this section, we give a generic construction of an \UAS scheme, based on
generic building blocks. In \secref{sec:instantiation}, we give a concrete
instantiation.

\subsection{Building Blocks}
\label{ssec:bblocks}

\paragraph{Vector Commitment schemes.} %
Defined as a tuple $(\CSetup,\CCommit)$. Algorithm $\Cparm \gets
\CSetup(\Csecpar)$ produces the parameters for committing to values. $\Ccom
\gets \CCommit(\Cparm, \msgset; r)$ produces a commitment \Ccom over a set of
messages \msgset, from which we may omit randomness $r$. \todo{Informally define
  hiding and binding, leaving formal definitions to the appendix.}

\paragraph{Public-Key Encryption.} %
Defined as a tuple $(\ESetup,\EKeyGen,\EEnc,\EDec)$. Algorithm $\Eparm \gets
\ESetup(\Esecpar)$ produces public parameters for the other algorithms.
$(\Eek,\Edk) \gets \EKeyGen(\Eparm)$ generates the encryption-decryption key
pair, algorithm $\Ec \gets \EEnc(\Eek,\msg)$ encrypts message \msg with
encryption key \Eek, producing ciphertext \Ec, and $\msg/\bot \gets \EDec(\Edk,
\Ec)$ decrypts ciphertexts using decryption key \Edk. \todo{Informally define
  security properties we'll need.}

\paragraph{Digital Signatures.} %
Defined as a tuple $(\SSetup,\SKeyGen,\SSign,\SVerify)$. Algorithm $\Sparm \gets
\SSetup(\Ssecpar)$ produces public parameters for the other algorithms.
$(\Svk,\Ssk) \gets \SKeyGen(\Sparm)$ generates the verification-signing key
pair, algorithm $\Ssig \gets \SSign(\Ssk,\msg)$ signs message \msg with
signing key \Ssk, producing signature \Ssig, and $1/0 \gets \SVerify(\Svk,
\Ssig,\msg)$ checks whether \Ssig is a valid signature over \msg, under
verification key \Svk. \todo{Informally define security properties we'll need.}

\paragraph{Non-Interactive Zero-Knowledge.} %
We use non-interactive zero-knowledge proofs of knowledge (NIZK), in the CRS
model \needcite. Informally, a NIZK scheme over an NP relation \NIZKRel is
defined as a tuple $(\NIZKSetup^\NIZKRel,\NIZKProve^\NIZKRel,
\NIZKVerify^\NIZKRel)$. Algorithm $\NIZKcrs \gets \NIZKSetup^\NIZKRel
(\NIZKsecpar)$ produces the common reference string \NIZKcrs. $\NIZKproof/\bot
\gets \NIZKProve^\NIZKRel(\NIZKcrs,\NIZKw,\NIZKx)$ creates a NIZK proof of
knowledge of witness \NIZKw for \NIZKx such that $(\NIZKw,\NIZKx) \in \NIZKRel$.
$1/0 \gets \NIZKVerify^\NIZKRel(\NIZKcrs,\NIZKx,\NIZKproof)$ verifies the proof.
\todo{Informally define security properties we'll need.}

\paragraph{Signatures over Blocks of Committed Messages, with proofs.} %
We use signature schemes that allow signing messages, or commitments to messages,
in blocks, and are compatible with (efficient) proof systems over the produced
signature and signed (commitments to) messages. For this purpose, we define such
schemes as a tuple $(\SBCMSetup,\SBCMKeyGen,\SBCMSign,\SBCMVerify)$. Algorithm
$\SBCMparm \gets \SBCMSetup(\SBCMsecpar)$ produces the public parameters for the
scheme. $(\SBCMvk,\SBCMsk) \gets \SBCMKeyGen(\SBCMparm)$ produces a
verification-signing key
pair. Algorithm $\SBCMsig \gets \SBCMSign(\SBCMsk,\Ccom,\msgset)$ produces a
signature over a set of committed messages \Ccom and a set of messages
\msgset, where either \Ccom or \msgset may be empty. $1/0 \gets
\SBCMVerify(\SBCMvk,\SBCMsig,\overline{\msgset})$ verifies a signature \SBCMsig
over message set $\overline{\msgset}$, which must contain both the messages that
were signed as commitments as well as those signed in ``the clear''. In
addition, the produced signatures must be compatible with (efficient) NIZK
proofs of knowledge of a signature, and of (arbitrary) claims over the signed
(committed) messages.
\todo{Informally define security properties we'll need.}

\subsection{Generic Construction \CUASGen}
\label{ssec:generic-construction-uas}

We use three different NP relations in our generic construction. Namely,
$\NIZKRel_{\Issue}$ for issuance, $\NIZKRel_{\Sign}$ for signing, and
$\NIZKRel_{\Inspect}$ for inspection. We will be defining them in the
corresponding protocol/algorithm.

\todo{Many variables need renaming here.}

\paragraph{$\parm \gets \Setup(\secpar,\AttrSpace)$.} %
The setup process essentially consists on generating the public parameters
for all the building blocks. In detail, it parses \secpar as $(\Csecpar,
\NIZKsecpar,\SBCMsecpar,\Esecpar)$. Then, run $\Cparm \gets
\CSetup(\Csecpar)$, $\SBCMparm \gets  \SBCMSetup(\SBCMsecpar)$, $\Sparm \gets
\SSetup(\Ssecpar)$, $\Eparm \gets \ESetup(\Esecpar)$, $\NIZKcrs_{\Issue} \gets
\NIZKSetup^{\NIZKRel_{\Issue}}(\NIZKsecpar)$, $\NIZKcrs_{\Sign} \gets
\NIZKSetup^{\NIZKRel_{\Sign}}(\NIZKsecpar)$, and $\NIZKcrs_{\Inspect} \gets
\NIZKSetup^{\NIZKRel_{\Inspect}}(\NIZKsecpar)$. Return $(\Cparm,\SBCMparm,
\Sparm,\Eparm,\NIZKcrs_{\Issue},\NIZKcrs_{\Sign},\NIZKcrs_{\Inspect},
\AttrSpace)$

\paragraph{$(\ipk,\isk) \gets \IKeyGen(\parm,\fissue)$.} %
To generate its key pair, each issuer first parses \parm as $(\cdot,\SBCMparm,
\Sparm,\cdot,\cdot,\cdot,\cdot,\cdot)$. Then, runs $(\Svk,\Ssk) \gets
\SKeyGen(\Sparm)$, $(\SBCMvk,\SBCMsk) \gets \SBCMKeyGen(\SBCMparm)$,
$\sig_{\fissue} \gets \SSign(\Ssk,\fissue)$, $\ipk \gets (\Svk,\fissue,
\sig_{\fissue})$, $\isk \gets \Ssk$ and return $(\ipk,\isk)$.

\paragraph{$(\opk,\osk) \gets \OKeyGen(\parm,\finsp)$.} %
To generate its key pair, each inspector first parses \parm as $(\cdot,\cdot,
\cdot,\Eparm,\cdot,\cdot,\cdot,\cdot)$. Then, runs $(\Svk,\Ssk) \gets \SKeyGen
(\Sparm)$, $(\Eek,\Edk) \gets \EKeyGen(\Eparm)$, $\sig_{\finsp} \gets \SSign
(\Ssk,\finsp)$, $\opk \gets (\Svk,\Eek,\finsp,\sig_{\finsp})$, and $\osk \gets
(\Ssk,\Edk)$. Finally, returns $(\opk,\osk)$.

\paragraph{$\usk \gets \UKeyGen(\parm)$.} %
Each user, prior to requesting credentials, generates his secret key by parsing
\parm as $(\cdot,\cdot,\cdot,\cdot,\cdot,\AttrSpace)$, and picking randomly
$\usk \getr \AttrSpace$. Finally, return \usk.

\paragraph{$\langle \cred/\bot,\utrans/\bot \rangle \gets
  \langle\Obtain(\usk,\scred,\attrs),\Issue(\isk,\upk,\sipk,\attrs)\rangle$.} %
The protocol is run between an issuer, and a user with secret key \usk and
credentials \scred, where each $\cred \in \scred$ is issued by an issuer with
public key $\ipk_{\cred}$ (which we assume that the user can easily retrieve,
e.g., from secure storage, given \cred), and attests attributes
$\attrs_{\cred}$. For readability we write $\attrs_{\scred}$ as abbreviation for
$\lbrace \attrs_{\cred} \rbrace_{\cred \in \scred}$, and similarly for
$\sipk_{\scred}$. The user requests a signature on a commitment to the user key,
as well as on the attributes in \attrs. In addition, the user proves that the
issuance function \fissue established by the issuer is satisfied by the
credentials in $\scred$
and its user secret key. For this, we define relation $\NIZKRel_{\Issue} = \lbrace
(\usk,\scred,\attrs_{\scred}), (\Ccom,\attrs,\sipk_{\scred}): \Ccom = \CCommit(usk) \land
\fissue(\usk,\scred,\attrs) = 1 \land \forall \cred \in \scred,
\SBCMVerify(\ipk_{\cred},\cred,
\attrs_{\cred} \cup \lbrace \usk \rbrace) = 1 \rbrace$. The interactive protocol
for a user to obtain a credential from an issuer of the system is as follows:

\begin{itemize}
\item \uline{User}: Commit to the user secret key with $\Ccom \gets
  \CCommit(\usk)$. Compute proof $\NIZKproof \gets
  \NIZKProve^{\NIZKRel_{\Issue}}(\NIZKcrs_{\Issue},(\usk,\scred,\attrs_{\scred}),
  (\Ccom,\attrs,\sipk_{\scred}))$. Send $(\Ccom,\NIZKproof)$ to Issuer.
\item \uline{Issuer}: Verify \NIZKproof with $\NIZKVerify^{\NIZKRel_{\Issue}}
  (\NIZKcrs_{\Issue},\NIZKproof,(\Ccom,\attrs,\sipk))$, and abort if it fails. Then,
  compute the credential by running $\cred \gets \SBCMSign(\SBCMsk,\Ccom,
  \attrs)$. Send \cred to User. Output $\utrans \gets (\Ccom,\attrs,\sipk,
  \cred,\NIZKproof)$.
\item \uline{User}: Verify the credential with $\SBCMVerify(\SBCMvk,\cred,
  \attrs \cup \lbrace \usk \rbrace)$. Reject if verification fails.
  Otherwise, return \cred.
\end{itemize}

\paragraph{$(\sig,\yeval) \gets \Sign(\usk,\opk,\scred,\msg,\feval)$.} %
In the signing algorithm, we make use of the following relation:
$\NIZKRel_{\Sign} = \lbrace (\usk,\scred,\attrs_{\scred},\yinsp,r),(\msg,\feval,
\yeval,\Ec,\sipk_{\scred},\Eek): \Ec = \EEnc(\Eek,\yinsp;r) \land \yeval =
\feval(\usk,\scred,\msg) \land
\yinsp = \finsp(\yeval,\usk,\scred,\msg) \land \forall \cred \in \scred,
\SBCMVerify(\ipk_{\cred},\cred,\attrs_{\cred} \cup \lbrace \usk \rbrace) = 1)
\rbrace$ where, for each $\cred \in \scred$, $\attrs_{\cred}$ and $\ipk_{\cred}$,
as well as $\attrs_{\scred}$ and $\sipk_{\scred}$ are as in $\langle \Obtain,
\Issue \rangle$.
%
From this, in order to produce a valid signature, the user first evaluates
$\yeval \gets \feval (\usk,\scred,\msg)$, and decides whether or not to continue
with the signing process -- this may depend, e.g., on the inspection policy of
\opk, as the output of \feval may influence whether the user will be
de-anonymizable or not, depending on the \finsp function in \opk.
%
Then, the user parses \opk as $(\Svk,\Eek,\finsp,\sig_{\finsp})$ and checks that
$\Verify(\Svk,\sig_{\finsp},\finsp) = 1$ (note that this step may be cached), to
compute $\yinsp \gets \finsp(\yeval,\usk,\scred,\msg)$, and encrypt it with
\Eek by running $\Ec \gets \EEnc(\Eek,\yeval;r)$ for some fresh randomness $r$.
Finally, the user computes
$\NIZKproof \gets \NIZKProve^{\NIZKRel_{\Sign}}(\NIZKcrs_{\Sign},(\usk,\scred,
\attrs_{\scred},\yinsp,r),(\msg,\feval,\yeval,\Ec,\sipk_{\scred},\Eek))$ and
outputs $(\sig = (\NIZKproof,\Ec),\yeval)$.

\paragraph{$1/0 \gets \Verify(\opk,\sipk,\sig,\yeval,\msg,\feval)$.} %
The ``cryptographic'' side of the verification essentially consists on checking
the NIZK proof. That is, parse \sig as $(\NIZKproof,\Ec)$ and check whether
$\NIZKVerify(\NIZKcrs,\NIZKproof,(\msg,\feval,\yeval,\Ec,\sipk,\opk)) = 1$. In
addition, the verifier may further check whether \yeval meets its needs.

\paragraph{$(\yinsp,\NIZKproof)/\bot \gets
  \Inspect(\osk,\sipk,\sig,\yeval,\msg,\feval)$.} %
We first define NIZK relation $\NIZKRel_{\Inspect} = \lbrace (\osk),(\Ec,\yinsp)
: \yinsp = \EDec(\osk,\Ec) \rbrace$.
%
For inspection, the inspector first verifies the signature by running $\Verify(
\opk,\sipk, \sig,\yeval,\msg,\feval)$. If the verification succeeds, it parses
\sig as $(\NIZKproof,\Ec)$, decrypts \Ec by running $\yeval \gets \EDec(\osk,
\Ec)$, and computes $\NIZKproof_{\Inspect} \gets \NIZKProve^{\NIZKRel_{\Inspect}}
(\NIZKcrs_{\Inspect},\osk,(\Ec,\yinsp))$. It returns $(\yinsp,
\NIZKproof_{\Inspect})$.

\paragraph{$1/0 \gets \Judge(\opk,\yinsp,\NIZKproof,\sig,\yeval,\msg)$.} %
To assess the validity of an inspection proof, first check the signature
by running $\Verify(\opk,\sipk, \sig,\yeval,\msg,\feval)$. If the check succeeds,
parse \sig as $((\cdot,\Ec),\cdot)$ and verify \NIZKproof with $\NIZKVerify
(\NIZKcrs_{\Inspect},\NIZKproof,(\Ec,\yinsp))$. Accept it the NIZK verification
passes, and reject otherwise.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "uas"
%%% End:
