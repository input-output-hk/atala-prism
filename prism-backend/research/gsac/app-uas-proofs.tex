\section{Correctness and Security Proofs for \CUASGen}
\label{app:uas-proofs}

Next, we define the \SimSetup, \ExtractIssue, \ExtractSign functions. \SimSetup
(formally defined in \figref{fig:helper-funcs}) essentially replaces the
\Setup algorithm of each NIZK with the corresponding \NIZKSimSetup algorithm,
and returns the generated parameters along with the
trapdoors. \ExtractIssue and \ExtractSign simply run the \Extract functions
of the corresponding \NIZK scheme, leveraging the trapdoor produced during
\SimSetup. Note that, due to the zero-knowledge and simulation extractability
properties (respectively) of the underlying NIZKs, the result of \SimSetup
is indistinguishable from that of \Setup, and the extracted values match those
used as witnesses in the proofs.

\begin{figure}[ht!]
  \centering  
  \scalebox{0.9}{
    \begin{minipage}[t]{\textwidth}
      \procedure{$\SimSetup(1^\secpar)$}{%
        \textrm{Parse}~\secpar~\textrm{as}~(\Csecpar,\NIZKsecpar,\SBCMsecpar,
        \Esecpar). \\
        \Cparm \gets \CSetup(\Csecpar), \SBCMparm \gets  \SBCMSetup(\SBCMsecpar) \\
        \Sparm \gets \SSetup(\Ssecpar), \Eparm \gets \ESetup(\Esecpar) \\
        (\NIZKcrs_{\Issue},\trap_{\Issue}) \gets
        \NIZKSimSetup^{\NIZKRel_{\Issue}}(\NIZKsecpar) \\
        (\NIZKcrs_{\Sign},\trap_{\Sign}) \gets
        \NIZKSimSetup^{\NIZKRel_{\Sign}}(\NIZKsecpar) \\
        (\NIZKcrs_{\Open},\trap_{\Open}) \gets
        \NIZKSimSetup^{\NIZKRel_{\Open}}(\NIZKsecpar) \\
        \pcreturn ((\Cparm,\SBCMparm,\Sparm,\Eparm,\NIZKcrs_{\Issue},
        \NIZKcrs_{\Sign},\NIZKcrs_{\Open},\AttrSpace), \\
        \pcind (\trap_{\Issue},\trap_{\Sign},\trap_{\Open}))
      }
      
      % \procedure{$\ExtractIssue(\parm,\trap,\utrans)$}{%
      %   \textrm{Parse \parm as $(\cdot,\cdot,\cdot,\cdot,\NIZKcrs_{\Issue},\cdot,
      %     \cdot,\cdot)$} \\
      %   \textrm{Parse \trap as $(\trap_{\Issue},\cdot,\cdot)$, and
      %     \utrans as $(\Ccom,\sipk,\cred,\NIZKproof)$} \\
      %   \pcif \NIZKVerify^{\NIZKRel_{\Issue}}(\NIZKcrs_{\Issue},
      %   \NIZKproof,(\Ccom,\attrs,\sipk)): \pcreturn \bot \\
      %   (\usk,\credid,\scred,\attrs_{\scred}) \gets
      %   \NIZKExtract^{\NIZKRel_{\Issue}}(\NIZKcrs_{\Issue},
      %   \trap_{\Issue},
      %   (\Ccom,\attrs,\sipk),\NIZKproof) \\
      %   \textrm{Let \credid be}~\suchthat~\trans[\credid] = \utrans;
      %   \uid \gets \OWNR[\credid] \\        
      %   \pcif \uid \in \HU \land \UK[\uid] \neq \usk: \pcreturn \bot \\
      %   \pcelse: \\
      %   \pcind \pcif \UK[\uid] = \bot: \UK[\uid] \gets \usk \\
      %   \pcind \pcelse \pcif \UK[\uid] \neq \usk: \pcreturn 0 \\
      %   \pcreturn (\uid,\usk,\credid,\scred,\attrs_{\scred}) \\
      % }
      
      % \procedure{$\ExtractSign(\parm,\trap,\oid,\siid,\sig,\yeval,\msg,\feval)$}{%
      %   \textrm{Parse \parm as $(\cdot,\cdot,\cdot,\cdot,\cdot,\NIZKcrs_{\Sign},
      %     \cdot)$} \\
      %   \textrm{Parse \trap as $(\cdot,\trap_{\Sign},\cdot)$, and
      %     \sig as $(\NIZKproof,\ceval,\cinsp)$} \\
      %   \textrm{Parse $\PUBOK[\oid]$ as $(\opk,\cdot)$ and let $\sipk \gets
      %     \PUBIK[\siid]$} \\
      %   \pcif \NIZKVerify^{\NIZKRel_{\Sign}}(\NIZKcrs_{\Sign},\NIZKproof,
      %   (\msg,\feval,\yeval,\Ec,\sipk,\opk)): \pcreturn \bot \\
      %   (\usk,\scredid,\scred,\attrs_{\scred},\yinsp,r) \gets
      %   \NIZKExtract^{\NIZKRel_{\Sign}}(\NIZKcrs^{\NIZKRel_{\Sign}},
      %   \NIZKtrap_{\Sign},
      %   (\msg,\feval,\yeval^0,\ceval,\cinsp,\sipk,\opk,\widetilde{\Eek}),
      %   \NIZKproof) \\
      %   \pcif \exists \uid \in \HU~\suchthat~\UK[\uid] = \usk: \\
      %   \pcreturn (\uid,\usk,\scred,\attrs_{\scred},\yeval^1,\yinsp) \\
      %   \pcelse \textrm{\todo{Need to add \cid as explicit attribute to the
      %       credentials (chosen by issuer) so that can bookkeep.}} \\
      %   \pcelse \textrm{\todo{then adapt the rest}} \\
      %   \pcind \pcelse \pcif \UK[\uid] \neq \usk: \pcreturn 0 \\
      %   \pcreturn (\usk,\scred,\attrs_{\scred},\yeval^1,\yinsp) \\
      % }
      
      % % \procedure{$\IdentifyCred(\parm,\trap,\usk,\attrs_{\cred},\cred)$}{%
      % %   \pcreturn \SBCMVerify(\ipk_{\cred},\cred,\usk,\attrs_{\cred}) \\
      % % }

      % \procedure{$\IdentifyCred(\parm,\trap,\usk,\attrs_{\cred},\cred,\ipk)$}{%
      %   \pcreturn \SBCMVerify(\ipk,\cred,\usk,\attrs_{\cred}) \\
      % }      

      % \procedure{$\IdentifySig(\parm,\trap,\usk,\scred,\Sig)$}{%
      %   \pcif \uid \in \HU: \pcreturn \usk = \UK[\uid] \\
      %   \pcfor \cid~\suchthat~\CRED[\cid] = (\uid,\cdot,\cdot,\cdot,\cdot,\cdot) \\
      %   \pcind (\usk',\cdot,\cdot,\cdot) \gets \ExtractIssue(\parm,\trap,\trans[\cid]) \\
      %   \pcind \pcif \usk = \usk': \pcreturn 1 \\
      %   \pcreturn 0
      % }

      % % \procedure{$\IdentifySig(\parm,\trap,\uid,\usk)$}{%
      % %   \pcif \uid \in \HU: \pcreturn \usk = \UK[\uid] \\
      % %   \pcfor \cid~\suchthat~\CRED[\cid] = (\uid,\cdot,\cdot,\cdot,\cdot,\cdot) \\
      % %   \pcind (\usk',\cdot,\cdot,\cdot) \gets \ExtractIssue(\parm,\trap,\trans[\cid]) \\
      % %   \pcind \pcif \usk = \usk': \pcreturn 1 \\
      % %   \pcreturn 0
      % % }
      
    \end{minipage}
  }
  \label{fig:helper-funcs}
  \caption{Definition of helper function \SimSetup, for \CUASGen.}
\end{figure}

\subsection{Correctness}

\begin{proof}[\thmref{thm:correctness-uas}; Correctness of \CUASGen]
  By correctness of \SBCM and the NIZK for $\NIZKRel_{\Sign}$, the signature
  produced at line 5 of \ExpCorrect is accepted at line 6 by \Verify.
  Moreover, all the credentials employed to honestly produce the signature,
  identified with \scid, meet their respective issuance policies due to
  correctness of the NIZK for $\NIZKRel_{\Issue}$, so no $\fissue^\cid$ check
  returns $0$ at line 9. Similarly, as $\feval \in \famfeval$ is checked at
  line 3, and due to correctness of the NIZK for $\NIZKRel_{\Sign}$, the
  output of \feval matches $\yeval^0$ at line $11$, which must have been
  computed over $\usk=\UK[\uid]$, as in line $10$, due to correctness of the
  commitment scheme. Finally, correctness of the NIZKs for $\NIZKRel_{\Sign}$
  and $\NIZKRel_{\Open}$, and correctness of the encryption scheme, ensure that
  \Judge accepts the proof produced by \Open, and \yinsp is the correct value
  for the chosen $\finsp^{\oid}$.
\end{proof}

\subsection{Issuance Anonymity}

\begin{proof}[\thmref{thm:issue-anonymity-uas}; Issuance anonymity of \CUASGen]
  We prove the special case in which the adversary makes only one query to the
  \OBTCHALb oracle. The generalization to polynomially many queries follows
  from a standard hybrid argument.

  We start from the \ExpIssAnonb, as defined in \figref{fig:exp-uas-anonb}. 

  Game 1: We simulate the NIZK proof corresponding to $\NIZKRel_{\Issue}$ that
  the \OBTCHALb oracle produces when queried by \adv. The zero-knowledge
  property of the NIZK system ensures that game 1 is indistinguishable from
  the original experiment.

  Game 2: In queries to \OBTCHALb, before simulating the NIZK proof, we replace
  the produced \yissue value with a random element from \rngfissue. Since
  \fissue is a \UAS-acceptable function, game 2 is indistinguishable from game
  1.

  From an adversary \adv~against Game 2, we can build an adversary \advB against
  \SBCM's blindness property. The simulation that
  \advB does is straightforward. \advB runs Game 2 for \adv, randomly picking
  a number $q < n$, where $n$ is the number of users that \adv~creates via
  \HUGEN, and assigning to the $q$-th user the $(\SBCMvk,\SBCMsk)$ key pair
  that \advB receives in its blindness game. Then, when \adv~makes a query
  to its \OBTCHALb oracle, if the chosen issuer is the $q$-th user, \advB
  forwards \adv's messages to its own $\langle COM(\SBCMvk,
  \overline{\smsg}_{\bin},\smsg),\cdot\rangle$ oracle. Finally, \advB outputs
  whatever \adv~does. Note that, since in Game 2 we replace the \yissue value
  with a random value, and simulate the $\NIZKRel_{\Issue}$ proof, \adv~is not
  receiving information about the blindly signed messages beyond what \advB
  forwards from its own oracle. Thus, if \adv~wins in its game, \advB wins in
  its blindness game. However, since \advB has to guess the correct user
  that \adv~will use as issuer in its \OBTCHALb oracle, we have a $1/n$ security
  loss, where $n$ is the total number of users created by \adv.
  %
  \qed
\end{proof}

\subsection{Signature Anonymity}

\begin{proof}[\thmref{thm:sign-anonymity-uas}; Signature anonymity of \CUASGen]

  In this proof, we restrict to the case in which the adversary can only make
  one query to the challenge oracle. Note however that the generalization to
  polynomially many queries given in \cite{bsz05} applies here too (with the
  corresponding security loss). Thus, proving security for one query to the
  challenge oracle is enough.

  We start from $G_0=\ExpSigAnonb$.  %
  From $G_0$, we consider $G^0_0 = \ExpSigAnonz$. The challenge sent to the
  adversary is $(\csig_0,\yeval) \gets \Sign(\PRVUK[\cuid_0],\PUBOK[\oid],
  \CRED[\scid_0],\msg,\feval)$, where $\csig_0 = (\pi_0,\cinsp)$, with
  $\pi_0 = \NIZKProve^{\NIZKRel_{\Sign}}(\NIZKcrs_{\Sign},(\msg,\feval,\yeval,
  \cinsp,\lbrace\PUBIK[\scid_{i,0}]\rbrace_{i\in[n]},\PUBOK[\oid]),
  (\PUBUK[\cuid_0],\PRVUK[\cuid_0],\lbrace (\scid_{i,0},\attrs_{i,0},
  \CRED[\scid_{i,0}]) \rbrace_{i\in[n]},\yeval^1,\yinsp,r,r'))$, and $\cinsp =
  \EEnc(\PUBOK[\oid],\yinsp;r')$, for some random $r,r'$ and $n \ge 0$.
  % 
  Further, we build $G_1^0$ from $G_0^0$ by simulating the proof $\pi_0$. That
  is, in $G_1^0$, $\csig_0 = (\pi_0^s,\ceval,\cinsp)$, where $\pi^s_0 =
  \NIZKSim^{\NIZKRel_{\Sign}}(\NIZKcrs_{\Sign},\NIZKtrap,(\msg,\feval,\yeval,
  \cinsp,\lbrace\PUBIK[\scid_{i,0}]\rbrace_{i\in[n]},\PUBOK[\oid]))$. By
  zero-knowledgeness of $\NIZK^{\Sign}$, $G_1^0$ is indistinguishable from
  $G_0^0$.

  Similarly, we consider $G_0^1$ and $G_1^1$. That is, $G_0^1 = \ExpSigAnono$,
  where the challenge
  sent to the adversary is $(\csig_1,\yeval) \gets \Sign(\PRVUK[\cuid_1],
  \PUBOK[\oid],\CRED[\scid_1],\msg,\feval)$, where $\csig_1 = (\pi_1,
  \cinsp)$, with $\pi_1 = \NIZKProve^{\NIZKRel_{\Sign}}(\NIZKcrs_{\Sign},
  (\msg,\feval,\yeval,
  \cinsp,\lbrace\PUBIK[\scid_{i,1}]\rbrace_{i\in[n]},\PUBOK[\oid]),
  (\PUBUK[\cuid_1],\PRVUK[\cuid_1],\lbrace (\scid_{i,1},\attrs_{i,1},
  \CRED[\scid_{i,1}]) \rbrace_{i\in[n]},\yeval^1,\yinsp,r,r'))$, and
  $\cinsp = \EEnc(\PUBOK[\oid],\yinsp;r')$, for random $r,r'$ and $n \ge 0$. As
  before, build $G_1^1$ from $G_0^1$, simulating $\pi_1$. That is, in $G_1^1$,
  $\csig_1 = (\pi_1^s,\ceval,\cinsp)$, where $\pi^s_1 =
  \NIZKSim^{\NIZKRel_{\Sign}}(\NIZKcrs_{\Sign},\NIZKtrap,(\msg,\feval,\yeval,
  \cinsp,\lbrace\PUBIK[\scid_{i,1}]\rbrace_{i\in[n]},\PUBOK[\oid]))$. Again, by
  zero-knowledge of $\NIZK^{\Sign}$, $G_1^1$ is
  indistinguishable from $G_0^1$.

  Note that, at this point, $G_1^1$ and $G_1^0$ are indistinguishable.
  Concretely, the challenge signatures they produce have the structure $\Sig_b =
  ((\pi_b,\cinsp),\yeval)$ where, to prevent trivial wins, \yeval is enforced
  (in the \SIGN oracle) to be the same for both challenge users, and \cinsp
  either encrypts the same value for both users, or \adv~cannot query the \OPEN
  oracle. \SIGN also enforces that $\PUBIK[\scid_0] = \PUBIK[\scid_1]$. Finally,
  the proofs $\pi_b$ are simulated, and thus reveal no information about the
  signer keys or credentials.

  Finally, consider the definition of $\AdvSigAnon=|\Pr\lbrack
  \ExpSigAnono(1^\secpar)=1\rbrack-\Pr\lbrack\ExpSigAnonz(1^\secpar)=1\rbrack|
  = |\Pr\lbrack G_0^1(1^\secpar)=1\rbrack-\Pr\lbrack
  G_0^0(1^\secpar)=1\rbrack| \approx
  |\Pr\lbrack G_1^1(1^\secpar)=1\rbrack-\Pr\lbrack
  G_1^0(1^\secpar)=1\rbrack|$, which is negligible.
  % 
  \qed
\end{proof}

% \subsection{Issuance Unforgeability}

% \begin{proof}[\thmref{thm:issue-forge-uas}; Issuance unforgeability of \CUASGen]
%   We show that the probability that \fissue outputs a wrong $\yinsp$ value is
%   negligible, as well as the probability that the credential identifier does not
%   belong to an existing (honest or corrupt) user.

%   Observe that the adversary is required to output a credential identifier for
%   which associated entries in \trans and \CRED exist; moreover, if such a
%   credential was produced by an issuer, we must have access to those entries, as
%   issuers are assumed to be honest in this game.
%   %
%   Since we can access $\trans[\cid] = (\yissue,\utrans)$, and \utrans contains
%   a NIZK proof $\NIZKproof_{\Issue}$ proving knowledge by the user of a witness
%   in $\NIZKRel_{\Issue}$, which is simulation extractable, \ExtractIssue
%   produces a tuple $(\upk,\usk,\lbrace (\cid_i,\attrs_i,\cred_i)
%   \rbrace_{i\in[n]}$.
%   %
%   From the fact that issuers are honest, we know that $\ATTR[\cid]$ must match
%   the attribute set \attrs used by user and issuer in the issuance protocol.
%   Thus, from  soundness of the NIZK system, the $(\upk,\lbrace (\cid_i,\attrs_i,
%   \cred_i) \rbrace_{i\in[n]}$ values within the extracted tuple, along with
%   $\ATTR[\cid] = \attrs$ must make \fissue output \yissue, except with
%   negligible probability. Moreover, soundness of the NIZK system also implies
%   that all credentials are bound to the same \usk, which is associated to the
%   extracted \upk.
  
%   Finally, suppose that the extracted \upk does not belong to a \uid in
%   $\HU \cup \CU$. Then, the produced credential is a forgery. \todo{How to
%     extract the forgery in this case?? I think that expanding the definition
%     so that it requires \adv~to produce a valid signature would make things
%     much easier...}
%   \qed
% \end{proof}

\subsection{Unforgeability}

\begin{proof}[\thmref{thm:forge-uas}; Signature unforgeability of \CUASGen]
  We show that an adversary \adv~winning \ExpForge can be used to break the
  one-more unforgeability property of \SBCM.
 
  If the verification at line 4 of \ExpForge holds, then $(\msg,\feval,
  \yeval,\cinsp,\sipk,\opk) \in \NIZKLang^{\Sign}$. Then:
  %

  \paragraph{(a) \Judge accepts $(\yinsp,\iproof)$.} %
  Simulation extractability of $\NIZK^{\Sign}$ ensures that $\cinsp =
  \EEnc(\Eek,\yinsp)$, and since $(\yinsp,\iproof)$ is generated honestly at
  line 5, then \yinsp is the correct decryption of \cinsp, and completeness of
  $\NIZK^{\Open}$ ensures that \Judge outputs $1$ at line 6.

  \paragraph{(b) All used credentials were correctly issued.} %
  Since issuers are assumed to be honest, we have access to the $\trans[\cid_i]$
  transcript for all credentials involved in producing the signature. Given
  simulation extractability of $\NIZK^{\Issue}$, \ExtractIssue outputs a valid
  witness $(\cdot,\cdot,\lbrace(\cid_{i,j},\attrs_{i,j},\cred_{i,j})
  \rbrace_{j\in[n_j]})$ from each $\trans[\cid_i]$. This, concretely, implies
  that the $\yissue^i$ value available in $\trans[\cid_i]$ matches the one
  output by \fissue. Similarly, due to simulation extractability, the set of
  credentials $\lbrace \cid_{i,j}\rbrace_{j\in[n_i]}$ used to request credential
  $\cid_i$ cannot include credentials owned by different users, as this
  condition is ensured by $\NIZKRel_{\Issue}$. Thus, $\uid = \OWNR[\lbrace
  \cid_{i,j} \rbrace_{j\in[n_i]}] \neq \bot$. Now, assume that $\uid \notin \HU
  \cup \CU$. This, in addition to the fact that {\usk}s are produced uniformly
  at random, means that $\cred_i$ is not bound to a \usk owned by a known
  user. But then, $\cred_i$ cannot have been produced via \OBTISS or \ISSUE,
  which only accept requests from known {\uid}s (either in \HU or \CU,
  respectively). Thus, $\cred_i$ is a valid \SBCM signature, that has not been
  produced via an honest query, which breaks the one-more forgery property of
  \SBCM.

  \paragraph{(c) $(\yeval^0,\yeval^1)$ are the correct signature evaluation
    pair.} Also, due to simulation extractability of $\NIZK^{\Sign}$:

  \begin{itemize}
  \item $\yeval^0 = \yeval$, where $(\yeval^0,\cdot) = \feval(\upk,\lbrace
    (\cid_i,\attrs_i) \rbrace_{i\in[n]},\msg)$, and $\yeval$ is as output by
    \adv~at step 2.    
  \item $\tyeval^1 = \yeval^1$, where $(\cdot,\yeval^1) = \feval(\upk,\lbrace
    (\cid_i,\attrs_i)\rbrace_{i\in[n]},\msg)$, and $\tyeval^1$ is as extracted
    by \ExtractSign at line 7.
  \end{itemize}

  Thus, the probability of \adv~winning at line 12 is negligible, due to
  simulation extractability of $\NIZK^{\Sign}$.

  \paragraph{(d) The output of \finsp matches the output of \Open.} %
  After (a), and correctness of the public key encryption algorihtm, the \yinsp
  value output by \Open is the correct decryption of
  \cinsp. After (c), the $(\yeval^0=\yeval,\yeval^1)$ values output by
  \ExtractSign match the evaluation of \feval. Thus, simulation extractability
  of $\NIZK^{\Sign}$ ensures that $\finsp((\yeval^0,\yeval^1),\upk,\lbrace
  (\cid_i,\attrs_i)\rbrace_{i\in[n]},\msg) = \yinsp$ and, also, that \yinsp
  matches the $\yinsp'$ value extracted by \ExtractSign. Thus, the probability
  of \adv~winning at line 13 is negligible due to simulation extractability
  of $\NIZK^{\Sign}$.

  \paragraph{(e) All {\cred}s are bound to the \usk of a known \uid.} %
  $\NIZKRel^{\Sign}$ includes a condition that $\forall i\in[n],
  \SBCMVerify(\ipk_i,\cred_i,\usk,\attrs_i) = 1$. Thus, simulation
  extractability of $\NIZK^{\Sign}$ and correctness of \SBCM, ensure that all
  credentials involved in the signature contain the same \usk as their user key
  (first) attribute. Thus, either $\OWNR[\lbrace \cid_i \rbrace_{i\in[n]}]$
  returns some \uid in $\HU \cup \CU$, or it returns $\bot$ because no such
  \uid exists (but not because more than one \cid belongs to different {\uid}s).
  Assume that no such \uid exists. Then, the {$\cred_i$}s extracted by
  \ExtractSign cannot have been produced via a call to either \OBTISS or \ISSUE,
  since they only accept calls from known {\uid}s (either in \HU or \CU,
  respectively). Since, by simulation extractability of $\NIZK^{\Sign}$, at
  least one such credential must have been used to produce the signature, then
  this breaks the one-more forgery property of the underlying \SBCM.
  %
  \qed
\end{proof}

\subsection{Non-Frameability}

\begin{proof}[\thmref{thm:frame-uas}; Non-frameability of \CUASGen]
  \label{prf:frame-uas}

  % We prove that, if the NIZK system used for $\NIZKRel_{\Sign}$ and
  % $\NIZKRel_{\Open}$ is zero-knowledge and simulation-extractable, and \SBCM is
  % blind, then our \CUASGen construction is secure.

  Since the signature output by \adv~is accepted by \Verify at line 4,
  simulation extractability of $\NIZK^{\Sign}$ ensures that $\yeval = \yeval^0$,
  and $\tyeval^1 = \yeval^1$. Similarly, if the $(\yinsp,\iproof)$
  pair output by \adv~is accepted by \Judge, simulation extractability of
  $\NIZK^{\Sign}$ and $\NIZK^{\Open}$ implies that both checks at lines 8 and 9
  pass. Hence, the probability that the adversary wins at either lines 8 or 9 is
  negligible, after simulation extractability of $\NIZK^{\Sign}$ and
  $\NIZK^{\Open}$.

  Next, we prove that, after zero-knowledge and simulation extractability of
  $\NIZKRel_{\Sign}$, and blindness of \SBCM, no credential from an honest user
  can be extracted from the signature output by \adv, except with negligible
  probability.
  %
  The crucial observation is that, as in \cite{cl06} \CUASGen's \Sign algorithm
  produces a signature of knowledge for the relation defined by
  $\NIZKRel^{\Sign}$. That is, given $(x,w) \in \NIZKRel^{\Sign}$, one can
  compare $x$ and $w$ to the public and private key of a signature algorithm,
  respectively. In $\NIZKRel^{\Sign}$, $(\upk,\usk,\lbrace (\cid_i,\attrs_i,
  \cred_i)\rbrace_{i\in[n]},\yeval^1,\yinsp,r,r')$ is the private key ($w$), and
  $(\msg,\feval,\yeval^0,\cinsp,\lbrace \ipk_i \rbrace_{i\in[n]},\Eek)$ is the
  public key ($x$).
  %
  From this, we prove that an adversary has only negligible probability to forge
  a signature as originating from an honest user without calling the \SIGN
  oracle. The strategy is similar to that in \cite[Theorem 2.1]{cl06}.

  Consider game $G_1$, which is equivalent to $G_0 = \ExpNonframe$, except that
  in the \Sign function within the \SIGN oracle, we simulate the NIZK proof.
  After the zero-knowledge property of $\NIZK^{\NIZKRel_{\Sign}}$, $G_1$ is
  indistinguishable from $G_0$. Now, in $G_1$, simulation extractability of
  $\NIZK^{\NIZKRel_{\Sign}}$ ensures that \ExtractSign outputs a valid
  witness for $(\msg,\feval,\yeval^0,\cinsp,\lbrace ipk_i \rbrace_{i\in[n]},
  \Eek)$. Note that this witness must include some \usk which, in case of
  being owned by an honest user, has not been leaked to \adv~--as the user
  has not been corrupted, nor the \usk has been leaked via \SIGN queries,
  where the proof of knowledge within \Sign is now simulated). Moreover,
  blindness of \SBCM ensures that the issuer (who is potentially corrupt), did
  not learn \usk either during calls to \OBTAIN. Thus, since \usk is picked
  uniformly at random by honest users, the probability that $\UK[\uid] = \usk$
  for $\uid \in \HU$ and \Sig produced by the adversary, is negligible.
  %
  \qed
\end{proof}

\subsection{Security of $\CUASGen^{hide-iss}$}
\label{sapp:sec-hide-iss}

The only aspect that changes from \CUASGen to $\CUASGen^{hide-iss}$ is the
relationship used for signing, where we hide the specific issuer who produced
the (now only) credential used for signing.
%
This change does not affect the proofs for issuance anonymity, nor signature
anonymity.
%
Concerning unforgeability, note that the credential that is used to produce the
\UAS signature still needs to originate from a \uid in either \HU or \CU.
Otherwise, such credential, extracted by \ExtractSign, is a forgery and breaks
the one-more forgery property of \SBCM. Moreover, such credential must exist,
due to simulation extractability of the underlying NIZK.
%
The proof for non-frameability is also unaffected by the change.

Thus, if \CUASGen is a secure \UAS scheme, so is $\CUASGen^{hide-iss}$.

\subsection{Security of $\CUASGen^{int}$}
\label{sapp:sec-interactive}

\paragraph{Issuance Anonymity.} Since issuance anonymity is independent of
whether signature/authentication is interactive or not, the proof for issuance
anonymity in $\CUASGen^{int}$ is the same as for \CUASGen.

\paragraph{Signature Anonymity.} To see why the interactive variant has
signature anonymity, assume an adversary \adv~that breaks it. We build \advB
against the non-interactive \ExpSigAnonb from \adv~as follows. \advB initializes
everything as in the \ExpSigAnonb game. When \adv~initiates a call to its
interactive \SIGN (resp. \CHALb) oracle, \advB forwards it to its own oracle
(but concatenating the random number to the message to be signed). \advB
forwards the response from its oracle to \adv. After such simulation, \advB just
outputs whatever $\adv$ outputs. Clearly, the simulation is perfect and, if
\adv~wins with non-negligible probability in the interactive case, then so
does \advB in the non-interactive case. Specifically, note that, since the \Sign
algorithm is probabilistic, even if a malicious verifier picks the same random
number in several queries (to the same or different users), the result will be
indistinguishable with overwhelming probability.

\paragraph{Unforgeability and non-frameability.} The simulation described for
the anonymity case (i.e., \advB concatenating the random numbers
to the message to be signed by the oracle) applies here too. Since the
interactive protocol includes non-interactive proofs for the $\NIZKRel^{\Sign}$
and $\NIZKRel^{Open}$ relations, the proofs for unforgeability and
non-frameability of \CUASGen still apply.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "uas-paper"
%%% End:
