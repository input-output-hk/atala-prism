\section{Correctness and Security Proofs for \CUASGen}
\label{app:uas-proofs}

\todo{Do we only need this for \fissue function?}
First, we formally define now what do we mean with \UAS-acceptable \fissue,
complementing the informal \defref{def:uas-acc-func}. 

\begin{figure}[ht!]
  \centering  
  \scalebox{0.9}{
    \procedure{$\Exp^{\UAS-acc-b}_\adv(1^\secpar)$}{%
      \parm \gets \Setup(1^\secpar) \\
      (\upk,\usk) \gets \KeyGen(\parm) \\
      (\st,\attrs, \lbrace (\cidi,\cidu,\cattrs_i) \rbrace_{i\in[n]})
      \gets \adv(\upk) \\
      \pcif b=0:
      \yissue^* \gets \fissue(\upk,\lbrace (\cidi,\cattrs_i)
      \rbrace_{i\in[n]},\attrs) \\
      \pcelse: \yissue^* \getr \rngfissue \setminus \lbrace 0 \rbrace \\
      b^* \gets \adv(\st,\yissue*) \\
      \pcreturn b=b^*
    }
  }
  \label{fig:uas-acceptable}
  \caption{Formal definition of \UAS-acceptable \fissue functions.}
\end{figure}


Next, we define the \SimSetup, \ExtractIssue, \ExtractSign functions. \SimSetup
(formally defined in \figref{fig:helper-funcs}) essentially replaces the
\Setup algorithm of each NIZK with the corresponding \NIZKSimSetup algorithm,
and returns the generated parameters along with the
trapdoors. \ExtractIssue and \ExtractSign simply run the \Extract functions
of the corresponding \NIZK scheme, leveraging the trapdoor produced during
\SimSetup. Note that, due to the zero-knowledge and simulation extractability
properties (respectively) of the underlying NIZKs, the result of \SimSetup
is indistinguishable from that of \Setup, and the extracted values match those
used as witnesses in the proofs.

\begin{figure}[ht!]
  \centering  
  \scalebox{0.9}{
    \begin{minipage}[t]{\textwidth}
      \procedure{$\SimSetup(1^\secpar)$}{%
        \textrm{Parse}~\secpar~\textrm{as}~(\Csecpar,\NIZKsecpar,\SBCMsecpar,
        \Esecpar). \\
        \Cparm \gets \CSetup(\Csecpar), \SBCMparm \gets  \SBCMSetup(\SBCMsecpar) \\
        \Sparm \gets \SSetup(\Ssecpar), \Eparm \gets \ESetup(\Esecpar) \\
        (\NIZKcrs_{\Issue},\trap_{\Issue}) \gets
        \NIZKSimSetup^{\NIZKRel_{\Issue}}(\NIZKsecpar) \\
        (\NIZKcrs_{\Sign},\trap_{\Sign}) \gets
        \NIZKSimSetup^{\NIZKRel_{\Sign}}(\NIZKsecpar) \\
        (\NIZKcrs_{\Open},\trap_{\Open}) \gets
        \NIZKSimSetup^{\NIZKRel_{\Open}}(\NIZKsecpar) \\
        \pcreturn ((\Cparm,\SBCMparm,\Sparm,\Eparm,\NIZKcrs_{\Issue},
        \NIZKcrs_{\Sign},\NIZKcrs_{\Open},\AttrSpace), \\
        \pcind (\trap_{\Issue},\trap_{\Sign},\trap_{\Open}))
      }
      
      % \procedure{$\ExtractIssue(\parm,\trap,\utrans)$}{%
      %   \textrm{Parse \parm as $(\cdot,\cdot,\cdot,\cdot,\NIZKcrs_{\Issue},\cdot,
      %     \cdot,\cdot)$} \\
      %   \textrm{Parse \trap as $(\trap_{\Issue},\cdot,\cdot)$, and
      %     \utrans as $(\Ccom,\sipk,\cred,\NIZKproof)$} \\
      %   \pcif \NIZKVerify^{\NIZKRel_{\Issue}}(\NIZKcrs_{\Issue},
      %   \NIZKproof,(\Ccom,\attrs,\sipk)): \pcreturn \bot \\
      %   (\usk,\credid,\scred,\attrs_{\scred}) \gets
      %   \NIZKExtract^{\NIZKRel_{\Issue}}(\NIZKcrs_{\Issue},
      %   \trap_{\Issue},
      %   (\Ccom,\attrs,\sipk),\NIZKproof) \\
      %   \textrm{Let \credid be}~\suchthat~\trans[\credid] = \utrans;
      %   \uid \gets \OWNR[\credid] \\        
      %   \pcif \uid \in \HU \land \UK[\uid] \neq \usk: \pcreturn \bot \\
      %   \pcelse: \\
      %   \pcind \pcif \UK[\uid] = \bot: \UK[\uid] \gets \usk \\
      %   \pcind \pcelse \pcif \UK[\uid] \neq \usk: \pcreturn 0 \\
      %   \pcreturn (\uid,\usk,\credid,\scred,\attrs_{\scred}) \\
      % }
      
      % \procedure{$\ExtractSign(\parm,\trap,\oid,\siid,\sig,\yeval,\msg,\feval)$}{%
      %   \textrm{Parse \parm as $(\cdot,\cdot,\cdot,\cdot,\cdot,\NIZKcrs_{\Sign},
      %     \cdot)$} \\
      %   \textrm{Parse \trap as $(\cdot,\trap_{\Sign},\cdot)$, and
      %     \sig as $(\NIZKproof,\ceval,\cinsp)$} \\
      %   \textrm{Parse $\PUBOK[\oid]$ as $(\opk,\cdot)$ and let $\sipk \gets
      %     \PUBIK[\siid]$} \\
      %   \pcif \NIZKVerify^{\NIZKRel_{\Sign}}(\NIZKcrs_{\Sign},\NIZKproof,
      %   (\msg,\feval,\yeval,\Ec,\sipk,\opk)): \pcreturn \bot \\
      %   (\usk,\scredid,\scred,\attrs_{\scred},\yinsp,r) \gets
      %   \NIZKExtract^{\NIZKRel_{\Sign}}(\NIZKcrs^{\NIZKRel_{\Sign}},
      %   \NIZKtrap_{\Sign},
      %   (\msg,\feval,\yeval^0,\ceval,\cinsp,\sipk,\opk,\widetilde{\Eek}),
      %   \NIZKproof) \\
      %   \pcif \exists \uid \in \HU~\suchthat~\UK[\uid] = \usk: \\
      %   \pcreturn (\uid,\usk,\scred,\attrs_{\scred},\yeval^1,\yinsp) \\
      %   \pcelse \textrm{\todo{Need to add \cid as explicit attribute to the
      %       credentials (chosen by issuer) so that can bookkeep.}} \\
      %   \pcelse \textrm{\todo{then adapt the rest}} \\
      %   \pcind \pcelse \pcif \UK[\uid] \neq \usk: \pcreturn 0 \\
      %   \pcreturn (\usk,\scred,\attrs_{\scred},\yeval^1,\yinsp) \\
      % }
      
      % % \procedure{$\IdentifyCred(\parm,\trap,\usk,\attrs_{\cred},\cred)$}{%
      % %   \pcreturn \SBCMVerify(\ipk_{\cred},\cred,\usk,\attrs_{\cred}) \\
      % % }

      % \procedure{$\IdentifyCred(\parm,\trap,\usk,\attrs_{\cred},\cred,\ipk)$}{%
      %   \pcreturn \SBCMVerify(\ipk,\cred,\usk,\attrs_{\cred}) \\
      % }      

      % \procedure{$\IdentifySig(\parm,\trap,\usk,\scred,\Sig)$}{%
      %   \pcif \uid \in \HU: \pcreturn \usk = \UK[\uid] \\
      %   \pcfor \cid~\suchthat~\CRED[\cid] = (\uid,\cdot,\cdot,\cdot,\cdot,\cdot) \\
      %   \pcind (\usk',\cdot,\cdot,\cdot) \gets \ExtractIssue(\parm,\trap,\trans[\cid]) \\
      %   \pcind \pcif \usk = \usk': \pcreturn 1 \\
      %   \pcreturn 0
      % }

      % % \procedure{$\IdentifySig(\parm,\trap,\uid,\usk)$}{%
      % %   \pcif \uid \in \HU: \pcreturn \usk = \UK[\uid] \\
      % %   \pcfor \cid~\suchthat~\CRED[\cid] = (\uid,\cdot,\cdot,\cdot,\cdot,\cdot) \\
      % %   \pcind (\usk',\cdot,\cdot,\cdot) \gets \ExtractIssue(\parm,\trap,\trans[\cid]) \\
      % %   \pcind \pcif \usk = \usk': \pcreturn 1 \\
      % %   \pcreturn 0
      % % }
      
    \end{minipage}
  }
  \label{fig:helper-funcs}
  \caption{Definition of helper function \SimSetup, for \CUASGen.}
\end{figure}

\subsection{Correctness}

\begin{proof}[\thmref{thm:correctness-uas}; Correctness of \CUASGen]
  By correctness of \SBCM and the NIZK for $\NIZKRel_{\Sign}$, the signature
  produced at line 5 of \ExpCorrect is accepted at line 6 by \Verify.
  Moreover, all the credentials employed to honestly produce the signature,
  identified with \scid, meet their respective issuance policies due to
  correctness of the NIZK for $\NIZKRel_{\Issue}$, so no $\fissue^\cid$ check
  returns $0$ at line 9. Similarly, as $\feval \in \famfeval$ is checked at
  line 3, and due to correctness of the NIZK for $\NIZKRel_{\Sign}$, the
  output of \feval matches $\yeval^0$ at line $11$, which must have been
  computed over $\usk=\UK[\uid]$, as in line $10$, due to correctness of the
  commitment scheme. Finally, correctness of the NIZKs for $\NIZKRel_{\Sign}$
  and $\NIZKRel_{\Open}$, and correctness of the encryption scheme, ensure that
  \Judge accepts the proof produced by \Open, and \yinsp is the correct value
  for the chosen $\finsp^{\oid}$.
\end{proof}

\subsection{Issuance Anonymity}

\begin{proof}[\thmref{thm:issue-anonymity-uas}; Issuance anonymity of \CUASGen]
  We prove the special case in which the adversary makes only one query to the
  \OBTCHALb oracle. The generalization to polynomially many queries follows
  from a standard hybrid argument.

  We start from the \ExpIssAnonb, as defined in \figref{fig:exp-uas-anonb}. 

  Game 1: We simulate the NIZK proof corresponding to $\NIZKRel_{\Issue}$ that
  the \OBTCHALb oracle produces when queried by \adv. The zero-knowledge
  property of the NIZK system ensures that game 1 is indistinguishable from
  the original experiment.

  Game 2: In queries to \OBTCHALb, before simulating the NIZK proof, we replace
  the produced \yissue value with a random element from \rngfissue. Since
  \fissue is a \UAS-acceptable function, game 2 is indistinguishable from game
  1.

  From an adversary \adv~against Game 2, we can build an adversary \advB against
  \SBCM's blindness property. The simulation that
  \advB does is straightforward. \advB runs Game 2 for \adv, randomly picking
  a number $q < n$, where $n$ is the number of users that \adv~creates via
  \UGEN, and assigning to the $q$-th user the $(\SBCMvk,\SBCMsk)$ key pair
  that \advB receives in its blindness game. Then, when \adv~makes a query
  to its \OBTCHALb oracle, if the chosen issuer is the $q$-th user, \advB
  forwards \adv's messages to its own $\langle COM(\SBCMvk,
  \overline{\smsg}_{\bin},\smsg),\cdot\rangle$ oracle. Finally, \advB outputs
  whatever \adv~does. Note that, since in Game 2 we replace the \yissue value
  with a random value, and simulate the $\NIZKRel_{\Issue}$ proof, \adv~is not
  receiving information about the blindly signed messages beyond what \advB
  forwards from its own oracle. Thus, if \adv~wins in its game, \advB wins in
  its blindness game. However, since \advB has to guess the correct user
  that \adv~will use as issuer in its \OBTCHALb oracle, we have a $1/n$ security
  loss, where $n$ is the total number of users created by \adv.
  %
  \qed
\end{proof}

\subsection{Signature Anonymity}

\begin{proof}[\thmref{thm:sign-anonymity-uas}; Signature anonymity of \CUASGen]

  In this proof, we restrict to the case in which the adversary can only make
  one query to the challenge oracle. Note however that the generalization to
  polynomially many queries given in \cite{bsz05} applies here too (with the
  corresponding security loss). Thus, proving security for one query to the
  challenge oracle is enough.

  We start from $G_0=\ExpSigAnonb$.  %
  From $G_0$, we consider $G^0_0 = \ExpSigAnonz$. The challenge sent to the
  adversary is $(\csig_0,\yeval) \gets \Sign(\PRVUK[\cuid_0],\PUBOK[\oid],
  \CRED[\scid_0],\msg,\feval)$, where $\csig_0 = (\pi_0,\cinsp)$, with
  $\pi_0 = \NIZKProve^{\NIZKRel_{\Sign}}(\NIZKcrs_{\Sign},(\msg,\feval,\yeval,
  \cinsp,\lbrace\PUBIK[\scid_{i,0}]\rbrace_{i\in[n]},\PUBOK[\oid]),
  (\PUBUK[\cuid_0],\PRVUK[\cuid_0],\lbrace (\scid_{i,0},\attrs_{i,0},
  \CRED[\scid_{i,0}]) \rbrace_{i\in[n]},\yeval^1,\yinsp,r,r'))$, and $\cinsp =
  \EEnc(\PUBOK[\oid],\yinsp;r')$, for some random $r,r'$ and $n \ge 0$.
  % 
  Further, we build $G_1^0$ from $G_0^0$ by simulating the proof $\pi_0$. That
  is, in $G_1^0$, $\csig_0 = (\pi_0^s,\ceval,\cinsp)$, where $\pi^s_0 =
  \NIZKSim^{\NIZKRel_{\Sign}}(\NIZKcrs_{\Sign},\NIZKtrap,(\msg,\feval,\yeval,
  \cinsp,\lbrace\PUBIK[\scid_{i,0}]\rbrace_{i\in[n]},\PUBOK[\oid]))$. By
  zero-knowledgeness of $\NIZK^{\Sign}$, $G_1^0$ is indistinguishable from
  $G_0^0$.

  Similarly, we consider $G_0^1$ and $G_1^1$. That is, $G_0^1 = \ExpSigAnono$,
  where the challenge
  sent to the adversary is $(\csig_1,\yeval) \gets \Sign(\PRVUK[\cuid_1],
  \PUBOK[\oid],\CRED[\scid_1],\msg,\feval)$, where $\csig_1 = (\pi_1,
  \cinsp)$, with $\pi_1 = \NIZKProve^{\NIZKRel_{\Sign}}(\NIZKcrs_{\Sign},
  (\msg,\feval,\yeval,
  \cinsp,\lbrace\PUBIK[\scid_{i,1}]\rbrace_{i\in[n]},\PUBOK[\oid]),
  (\PUBUK[\cuid_1],\PRVUK[\cuid_1],\lbrace (\scid_{i,1},\attrs_{i,1},
  \CRED[\scid_{i,1}]) \rbrace_{i\in[n]},\yeval^1,\yinsp,r,r'))$, and
  $\cinsp = \EEnc(\PUBOK[\oid],\yinsp;r')$, for random $r,r'$ and $n \ge 0$. As
  before, build $G_1^1$ from $G_0^1$, simulating $\pi_1$. That is, in $G_1^1$,
  $\csig_1 = (\pi_1^s,\ceval,\cinsp)$, where $\pi^s_1 =
  \NIZKSim^{\NIZKRel_{\Sign}}(\NIZKcrs_{\Sign},\NIZKtrap,(\msg,\feval,\yeval,
  \cinsp,\lbrace\PUBIK[\scid_{i,1}]\rbrace_{i\in[n]},\PUBOK[\oid]))$. Again, by
  zero-knowledge of $\NIZK^{\Sign}$, $G_1^1$ is
  indistinguishable from $G_0^1$.

  Note that, at this point, $G_1^1$ and $G_1^0$ are indistinguishable.
  Concretely, the challenge signatures they produce have the structure $\Sig_b =
  ((\pi_b,\cinsp),\yeval)$ where, to prevent trivial wins, \yeval is enforced
  (in the \SIGN oracle) to be the same for both challenge users, and \cinsp
  either encrypts the same value for both users, or \adv~cannot query the \OPEN
  oracle. \SIGN also enforces that $\PUBIK[\scid_0] = \PUBIK[\scid_1]$. Finally,
  the proofs $\pi_b$ are simulated, and thus reveal no information about the
  signer keys or credentials.

  Finally, consider the definition of $\AdvSigAnon=|\Pr\lbrack
  \ExpSigAnono(1^\secpar)=1\rbrack-\Pr\lbrack\ExpSigAnonz(1^\secpar)=1\rbrack|
  = |\Pr\lbrack G_0^1(1^\secpar)=1\rbrack-\Pr\lbrack
  G_0^0(1^\secpar)=1\rbrack| \approx
  |\Pr\lbrack G_1^1(1^\secpar)=1\rbrack-\Pr\lbrack
  G_1^0(1^\secpar)=1\rbrack|$, which is negligible.
  % 
  \qed
\end{proof}

\subsection{Issuance Unforgeability}

\begin{proof}[\thmref{thm:issue-forge-uas}; Issuance unforgeability of \CUASGen]
  We show that the probability that \fissue outputs a wrong $\yinsp$ value is
  negligible, as well as the probability that the credential identifier does not
  belong to an existing (honest or corrupt) user.

  Observe that the adversary is required to output a credential identifier for
  which associated entries in \trans and \CRED exist; moreover, if such a
  credential was produced by an issuer, we must have access to those entries, as
  issuers are assumed to be honest in this game.
  %
  Since we can access $\trans[\cid] = (\yissue,\utrans)$, and \utrans contains
  a NIZK proof $\NIZKproof_{\Issue}$ proving knowledge by the user of a witness
  in $\NIZKRel_{\Issue}$, which is simulation extractable, \ExtractIssue
  produces a tuple $(\upk,\usk,\lbrace (\cid_i,\attrs_i,\cred_i)
  \rbrace_{i\in[n]}$.
  %
  From the fact that issuers are honest, we know that $\ATTR[\cid]$ must match
  the attribute set \attrs used by user and issuer in the issuance protocol.
  Thus, from  soundness of the NIZK system, the $(\upk,\lbrace (\cid_i,\attrs_i,
  \cred_i) \rbrace_{i\in[n]}$ values within the extracted tuple, along with
  $\ATTR[\cid] = \attrs$ must make \fissue output \yissue, except with
  negligible probability. Moreover, soundness of the NIZK system also implies
  that all credentials are bound to the same \usk, which is associated to the
  extracted \upk.
  
  Finally, suppose that the extracted \upk does not belong to a \uid in
  $\HU \cup \CU$. Then, the produced credential is a forgery. \todo{How to
    extract the forgery in this case?? I think that expanding the definition
    so that it requires \adv~to produce a valid signature would make things
    much easier...}
  \qed
\end{proof}

\subsection{Signature Unforgeability}

\begin{proof}[\thmref{thm:sign-forge-uas}; Signature unforgeability of \CUASGen]
  We show that an adversary \adv~winning \ExpForgeSign can be used to break the
  one-more unforgeability property of \SBCM.
 
  If the verification at line 4 of \ExpForgeSign holds, then $(\msg,\feval,
  \yeval,\cinsp,\sipk,\opk) \in \NIZKLang^{\Sign}$. Then:
  %

  \paragraph{(a) \Judge accepts $(\yinsp,\iproof)$.} %
  Simulation extractability of $\NIZK^{\Sign}$ thus ensures that $\cinsp =
  \EEnc(\Eek,\yinsp)$, and since $(\yinsp,\iproof)$ is generated honestly at
  line 5, then \yinsp is the correct decryption of \cinsp, and completeness of
  $\NIZK^{\Open}$ ensures that \Judge outputs $1$ at line 6.

  \paragraph{(b) $(\yeval^0,\yeval^1)$ are the correct signature evaluation
    pair.} Also, due to simulation extractability of $\NIZK^{\Sign}$:

  \begin{itemize}
  \item $\yeval^0 = \yeval$, where $(\yeval^0,\cdot) = \feval(\upk,\lbrace
    (\cid_i,\attrs_i) \rbrace_{i\in[n]},\msg)$, and $\yeval$ is as output by
    \adv~at step 2.    
  \item $\tyeval^1 = \yeval^1$, where $(\cdot,\yeval^1) = \feval(\upk,\lbrace
    (\cid_i,\attrs_i)\rbrace_{i\in[n]},\msg)$, and $\tyeval^1$ is as extracted
    by \ExtractSign at line 7.
  \end{itemize}

  Thus, the probability of \adv~winning at line 9 is negligible, due to
  simulation extractability of $\NIZK^{\Sign}$.

  \paragraph{(c) The output of \finsp matches the output of \Open.} %
  After (a), and correctness of the public key encryption algorihtm, the \yinsp
  value output by \Open is the correct decryption of
  \cinsp. After (b), the $(\yeval^0=\yeval,\yeval^1)$ values output by
  \ExtractSign match the evaluation of \feval. Thus, simulation extractability
  of $\NIZK^{\Sign}$ ensures that $\finsp((\yeval^0,\yeval^1),\upk,\lbrace
  (\cid_i,\attrs_i)\rbrace_{i\in[n]},\msg) = \yinsp$ and, also, that \yinsp
  matches the $\yinsp'$ value extracted by \ExtractSign. Thus, the probability
  of \adv~winning at line 10 is negligible due to simulation extractability
  of $\NIZK^{\Sign}$.

  \paragraph{(d) All {\cred}s are bound to the same \usk.} %
  $\NIZKRel^{\Sign}$ includes a condition that $\forall i\in[n],
  \SBCMVerify(\ipk_i,\cred_i,\usk,\attrs_i) = 1$. Thus, simulation
  extractability of $\NIZK^{\Sign}$ and correctness of \SBCM, ensure that all
  credentials involved in the signature contain the same \usk as their user key
  (first) attribute. Thus, either $\OWNR[\lbrace \cid_i \rbrace_{i\in[n]}]$
  returns some \uid in $\HU \cup \CU$, or it returns $\bot$ because no such
  \uid exists (but not because more than one \cid belongs to different {\uid}s).
  Assume that no such \uid exists. Clearly, such a signature breaks the one-more
  forgery property of \SBCM, as it cannot have been produced via a call to
  \SIGN, which only accepts {\cid}s that belong to known {\uid}s. Therefore, the
  probability that \adv~wins at line 11 is negligible, given simulation
  extractability of $\NIZK^{\Sign}$, and correctness and one-more forgery
  security of \SBCM.
  %
  \qed
\end{proof}

\subsection{Non-Frameability}

\begin{proof}[\thmref{thm:frame-uas}; Non-frameability of \CUASGen]

  % We prove that, if the NIZK system used for $\NIZKRel_{\Sign}$ and
  % $\NIZKRel_{\Open}$ is zero-knowledge and simulation-extractable, and \SBCM is
  % blind, then our \CUASGen construction is secure.

  First, suppose that, in the check done at line 10, the \Sig that \adv~outputs
  at line 2 exists in \SIG, for some \uid. In that case, given that the
  signature is accepted by \Verify at
  line 3, and after simulation extractability of $\NIZK^{\Sign}$, $\yeval =
  \yeval^0$, and $\tyeval^1 = \yeval^1$. Similarly, since the $(\yinsp,\iproof)$
  pair output by \adv~is accepted by \Judge, simulation extractability of
  $\NIZK^{\Sign}$ and $\NIZK^{\Open}$ implies that both checks at lines 7 and 8
  pass. Hence, the probability that the adversary wins at either lines 7 or 8 is
  negligible, after simulation extractability of $\NIZK^{\Sign}$ and
  $\NIZK^{\Open}$.

  Next, suppose that the \Sig output by \adv~at line 2 does not exist in \SIG.
  We prove that zero-knowledge and simulation extractability of
  $\NIZKRel_{\Sign}$, and blindness of \SBCM, ensure that this only happens with
  negligible probability.
  The crucial observation is that, as in \cite{cl06} \CUASGen's \Sign algorithm
  produces a signature of knowledge for the relation defined by
  $\NIZKRel^{\Sign}$. That is, given $(x,w) \in \NIZKRel^{\Sign}$, one can
  compare $x$ and $w$ to the public and private key of a signature algorithm,
  respectively. In $\NIZKRel^{\Sign}$, $(\usk,\scred,\attrs_{\scred},\yeval^1,
  \yinsp,r,r')$ is the private key ($w$), and $(\msg,\feval,\yeval^0,\ceval,
  \cinsp,\sipk_{\scred},\Eek,\widetilde{\Eek})$ is the public key ($x$).
  %
  From this, we prove that an adversary has only negligible probability to forge
  a signature as originating from an honest user without calling the \SIGN
  oracle. The strategy is similar to that in \cite[Theorem 2.1]{cl06}.

  Consider game $G_1$, which is equivalent to $G_0 = \ExpNonframe$, except that
  in the \Sign function within the \SIGN oracle, we simulate the NIZK proof.
  After the zero-knowledge property of $\NIZK^{\NIZKRel_{\Sign}}$, $G_1$ is
  indistinguishable from $G_0$. Now, in $G_1$, simulation extractability of
  $\NIZK^{\NIZKRel_{\Sign}}$ ensures that \ExtractSign must output a valid
  witness for $(\msg,\feval,\yeval^0,\cinsp,\lbrace ipk_i \rbrace_{i\in[n]},
  \Eek)$. Note that this witness must include some \usk which,
  for \adv~to win the game, must belong to an honest user. However, since the
  user (whichever it is) has not been corrupted, its \usk has not been leaked
  to \adv~via corruption queries (nor via \SIGN queries, where the proof of
  knowledge within \Sign is now simulated). Moreover, blindness of \SBCM ensures
  that the issuer (who is potentially corrupt), did not learn \usk either during
  calls to \OBTAIN. Thus, the probability that $\UK[\uid] = \usk$ for $\uid \in
  \HU$ and \Sig produced by the adversary, is negligible.
  %
  \qed
\end{proof}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "uas-paper"
%%% End:
