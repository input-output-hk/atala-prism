\section{Correctness and Security Proofs for \CUASGen}
\label{app:uas-proofs}

Next, we define the \SimSetup, \ExtractIssue, \ExtractSign, and \VerCred
functions. \SimSetup (formally defined in \figref{fig:helper-funcs}) essentially
replaces the \Setup algorithm of each NIZK with the corresponding \NIZKSimSetup
algorithm, and returns the generated parameters along with the trapdoors.
\ExtractIssue and \ExtractSign simply run the \helper{\Extract} functions of the
corresponding \NIZK scheme, leveraging the trapdoor produced during \SimSetup.
Note that, in our games definitions, both algorithms are always run over
signatures that have already been verified (in the case of \ExtractSign)
or transcripts maintained by honest issuers (in the case of \ExtractIssue).
Thus, the zero-knowledge proofs they contain are valid. Concerning \SimSetup,
due to the zero-knowledge and simulation extractability properties
(respectively) of the underlying NIZKs, its result is indistinguishable from
that of \Setup, and the extracted values match those used as witnesses in the
proofs. Finally, \VerCred simply calls the \SBCMVerify function with the
received data -- where \usk is signed in committed form, \cid and \attrs in
plain form, and \cred is their alleged signature by the owner of public key
\ipk.

\begin{figure}[ht!]
  \centering  
  \scalebox{0.9}{
    \begin{minipage}[t]{\textwidth}
      \procedure{$\SimSetup(1^\secpar)$}{%
        % \Cparm \gets \CSetup(\Csecpar), 
        \SBCMparm \gets  \SBCMSetup(\secpar) \\
        % \Sparm \gets \SSetup(\Ssecpar), 
        \Eparm \gets \ESetup(\secpar) \\
        (\NIZKcrs_{\Issue},\trap_{\Issue}) \gets
        \NIZKSimSetup^{\RelIss}(\secpar) \\
        (\NIZKcrs_{\Sign},\trap_{\Sign}) \gets
        \NIZKSimSetup^{\RelSig}(\secpar) \\
        (\NIZKcrs_{\Open},\trap_{\Open}) \gets
        \NIZKSimSetup^{\RelIns}(\secpar) \\
        \pcreturn ((% \Cparm,
        \SBCMparm,% \Sparm,
        \Eparm,\NIZKcrs_{\Issue},
        \NIZKcrs_{\Sign},\NIZKcrs_{\Open},\AttrSpace),
        (\trap_{\Issue},\trap_{\Sign},\trap_{\Open}))
      }
      
      % \procedure{$\ExtractIssue(\parm,\trap,\utrans)$}{%
      %   \textrm{Parse \parm as $(\cdot,\cdot,\cdot,\cdot,\NIZKcrs_{\Issue},\cdot,
      %     \cdot,\cdot)$} \\
      %   \textrm{Parse \trap as $(\trap_{\Issue},\cdot,\cdot)$, and
      %     \utrans as $(\Ccom,\sipk,\cred,\NIZKproof)$} \\
      %   \pcif \NIZKVerify^{\NIZKRel_{\Issue}}(\NIZKcrs_{\Issue},
      %   \NIZKproof,(\Ccom,\attrs,\sipk)): \pcreturn \bot \\
      %   (\usk,\credid,\scred,\attrs_{\scred}) \gets
      %   \NIZKExtract^{\NIZKRel_{\Issue}}(\NIZKcrs_{\Issue},
      %   \trap_{\Issue},
      %   (\Ccom,\attrs,\sipk),\NIZKproof) \\
      %   \textrm{Let \credid be}~\suchthat~\trans[\credid] = \utrans;
      %   \uid \gets \OWNR[\credid] \\        
      %   \pcif \uid \in \HU \land \UK[\uid] \neq \usk: \pcreturn \bot \\
      %   \pcelse: \\
      %   \pcind \pcif \UK[\uid] = \bot: \UK[\uid] \gets \usk \\
      %   \pcind \pcelse \pcif \UK[\uid] \neq \usk: \pcreturn 0 \\
      %   \pcreturn (\uid,\usk,\credid,\scred,\attrs_{\scred}) \\
      % }
      
      % \procedure{$\ExtractSign(\parm,\trap,\oid,\siid,\sig,\yeval,\msg,\feval)$}{%
      %   \textrm{Parse \parm as $(\cdot,\cdot,\cdot,\cdot,\cdot,\NIZKcrs_{\Sign},
      %     \cdot)$} \\
      %   \textrm{Parse \trap as $(\cdot,\trap_{\Sign},\cdot)$, and
      %     \sig as $(\NIZKproof,\ceval,\cinsp)$} \\
      %   \textrm{Parse $\PUBOK[\oid]$ as $(\opk,\cdot)$ and let $\sipk \gets
      %     \PUBIK[\siid]$} \\
      %   \pcif \NIZKVerify^{\NIZKRel_{\Sign}}(\NIZKcrs_{\Sign},\NIZKproof,
      %   (\msg,\feval,\yeval,\Ec,\sipk,\opk)): \pcreturn \bot \\
      %   (\usk,\scredid,\scred,\attrs_{\scred},\yinsp,r) \gets
      %   \NIZKExtract^{\NIZKRel_{\Sign}}(\NIZKcrs^{\NIZKRel_{\Sign}},
      %   \NIZKtrap_{\Sign},
      %   (\msg,\feval,\yeval^0,\ceval,\cinsp,\sipk,\opk,\widetilde{\Eek}),
      %   \NIZKproof) \\
      %   \pcif \exists \uid \in \HU~\suchthat~\UK[\uid] = \usk: \\
      %   \pcreturn (\uid,\usk,\scred,\attrs_{\scred},\yeval^1,\yinsp) \\
      %   \pcelse \textrm{\todo{Need to add \cid as explicit attribute to the
      %       credentials (chosen by issuer) so that can bookkeep.}} \\
      %   \pcelse \textrm{\todo{then adapt the rest}} \\
      %   \pcind \pcelse \pcif \UK[\uid] \neq \usk: \pcreturn 0 \\
      %   \pcreturn (\usk,\scred,\attrs_{\scred},\yeval^1,\yinsp) \\
      % }
      
      % % \procedure{$\IdentifyCred(\parm,\trap,\usk,\attrs_{\cred},\cred)$}{%
      % %   \pcreturn \SBCMVerify(\ipk_{\cred},\cred,\usk,\attrs_{\cred}) \\
      % % }

      % \procedure{$\IdentifyCred(\parm,\trap,\usk,\attrs_{\cred},\cred,\ipk)$}{%
      %   \pcreturn \SBCMVerify(\ipk,\cred,\usk,\attrs_{\cred}) \\
      % }      

      % \procedure{$\IdentifySig(\parm,\trap,\usk,\scred,\Sig)$}{%
      %   \pcif \uid \in \HU: \pcreturn \usk = \UK[\uid] \\
      %   \pcfor \cid~\suchthat~\CRED[\cid] = (\uid,\cdot,\cdot,\cdot,\cdot,\cdot) \\
      %   \pcind (\usk',\cdot,\cdot,\cdot) \gets \ExtractIssue(\parm,\trap,\trans[\cid]) \\
      %   \pcind \pcif \usk = \usk': \pcreturn 1 \\
      %   \pcreturn 0
      % }

      % % \procedure{$\IdentifySig(\parm,\trap,\uid,\usk)$}{%
      % %   \pcif \uid \in \HU: \pcreturn \usk = \UK[\uid] \\
      % %   \pcfor \cid~\suchthat~\CRED[\cid] = (\uid,\cdot,\cdot,\cdot,\cdot,\cdot) \\
      % %   \pcind (\usk',\cdot,\cdot,\cdot) \gets \ExtractIssue(\parm,\trap,\trans[\cid]) \\
      % %   \pcind \pcif \usk = \usk': \pcreturn 1 \\
      % %   \pcreturn 0
      % % }
      
    \end{minipage}
  }
  \label{fig:helper-funcs}
  \caption{Definition of helper function \SimSetup, for \CUASGen.}
\end{figure}

\subsection{Correctness}

\begin{proof}[\thmref{thm:correctness-uas}; Correctness of \CUASGen]
  By correctness of \SBCM and the NIZK for \RelSig, the signature
  produced at line 4 of \ExpCorrect is accepted at line 5 by \Verify.
  Moreover, all the credentials employed to honestly produce the signature,
  identified with \scid, meet their respective (honest) issuance policies due to
  correctness of the NIZK for \RelIss, so no $\fissue^{\cid}$ check
  returns $\neq \yissue^i$ at line 10. Similarly, as $\feval \in \famfeval$ is
  checked at line 3, and due to correctness of the NIZK for \RelSig,
  the output of \feval matches \yeval at line $12$. Finally, correctness of the
  NIZKs for \RelSig and \RelIns, and correctness of the encryption scheme,
  ensure that \Judge accepts the proof produced by \Open, and \yinsp is the
  correct value for the (honestly) chosen \finsp.
\end{proof}

\subsection{Issuance Anonymity}

\begin{proof}[\thmref{thm:issue-anonymity-uas}; Issuance anonymity of \CUASGen]
  We prove the special case in which the adversary makes only one query to the
  \OBTCHALb oracle. The generalisation to polynomially many queries follows
  from a standard hybrid argument.

  We start from the \ExpIssAnonb, as defined in \figref{fig:exp-uas-anonb}. 

  Game 1: We simulate the NIZK proof corresponding to \RelIss that
  the \OBTCHALb oracle produces when queried by \adv. The zero-knowledge
  property of the NIZK system ensures that game 1 is indistinguishable from
  the original experiment.

  Game 2: In queries to \OBTCHALb, before simulating the NIZK proof, we replace
  the produced \yissue value with a random element from $\rngfissue \setminus
  0$. Since \fissue is a \UAS-acceptable function, game 2 is indistinguishable
  from game 1.

  From an adversary \adv~against game 2, we can build an adversary \advB against
  \SBCM's blindness property. The simulation that \advB does is straightforward.
  \advB runs game 2 for \adv, using the \SBCM \parm variable it receives, to
  set up the \SBCM instance for game 2. When \adv~makes a query to its \OBTCHALb
  oracle, \advB prepares a call to its $\oracle{BLIND}^\RelIss$ oracle, setting
  $\osmsg_b \gets \PRVUK[\cuid_b]$ as message to be blindly signed and
  accompanying each $\osmsg_b$ with its corresponding
  $(\cscid_{i,b},\ATTR[\cscid_{i,b}])$ (for all $i\in[n]$). In the response
  received from $\oracle{BLIND}^\RelIss$ (which succeeds in case both options
  are in \RelIss), \advB replaces the proof with a simulated one, and \yissue
  with a random value (as done in game 2). With the response from \adv, \advB
  completes the credential running \SBCMUnblind as usual. The rest of the
  simulation is as in game 2. Finally, \advB outputs whatever \adv~outputs.
  Again, zero-knowledge of the NIZK for \RelIss, and the fact that \fissue is
  \UAS-acceptable, ensure that simulation is correct, and \advB wins whenever
  \adv~does.
  %
  \qed
\end{proof}

\subsection{Signature Anonymity}

\begin{proof}[\thmref{thm:sign-anonymity-uas}; Signature anonymity of \CUASGen]

  In this proof, we restrict to the case in which the adversary can only make
  one query to the challenge oracle. Note however that the generalisation to
  polynomially many queries given in \cite{bsz05} applies here too (with the
  corresponding security loss). Thus, proving security for one query to the
  challenge oracle is enough.

  We start from $G_0=\ExpSigAnonb$.  %
  From $G_0$, we consider $G^0_0 = \ExpSigAnonz$. The challenge sent to the
  adversary is $(\csig_0,\yeval) \gets \Sign(\PRVUK[\cuid_0],\PUBOK[\oid],
  \CRED[\scid_0],\msg,\feval)$, where $\csig_0 = (\pi_0,\cinsp)$, with
  $\pi_0 = \NIZKProve^{\NIZKRel_{\Sign}}(\NIZKcrs_{\Sign},(\msg,\feval,\yeval,
  \cinsp,\lbrace\PUBIK[\scid_{i,0}]\rbrace_{i\in[n]},\PUBOK[\oid]),
  (\PUBUK[\cuid_0],\PRVUK[\cuid_0],\lbrace (\scid_{i,0},\attrs_{i,0},
  \CRED[\scid_{i,0}]) \rbrace_{i\in[n]},\yeval^1,\yinsp,r,r'))$, and $\cinsp =
  \EEnc(\PUBOK[\oid],\yinsp;r')$, for some random $r,r'$ and $n \ge 0$.
  % 
  Further, we build $G_1^0$ from $G_0^0$ by simulating the proof $\pi_0$. That
  is, in $G_1^0$, $\csig_0 = (\pi_0^s,\ceval,\cinsp)$, where $\pi^s_0 =
  \NIZKSim^{\NIZKRel_{\Sign}}(\NIZKcrs_{\Sign},\NIZKtrap,(\msg,\feval,\yeval,
  \cinsp,\lbrace\PUBIK[\scid_{i,0}]\rbrace_{i\in[n]},\PUBOK[\oid]))$. By
  zero-knowledgeness of $\NIZK^{\Sign}$, $G_1^0$ is indistinguishable from
  $G_0^0$.

  Similarly, we consider $G_0^1$ and $G_1^1$. That is, $G_0^1 = \ExpSigAnono$,
  where the challenge
  sent to the adversary is $(\csig_1,\yeval) \gets \Sign(\PRVUK[\cuid_1],
  \PUBOK[\oid],\CRED[\scid_1],\msg,\feval)$, where $\csig_1 = (\pi_1,
  \cinsp)$, with $\pi_1 = \NIZKProve^{\NIZKRel_{\Sign}}(\NIZKcrs_{\Sign},
  (\msg,\feval,\yeval,
  \cinsp,\lbrace\PUBIK[\scid_{i,1}]\rbrace_{i\in[n]},\PUBOK[\oid]),
  (\PUBUK[\cuid_1],\PRVUK[\cuid_1],\lbrace (\scid_{i,1},\attrs_{i,1},
  \CRED[\scid_{i,1}]) \rbrace_{i\in[n]},\yeval^1,\yinsp,r,r'))$, and
  $\cinsp = \EEnc(\PUBOK[\oid],\yinsp;r')$, for random $r,r'$ and $n \ge 0$. As
  before, build $G_1^1$ from $G_0^1$, simulating $\pi_1$. That is, in $G_1^1$,
  $\csig_1 = (\pi_1^s,\ceval,\cinsp)$, where $\pi^s_1 =
  \NIZKSim^{\NIZKRel_{\Sign}}(\NIZKcrs_{\Sign},\NIZKtrap,(\msg,\feval,\yeval,
  \cinsp,\lbrace\PUBIK[\scid_{i,1}]\rbrace_{i\in[n]},\PUBOK[\oid]))$. Again, by
  zero-knowledge of $\NIZK^{\Sign}$, $G_1^1$ is
  indistinguishable from $G_0^1$.

  Note that, at this point, $G_1^1$ and $G_1^0$ are indistinguishable.
  Concretely, the challenge signatures they produce have the structure $\Sig_b =
  ((\pi_b,\cinsp),\yeval)$ where, to prevent trivial wins, \yeval is enforced
  (in the \SIGN oracle) to be the same for both challenge users, and \cinsp
  either encrypts the same value for both users, or \adv~cannot query the \OPEN
  oracle. \SIGN also enforces that $\PUBIK[\scid_0] = \PUBIK[\scid_1]$. Finally,
  the proofs $\pi_b$ are simulated, and thus reveal no information about the
  signer keys or credentials.

  Finally, consider the definition of $\AdvSigAnon=|\Pr\lbrack
  \ExpSigAnono(1^\secpar)=1\rbrack-\Pr\lbrack\ExpSigAnonz(1^\secpar)=1\rbrack|
  = |\Pr\lbrack G_0^1(1^\secpar)=1\rbrack-\Pr\lbrack
  G_0^0(1^\secpar)=1\rbrack| \approx
  |\Pr\lbrack G_1^1(1^\secpar)=1\rbrack-\Pr\lbrack
  G_1^0(1^\secpar)=1\rbrack|$, which is negligible.
  % 
  \qed
\end{proof}

\subsection{Issuance Unforgeability}

\begin{proof}[\thmref{thm:issue-forge-uas}; Issuance unforgeability of \CUASGen]
  We show that, assuming simulation extractability of the NIZK for \RelIss, and
  correctness and unforgeability of \SBCM, then \CUASGen has issuance
  unforgeability.

  Observe that we restrict to credentials issued by honest issuers. Thus, if a
  credential with identifier \cid was issued by an honest issuer, a matching
  $\trans[\cid]$ entry corresponding to its issuance must exist.
  %
  Then, $\trans[\cid] = (\yissue,\utrans)$, and \utrans contains a NIZK proof
  \NIZKproof proving knowledge by the (potentially corrupt) user of a witness in
  \RelIss. Since the issuer is honest, it verifies the NIZK as part of the
  issuance protocol, rejecting if the proof is not valid. Thus, by simulation
  extractability, \ExtractIssue produces a $(\upk,\usk,\lbrace (\cid_i,\attrs_i,
  \cred_i,\ipk_i) \rbrace_{i\in[n]},(\cid,\attrs,\cred,\ipk))$ tuple.

  Since credential \cid was honestly issued, simulation extractability and
  correctness of \SBCM ensure that \VerCred returns $1$ when run over the values
  output by \adv, along with the \usk extracted by \ExtractIssue. Also, by
  simulation extractability, the value output by \fissue, when evaluated upon
  the extracted values, must match the \yissue value stored alongside
  $\trans[\cid]$.
  %
  In addition, the adversary wins if the \uid associated to the {\cid}s involved
  in the request (i.e., both the \cid output by the adversary, as well as those
  used to support its issuance) is not in \HU or \CU. This can happen if: (1)
  all {\cid}s have the same owner \uid, but this \uid is different to all known
  {\uid}s; or (2) $\OWNR[\scid] = \bot$ which, by definition of \OWNR happens if
  not all of the involved {\cid}s in \scid have the same owner. Since the NIZK
  used for \RelIss is simulation extractable -- where the issuer verifies that
  all credentials are bound to the same \usk -- and due to correctness of \SBCM,
  the probability that (2) happens is negligible, which means that all involved
  {\cid}s have the same owner. Also, regarding (1), this owner must be in either
  \HU or \CU as the \cid output by the adversary in step 2 has been produced via
  \ISSUE or \OBTISS which, by definition, only accept known {\uid}s. Thus, the
  probability that \adv~wins the \ExpForgeIssue game is negligible.

  Finally, the adversary may also win if any of the $\cred_i$ credentials (1) is
  not a valid signature by its issuer, or (2) if it is a valid signature by some
  honest issuer who did not produce it. As before, (1) has negligible
  probability due to simulation extractability of the NIZK for \RelIss. For (2),
  assume that such a $\cred_i$ exists, then, it is an \SBCM forgery -- i.e., a
  valid signature, verifiable under $\ipk_i$ belonging to an honest issuer, who
  did not produce it via a call to \OBTISS or \ISSUE. Thus, it breaks the
  one-more unforgeability property of \SBCM. By security of \SBCM, the
  probability that it happens must be negligible.
  %
  \qed
\end{proof}

\iffalse
\begin{proof}[\thmref{thm:issue-forge-uas}; Issuance unforgeability of \CUASGen]
  We show that the probability that \fissue outputs a wrong $\yissue$ value is
  negligible, as well as the probability that the issued credential, and any
  supporting credential used in the request, do not all belong to a same known
  (honest or corrupt) user.

  Observe that we restrict to credentials issued by honest issuers. Thus, if a
  credential with identifier \cid was issued by an honest issuer, a matching
  $\trans[\cid]$ entry corresponding to its issuance must exist.
  %
  Then, $\trans[\cid] = (\yissue,\utrans)$, and \utrans contains a NIZK proof
  $\NIZKproof_{\Issue}$ proving knowledge by the (potentially corrupt) user of a
  witness in $\NIZKRel_{\Issue}$. Since the issuer is honest, it verifies the
  NIZK as part of the issuance protocol, rejecting if the proof is not valid.
  Thus, by simulation extractability, \ExtractIssue produces a $(\upk,\usk,
  \lbrace (\cid_i,\attrs_i,\cred_i) \rbrace_{i\in[n]},(\cid,\attrs,\cred))$
  tuple. Also due to simulation extractability, the value output by \fissue,
  when evaluated upon the extracted values, must match the \yissue value
  associated to $\trans[\cid]$.

  Finally, the adversary wins if the \uid associated to the {\cid}s involved in
  the request (i.e., both the \cid output by the adversary, as well as those
  used to support its issuance) is not in \HU or \CU. This can happen if: (1)
  all {\cid}s have the same owner \uid, but this \uid is different to all known
  {\uid}s; or (2) $\OWNR[\scid] = \bot$ which, by definition of \OWNR happens if
  not all of the involved {\cid}s in \scid have the same owner. Since the NIZK
  used for $\NIZKRel_{\Issue}$ is simulation extractable -- where the issuer
  verifies that all credentials are bound to the same \usk -- and due to
  correctness of \SBCM, the probability that (2) happens is negligible, which
  means that all involved {\cid}s have the same owner. Also, regarding (1), this
  owner must be in either \HU or \CU as the \cid output by the adversary in step
  2 has been produced via \ISSUE or \OBTISS which, by definition, only accept
  known {\uid}s. Thus, the probability that \adv~wins the \ExpForgeIssue game is
  negligible.
  \qed
\end{proof}
\fi
\subsection{Signature Unforgeability}

\begin{proof}[\thmref{thm:sign-forge-uas}; Signature unforgeability of \CUASGen]
  We show that an adversary \adv~winning \ExpForgeSign can be used to break the
  one-more unforgeability property of \SBCM.
 
  If the verification at line 4 of \ExpForgeSign holds, then $(\msg,\feval,
  \yeval,\cinsp,\sipk,\opk) \in \NIZKLang^{\Sign}$. Then:
  %

  \paragraph{(a) \Judge accepts $(\yinsp,\iproof)$.} %
  Simulation extractability of the NIZK for \RelSig ensures that $\cinsp =
  \EEnc(\Eek,\yinsp)$, and since $(\yinsp,\iproof)$ is generated honestly at
  line 5, then \yinsp is the correct decryption of \cinsp, and completeness of
  the NIZK for \RelIns ensures that \Judge outputs $1$ at line 6.

  \paragraph{(b) $(\yeval^0,\yeval^1)$ are the correct signature evaluation
    pair.} Also, due to simulation extractability of the NIZK for \RelSig:

  \begin{itemize}
  \item $\yeval^0 = \yeval$, where $(\yeval^0,\cdot) = \feval(\upk,\lbrace
    (\cid_i,\attrs_i) \rbrace_{i\in[n]},\msg)$, and $\yeval$ is as output by
    \adv~at step 2.    
  \item $\tyeval^1 = \yeval^1$, where $(\cdot,\yeval^1) = \feval(\upk,\lbrace
    (\cid_i,\attrs_i)\rbrace_{i\in[n]},\msg)$, and $\tyeval^1$ is as extracted
    by \ExtractSign at line 7.
  \end{itemize}

  Thus, the probability of \adv~winning at line 12 is negligible, due to
  simulation extractability of the NIZK for \RelSig.

  \paragraph{(c) The output of \finsp matches the output of \Open.} %
  After (a), and correctness of the public key encryption algorithm, the \yinsp
  value output by \Open is the correct decryption of
  \cinsp. After (c), the $(\yeval^0=\yeval,\yeval^1)$ values output by
  \ExtractSign match the evaluation of \feval. Thus, simulation extractability
  of the NIZK for \RelSig ensures that $\finsp((\yeval^0,\yeval^1),\upk,\lbrace
  (\cid_i,\attrs_i)\rbrace_{i\in[n]},\msg) = \yinsp$ and, also, that \yinsp
  matches the $\yinsp'$ value extracted by \ExtractSign. Thus, the probability
  of \adv~winning at line 13 is negligible due to simulation extractability
  of the NIZK for \RelSig.

  \paragraph{(d) All {\cred}s are bound to the \usk of a known \uid.} %
  \RelSig includes a condition that $\forall i\in[n], 
  \SBCMVerify(\ipk_i,\cred_i,\usk,\attrs_i) = 1$. Thus, simulation
  extractability of the NIZK for \RelSig and correctness of \SBCM, ensure that
  all credentials involved in the signature contain the same \usk as their user
  key  (first) attribute. Thus, either $\OWNR[\lbrace \cid_i \rbrace_{i\in[n]}]$
  returns some \uid in $\HU \cup \CU$, or it returns $\bot$ because no such
  \uid exists (but not because more than one \cid belongs to different {\uid}s).
  Assume that no such \uid exists. Then, the {$\cred_i$}s extracted by
  \ExtractSign cannot have been produced via a call to either \OBTISS or \ISSUE,
  since they only accept calls from known {\uid}s (either in \HU or \CU,
  respectively). Since, by simulation extractability of the NIZK for \RelSig at
  least one such credential must have been used to produce the signature, then
  this breaks the one-more forgery property of the underlying \SBCM scheme.

  \paragraph{(e) All used credentials have been honestly issued.} %
  Finally, assume that there exists some $\cred_i$ among the ones used to
  produce the signature such that the credential is valid (i.e., \VerCred
  returns $1$ for the extracted values), but no matching entry exists in
  $\CRED[\cid]$. This means that the credential is a valid signature by the
  honest issuer with public key $\ipk_i$, but it was not produced via a call
  to \OBTISS or \ISSUE. Thus, it directly breaks the one-more forgery property
  of the underlying \SBCM scheme.
  %
  \qed
\end{proof}

\subsection{Non-Frameability}

\begin{proof}[\thmref{thm:frame-uas}; Non-frameability of \CUASGen]
  \label{prf:frame-uas}

  % We prove that, if the NIZK system used for $\NIZKRel_{\Sign}$ and
  % $\NIZKRel_{\Open}$ is zero-knowledge and simulation-extractable, and \SBCM is
  % blind, then our \CUASGen construction is secure.

  Since the signature output by \adv~is accepted by \Verify at line 4,
  simulation extractability of the NIZK for \RelSig ensures that $\yeval =
  \yeval^0$, and $\tyeval^1 = \yeval^1$. Similarly, if the $(\yinsp,\iproof)$
  pair output by \adv~is accepted by \Judge, simulation extractability of
  the NIZKs for \RelSig and \RelIns implies that both checks at lines 8 and 9
  pass. Hence, the probability that the adversary wins at either lines 8 or 9 is
  negligible, after simulation extractability of the NIZKs for \RelSig and
  \RelIns.

  Next, we prove that, after zero-knowledge and simulation extractability of the
  NIZK for \RelSig, and blindness of \SBCM, no credential from an honest user
  can be extracted from the signature output by \adv, except with negligible
  probability.
  %
  The crucial observation is that, as in \cite{cl06} \CUASGen's \Sign algorithm
  produces a signature of knowledge for the relation defined by \RelSig
  That is, given $(x,w) \in \NIZKRel^{\Sign}$, one can compare $x$ and $w$ to
  the public and private key of a signature algorithm, respectively. In \RelSig,
  $(\upk,\usk,\lbrace (\cid_i,\attrs_i,
  \cred_i)\rbrace_{i\in[n]},\yeval^1,\yinsp,r,r')$ is the private key ($w$), and
  $(\msg,\feval,\yeval^0,\cinsp,\lbrace \ipk_i \rbrace_{i\in[n]},\ek)$ is the
  public key ($x$).
  %
  From this, we prove that an adversary has only negligible probability to forge
  a signature as originating from an honest user without calling the \SIGN
  oracle. The strategy is similar to that in \cite[Theorem 2.1]{cl06}.

  Consider game $G_1$, which is equivalent to $G_0 = \ExpNonframe$, except that
  in the \Sign function within the \SIGN oracle, we simulate the NIZK proof.
  After the zero-knowledge property of the NIZK for \RelSig, $G_1$ is
  indistinguishable from $G_0$. Now, in $G_1$, simulation extractability of
  the NIZK for \RelSig ensures that \ExtractSign outputs a valid
  witness for $(\msg,\feval,\yeval^0,\cinsp,\lbrace ipk_i \rbrace_{i\in[n]},
  \ek)$. Note that this witness must include some \usk which, in case of
  being owned by an honest user, has not been leaked to \adv~--as the user
  has not been corrupted, nor the \usk has been leaked via \SIGN queries,
  where the proof of knowledge within \Sign is now simulated). Moreover,
  blindness of \SBCM ensures that the issuer (who is potentially corrupt), did
  not learn \usk either during calls to \OBTAIN. Thus, since \usk is picked
  uniformly at random by honest users, the probability that $\UK[\uid] = \usk$
  for $\uid \in \HU$ and \Sig produced by the adversary, is negligible.
  %
  \qed
\end{proof}

\subsection{Security of \CUASGenHideIss}
\label{sapp:sec-hide-iss}

The only aspect that changes from \CUASGen to \CUASGenHideIss is the
relationship used for signing, where we hide the specific issuer who produced
the (now only) credential used for signing.
%
This change does not affect the proofs for issuance anonymity, nor signature
anonymity.
%
Issuance unforgeability is also unaffected by the change. Concerning signature
unforgeability, note that the credential that is used to produce the \UAS
signature still needs to originate from a \uid in either \HU or \CU.
Otherwise, such credential, extracted by \ExtractSign, is a forgery and breaks
the one-more forgery property of \SBCM. Moreover, such credential must exist,
due to simulation extractability of the underlying NIZK.
%
The proof for non-frameability is also unaffected by the change.

Thus, if \CUASGen is a secure \UAS scheme, so is \CUASGenHideIss.

\subsection{Security of \CUASGenInt}
\label{sapp:sec-interactive}

\paragraph{Issuance Anonymity.} Since issuance anonymity is independent of
whether signature/authentication is interactive or not, the proof for issuance
anonymity in \CUASGenInt is the same as for \CUASGen.

\paragraph{Signature Anonymity.} To see why the interactive variant has
signature anonymity, assume an adversary \adv~that breaks it. We build \advB
against the non-interactive \ExpSigAnonb from \adv~as follows. \advB initialises
everything as in the \ExpSigAnonb game. When \adv~initiates a call to its
interactive \SIGN (resp. \CHALb) oracle, \advB forwards it to its own oracle
(but concatenating the random number to the message to be signed). \advB
forwards the response from its oracle to \adv. After such simulation, \advB just
outputs whatever $\adv$ outputs. Clearly, the simulation is perfect and, if
\adv~wins with non-negligible probability in the interactive case, then so
does \advB in the non-interactive case. Specifically, note that, since the \Sign
algorithm is probabilistic, even if a malicious verifier picks the same random
number in several queries (to the same or different users), the result will be
indistinguishable with overwhelming probability.

\paragraph{Unforgeability and non-frameability.} The simulation described for
the anonymity case (i.e., \advB concatenating the random numbers
to the message to be signed by the oracle) applies here too. Since the
interactive protocol includes non-interactive proofs for the \RelSig
and \RelIns relations, the proofs for unforgeability and
non-frameability of \CUASGen still apply.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "uas-paper"
%%% End:
