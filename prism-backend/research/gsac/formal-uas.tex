\section{Formalizing \UAS}
\label{sec:formal-uas}

% [11 pages max]

Next we formalize our notion of Universal Anonymous Signatures
(\UAS). We define its syntax, model, and give a generic construction, which
we prove secure according to our model. 

The main contribution of this section is giving a simple syntax and model that
still allow spanning a wide variety of related schemes. We combine aspects of GS
and AC schemes, generalizing whenever possible. Like in ACs, there are multiple
issuers, and each user can get one or more credentials from any of them; and,
also, use more than one credential simultaneously to produce a signature. We
incorporate openers, as in GSs, but there is no tight relationship between
issuer and opener. As a consequence, signers (potentially along with verifiers)
may choose, on a per-signature basis, the policies governing the utility
information extractable from a signature. Finally, we incorporate functions that
allow tweaking the conditions checked at credential issuance and signature
generation times, including the information that an opener will be able to
extract from a signature. This flexibilizes the scheme even beyond the loose
relationship between issuer and opener.

\paragraph{Users and credentials.} %
We model a scheme in which every single user may have multiple credentials.
Moreover, previously obtained credentials can be leveraged simultaneously to
obtain a new one. In this setting, a perhaps too strict assumption we make is
that, once a user gets compromised, all of the credentials owned by that user
are compromised too. While there may be real world situations for which this is
too aggressive, it is certainly a worst-case scenario, and greatly simplifies
the modelling.
%
Somehow related, we model a scheme in which users generate their secret keys in
a standalone way, and then leverage their keys to request credentials.
Therefore, if one ``user'' generates (e.g.) two keys, and then uses each of
these keys to request multiple credentials, then from the point of view of our
modelling, we see this \emph{cryptographically} as two different users. 

\subsection{Syntax}
\label{ssec:syntax-uas}

An \UAS scheme is composed by the following algorithms:

\begin{description}
\item[$\Setup(\secpar) \rightarrow \parm$.] Given a security parameter \secpar,
  returns a global system parameter variable \parm. We assume that \parm are
  available to all the other functions, even if not explicitly listed in their
  input parameters.
\item[$\IKeyGen(\parm,\fissue) \rightarrow (\ipk,\isk)$.] Given \parm, and the
  function \fissue for checking that credential requestors meet the conditions
  to be issued a credential, an issuer runs \IKeyGen to generate its issuing key
  pair. 
\item[$\OKeyGen(\parm,\finsp) \rightarrow (\opk,\osk)$.] Given \parm, and the
  function \finsp, an opener runs \OKeyGen to generate its opening key pair.
  The function \finsp defines the type of utility that will be extractable from
  signatures.
\item[$\UKeyGen(\parm) \rightarrow (\upk,\usk)$.] Given \parm, returns a user's
  key pair.
\item[$\langle
  \Obtain(\usk,\ipk,\sCred,\attrs),
  \Issue(\isk,\sipk,\attrs))  
  \rangle \rightarrow \langle \Cred/\bot,\utrans/\bot
  \rangle$.] %
  This interactive protocol lets a user with key \usk running the \Obtain
  process, receive a credential $\Cred=(\cid,\attrs,\cred,\ipk)$ from an
  issuer in the system, where \cid is a unique identifier for the credential,
  \ipk is the issuer's public key and \cred is the actual credential, on
  attribute set \attrs. The user may leverage a set of previously obtained
  credentials $\sCred=\lbrace (\cid_i,\cattrs_i,\cred_i,\ipk_i)
  \rbrace_{i\in[n]}$, from which we may omit the $\ipk_i$s for readability. The
  user outputs the produced credential \Cred, while the issuer outputs the
  corresponding protocol transcript \utrans.
\item[$\Sign(\usk,\opk,\sCred,\msg,\feval) \rightarrow (\sig,\yeval)$.] %
  Upon receiving a user secret key \usk, opener public key \opk, a set of
  credentials \sCred, a message \msg and evaluation function \feval, returns
  signature \sig, and a plaintext value \yeval. We use use \Sig to denote the
  tuple $(\sig,\yeval)$.
\item[$\Verify(\opk,\sipk,\Sig,\msg,\feval) \rightarrow 1/0$.]
  Checks whether $\Sig = (\sig,\yeval)$ is a valid signature
  over message \msg, from a user with credentials issued by issuers with public
  keys in \sipk, for evaluation function \feval and opener key \opk.
\item[$\Open(\osk,\sipk,\Sig,\msg,\feval) \rightarrow
  (\yinsp,\iproof)/\bot$.]
  Executed by the opener with private key \osk. Receives a signature $\Sig=
  (\sig,\yeval)$ over message \msg and evaluation function \feval,
  generated using credentials issued by the issuers with public keys in \sipk.
  If \Sig is valid, the function outputs a value $\yinsp$, and a proof of
  correct opening \iproof.
\item[$\Judge(\opk,\sipk,\yinsp,\iproof,\Sig,\msg,\feval) \rightarrow 1/0$.] %
  Checks if \iproof is a valid opening correctness proof for the value \yinsp,
  obtained by applying \Open to the the signature $\Sig = (\sig,\yeval)$
  over message \msg, and for evaluation function \feval. 
\end{description}

\paragraph{Issuance, evaluation, and opening functions.} %
We introduce three functions in our syntax and model. Through them,
it is possible to modulate the behaviour of the resulting instantiation, by
controling the conditions upon which a new credential can be issued, or the
information revealed at signing time, or after signing. In all cases, it is
the user who computes them, and has to prove correctness of such computation.
We give concrete examples in \secref{sec:relationships}, and define them next:

\begin{description}
\item[$\fissue: ((\upk,\usk),\attrs,\lbrace (\cid_i,\cattrs_i)
  \rbrace_{i \in [n]}) \rightarrow 0/1$.] Chosen
  by each issuer within a family of functions \famfissue, the issuance function
  defines the customized conditions required by the issuer to grant a credential
  over attributes \attrs, when requested by a user with key pair $(\upk,\usk)$,
  leveraging a set of $n$ previously obtained credentials with identifiers and
  attributes given by $\lbrace (\cid_i,\cattrs_i) \rbrace_{i \in [n]}$ (where $n$
  may be $0$ if no previously obtained credential is used). \fissue returns $1$
  to accept a request, $0$ to reject it.
\item[$\feval: ((\upk,\usk),\lbrace(\cid_i,\cattrs_i)\rbrace_{i \in [n]},\msg)
  \rightarrow (\yeval^0,\yeval^1)$.] Signing evaluation functions, from a
  family of functions \famfeval, can be set on a per-signature basis. They
  receive the user key pair $(\upk,\usk)$, a set of credentials with identifiers
  and attributes given by $\lbrace (\cid_i,\cattrs_i) \rbrace_{i \in [n]}$
  (where $n \ge 1$), and the message to be signed \msg. \feval outputs two
  values, $\yeval^0$ and $\yeval^1$, which can be used to modulate the bevahiour
  of \finsp, and must belong in a well defined set \rngfeval. For readability,
  we write $\Yeval = (\yeval^0,\yeval^1)$.
\item[$\finsp: (\Yeval,(\upk,\usk),\lbrace \cid_i,\cattrs_i\rbrace_{i \in [n]},
  \msg) \rightarrow \yinsp$.]
  Chosen by openers from a family of functions \famfinsp. The opening
  functions define what utility value (derived from the user's secret key,
  credentials' identifiers and attributes used for signing, and signed message)
  should be extractable by an opener. Its behaviour can be modulated by \Yeval,
  and it outputs a value \yinsp, which must belong in a well defined set
  \rngfinsp.
\end{description}

\feval and \finsp may seem redundant. However, the former is chosen on a
per-signature basis, probably after negotiation between signer and verifier, and
governs the information revealed at signing time. On the other hand, \finsp
governs the information that may be revealed after signing, and is defined by
openers when they set up their key pair. Thus even though signers and verifiers
may negotiate to use any opener for a given signature, it is not possible for
an opener to change the chosen function. In the sequel, we restrict to
\UAS-acceptable functions, which we will also use to give \CUASGen restrictions.
Both concepts are defined next.

\begin{definition}{(\UAS-acceptable functions)}
  \label{def:uas-acc-func}
  We say that a \fissue (similarly, \feval or \finsp) function chosen from some
  family \famfissue (similarly, \famfeval or \famfinsp) is \UAS-acceptable if it
  is one-way with respect to $(\upk,\usk)$. That is, given the output of \fissue
  (similarly, \feval or \finsp), it is at least computationally unfeasible to
  recover the $(\upk,\usk)$ value used to produce it.
\end{definition}

\begin{definition}{(\CUASGen restrictions)}
  \label{def:uas-restrictions}
  Let \CUASGen be a construction of an \UAS scheme, secure according to
  the model defined in \secref{ssec:model-uas}, and three functions $\fissue^a$,
  $\feval^b$, $\finsp^c$ compatible with the previous definitions. We say that
  \CUASGen, instantiated with $\fissue^a$, $\feval^b$, and $\finsp^c$, is a
  $(\fissue^a,\feval^b,\finsp^c)$-restriction of \CUASGen.
\end{definition}

% To summarize the previous, we depict in \figref{fig:uas-signature} the structure
% of an \UAS signature, including its main components and how they enable the
% previously stated generalization claims.

% \begin{figure}[ht!]
%   \centering
%   %\input{figures/uas-signature.tex}
%   \caption{Structure of an \UAS signature.}
%   \label{fig:uas-signature}
% \end{figure}

\subsection{Security Model}
\label{ssec:model-uas}

We define the security expected from an \UAS scheme using a game-based approach.
An \UAS scheme must ensure privacy at credential issuance, meaning that two
runs of the credential issuance protocol should not leak any information beyond
necessary about the user requesting the credential. Note that this is now
crucial for privacy since, as AC schemes, \UAS allows multiple credentials per
user -- thus, knowing what user is requesting which credential can lead to user
profiling. It must also ensure signature privacy, meaning that no information
can be learned by third parties from a signature, beyond what the user chooses
to reveal, and what may be extractable by the chosen opener. Issuance
unforgeability requires that \UAS schemes ensure that the claims used to support
a credential request cannot be falsified (issuance unforgeability). Similarly,
signature unforgeability requires that no adversary should be able to falsify
the correctness proofs for the claims included in the signatures. In both cases
(issuance and signature unforgeability), we require all credentials involved in
the corresponding process to be associated to a known user key. Finally, \UAS
schemes inherit the useful non-frameability property of GS schemes where even
the issuer is corrupt. In this case, we can ensure that no honest user
can be framed with having created a signature that s/he did not create --
although the concept may get a bit blurred, as there is no traditional opening.
%
We describe next the global variables and oracles that we use in our modelling.

\paragraph{Global Variables.} %
Users are referred to with user identifiers, \uid; for credentials, we use \cid;
for issuers, \iid; and for openers, \oid.  In all cases, we use bold font to
denote sets: e.g., \scid and \siid denote sets of credential and issuer
identifiers. All tables/sets are initialized as empty tables/sets. For
notational convenience, we often use these identifiers instead of the
corresponding user/issuer/opener keys.


\begin{description}
\item[$\mathsf{H}\lbrace\mathsf{U},\mathsf{I},\mathsf{O} \rbrace$.] Keep
  track of honest users/issuers/openers. They are sets of
  {\uid}s/{\iid}s/{\oid}s.
\item[$\mathsf{C}\lbrace\mathsf{U},\mathsf{I},\mathsf{O} \rbrace$.] Keep
  track of corrupt users/issuers/openers. They are sets of
  {\uid}s/{\iid}s/{\oid}s.    
\item[\UK, \PUBUK and \PRVUK.] \UK maintains user key pairs $(\upk,\usk)$. To
  refer to the key of a specific user, we use $\UK[\uid]$. \PUBUK indexes the
  public keys, and \PRVUK the private keys.
\item[\IK, \PUBIK and \PRVIK.] \IK maintains issuer key pairs, where
  $\IK[\iid]$ refers to the key pair of the issuer with identifier \iid. We
  use \PUBIK to refer to the public component, which also includes the \fissue
  function; and \PRVIK refers to the private component of the key pair.
\item[\OK, \PUBOK, \PRVOK.] Same as \IK, but for opener key pairs. Instead
  of \fissue, \OK includes the \finsp function.
\item[\CRED.] Stores information related to credentials obtained by users in
  the system. Thus, it is indexable by \cid. More specifically, it stores
  tuples of the form $(\uid,\cred,\iid,\attrs,n,\lbrace (\cid_i,\iid_i)
  \rbrace_{i \in [n]})$, where \uid is the identifier of the owner of the
  credential, \cred (when available) is the credential itself, \iid is the
  identifier of the credential issuer, \attrs are the attributes included in
  \cred, $n$ is the number of credentials used to support this request, and
  $(\cid_i,\iid_i)$ for $i \in [n]$ are the corresponding credential and issuer
  identifiers. For notational convenience, we may use $\CRED[\scid]$
  to refer to $\CRED[\cid]$ for all {\cid}s in a set \scid. Also, when clear
  from context, we sometimes use $\CRED[\cid]$ (resp. $\CRED[\scid]$ to
  mean \cred (resp. \scred) in $\CRED[\cid] = (\cdot,\cred,\cdot,\cdot,
  \cdot,\cdot)$ (resp. $\CRED[\scid]$).
\item[\CCRED.] Like \CRED, but keeps track of challenge credentials in the
  issuance anonymity game.
\item[\OWNR.] For notational convenience, when we write $\OWNR[\cid]$ we mean
  ``\uid such that $\CRED[\cid] = (\uid,\cdot,\cdot,\cdot,\cdot,\cdot)$''. We
  may also use \OWNR over a set of {\cid}s (\scid). In that case, our convention
  is that $\OWNR[\scid]$ returns $\bot$ if not all passed {\cid}s belong to the
  same \uid.
\item[\ATTR.] For notational convenience, when we write $\ATTR[\cid]$ we mean
  ``\attrs such that $\CRED[\cid] = (\cdot,\cdot,\cdot,\attrs,\cdot,\cdot)$''.
\item[\ISR.] For notational convenience, when we write $\ISR[\cid]$ we mean
  ``\iid such that $\CRED[\cid] = (\cdot,\cdot,\iid,\cdot,\cdot,\cdot)$''.
\item[\SIG.] Maintains signatures generated via the \SIGN oracle. Entries of
  this table are $(\oid,\scid,\sig,\Yeval,\msg,\feval)$ tuples, where \oid is
  the opener, \scid is the set of identifiers of the credentials used for
  signing, \feval is the signing evaluation function, and \sig and \msg are the
  produced signature and signed message.
\item[\CSIG.] Maintains challenge signatures output to the adversary in the
  signature anonymity game, and is indexable by challenge signatures \csig.
  Each entry contains also $\cuid_b$ and $\cscid_b$, respectively the challenge
  user  and credential identifiers set used to produce \csig; as well as the
  corresponding challenge user and credential set indexed by the complementary
  $1-b$; the signed message \msg and signing evaluation function \feval, the
  result of \feval, \Yeval, and the opener identifier \oid.
\end{description}

\paragraph{Oracles.} %
In the game-based definitions of our \UAS model, we leverage the following
oracles, which are formally defined in \figref{fig:oracles1} and
\figref{fig:oracles2}. 

\begin{description}
\item[\IGEN.] Adds a new issuer to the game, generating its keypair and setting
  the associated issuance function.
\item[\OGEN.] Adds a new opener to the game, generating its key pair and
  setting the associated evaluation and inspection functions.
\item[\ICORR.] Corrupts an existing (and honest) issuer, by giving its secret
  key to the adversary.
\item[\OCORR.] Corrupts an existing (and honest) opener, by giving its secret
  key to the adversary.  
\item[\HUGEN.] Adds a new honest user to the game, by honestly generating
  the user's key pair.
\item[\CUGEN.] Adds a new corrupt user to the game or, if the specified
  user already exists and is honest, corrupts it, leaking its key and
  credentials.
\item[\RREG.] Reads the given transcript table entry.
\item[\WREG.] Sets a transcript table entry to the given value.
\item[\OBTISS.] Lets the adversary add a new honestly generated credential to
  the game, on behalf of an honest user.
\item[\OBTAIN.] Enables the adversary to play the role of a dishonest issuer, by
  letting it interact with honest users who want to receive credentials.
\item[\ISSUE.] Allows the adversary to play the role of dishonest users,
  requesting an honest issuer to produce credentials for them.
\item[\SIGN.] Lets the adversary get signatures from credentials belonging
  to honest users.
\item[\OPEN.] Given an honestly produced signature, outputs the result of the
  opening function, along with a correctness proof.
\item[\OBTCHALb.] Upon receiving a target credential identifier, two challenge
  users and credential sets, an honest issuer identifier, and a set of
  attributes, issues a credential for the challenge user and credential set
  defined by the bit $b$. 
\item[\CHALb.] Upon receiving two challenge users and credential sets, a common
  singing evaluation function and a message, returns a signature produced by one
  of these two user and credential sets, defined by the bit $b$.
\end{description}

{%\setlength\intextsep{\sep}
  \begin{figure*}[htp!]
    \centering
    \scalebox{0.9}{

      \begin{minipage}[t]{0.55\textwidth}

        \procedure{$\IGEN(\iid,\fissue)$}{%
          \pcif \iid \in \HI \lor \iid \in \CI: \pcreturn \bot \\
          \pcif \fissue \notin \famfissue: \pcreturn \bot \\
          (\ipk,\isk) \gets \IKeyGen(\parm) \\
          \IK[\iid] \gets ((\ipk,\fissue),\isk) \\
          \HI \gets \HI \cup \lbrace \iid \rbrace \\
          \pcreturn \ipk \\
        }

        \procedure{$\ICORR(\iid)$}{%
          \pcif \iid \in \CI \lor \iid \notin \HI: \pcreturn \bot \\
          \HI \gets \HI \setminus \lbrace \iid \rbrace \\
          \CI \gets \CI \cup \lbrace \iid \rbrace \\
          \pcreturn \isk \\
        }        

        \procedure{$\HUGEN(\uid)$}{%
          \pcif \uid \in \HU \lor \uid \in \CU: \pcreturn \bot \\
          (\upk,\usk) \gets \UKeyGen(\parm) \\
          \UK[\uid] \gets (\upk,\usk);
          \HU \gets \HU \cup \lbrace  \uid \rbrace \\
          \pcreturn \top \\
        }

        \procedure{$\RREG(i)$}{%
          \pcreturn \trans[i]
        }        
        
      \end{minipage}
    }
    \scalebox{0.9}{
      
      \begin{minipage}[t]{.5\textwidth}

        \procedure{$\OGEN(\oid,\finsp)$}{%
          \pcif \oid \in \HO \lor \oid \in \CO: \pcreturn \bot \\
          \pcif \finsp \notin \famfinsp: \pcreturn \bot \\
          (\opk,\osk) \gets \OKeyGen(\parm) \\
          \OK[\oid] \gets ((\opk,\finsp),\osk) \\
          \HO \gets \HO \cup \lbrace \oid \rbrace \\
          \pcreturn \opk \\
        }

        \procedure{$\OCORR(\oid)$}{%
          \pcif \oid \in \CO \lor \oid \notin \HO: \pcreturn \bot \\
          \pcif \exists (\oid,\cdot,\cdot,\cdot,\cdot,
          \cdot,\cdot,\cdot,\cdot) \in \CSIG: \pcreturn \bot \\
          \HO \gets \HO \setminus \lbrace \oid \rbrace \\
          \CO \gets \CO \cup \lbrace \oid \rbrace \\
          \pcreturn \osk \\
        }        
        
        \procedure{$\CUGEN(\uid)$}{%          
          \pcif \uid \in \CU: \pcreturn \bot \\
          \CU \gets \CU \cup \lbrace \uid \rbrace \\          
          \pcif \uid \in \HU: \\
          \pcind \HU \gets \HU \setminus \lbrace \uid \rbrace; \\
          \pcind \pcreturn (\UK[\uid],\CRED[\uid]) \\
          \pcelse: \UK[\uid] = \bot \\          
          \pcreturn \top \\
        }

        \procedure{$\WREG(i,\rho)$}{%
          \trans[i] \gets \rho
        }        
        
      \end{minipage}
      
    }

    \caption{Detailed oracles available in our model (1/2). Oracles for
      generating key material for users, issuers, and openers.}
    \label{fig:oracles1}
  \end{figure*}
}

{%\setlength\intextsep{\sep}
  \begin{figure*}[htp!]
    \centering
    \scalebox{0.9}{

      \begin{minipage}[t]{0.55\textwidth}

        \procedure{$\OBTISS(\cid,\uid,\iid,\attrs,\lbrace (\cid_i,\iid_i)
          \rbrace_{i \in [n]})$}{%
          \pcif \uid \notin \HU: \pcreturn \bot \\
          \pcif \iid \notin \HI: \pcreturn \bot \\
          \pcif \exists i \in [n]~\suchthat~\cid_i \in \CCRED: \pcreturn \bot \\
          \pcif \CRED[\cid] \neq \bot \lor \CCRED[\cid] \neq \bot:
          \pcreturn \bot \\
          \langle \Cred, \utrans \rangle \gets
          \langle \Obtain(\UK[\uid],\CRED[\lbrace \cid_i\rbrace_{i\in[n]}],\attrs), \\
          \hspace*{60pt} \Issue(\PRVIK[\iid],\ISR[\lbrace \cid_i\rbrace_{i\in[n]}],\attrs)
          \rangle \\
          \trans[\cid] \gets \utrans \\
          \CRED[\cid] \gets (\uid, \cred, \iid, \attrs, n,
          \lbrace(\cid_i,\iid_i)\rbrace_{i\in[n]}) \\
          \pcreturn \top \\
        }

        \procedure{$\ISSUE(\cid,\uid,\iid,\attrs,\siid=\lbrace \iid_i
          \rbrace_{i\in[n]})$}{%
          \pcif \uid \notin \CU: \pcreturn \bot \\          
          \pcif \iid \notin \HI: \pcreturn \bot \\
          \pcif \CRED[\cid] \neq \bot \lor \CCRED[\cid] \neq \bot:
          \pcreturn \bot \\
          \langle \cdot, \utrans \rangle \gets
          \langle \adv, 
          \Issue(\PRVIK[\iid],\siid,\attrs) \rangle \\
          \trans[\cid] \gets \utrans \\
          \CRED[\cid] \gets (\uid,\cdot,\iid,\attrs,n,\lbrace(\cdot,\iid_i)
          \rbrace_{i\in[n]}) \\
          \pcreturn \top \\          
        }

        \procedure{$\SIGN(\uid,\oid,\scid=\lbrace\cid_i\rbrace_{i\in[n]},\msg,
          \feval)$}{%
          \pcif \uid \notin \HU: \pcreturn \bot \\
          \pcif \exists i \neq j \in [n]~\suchthat~\cid_i \in \CRED \land
          \cid_j \in \CCRED: \\
          \pcind \pcreturn \bot \\
          \pcif \feval \notin \famfeval: \pcreturn \bot \\
          \Sig \gets \Sign(\UK[\uid],\PUBOK[\oid],\scid,\msg,\feval) \\
          \Yeval=(\yeval^0,\yeval^1) \gets \feval(\UK[\uid],\scid,\msg) \\
          \pcif \Yeval \notin \rngfeval: \pcreturn \bot \\
          \SIG[\uid] \gets \SIG[\uid] \cup
          \lbrace (\oid,\scid,\Sig,\Yeval,\msg,\feval) \rbrace \\
          \pcreturn \Sig \\
        }        

        \procedure{$\OPEN(\oid,\Sig,\msg)$}{%
          \textrm{Let}~\uid~\textrm{be s.t.}~(\oid,\scid,\Sig,\Yeval,\msg,\feval)
          \in \SIG[\uid] \\
          (\yinsp,\iproof) \gets
          \Open(\PRVOK[\oid],\PUBIK[\scid],\Sig,\msg,\feval) \\
          \pcif \CSIG[\Sig] \neq \bot: \\
          \pcind \textrm{Parse $\CSIG[\Sig]$ as $(\oid,\cuid_b,\scid_b,
            \Yeval,\msg,\feval$} \\          
          \hspace*{83pt}\cuid_{1-b},\cSig_{1-b},\scid_{1-b},
          \TYeval) \\
          \pcind (\tyinsp,\tiproof) \gets
          \Open(\PRVOK[\oid],\IK[\ISR[\scid]],\\
          \hspace*{107pt} \cSig_{1-b},\msg,\feval) \\
          \pcind \pcif \tyinsp \neq \yinsp: \pcreturn \bot \\
          \pcreturn (\yinsp,\iproof)
        }
        
      \end{minipage}
    }
    \scalebox{0.9}{
      
      \begin{minipage}[t]{.5\textwidth}

        \procedure{$\OBTAIN(\cid,\uid,\iid,\attrs,\lbrace (\cid_i,\iid_i)
          \rbrace_{i\in[n]})$}{%
          \pcif \uid \notin \HU: \pcreturn \bot \\
          \pcif \iid \notin \CI: \pcreturn \bot \\
          \pcif \exists i \in [n]~\suchthat~\cid_i \in \CCRED: \pcreturn \bot \\
          \pcif \CRED[\cid] \neq \bot \lor \CCRED[\cid] \neq \bot: \pcreturn \bot \\
          \langle \Cred, \cdot \rangle \gets
          \langle \Obtain(\UK[\uid],\PUBIK[\iid],\lbrace \cid_i\rbrace_{[n]},
          \attrs),\adv \rangle \\
          \CRED[\cid] \gets (\uid,\cred,\iid,\attrs,n,\lbrace(\cid_i,\iid_i)
          \rbrace_{i\in[n]}) \\
          \pcreturn \top \\
        }

        \procedure{$\OBTCHALb(\cid,\cuid_{0,1},\iid,\attrs,\cscid_{0,1}=
          \lbrace (\ccid_{0,i},\ccid_{1,i}) \rbrace_{i\in[n]})$}{%
          \pcif \cuid_0 \notin \HU \lor \cuid_1 \notin \HU: \pcreturn \bot \\
          \pcif \iid \notin \CI: \pcreturn \bot \\
          \pcif \CRED[\cid] \neq \bot: \pcreturn \bot \\
          \pcif \exists i\in[n]~\suchthat~
          \PUBIK[\cscid_{0,i}] \neq \PUBIK[\cscid_{1,i}]: \pcreturn \bot \\
          \pcif \pcfor d \in \bin,~ \exists \cid' \in \cscid_d~\suchthat~\cid'
          \in \CRED: \\
          \pcind \pcreturn \bot \\
          \textrm{Parse}~\PUBIK[\iid]~\textrm{as}~((\cdot,\fissue),\cdot) \\
          \pcif \fissue(\UK[\cuid_0],\cscid_0,\attrs) \neq
          \fissue(\UK[\cuid_1],\cscid_1,\attrs) \\
          \langle \Cred, \cdot \rangle \gets
          \langle \Obtain(\UK[\cuid_b],\PUBIK[\iid],\cscid_b,\attrs),\adv \rangle \\
          \CCRED[\ccid_b] \gets (\cuid_b,\cred,\iid,\attrs,\cscid_b,\siid) \\
          \pcreturn \top \\
        }

        \procedure{$\CHALb(\cuid_{0,1},\oid,\cscid_{0,1}=
          \lbrace (\ccid_{0,i},\ccid_{1,i}) \rbrace_{i\in[n]},\msg,\feval)$}{%
          \pcif \cuid_0 \notin \HU \lor \cuid_1 \notin \HU: \pcreturn \bot \\
          \pcif \exists i\in[n]~\suchthat~
          \PUBIK[\cscid_{0,i}] \neq \PUBIK[\cscid_{1,i}]: \pcreturn \bot \\
          \pcif \feval \notin \famfeval: \pcreturn \bot \\
          \Yeval = (\yeval^0,\yeval^1) \gets \feval(\UK[\cuid_0],\cscid_0,
          \msg) \\
          \TYeval = (\tyeval^0,\tyeval^1) \gets
          \feval(\UK[\cuid_1],\cscid_1,\msg) \\
          \pcif \yeval^0 \neq \tyeval^0: \pcreturn \bot \\
          \pcif \Yeval \notin \rngfeval \lor \TYeval \notin \rngfeval:
          \pcreturn \bot \\          
          \cSig_b \gets \Sign(\UK[\cuid_b],\PUBOK[\oid], \\
          \hspace*{71pt}\cscid_b,\msg,\feval) \\
          \cSig_{1-b} \gets \Sign(\UK[\cuid_{1-b}],\PUBOK[\oid], \\
          \hspace*{80pt}\cscid_{1-b},\msg,\feval) \\          
          \CSIG[\cSig_b] \gets 
          \lbrace (\oid,\cuid_b,\cscid_b,\Yeval,\msg,\feval,\\
          \hspace*{74pt}\cuid_{1-b},\cSig_{1-b},\cscid_{1-b},\TYeval)\rbrace \\
          \pcreturn \cSig_b
        }
        
      \end{minipage}
      
    }

    \caption{Detailed oracles available in our model (2/2). Oracles for
      obtaining credentials, signatures, and processing them.}
    \label{fig:oracles2}
  \end{figure*}
}

\paragraph{Helper functions \SimSetup, \ExtractIssue, and \ExtractSign.}
%, \IdentifyCred, and \IdentifySig.}
We assume the existence of these helper functions. They are not functions
available in the actual scheme, but rather to the challenger in the experiments
we use to formalize security of \UAS schemes.
% Consequently, while we introduce them here and specify some conditions they need
% to meet, their definition is dependent on the construction.
\todo{Better describe this when finished making changes.}
% We fully define
% them for our generic construction \CUASGen in \appref{app:uas-proofs}. Similar
% techniques have been used before to prove security in privacy-preserving schemes
% with some sort of accountability, but that do not offer conventional opening as
% vanilla group signatures. For instance, see related works on DAA
% \cite{bfg+11,cdl16} and group signature variants \cite{dl21,fgl21,gl19,lnpy21}.
% More concretely, these functions are as follows:

\begin{description}
\item[$\SimSetup(1^\secpar) \rightarrow (\parm,\trap)$.] Given a security
  parameter, outputs global (simulated) parameters \parm whose distribution is
  indistinguishable to that produced by the \Setup algorithm, as well as a
  trapdoor \trap.
\item[$\ExtractIssue(\trap,\utrans) \rightarrow ((\upk,\usk),\sCred=
  \lbrace(\cid_i,\attrs_i,\cred_i) \rbrace_{i \in [n]})$.]
  Receives trapdoor \trap and an $\langle \Obtain, \Issue \rangle$ transcript,
  and returns the credential set \sCred, if any, involved in the request. It
  needs an honest issuer as, otherwise, the transcripts won't be available. 
\item[$\ExtractSign(\trap,\oid,\lbrace \iid_i \rbrace_{i \in [n]},\Sig,\msg,
  \feval) \rightarrow ((\upk,\usk),\sCred=\lbrace(\cid_i,\attrs_i,\cred_i)
  \rbrace_{i \in [n]},\yeval^1,\yinsp)$.] Receives a trapdoor \trap, a signature
  \Sig, as well as the opener identifier \oid, and the identifiers of all
  issuers of the credentials used to produce the signature over \msg, and for
  \feval. It outputs the user secret key and credential set \sCred used to
  generate the signature, and the $\yeval^1$ and \yinsp values.
% \item[$\IdentifyCred(\trap,\usk,\attrs_{\cred},\cred,\ipk)$.] Returns $1$ if
%   \cred has been issued over attributes $\attrs_{\cred}$ and for a user with
%   secret key \usk, by honest issuer with public key \ipk. Otherwise, it returns
%   $0$.

%   The \IdentifyCred function defined by \UAS constructions must satisfy that
%   for any \cred obtained as the result of an $\langle \Obtain,\Issue \rangle$
%   interaction with an honest issuer, there exists \emph{exactly one} set of
%   $(\usk,\attrs_{\cred})$ such that \IdentifyCred equals $1$.
%   %In order to be meaningful, this requires that,
%   %for every $(\attrs_{\cred},\cred)$ pair, there is at most one \usk that makes
%   \IdentifyCred return $1$.
% \item[$\IdentifySig(\trap,\usk,\scred,\Sig)$.] Returns $1$ is $(\usk,\scred)$
%   are the secret key and credential set used to produce \Sig, otherwise, returns
%   $0$.

%   The \IdentifySig function defined by \UAS constructions must satisfy that, for
%   signatures accepted by \Verify, there must exist \emph{exactly one} $(\usk,
%   \scred)$ combination that makes \IdentifySig return $1$.
%   % . This is trivial for honest users, for which there must be a one-to-one
%   % relationship between {\uid}s and {\usk}s. For corrupt users, \IdentifyUK has
%   % to iterate through the $\langle\Obtain,\Issue\rangle$ transcripts associated
%   % to \uid, extract the used secret key, and check if there is a match. In the
%   % latter case, there is no guarantee of getting a one-to-one relationship
%   % between \usk and \uid. Also, when used for corrupt users, this can only be
%   % used when the issuer is honest, as transcripts are needed. 
\end{description}

% Note that, for all the helper functions, in the case of credentials, transcripts,
% and signatures by honest users, it is enough to have access to the corresponding
% state information (described below) maintained by the challenger in our
% experiments. For credentials and join transcripts of corrupt users, or
% dishonestly produced signatures, we do need to perform actual extraction.
% Certainly, the challenger
% needs special knowledge/power such as decryption trapdoors, the ability to
% rewind the game, or program random oracles. The approach needs thus to depend on
% the concrete construction. \jdv{Although, for the case of \ExtractIssue and
%   \IdentifyUK, online extractability (or alternative requirements, such as
%   non-parallel or logarithmic number of joins) is necessary.}

\paragraph{Correctness.} %
Correctness of \UAS schemes is formalized through the experiment in
\figref{fig:exp-uas-corr}. It states that a signature over any arbitrary message
and valid function \feval, produced honestly leveraging credential set \scid,
owned by user \uid, is accepted by \Verify. Moreover, all the credentials in
\scid meet the conditions set by the corresponding \fissue defined by the issuer
which issued each credential. Similarly, the output of \feval matches the
value produced by \Sign alongside with \sig; and the value produced by \Open
is accepted by \Judge, and matches the output of applying \finsp on \Yeval, the
credentials, user key, and message.

\begin{definition}{(Correctness of \UAS)}
  \label{def:correctness-uas}
  An \UAS scheme is correct if, for any p.p.t. adversary $\adv$,
  $\ExpCorrect(1^\secpar)$ outputs 1 with negligible probability.
\end{definition}

\begin{figure}[htp!]
  \procedure[linenumbering]{$\ExpCorrect(1^\secpar)$}{%
    \textrm{\todo{This needs updating}} \\
    \parm \gets \Setup(1^\secpar) \\
    (\uid,\oid,\scid,\msg,\feval)
    \gets \adv^{\IGEN,\OGEN,\HUGEN,\OBTISS,\RREG}(\parm) \\
    \pcif \feval \notin \famfeval: \pcreturn 0 \\
    \pcif \OWNR[\scid] \neq \uid: \pcreturn 0 \\
    (\Sig = (\sig,\yeval)) \gets \Sign(\UK[\uid],\PUBOK[\oid],\scid,\msg,
    \feval) \\
    \pcif \Verify(\PUBOK[\oid],\PUBIK[\scid],\Sig,\msg,\feval) = 0: \pcreturn 1 \\
    \pcfor \cid \in \scid \pcdo: \\
    \pcind \textrm{Let}~\scred^{\cid}~\textrm{be the credentials used to obtain}
    ~\cid;~\textrm{Parse}~\PUBIK[\ISR[\cid]]~\textrm{as}~((\cdot,\fissue^{\cid}),\cdot)\\
    \pcind \pcif \fissue^{\cid}(\UK[\uid],\scred^{\cid},\ATTR[\cid]) = 0: \pcreturn 1 \\
    (\yeval^0,\yeval^1) \gets \feval(\UK[\uid],\scid,\msg) \\
    \pcif \yeval^0 \neq \yeval: \pcreturn 1 \\
    (\yinsp,\iproof) \gets \Open(\PRVOK[\gid],\PUBIK[\scid],\Sig,\msg,\feval) \\
    \pcif \Judge(\PUBOK[\oid],\PUBIK[\scid],\yinsp,\iproof,\Sig,\msg,\feval)
    = 0~\lor \\
    \pcind \yinsp \neq \finsp^\gid((\yeval,\yeval^1),\UK[\uid],\scid,\msg)): \\
    \pcind \pcreturn 1 \\
    \pcreturn 0
  }  
  \caption{Correctness experiment for \UAS schemes.}
  \label{fig:exp-uas-corr}
\end{figure}

\subsubsection{Security Properties}
\label{sssec:security}

Security of an \UAS scheme is defined in terms of anonymity, unforgeability and
non-frameability. We now introduce and formally define the corresponding
properties.
% In addition, we define two auxiliary properties for defining
% the expected behaviour of the \ExtractIssue and \ExtractSign functions.
% \todo{The following may need to be moved elsewhere and/or re-written.}
% For instance, the extraction type are used in
% \cite{lnpy21,nps22}, and functions of the identify type are used in
% \cite{bfg+11,cdl16,gl19,dl21,fgl21}. Indeed, it seems hard to avoid resorting to
% these techniques when there is no traditional notion of opening. Since, mostly
% the unforgeability and non-frameability properties build on the extractability
% and identifiability ones, we define them first. Then, we proceed with the usual
% notions.

% \todo{Maybe do some drawing of the cred tree.}

% In the following, we use some custom notation to refer to the tree-like
% relationships that may be built between credentials and, more concretely, their
% related data (like {\usk}s, {\cid}s, and attribute sets {\attrs}s) when a user
% leverages previously obtained credentials in order to obtain new ones. To
% facilitate the explanation, we refer to \figref{fig:cred-tree}. In a nutshell,
% we use $tree_{\cid}$ to refer to the whole tree of {\cid}s that have been used
% to produce the credential with identifier \cid -- and, similarly, $tree_{\usk}$
% for {\usk}s, and $tree_{\attrs}$ for attribute sets. 

% \begin{figure}[htp!]
%   \centering
%   \includegraphics[width=0.5\textwidth]{figures/cred-tree.png}
%   \caption{Credential trees, and their corresponding notation.
%     We use $Tree_x$, where $x \in \lbrace \usk,\cid,\attrs \rbrace$ to
%     denote the whole tree of {\usk}s, {\cid}s, and {\attrs}s. \\
%     \todo{Move to Tikz.}}
%   \label{fig:cred-tree}
% \end{figure}

% \paragraph{Extractability.} %
% We require that the witnesses used to produce each credential and signature can
% be extracted from the corresponding \utrans and signature, respectively.
% Furthermore, in order for our generalized notion of utility to be sound, it
% is required that, whenever a credential is issued by an honest issuer, \fissue
% accepts the extracted witnesses; and whenever a signature is accepted by
% \Verify, the extracted witnesses match the expected outputs by \feval and
% \finsp. We capture this in the \ExpExtractIssue and \ExpExtractSign games, which
% are crucial in the unforgeability and non-frameability requirements.

% In the extractability variant for credentials, \ExpExtractIssue, the adversary
% wins if it manages to get a credential produced by an honest issuer, such that
% the issuance predicate \fissue rejects the extracted witnesses, or if some of
% the involved credentials is associated to a different \usk.
% %
% In the variant for signatures, \ExpExtractSign, the adversary wins if the
% witnesses extracted from a signature accepted by \Verify make \feval and \finsp
% output inconsistent values.
% %
% The oracles available in \ExpExtractIssue is, $\OExt \gets (\lbrace\HU,\CU
% \rbrace\GEN,\IGEN,\OGEN,\OCORR,\OBTISS,\ISSUE,\RREG,\SIGN,\OPEN)$. Note that,
% for \ExpExtractIssue, honest issuers are required, as we rely on the
% availability of $\langle \Obtain,\Issue \rangle$ transcripts to assist on the
% extraction. On the other hand, for \ExpExtractSign, as we extract directly from
% signatures, honest issuers are not a requirement, so the adversary is given
% access to $\ICORR$ too.

% \begin{figure*}[htp!]
%   \centering
%   \scalebox{0.9}{
%     \begin{minipage}[t]{0.6\textwidth}
%       \procedure[linenumbering]{$\ExpExtractIssue(1^\secpar)$}{%
%         (\parm, \trap) \gets  \SimSetup(1^\secpar) \\
%         \cid \gets \adv^{\OExt}(\parm) \\
%         (\usk,\lbrace(\cid_i,\attrs_i,\cdot)\rbrace_{i \in [n]}) \gets
%         \ExtractIssue(\trap,\trans[\cid]) \\
%         \pcfor i \in [n]: (\usk_i,\cdot) \gets \ExtractIssue(\trap,
%         \trans[\cid_i]) \\
%         \pcif \exists i \in [n]~\suchthat~\usk \neq \usk_i: \pcreturn 1 \\
%         \pcif \fissue(\usk,\ATTR[\cid],\lbrace \cid_i \rbrace_{i \in [n]},
%         \lbrace\attrs_i\rbrace_{i \in [n]}) = 0: \\
%         \pcind \pcreturn 1 \\
%         \pcreturn 0
%       }
%     \end{minipage}
%     \vspace*{0.5em}
    
%     \begin{minipage}[t]{0.5\textwidth}
%       \procedure[linenumbering]{$\ExpExtractSign(1^\secpar)$}{%
%         (\parm, \trap) \gets \SimSetup(1^\secpar) \\
% 	(\oid,\siid,\Sig=(\sig,\yeval),\msg,\feval) \gets
%         \adv^{\OExt,\ICORR}(\parm) \\
% 	\pcif \Verify(\oid,\siid,\Sig,\msg,\feval) = 0: \pcreturn 0 \\
% 	(\usk,\lbrace (\cid_i,\attrs_{\cid_i},\cdot) \rbrace_{i\in[n]},
%         \yeval^1,\yinsp) \gets \ExtractSign(\trap,\oid,\siid,\Sig,\msg,\feval) \\
%         (\yeval^0,\yeval^1) \gets \feval(\usk,\lbrace\cid_i\rbrace_{i \in [n]},
%         \lbrace\attrs_i\rbrace_{i \in [n]}, \msg) \\
%         \pcif \yeval \neq \yeval^0 \lor \yeval^1 \neq \tyeval^1:
%         \pcreturn 1 \\
%         \pcif \finsp((\yeval^0,\yeval^1),\usk,\lbrace\cid_i\rbrace_{i \in [n]},
%         \lbrace\attrs_i\rbrace_{i \in [n]},\msg) \neq \yinsp:
%         \pcreturn 1 \\
% 	\pcreturn 0
%       }
%     \end{minipage}
%   }
%   \caption{Extractability experiments for \UAS schemes.}
%   \label{fig:exp-uas-extract}
% \end{figure*}

% \paragraph{Identifiability.} %
% On their own, the extractability properties only ensure that credentials and
% signatures have been produced by leveraging knowledge of some witnesses.
% However, they do not establish any relationship between those witnesses and
% users. While the actual technicalities of doing so is dependent on the
% construction, we can, modelling-wise, enforce constraints that associate
% user identifiers ({\uid}s, tracked by the game environment) with potential
% witnesses. Namely, we require that it must be possible to associate any
% credential (obtained from an honest issuer), or any signature accepted by
% \Verify, with exactly one user identifier.

% As for extractability, we define two variants. For credentials, in
% \ExpIdentifyCred we require the adversary to output the identifier of a
% credential obtained from an honest issuer. The adversary wins if, given the
% witnesses extracted from the corresponding transcript, the \IdentifyCred helper
% function outputs a set \suid of user identifiers with cardinality different than
% $1$.
% %
% Similarly, for signatures, the adversary wins if it is able to produce a
% signature from which the extracted witnesses, when passed to \IdentifySig,
% output a set \suid of user identifiers with cardinality different than $1$.
% %
% The oracles are as in the extractability experiments. Namely, in the
% \ExpIdentifyCred game, the adversary has access to $\OId \gets (\lbrace\HU,\CU
% \rbrace\GEN,\IGEN,\OGEN,\OCORR,\OBTISS,\ISSUE,\RREG,\SIGN,\OPEN)$, while in
% \ExpIdentifySign it also has access to \ICORR. The same reasoning applies.

% \begin{figure*}[htp!]
%   \centering
%   \scalebox{0.9}{
%     \begin{minipage}[t]{0.6\textwidth}
%       \procedure[linenumbering]{$\ExpIdentifyCred(1^\secpar)$}{%
%         (\parm, \trap) \gets  \SimSetup(1^\secpar) \\
%         \cid \gets \adv^{\OId}(\parm) \\
%         (\usk,\scred,\attrs_{\scred}) \gets \ExtractIssue(\trap,\trans[\cid]) \\
%         \pcfor \cred \in \scred: \\
%         \pcind \suid \gets \IdentifyCred(\trap,\usk,\attrs_{\cred},\cred,\ipk_{\cred}) \\
%         \pcind \pcif |\suid| \neq 1: \pcreturn 1 \\
%         \pcind \pcif \suid~\textrm{differs from previous iterations}: \\
%         \pcind \pcind \pcreturn 1 \\
%         \pcreturn 0
%       }
%     \end{minipage}
%     \vspace*{0.5em}
    
%     \begin{minipage}[t]{0.5\textwidth}
%       \procedure[linenumbering]{$\ExpIdentifySign(1^\secpar)$}{%
%         (\parm, \trap) \gets \SimSetup(1^\secpar) \\
% 	(\oid,\siid,\Sig,\msg,\feval) \gets \adv^{\OId,\ICORR}(\parm) \\
% 	\pcif \Verify(\oid,\siid,\Sig,\msg,\feval) = 0: \pcreturn 0 \\
% 	(\usk,\scred,\attrs_{\scred},\yeval^1,\yinsp) \gets
%         \ExtractSign(\trap,\oid,\siid,\Sig,\msg,\feval) \\
% 	\suid \gets \IdentifySig(\trap,\usk,\scred,\Sig) \\
% 	\pcif |\suid| \neq 1: \pcreturn 1 \\
% 	\pcreturn 0
%       }
%     \end{minipage}
%   }
%   \caption{Identifiability experiments for \UAS schemes.}
%   \label{fig:exp-uas-identify}
% \end{figure*}

% \begin{definition}{(Identifiable credentials in \UAS)}
%   \label{def:identify-cred-uas}  
%   We define the advantage \AdvIdCred of $\adv$ against \ExpIdentifyCred as
%   $\AdvIdCred=|\Pr\lbrack\ExpIdentifyCred(1^\secpar)=1\rbrack-
%   \Pr\lbrack\ExpIdentifyCred(1^\secpar)=1\rbrack|$.
%   %
%   An \UAS scheme \emph{with extractable issuance} satisfies identifiable
%   credentials if, for any p.p.t. adversary $\adv$, \AdvIdCred is a negligible
%   function of $1^\secpar$.
% \end{definition}

% \begin{definition}{(Identifiable signatures in \UAS)}
%   \label{def:identify-sig-uas}  
%   We define the advantage \AdvIdSign of $\adv$ against \ExpIdentifySign as
%   $\AdvIdSign=|\Pr\lbrack\ExpIdentifySign(1^\secpar)=1\rbrack-
%   \Pr\lbrack\ExpIdentifySign(1^\secpar)=1\rbrack|$.
%   %
%   An \UAS scheme \emph{with extractable signatures} satisfies identifiable
%   signature if, for any p.p.t. adversary $\adv$, \AdvIdSign is a negligible
%   function of $1^\secpar$.
% \end{definition}

\paragraph{Anonymity.} %
Users may see their privacy compromised through their interactions with issuers
to request a credential, or via the signatures they produce. Thus, we define two
games to define the privacy expected in those situations.

The issuance anonymity game captures that, given polymomially many
credential issuance interactions, the adversary gains no information about the
user(s) behind them. For this, we allow the adversary to control targetted
issuers and openers (although it may also add honest ones), and add honest and
corrupt users. The adversary can also obtain credentials, produce signatures,
and open them. We need to make some limitations to prevent trivial wins: first,
when querying the oracle for obtaining a challenge credential out of two
possible user-credential set pairs, the issuance protocol must either succeed or
fail for both; also, the adversary can open signatures produced with credential
sets containing challenge credentials $\cred_b$, only if the output of \Open is
the same as with the complementary $\cred_{1-b}$ (note that any other signature
can be open).
Intuitively, if the adversary cannot distinguish arbitrary runs with all oracles
(provided the previous constraint) when he gets challenge credentials $\cred_b$
from runs with credentials $\cred_{1-b}$, then the issuance protocol is
privacy-preserving.

The signature anonymity game is similar to the traditional one in GS schemes.
It captures that the signatures produced by system users do not leak information
about their identity beyond what is already revealed via $\yeval^0$ and what
may be revealed via \yinsp. Concretely, the adversary can interact with oracles
as in the issuance anonymity game, except that instead of obtaining challenge
credentials, it obtains challenge signatures. These signatures must have been
produced via the \CHALb oracle, which ensures that the $\yeval^0$ value is the
same for both input sets -- otherwise, rejects creating the signature. We also
allow opening signatures; even challenge $\cSig_b$ signatures, as long as the
\yinsp value of the counterpart $\cSig_{1-b}$ is the same. Note that this is
stronger than the traditional CCA-like security of group signatures, where no
challenge signature can be open.

The formal specification of the anonymity games is given in
\figref{fig:exp-uas-anonb}, where
$\OIssAnon \gets (\lbrace\HU,\CU\rbrace\GEN,\lbrace\II,\OO\rbrace\GEN,\lbrace\II,
\OO\rbrace\CORR,\OBTAIN,\WREG,\SIGN,\OPEN,\OBTCHALb)$, and $\OSigAnon
\gets (\lbrace\HU,\CU\rbrace\GEN,\lbrace\II,\OO\rbrace\GEN,\lbrace\II,\OO\rbrace
\CORR,\OBTAIN,\WREG,\SIGN,\OPEN,\CHALb)$.

\begin{figure*}[htp!]
  \centering
  \scalebox{0.9}{
    \begin{minipage}[t]{0.5\textwidth}
      \procedure[linenumbering]{$\ExpIssAnonb(1^\secpar)$}{%
        (\parm,\trap) \gets \SimSetup(1^\secpar) \\
        b^* \gets \adv^{\OIssAnon} (\parm) \\
        \pcreturn b^*
      }
    \end{minipage}
    
    \begin{minipage}[t]{0.5\textwidth}
      \procedure[linenumbering]{$\ExpSigAnonb(1^\secpar)$}{%
        (\parm,\trap) \gets \SimSetup(1^\secpar) \\
        b^* \gets \adv^{\OSigAnon} (\parm) \\
        \pcreturn b^*
      }
    \end{minipage}
  }
  \caption{Issuance and signature anonymity experiments for \UAS schemes.}
  \label{fig:exp-uas-anonb}
\end{figure*}

\begin{definition}{(Issuance anonymity in \UAS)}
  \label{def:issue-anonymity-uas}  
  We define the advantage \AdvIssAnon of $\adv$ against \ExpIssAnonb as
  $\AdvIssAnon=|\Pr\lbrack\ExpIssAnono(1^\secpar)=1\rbrack-
  \Pr\lbrack\ExpIssAnonz(1^\secpar)=1\rbrack|$.
  %
  An \UAS scheme satisfies issuance anonymity if, for any p.p.t. adversary
  $\adv$, \AdvIssAnon is a negligible function of $1^\secpar$.
\end{definition}

\begin{definition}{(Signature anonymity in \UAS)}
  \label{def:sign-anonymity-uas}  
  We define the advantage \AdvSigAnon of $\adv$ against \ExpSigAnonb as
  $\AdvSigAnon=|\Pr\lbrack\ExpSigAnono(1^\secpar)=1\rbrack-
  \Pr\lbrack\ExpSigAnonz(1^\secpar)=1\rbrack|$.
  %
  An \UAS scheme satisfies signature anonymity if, for any p.p.t. adversary
  $\adv$, \AdvSigAnon is a negligible function of $1^\secpar$.
\end{definition}

\paragraph{On the generality of anonymity in \UAS schemes.} %
From the point of view of the achieved privacy, depending on how one defines
\fissue, \feval and \finsp, it is easy to see that the resulting scheme would
have different privacy level. For instance, a scheme that has very granular
\feval outputs barely provides privacy. Or a scheme for which most signatures
include the same \finsp value has less accountability, but higher privacy.
%
This is a natural consequence of the fact that, with different choices of those
functions, one can mimic the behaviour of (more restricted) schemes. For
instance, by setting \finsp to output the signer's public key, and \feval to
output nothing, one gets the same anonymity as in vanilla group signatures
(concretely, no challenge signature can be opened). Or, if \feval outputs any
arbitrary subset of the attributes in the used credential(s), and \finsp outputs
any constant value, then we get the same anonymity as in conventional selective
disclosure anonymous credential schemes, where any pair of users with different
subset of revealed attributes are clearly distinguishable. The impact of \fissue
is somehow orthogonal to the previous, but can be seen as a kind of equivalent
to \feval, at issuance time.
%
Importantly, note that the model is agnostic to the concrete instantiation of
these functions, and just cares about whether their outputs are equal or not,
in order to avoid trivial wins by the adversary.

\paragraph{Unforgeability.} \UAS inherits from AC and GS schemes two different
notions of unforgeability: from AC schemes, the notion that no adversary can
prove claims unless it owns credentials with the proper attributes; from GS
schemes, that only credential owners can produce valid signatures. \UAS also
has verifiable openings as some group signature schemes, which sits somewhere
in between, and we must ensure that the values output by \Open are correct and
trace back to a user with consistent credentials. All the previous is captured
by a signature unforgeability property. We define this by allowing the adversary
to call any oracle, except the one for corrupting issuers. The adversary wins if
it produces a valid signature over some message that: (1), opens to a wrong
value, or to a value that cannot be processed by \Judge; (2), is not consistent
with the expected \Yeval value; or (3), cannot be associated to known
credentials owned by a known user.

Again, since \UAS schemes (may) require proving claims at issuance time, we
need to ensure that those claims cannot be forged by an adversary without the
proper attributes. In this case, since we (need to) assume trusted issuers, we
can condition on having the $\langle \Obtain,\Issue \rangle$ transcripts
available for analysis. Thus, the adversary -- with access to the same oracles
as above -- is challenged to output a credential identifier for a credential
that exists in \CRED and (1), the conditions required by \fissue were not
satisfied, or some of the credentials used to support the request does not
belong to the requesting user; or (2) all credentials used to support the
request are bound to the same secret key, but that secret key does not belong
to any known user. The issuance unforgeability notion formalizes this.

For both \ExpForgeIssue and \ExpForgeSign (in \figref{fig:exp-uas-unfor}), the
adversary is given access to the oracle set $\Oforgeissue = \Oforgesign \gets
\lbrace\HU,\CU\rbrace\GEN,\IGEN,\OGEN,\OCORR,\OBTISS,\ISSUE,\RREG,\SIGN,\OPEN$.

\begin{figure}[htp!]
  \centering
  \scalebox{0.9}{
    \begin{minipage}[t]{0.57\textwidth}
      \procedure[linenumbering]{$\ExpForgeIssue(1^\secpar)$}{%
        (\parm,\trap) \gets \SimSetup(1^\secpar) \\
        \cid \gets \adv^{\Oforgeissue}(\parm) \\
        \pcif \trans[\cid] = \bot \lor \CRED[\cid] = \bot: \\
        \pcind \pcreturn 0 \\
        % (\usk,\sCred) \gets \ExtractIssue(\trap,\trans[\cid]) \\
        ((\upk,\usk),\lbrace(\cid_i,\attrs_i,\cdot)\rbrace_{i \in [n]}) \\
        \hspace*{5em}\gets \ExtractIssue(\trap,\trans[\cid]) \\
        % \pcfor i \in [n]: (\usk_i,\cdot) \gets \ExtractIssue(\trap,
        % \trans[\cid_i]) \\
        % \pcif \exists i \in [n]~\suchthat~\usk \neq \usk_i: \pcreturn 1 \\
        \pcif \fissue((\upk,\usk),\ATTR[\cid],\lbrace (\cid_i,\attrs_i)
        \rbrace_{i\in[n]}) = 0: \\
        \pcind \pcreturn 1 \\
        \pcif \OWNR[\cid] \notin \HU \cup \CU: \pcreturn 1 \\
        \pcreturn 0
      }
    \end{minipage}
    \begin{minipage}[t]{0.5\textwidth}
      \procedure[linenumbering]{$\ExpForgeSign(1^\secpar)$}{%
        (\parm,\trap) \gets \Setup(1^\secpar) \\
        (\oid,\siid,\Sig=(\sig,\yeval),\msg,\feval) \gets \adv^{\Oforgesign}(\parm) \\
        \pcif \exists \uid~\suchthat~(\cdot,\cdot,\Sig,\cdot,\msg,\feval) \in
        \SIG[\uid]: \pcreturn 0 \\
        \pcif \Verify(\PUBOK[\oid],\PUBIK[\siid],\Sig,\msg,\feval) = 0:
        \pcreturn 0 \\
        (\yinsp,\iproof) \gets \Open(\PRVOK[\oid],\siid,\Sig,\msg) \\
        \pcif \Judge(\PUBOK[\oid],\PUBIK[\siid],\yinsp,\iproof,\Sig,\msg,\feval)
        = 0: \pcreturn 1 \\
        % (\usk,\sCred,\tyeval^1,\yinsp') \gets
        % \ExtractSign(\trap,\oid,\siid,\Sig,\msg,\feval) \\
        % \pcif \yinsp \neq \yinsp': \pcreturn 1 \\
        % \pcreturn 0
	((\upk,\usk),\lbrace(\cid_i,\attrs_i,\cdot)\rbrace_{i\in[n]},
        \yeval^1,\yinsp') \gets \ExtractSign(\trap,\oid,\siid,\Sig,\msg,\feval) \\
        (\yeval^0,\yeval^1) \gets \feval((\upk,\usk),\lbrace(\cid_i,\attrs_i)
        \rbrace_{i\in[n]}, \msg) \\
        \pcif \yeval \neq \yeval^0 \lor \yeval^1 \neq \tyeval^1:
        \pcreturn 1 \\
        \pcif \finsp((\yeval^0,\yeval^1),(\upk,\usk),\lbrace(\cid_i,\attrs_i)
        \rbrace_{i\in[n]},\msg)
        \neq \yinsp \lor \yinsp \neq \yinsp':
        \pcreturn 1 \\
        \pcif \OWNR[\scid] \notin \HU \cup \CU: \pcreturn 1 \\
        \pcreturn 0        
      }      
    \end{minipage}
  }
  \caption{Experiments for credential issuance and signature unforgeability in
    \UAS schemes.}
  \label{fig:exp-uas-unfor}
\end{figure}    

% \begin{figure}[htp!]
%     \procedure[linenumbering]{$\ExpForgeSign(1^\secpar)$}{%
%       (\parm,\trap) \gets \Setup(1^\secpar) \\
%       (\oid,\siid,\Sig=(\sig,\yeval),\msg,\feval) \gets \adv^{\Oforgesign}(\parm) \\
%       \pcif \exists \uid~\suchthat~(\cdot,\cdot,\Sig,\cdot,\msg,\feval) \in
%       \SIG[\uid]: \pcreturn 0 \\
%       \pcif \Verify(\PUBOK[\oid],\PUBIK[\siid],\Sig,\msg,\feval) = 0:
%       \pcreturn 0 \\
%       (\yinsp,\iproof) \gets \Open(\PRVOK[\oid],\siid,\Sig,\msg) \\
%       \pcif \Judge(\PUBOK[\oid],\PUBIK[\siid],\yinsp,\iproof,\Sig,\msg,\feval)
%       = 0: \pcreturn 1 \\
%       (\usk,\scred,\attrs_{\scred},\tyeval^1,\yinsp') \gets
%       \ExtractSign(\trap,\oid,\siid,\Sig,\msg,\feval) \\
%       % \Yeval=(\yeval^0,\yeval^1) \gets \feval(\usk,\scred,\msg) \\
%       % \pcif \yeval \neq \yeval^0 \lor \yeval^1 \neq \tyeval^1:
%       % \pcreturn 1 \\
%       % \pcif \finsp((\yeval^0,\yeval^1),\usk,\scred,\msg) \neq \yinsp:
%       % \pcreturn 1 \\
%       \uid \gets \IdentifyCred(\trap,\usk,\attrs_{\cred},\cred,\ipk_{\cred}) \\
%       \uid' \gets \IdentifySig(\trap,\usk,\scred,\Sig) \\
%       \pcif \uid \neq \uid' \lor \uid \notin \HU \cup \CU: \pcreturn 1 \\
%       %\pcif \exists \cred \in \scred~\suchthat~
% %      \IdentifyCred(\tau,\usk,\attrs_{\cred},\cred,\ipk_{\cred}) = 0:
%       % \pcreturn 1 \\
%       % \pcif \nexists \uid~\suchthat~\IdentifySig(\trap,\usk,\scred,\Sig) = 1:
%       % \pcreturn 1 \pccomment{\todo{\uid-\usk}} \\
%       \pcreturn 0
%     }
%   \caption{Experiment for unforgeability of signatures in \UAS schemes.}
%   \label{fig:exp-uas-unfor-sign}
% \end{figure}

\begin{definition}{(Unforgeable issuance of \UAS)}
  \label{def:issue-forge-uas}  
  We define the advantage \AdvForgeIssue of $\adv$ against \ExpForgeIssue as
  $\AdvForgeIssue=\Pr\lbrack\ExpForgeIssue(1^\secpar)=1\rbrack$.
  %
  A \UAS scheme has unforgeable issuance if, for any p.p.t. adversary $\adv$,
  \AdvForgeIssue is a negligible function of $1^\secpar$.
\end{definition}

\begin{definition}{(Unforgeable signing of \UAS)}
  \label{def:sign-forge-uas}  
  We define the advantage \AdvForgeSign of $\adv$ against \ExpForgeSign as
  $\AdvForgeSign=\Pr\lbrack\ExpForgeSign(1^\secpar)=1\rbrack$.
  %
  A \UAS scheme has unforgeable signing if, for any p.p.t. adversary $\adv$,
  \AdvForgeSign is a negligible function of $1^\secpar$.
\end{definition}

For short, we say that an \UAS scheme that has both unforgeable issuance and
signing, is an unforgeable \UAS scheme.

\paragraph{On the generality of unforgeability in \UAS schemes.} %
Regarding the information revealed at signature time ($\yeval^0$), \UAS's
unforgeability notion is equivalent to that of known AC schemes. It is the
generalization of the information output at opening time ($\yinsp$), only
present up to know in MPS \needcite what makes the notion of unforgeability more
subtle. The fact that multiple users may produce signatures opening to the same
value necessarily forces to generalize what is a forgery -- and, certainly,
resorting to extraction-based techniques seems unavoidable.

As for anonymity, note that by tweaking the \fissue, \feval and \finsp
functions, one can easily mimic behaviour of more restricted schemes. For
instance, \feval, along with the $\yeval^0$ output, allows revealing
authenticated attribute-related information alongside the signatures, as in AC
schemes. Or, with \fissue, rules for delegation can be easily encoded, leading
to delegatable schemes.

\paragraph{Non-frameability.} %
The notion of non-frameability in \UAS schemes is unavoidably more subtle than
in group signatures. To see this, we note that, by allowing arbitrary
evaluation and open functions to be used, it can be perfectly valid to
have a signature produced by a corrupted user output the same \yeval or \yinsp
values than the ones output when evaluating or opening a signature by an honest
user.
%
More generally, since the issuer is dishonest in non-frameability properties
and, in \UAS, the value produced by \Open may depend on the attributes
included in user credentials, the adversary may even be able to just produce
``legitimate'' openings that output any desired value. Note that this is a
relevant property, as it tells us the minimal unforgeability expectations we
can have, even against malicious issuers and openers.

In the non-frameability definition for \UAS, given in experiment \ExpNonframe in
\figref{fig:exp-uas-frame}, the adversary is challenged to produce a signature
and opening proof that is accepted by \Verify and \Judge, respectively. From
the signature, we then extract the secret data used to generate it. The
adversary wins if the signature and opening proof are accepted, but the \yeval
or \yinsp values do not match what they should be based on the extracted data;
or if the signature can be associated to the secret key of an honest user who
did not produce it (i.e., no matching call to \SIGN exists). In the game, the
adversary has access to the oracles in $\Oframe \gets
\lbrace\HU,\CU\rbrace\GEN, \lbrace\II,\OO\rbrace\GEN,\lbrace\II,\OO\rbrace\CORR,
\WREG,\OBTAIN,\SIGN$.

\begin{figure}[htp!]  
  \centering
  \scalebox{0.9}{
    \procedure[linenumbering]{$\ExpNonframe(1^\secpar)$}{%
      (\parm,\trap) \gets \SimSetup(1^\secpar) \\
      (\oid,\siid,\Sig=(\sig,\yeval),\msg,\feval,\yinsp,\iproof) \gets
      \adv^{\Oframe}(\parm) \\
      \pcif \Verify(\PUBOK[\oid],\PUBIK[\siid],\Sig,\msg,\feval) = 0:
      \pcreturn 0 \\
      \pcif \Judge(\PUBOK[\oid],\PUBIK[\siid],\yinsp,\iproof,\Sig,\msg) = 0:
      \pcreturn 0 \\
      ((\upk,\usk),\lbrace(\cid_i,\attrs_i,\cdot)\rbrace_{i\in[n]},\tyeval^1,\yinsp') \gets
      \ExtractSign(\trap,\oid,\siid,\Sig,\msg,\feval) \\
      % \Yeval=(\yeval^0,\yeval^1) \gets \feval(\usk,\scred,\msg) \\
      % \pcif \yeval \neq \yeval^0 \lor \tyeval^1 \neq \yeval^1: \pcreturn 1 \\
      % \pcif \finsp(\Yeval,\usk,\scred,\msg) \neq \yinsp
      % \lor \yinsp \neq \yinsp': \pcreturn 1 \\
      \Yeval=(\yeval^0,\yeval^1) \gets \feval((\upk,\usk),\lbrace (\cid_i,
      \attrs_i)\rbrace_i{i\in[n]}, \msg) \\
      \pcif \yeval \neq \yeval^0 \lor \yeval^1 \neq \tyeval^1:
      \pcreturn 1 \\
      \pcif \finsp((\yeval^0,\yeval^1),(\upk,\usk),\lbrace(\cid_i,\attrs_i)
      \rbrace_{i\in[n]},\msg)
      \neq \yinsp \lor \yinsp \neq \yinsp': \\
      \pcind \pcreturn 1 \\
      \pcif \OWNR[\scid] \in \HU \land
      (\cdot,\cdot,\Sig,\Yeval,\msg,\feval) \notin \SIG[\OWNR[\scid]]: \\
      \pcind \pcreturn 1 \\
      \pcreturn 0
    }
  }
  \caption{Experiment for non-frameability on \UAS schemes.}
  \label{fig:exp-uas-frame}
\end{figure}

\begin{definition}{(Non-frameability of \UAS)}
  \label{def:frame-uas}
  We define the advantage \AdvNonframe of $\adv$ against \ExpNonframe as
  $\AdvNonframe=\Pr\lbrack\ExpNonframe(1^\secpar)=1\rbrack$.
  %
  An \UAS scheme satisfies non-frameability if, for any p.p.t. adversary $\adv$,
  \AdvNonframe is a negligible function of $1^\secpar$.
\end{definition}

\paragraph{On the generality of non-frameability in \UAS schemes.} %
The notion captured in \UAS is a sort of extension of the non-frameability
notion in group signatures, in two aspects. First, by defining a very granular
\finsp function (one that outputs the signers public key, or equivalent),
we get a scheme in which it is not possible to frame a user at all. Yet, by
defining a coarser \finsp function (e.g., one that outputs the nationality of
the signer), while framing a single user is still not possible (the checks in
lines 9 an 10 avoid it), in practice, there will be a set of ``potential
candidates to frame'' (e.g., all users of the given nationality). This can be
seen as a useful feature in many use cases, though.
%
The second aspect follows a similar reasoning, but through \feval. However, this
type of functionality revealing information at signing time is not available in
group signatures. Also, even though it is available in anonymous credentials, no
equivalent property has been considered, to the best of our knowledge. Thus,
through \UAS schemes, we extend the unforgeability expectations against corrupt
issuers, to the AC domain.

% Anonymous credentials do not have non-frameability property and, thus, it is
% hard to make a comparison. However, we can draw some connections with AC schemes
% that support revocation, as revocation is somehow equivalent to linking, which
% is a type of inspection available in group signatures. In this sense, note that
% basic revocation (without straight deanonymization) can be trivially achieved
% through our generic \Open function. For instance, one could set \finsp to
% be a pseudorandom number seeded with the user's public key (or credential). In
% this sense, \Open could be essentially seen as a Verifiable Random Function.
% If we compare with group signatures, our notion is also more general than the
% conventional one, again for the same reason as sign unforgeability (i.e., \Open
% can return any value, not just the signer's identity). Thus, the need to extract
% the signer's data in order to detect if a framing has taken place.

\subsection{\CUASGen: A Generic \UAS Construction}
\label{ssec:generic-construction-uas}

In this section, we give a generic construction of an \UAS scheme, based on
generic building blocks. We use three different NP relations in our generic
construction. Namely: $\NIZKRel_{\Issue}$, $\NIZKRel_{\Sign}$, and
$\NIZKRel_{\Open}$, described next and specified in CS notation \needcite
in \figref{fig:nizkrels}.

\begin{description}
\item[$\NIZKRel_{\Issue}$:] For NIZK proofs at issuance time. Requires that the
  owner commits to, and proves knowledge of, \usk. It also requires that any
  additional credential supporting the request be a valid credential (signed by
  some issuer) and bound to \usk. Finally, it also enforces the
  corresponding \fissue policy.
\item[$\NIZKRel_{\Sign}$:] For NIZK proofs at signing time. Ensures that
  signatures ``encode'' the correct signature evaluation and opening values, and
  that any credential used to create the signature is bound to the same \usk.
\item[$\NIZKRel_{\Open}$:] For NIZK proofs at opening time. Ensures that the
  utility information extracted by the \Open algorithm is correct.
\end{description}

\begin{figure}[ht!]
  \centering
  \scalebox{0.9}{
    \input{figures/nizk.tex}
  }
  \caption{CS specification of the NP relations used in \CUASGen.
  \todo{Is $\C = \CCommit(\usk;r)$ needed now that \upk is added?}}
  \label{fig:nizkrels}
\end{figure}

From them, we build \CUASGen as follows.

\paragraph{$\parm \gets \Setup(\secpar,\AttrSpace)$.} %
The setup process essentially generates the public parameters for all the
building blocks. It runs $\Cparm \gets \CSetup(\secpar)$, $\SBCMparm \gets
\SBCMSetup(\secpar)$, $\Sparm \gets \SSetup(\secpar)$, $\Eparm \gets
\ESetup(\secpar)$, $\NIZKcrs_{\Issue} \gets \NIZKSetup^{\NIZKRel_{\Issue}}
(\secpar)$, $\NIZKcrs_{\Sign} \gets \NIZKSetup^{\NIZKRel_{\Sign}}(\secpar)$, and
$\NIZKcrs_{\Open} \gets \NIZKSetup^{\NIZKRel_{\Open}}(\secpar)$. Return $
(\Cparm,\SBCMparm,\Sparm,\Eparm,\NIZKcrs_{\Issue},\NIZKcrs_{\Sign},
\NIZKcrs_{\Open},\AttrSpace)$. % Many of these parameter setup algorithms can
% actually be run by separate entities. For simplicity of exposition, we bundle
% them together here.

\paragraph{$(\ipk,\isk) \gets \IKeyGen(\parm,\fissue)$.} %
Each issuer first parses \parm as $(\cdot,\SBCMparm,
\Sparm,\cdot,\cdot,\cdot,\cdot,\cdot)$. Then, runs $(\Svk,\Ssk) \gets
\SKeyGen(\Sparm)$, $(\SBCMvk,\SBCMsk) \gets \SBCMKeyGen(\SBCMparm)$,
$\sig_{\fissue} \gets \SSign(\Ssk,\fissue)$, $\ipk \gets (\SBCMparm,\Svk,
\fissue,\sig_{\fissue})$, $\isk \gets \Ssk$ and return $(\ipk,\isk)$.

\paragraph{$(\opk,\osk) \gets \OKeyGen(\parm,\finsp)$.} %
Each opener first parses \parm as $(\cdot,\cdot,
\cdot,\Eparm,\cdot,\cdot,\cdot,\cdot)$. Then, runs $(\Svk,\Ssk) \gets \SKeyGen
(\Sparm)$, $(\Eek,\Edk) \gets \EKeyGen(\Eparm)$, $\sig_{\finsp} \gets \SSign
(\Ssk,\finsp)$, $\opk \gets (\Sparm,\Svk,\Eek,\finsp,\sig_{\finsp})$, and $\osk
\gets (\Ssk,\Edk)$.

\paragraph{$\usk \gets \UKeyGen(\parm)$.} %
Each user, prior to requesting credentials, generates his secret key by picking
randomly $\usk \getr \AttrSpace$. Set $\upk \gets \CCommit(\usk;0)$.

\paragraph{$\langle \cred/\bot,\utrans/\bot \rangle \gets
  \langle\Obtain(\usk,\ipk,\lbrace (\cid_i,\cattrs_i,\cred_i) \rbrace_{i\in[n]},
  \attrs),\Issue(\isk,\lbrace \ipk_i \rbrace_{i\in[n]},\attrs)\rangle$.} %
The protocol is run between an issuer with key pair $(\ipk,\isk)$, and a user
with secret key \usk and credentials $\lbrace \cred_i \rbrace_{i\in[n]}$, where
each $\cred_i$ is issued by an issuer with public key $\ipk_i$, and
attests attributes $\cattrs_i$. The user requests a signature on a commitment to
the user key, as well as on the attributes in \attrs. In addition, the user
proves that the issuance function \fissue established by the issuer is satisfied
by the $\cred_i$ credentials and its user secret key. This is achieved through
an execution of an \SBCM interactive signing protocol with $\NIZKRel_{\Issue}$
as NP relation -- which contains the verification that \fissue returns $1$,
among other checks as described earlier. Concretely, the user runs
$\SBCMCom^{\NIZKRel_{\Issue}}(\ipk,\usk,(\cid,\attrs),\lbrace (\cid_i,\cattrs_i,
\cred_i)\rbrace_{i\in[n]},\lbrace \ipk_i \rbrace_{i\in[n]})$, and the issuer
runs $\SBCMSign^{\NIZKRel_{\Issue}}(\isk,(\cid,\attrs),\lbrace\ipk_i
\rbrace_{i\in[n]})$, for some commonly agreed and fresh \cid. The credential
\cred produced by the user is the result of the interactive signing protocol,
and the \utrans entry for the issuer is its transcript, which is a $(\Ccom,
\lbrace \cid,\attrs\rbrace,\lbrace \ipk_i \rbrace_{i\in[n]},\cred,\pi)$ tuple.

\paragraph{$\Sig \gets \Sign(\usk,\opk,
  \sCred=(\lbrace (\cid_i,\cattrs_i,\cred_i,\ipk_i)\rbrace_{i\in[n]}),
  \msg,\feval)$.} %
In the signing algorithm, we make use of relation $\NIZKRel_{\Sign}$.
% 
The user first evaluates $\Yeval = (\yeval^0,\yeval^1) \gets \feval (\usk,
\lbrace(\cid_i,\cattrs_i)\rbrace_{i\in[n]},\msg)$.
Then, parses \opk as $(\Svk,\Eek,\finsp,\sig_{\finsp})$ and checks that
$\Verify(\Svk,\sig_{\finsp},\finsp) = 1$
(this step may be cached), to compute $\yinsp \gets \finsp((\yeval^0,
\yeval^1),\usk,\lbrace(\cid_i,\cattrs_i)\rbrace_{i\in[n]},\msg)$, and encrypts
\yinsp by running $\cinsp \gets \EEnc(\Eek,\yinsp; r)$ for some fresh randomness
$r$. Finally, the user
computes $\NIZKproof \gets \NIZKProve^{\NIZKRel_{\Sign}}(\NIZKcrs_{\Sign},(\usk,
\lbrace(\cid_i,\cattrs_i,\cred_i)\rbrace_{i\in[n]},\yeval^1,\yinsp,r),(\msg,
\feval,\yeval^0,\cinsp,\lbrace \ipk_i\rbrace_{i\in[n]},\Eek))$ and outputs
$(\sig = (\NIZKproof,\cinsp),\yeval^0)$. Note that, depending on the value of
\Yeval and \yinsp, the user may decide to abort
the signing if the resulting values are too privacy-threatening.

\paragraph{$1/0 \gets \Verify(\opk,\sipk=\lbrace\ipk_i\rbrace_{i\in[n]},
  \Sig,\msg,\feval)$.} %
The ``cryptographic'' side of the verification consists on checking
the NIZK proof. That is, parse \Sig as $(\sig = (\NIZKproof,\cinsp),\yeval)$ and
check whether $\NIZKVerify(\NIZKcrs,\NIZKproof,(\msg,\feval,\yeval,
\cinsp,\sipk,\opk)) = 1$. In addition, the verifier may further check
whether \yeval meets its needs.

\paragraph{$(\yinsp,\NIZKproof)/\bot \gets
  \Open(\osk,\sipk,\Sig,\msg,\feval)$.} %
Here we leverage relation $\NIZKRel_{\Open}$.
%
To open a signature, the opener first verifies the signature by running $\Verify
(\opk,\sipk, \Sig,\msg,\feval)$. If verification succeeds, it parses
\Sig as $(\sig=(\NIZKproof,\cinsp),\yeval)$, decrypts \Ec by running $\yinsp
\gets \EDec(\osk,\cinsp)$, and computes $\NIZKproof_{\Open} \gets
\NIZKProve^{\NIZKRel_{\Open}}(\NIZKcrs_{\Open},\osk,(\cinsp,\yinsp))$. It
returns $(\yinsp,\NIZKproof_{\Open})$.

\paragraph{$1/0 \gets \Judge(\opk,\yinsp,\NIZKproof,\Sig,\msg)$.} %
To assess the validity of an opening proof, first check the signature
by running $\Verify(\opk,\sipk,\Sig,\msg,\feval)$. If the check succeeds,
parse \Sig as $((\cdot,\cinsp),\cdot)$ and verify \NIZKproof with
$\NIZKVerify(\NIZKcrs_{\Open},\NIZKproof,(\cinsp,\yinsp))$. Accept it the NIZK
verification passes, and reject otherwise.

\paragraph{Interactive Credential Presentation.} In \appref{app:interactive-uas}
we show how to convert the non-interactive signing and verification processes
into an interactive protocol. While the transformation is quite straightforward,
it is of high relevance for real world use cases.

\subsection{Correctness and Security of \CUASGen}
\label{ssec:security-uas}

We state the correctness and security theorems next. For lack of space, we defer
the proofs to \appref{app:uas-proofs}.

\begin{theorem}[Correctness of \CUASGen]
  \label{thm:correctness-uas}
  If the underlying schemes for commitments, public-key encryption and \SBCM,
  are correct, as well as the NIZKs for $\NIZKRel_{\Issue}$, $\NIZKRel_{\Sign}$,
  and $\NIZKRel_{\Open}$, our generic construction \CUASGen satisfies
  correctness as defined in \defref{def:correctness-uas}.
\end{theorem}

\begin{theorem}[Issuance anonymity of \CUASGen]
  \label{thm:issue-anonymity-uas}
  If the NIZK systems used for $\NIZKRel_{\Issue}$ and $\NIZKRel_{\Sign}$ are
  zero-knowledge, our \CUASGen construction satisfies issuance anonymity as
  defined in \defref{def:issue-anonymity-uas}.
\end{theorem}

\begin{theorem}[Signature anonymity of \CUASGen]
  \label{thm:sign-anonymity-uas}
  If the NIZK system used for $\NIZKRel_{\Sign}$ is zero-knowledge, and the
  public-key encryption scheme is IND-CCA secure, our \CUASGen construction
  satisfies signature anonymity as defined in \defref{def:sign-anonymity-uas}.
\end{theorem}

\begin{theorem}[Issuance unforgeability of \CUASGen]
  \label{thm:issue-forge-uas}
  If the underlying NIZK used for $\NIZKRel_{\Issue}$ is zero-knowledge,
  simulation extractable and sound, then our \CUASGen construction satisfies
  issuance unforgeability as defined in \defref{def:issue-forge-uas}.
\end{theorem}

\begin{theorem}[Signing unforgeability of \CUASGen]
  \label{thm:sign-forge-uas}
  If the underlying NIZK scheme for $\NIZKRel_{\Sign}$ is simulation
  extractable,the NIZK scheme for $\NIZKRel_{\Open}$ is complete, the public-key
  encryption scheme is correct, and \SBCM is correct and one-more unforgeable,
  then our \CUASGen construction satisfies signing unforgeability as defined in
  \defref{def:sign-forge-uas}, except with negligible probability.
\end{theorem}

\begin{theorem}[Non-frameability of \CUASGen]
  \label{thm:frame-uas}
  If the underlying scheme for $\NIZK^{\Sign}$ is zero-knowledge and simulation
  extractable, the scheme for $\NIZK^{\Open}$ is simulation-extractable, and
  \SBCM scheme is blind, then our \CUASGen construction satisfies
  non-frameability as defined in \defref{def:frame-uas}, except with negligible
  probability.
\end{theorem}

\subsection{\CUASGen variants}
\label{ssec:variants}

In previous subsections, we have described a main construction for \CUASGen,
where generalization is achieved by allowing system designers to specify
concrete \fissue, \feval and \finsp functions depending on their needs. Note
however that alternative constructions are possible, that are close to \CUASGen,
but differ in key aspects while still meeting the \UAS model. We briefly
describe them next, as we leverage them to build related schemes. Security
proofs are deferred to \appref{app:uas-variants-proofs}

\paragraph{$\CUASGen^{prv-iss}$: Tweaking $\NIZKRel_{\Sign}$ for issuer
  privacy.} %
In \CUASGen, it is required that the identity of the issuer of each credential
used to produce a signature is revealed. This seems reasonable for usual
situations since, intuitively, it would seem hard for a verifier to accept a
signature produced with a credential without knowing if the issuer is
trustworthy. However, there may also be cases in which relaxations are
acceptable. For instance, it may be enough to know that the issuer belongs to
some set of well-known issuers. From a more theoretical point of view, this is
also interesting, as it allows to mimic ring signatures from \UAS constructions.
\todo{XXX}

\paragraph{$\CUASGen^{usr-iss}$: Collapsing issuers and users.} %
On occasions, it may be useful to not make a distinction between issuers and
users. For instance, for credential delegation, or in decentralized identity
systems. In both cases, users may end up acting as issuers themselves.
\todo{XXX}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "uas-paper"
%%% End:
