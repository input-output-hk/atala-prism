\section{Formalizing \UAS}
\label{sec:formal-uas}

% [11 pages max]

Next we formalize our notion of Universal Anonymous Signatures
(\UAS). We define its syntax, model, and give a generic construction, which
we prove secure. 

The main contribution of this section is giving a simple syntax and model that
still allow spanning a wide variety of related schemes. We combine aspects of GS
and AC schemes, generalizing whenever possible. Like in ACs, there are multiple
issuers, and each user can get one or more credentials from any of them; and,
also, use more than one credential simultaneously to produce a signature. We
incorporate openers, as in GSs, but there is no tight relationship between
issuer and opener. As a consequence, users (potentially along with verifiers)
may choose, on a per-signature basis, the policies governing the utility
information extractable from a signature. Finally, we incorporate functions that
allow tweaking the conditions checked at credential issuance and signature
generation times, including the information that an opener will be able to
extract from a signature.

\paragraph{Users and credentials.} %
In our model, every single user may have multiple credentials. In this
setting, a perhaps too strict assumption we make is that, once a user gets
compromised, all of the credentials owned by that user are compromised too.
While there may be real world situations for which this is too aggressive, it is
certainly a worst-case scenario, and greatly simplifies the modelling.
%
% Somehow related, we model a scheme in which users generate their secret keys in
% a standalone way, and then leverage these keys to request credentials. This may
% seem too ideal as a model for real world situations, as we cannot know how
% many keys a user has generated. However, we argue that this can in fact be very
% close to reality, where a well-known issuer, after properly identifying a user,
% attests the (possibly blinded) public key this user proves control of. Indeed,
% our model and syntax support exactly this approach, by allowing users to
% leverage previously obtained credentials in order to request new ones.
% A consequence of this is that, if ``one user'' generates (e.g.) two keys, and
% then uses each of these keys to request multiple credentials, then from the
% point of view of our modelling, we see this \emph{cryptographically} as two
% different users -- and, anyway, that same ``user'' cannot combine credentials
% bound to different keys.

\paragraph{Users and issuers.} %
A relevant aspect of our model is that users and issuers are basically the
same: an entity with a key pair. The difference is that, when users wish to
become issuers, they advertise their public keys, along with their conditions
for granting credentials. To simplify, we just assume that they somehow
``publish their public keys'', which can be done in several ways in practice.

\paragraph{Functional placeholders.} %
We use generic functions to capture, at the design level, that users need
to prove concrete claims over their private information. Looking a bit ahead,
the output of these functions is defined in terms of (subsets of) the users'
key, credentials and attributes, and signed message. But, during our modelling,
we are only concerned with preventing that the output of these functions can
be altered, and with ensuring that it does not threaten privacy beyond what is
necessary or unavoidable to reach the flexibility we want.

\subsection{Syntax}
\label{ssec:syntax-uas}

An \UAS scheme is composed by the following algorithms:

\begin{description}
\item[$\Setup(\secpar) \rightarrow \parm$.] Given a security parameter \secpar,
  returns a global system parameter variable \parm. We assume that \parm are
  available to all other functions.
\item[$\KeyGen(\parm) \rightarrow (\upk,\usk)$.] Given \parm, a user runs
  \KeyGen to generate its user key pair. 
\item[$\OKeyGen(\parm,\finsp) \rightarrow (\opk,\osk)$.] Given \parm, and the
  function \finsp, an opener runs \OKeyGen to generate its opening key pair.
  The function \finsp defines the type of utility that will be extractable from
  signatures.
\item[$\ISet(\upk,\usk,\fissue) \rightarrow \ipk$.] Given a user key
  pair, and an issuance function \fissue for checking that credential requestors
  meet some conditions to be issued a credential, an existing user runs \ISet to
  extend the user public key, enabling this user to issue credentials meeting
  \fissue.
%\item[$\UKeyGen(\parm) \rightarrow (\upk,\usk)$.] Given \parm, returns a user's
%  key pair.
\item[$\langle
  \Obtain(\usk,\cidu,\ipk,\sCred,\attrs),
  \Issue(\isk,\cidi,\sipk,\attrs))  
  \rangle \rightarrow \langle \Cred/\bot,R/\bot
  \rangle$.] %
  This interactive protocol lets a user with key \usk receive a credential
  $\Cred=(\cid,\attrs,\cred,\ipk)$
  from an issuer in the system. $\cid=(\cidi,\cidu)$ is a unique identifier for
  the credential, where issuer and user randomly pick \cidi and \cidu,
  respectively (to ease notation, whenever we write just \cid, we mean $(\cidi,
  \cidu)$). \ipk is the issuer's public key and \cred is the actual credential,
  on attribute set \attrs. The user may leverage a set of previously obtained
  credentials $\sCred=\lbrace (\cid_i=(\cidi_i,\cidu_i),\cattrs_i,\cred_i,
  \ipk_i)\rbrace_{i\in[n]}$, from which we may omit the $\ipk_i$s for
  readability. The user outputs the produced credential \Cred, while the issuer
  outputs $R \gets (\yissue,\utrans)$, for some value $\yissue$ output by
  the \fissue function defined by the issuer, and $\utrans$ being the transcript
  of the communication.
\item[$\Sign(\usk,\opk,\sCred,\msg,\feval) \rightarrow (\sig,\yeval)$.] %
  Upon receiving user secret key \usk, opener public key \opk, 
  credentials \sCred, message \msg and evaluation function \feval, returns
  signature \sig, and a value \yeval. We use use \Sig to denote the
  tuple $(\sig,\yeval)$.
\item[$\Verify(\opk,\sipk,\Sig,\msg,\feval) \rightarrow 1/0$.]
  Checks whether $\Sig = (\sig,\yeval)$ is a valid signature
  over message \msg, from a user with credentials issued by issuers with public
  keys in \sipk, for evaluation function \feval and opener key \opk.
\item[$\Open(\osk,\sipk,\Sig,\msg,\feval) \rightarrow
  (\yinsp,\iproof)/\bot$.]
  Run by the opener with private key \osk. Receives a signature $\Sig=
  (\sig,\yeval)$ over message \msg and evaluation function \feval,
  generated using credentials by issuers with public keys in \sipk.
  If \Sig is valid, the function outputs a value $\yinsp$, and a proof of
  correct opening \iproof.
\item[$\Judge(\opk,\sipk,\yinsp,\iproof,\Sig,\msg,\feval) \rightarrow 1/0$.] %
  Checks if \iproof is a valid opening correctness proof for the value \yinsp,
  obtained by applying \Open to the the signature $\Sig = (\sig,\yeval)$
  over message \msg, and for evaluation function \feval. 
\end{description}

\paragraph{Issuance, evaluation, and opening functions.} %
We introduce three functions in our syntax and model. Through them, it is
possible to modulate the behaviour of the resulting instantiation, by
controling the conditions upon which a new credential can be issued, the
information revealed at signing time, or after signing. In all cases, it is
the user who computes them, and has to prove correctness of such computation.
We give concrete examples in \secref{sec:relationships}.

\begin{description}
\item[$\fissue: (\upk,\cid,\attrs,\lbrace (\cid_i,\cattrs_i)\rbrace_{i \in [n]})
  \rightarrow \yissue$.] Chosen
  by each issuer within a family of functions \famfissue, the issuance function
  defines the conditions required by the issuer to grant a credential
  with identifier $\cid = (\cidi,\cidu)$, over attributes \attrs, when requested
  by a user with public key \upk, leveraging a set of $n$ previously obtained
  credentials with identifiers and attributes given by $\lbrace (\cid_i,
  \cattrs_i) \rbrace_{i \in [n]}$ (where $n$ may be $0$). \fissue returns
  a value $\yissue \in \rngfissue \cup \lbrace 0 \rbrace$, where we adopt the
  convention that $\yissue = 0$ means that the issuance request is denied; and
  $\yissue \neq 0$ means that the request is approved. \fissue functions must be
  \UAS-acceptable, as defined in \defref{def:uas-acc-func}.
\item[$\feval: (\upk,\lbrace(\cid_i,\cattrs_i)\rbrace_{i \in [n]},\msg)
  \rightarrow (\yeval^0,\yeval^1)$.] Signing evaluation functions, from a
  family of functions \famfeval, can be set on a per-signature basis. They
  receive the user public key \upk, a set of credentials with identifiers
  and attributes $\lbrace (\cid_i,\cattrs_i) \rbrace_{i \in [n]}$
  (where $n \ge 1$), and the message to be signed \msg. \feval outputs two
  values, $\yeval^0$ and $\yeval^1$. Both must belong in a well defined set
  \rngfeval. For readability, we write $\Yeval = (\yeval^0,\yeval^1)$.
\item[$\finsp: (\Yeval,\upk,\lbrace (\cid_i,\cattrs_i) \rbrace_{i \in [n]},
  \msg) \rightarrow \yinsp$.]
  Chosen by openers from a family of functions \famfinsp. The opening
  functions define what utility value (derived from the user's secret key,
  credentials' identifiers and attributes used for signing, and signed message)
  should be extractable by an opener. Its behaviour can be modulated by \Yeval,
  and it outputs a value \yinsp, which must belong in a well defined set
  \rngfinsp.
\end{description}

\feval and \finsp may seem redundant. However, the former is chosen on a
per-signature basis, probably after negotiation between signer and verifier, and
governs the information revealed at signing time. On the other hand, \finsp
governs the information that may be revealed after signing, and is defined by
openers when they set up their key pair. Thus even though signers and verifiers
may negotiate to use any opener for a given signature, it is not possible for
an opener to change the chosen function.

Concerning \fissue functions, our \UAS model requires them to be
\UAS-acceptable. At a high level, this requires that \fissue functions do not
reveal anything about the signer's data used as input. This is formally captured
in \figref{fig:uas-acceptable}.
%
A \UAS construction thus can only be secure if the \fissue functions it uses
are \UAS-acceptable.

\begin{figure}[ht!]
  \centering  
  \scalebox{0.85}{
    \procedure{$\Exp^{\UAS-acc-b}_\adv(1^\secpar)$}{%
      \parm \gets \Setup(1^\secpar) \\
      (\upk,\usk) \gets \KeyGen(\parm) \\
      (\st,\attrs, \lbrace (\cidi,\cidu,\cattrs_i) \rbrace_{i\in[n]})
      \gets \adv(\upk) \\
      \pcif b=0:
      \yissue^* \gets \fissue(\upk,\cid,\attrs,\lbrace (\cid_i,\cattrs_i)
      \rbrace_{i\in[n]}) \\
      \pcelse: \yissue^* \getr \rngfissue \setminus \lbrace 0 \rbrace \\
      b^* \gets \adv(\st,\yissue^*) \\
      \pcreturn b^*
    }
  }
  \label{fig:uas-acceptable}
  \caption{Formal definition of \UAS-acceptable \fissue functions.}
\end{figure}

\begin{definition}{(\UAS-acceptable \fissue functions)}
  \label{def:uas-acc-func}
  A \fissue function is \UAS-acceptable if, for any p.p.t. adversary \adv,
  $|\Pr[\Exp^{\UAS-acc-1}_\adv(1^\secpar)=1]-\Pr[\Exp^{\UAS-acc-0}_\adv
  (1^\secpar)=0]|$ is a negligible function of $1^\secpar$.
\end{definition}

Next, we define the concept of \CUASGen restrictions. These are special
cases of our generic construction that target a concrete variant of the
utility-privacy tradeoff by defining concrete \fissue, \feval and \finsp
functions. Security of \CUASGen implies security of its restrictions, if
the chosen \fissue functions are \CUASGen-acceptable.

\begin{definition}{(\CUASGen restrictions)}
  \label{def:uas-restrictions}
  Let \CUASGen be a construction of an \UAS scheme, secure according to
  the model defined in \secref{ssec:model-uas}, and three functions $\fissue^a$,
  $\feval^b$, $\finsp^c$ compatible with the previous definitions. We say that
  \CUASGen, instantiated with $\fissue^a$, $\feval^b$, and $\finsp^c$, is a
  $(\fissue^a,\feval^b,\finsp^c)$-restriction of \CUASGen.
\end{definition}

\subsection{Security Model}
\label{ssec:model-uas}

We define the security expected from an \UAS scheme using a game-based approach.
An \UAS scheme must ensure privacy at credential issuance, meaning that two
runs of the credential issuance protocol should not leak any information beyond
necessary about the user requesting the credential. Note that this is now
crucial for privacy since \UAS allows multiple credentials per
user -- thus, knowing what user is requesting which credential can lead to user
profiling. It must also ensure signature privacy, meaning that no information
can be learned by third parties from a signature, beyond what the user chooses
to reveal, and what may be extractable by the chosen opener. Unforgeability
requires that \UAS schemes ensure that the claims used to support a credential
request cannot be falsified, and that no adversary is able to falsify
the correctness proofs for the claims included in the signatures. In addition,
we require all credentials involved in the corresponding process to be
associated to a known user key. Finally, \UAS schemes inherit the useful
non-frameability property of GS schemes where even the issuer is corrupt. In
this case, we can ensure that no honest user can be framed with having created a
signature that s/he did not create -- although the concept may get a bit
blurred, as there is no traditional opening.
%
We describe next the global variables and oracles that we use in our modelling.

\paragraph{Global Variables.} %
Users are referred to with user identifiers, \uid; for credentials, we use \cid;
and for openers, \oid. Although issuers are ``extended'' users, and thus can be
identified by their \uid, we also sometimes use \iid to refer to a user acting
as issuer, especially, for operations involving both a user and an issuer (this
also applies for key pairs).
%
For notational convenience, we often use these identifiers instead of the
corresponding user/issuer/opener keys.
%
All tables/sets are initialized as empty tables/sets. We use the following sets
and tables in our definitions:

\begin{description}
\item[$\mathsf{H}\lbrace\mathsf{U},\mathsf{I},\mathsf{O} \rbrace$.] Sets of
  honest {\uid}s/{\iid}s/{\oid}s.
\item[$\mathsf{C}\lbrace\mathsf{U},\mathsf{I},\mathsf{O} \rbrace$.] Sets of
  corrupt {\uid}s/{\iid}s/{\oid}s.
\item[\UK,\IK,\OK.] Tables maintaining key pairs of users $(\upk,\usk)$, issuers
  $(\ipk,\isk)$, and openers $(\opk,\osk)$. They are indexable by \uid,
  \iid, and \oid, respectively. Also, issuers' public keys contain their \fissue
  function, and openers' public keys contain their \finsp function.
\item[\PUBUK,\PUBIK,\PUBOK and \PRVUK,\PRVIK,\PRVOK.] Shorthands referring to
  public keys of users, issuers or openers ($\mathsf{PXK}$) or their private
  keys ($\mathsf{SXK}$).
\item[\CRED.] Stores information related to credentials obtained by users in
  the system. Thus, it is indexable by \cid. More specifically, it stores
  tuples of the form $(\uid,\cred,\iid,\attrs,n,\lbrace (\cid_i,\iid_i)
  \rbrace_{i \in [n]})$, where \uid is the identifier of the owner of the
  credential, \cred (when available) is the credential itself, \iid is the
  identifier of the credential issuer, \attrs are the attributes included in
  \cred, $n$ is the number of credentials used to support this request, and
  $(\cid_i,\iid_i)$ for $i \in [n]$ are the corresponding credential and issuer
  identifiers. For notational convenience, we may use $\CRED[\scid]$
  to refer to $\CRED[\cid]$ for all {\cid}s in a set \scid. Also, when clear
  from context, we sometimes use $\CRED[\cid]$ (resp. $\CRED[\scid]$) to
  mean \cred (resp. \scred) in $\CRED[\cid] = (\cdot,\cred,\cdot,\cdot,
  \cdot,\cdot)$ (resp. $\CRED[\scid]$).
\item[\CCRED.] Like \CRED, but tracks challenge credentials.
\item[\OWNR.] For notational convenience, when we write $\OWNR[\cid]$ we mean
  ``\uid such that $\CRED[\cid] = (\uid,\cdot,\cdot,\cdot,\cdot,\cdot)$'', or
  $\bot$ if there is no wuch \uid. We may also use \OWNR over a set of {\cid}s
  (\scid). In that case, our convention is that $\OWNR[\scid]$ returns $\bot$ if
  not all passed {\cid}s belong to the same \uid. Since $\bot$ is not a valid
  \uid, all conditions checking membership of the output of \OWNR to a list of
  users equal false if \OWNR returns $\bot$.
\item[\ATTR.] For notational convenience, when we write $\ATTR[\cid]$ we mean
  ``\attrs such that $\CRED[\cid] = (\cdot,\cdot,\cdot,\attrs,\cdot,\cdot)$''.
\item[\ISR.] For notational convenience, when we write $\ISR[\cid]$ we mean
  ``\iid such that $\CRED[\cid] = (\cdot,\cdot,\iid,\cdot,\cdot,\cdot)$''.
\item[\SIG.] Maintains signatures generated via the \SIGN oracle. Entries of
  this table are $(\oid,\scid,\sig,\Yeval,\msg,\feval)$ tuples, where \oid is
  the opener, \scid is the set of identifiers of the credentials used for
  signing, \feval is the signing evaluation function, and \sig and \msg are the
  produced signature and signed message.
\item[\CSIG.] Maintains challenge signatures output to the adversary in the
  signature anonymity game, and is indexable by challenge signatures \csig.
  Each entry contains also $\cuid_b$ and $\cscid_b$, respectively the challenge
  user  and credential identifiers set used to produce \csig; as well as the
  corresponding challenge user and credential set indexed by the complementary
  $1-b$; the signed message \msg and signing evaluation function \feval, the
  result of \feval, \Yeval, and the opener identifier \oid.
\end{description}

\paragraph{Oracles.} %
In the game-based definitions of our \UAS model, we leverage the following
oracles, which are formally defined in \figref{fig:oracles1} and
\figref{fig:oracles2}. 

\begin{description}
% \item[\IGEN.] Adds a new issuer to the game, generating its keypair and setting
%   the associated issuance function.
\item[\HUGEN.] Adds a new honest user to the game, generating its keypair.
\item[\CUGEN.] Adds a new corrupt user to the game, setting its \upk to the
  value given by the adversary.  
\item[\OGEN.] Adds a new opener to the game, generating its key pair and
  setting its evaluation and inspection functions.
% \item[\ICORR.] Corrupts an existing (and honest) issuer, by giving its secret
%   key to the adversary.
\item[\ISET.] ``Upgrades'' a user to become an issuer, specifying its
  \fissue function.
\item[\UCORR.] Corrupts an existing (and honest) user, giving its secret
  key to the adversary. If the user was also an issuer, it becomes a corrupt
  issuer too.
\item[\OCORR.] Corrupts an existing (and honest) opener, by giving its secret
  key to the adversary.
% \item[\HUGEN.] Adds a new honest user to the game, by honestly generating
%   the user's key pair.
% \item[\CUGEN.] Adds a new corrupt user to the game or, if the specified
%   user already exists and is honest, corrupts it, leaking its key and
%   credentials.
\item[\RREG.] Reads the given transcript table entry.
\item[\WREG.] Sets a transcript table entry to the given value.
\item[\OBTISS.] Lets the adversary add a new honestly generated credential to
  the game, on behalf of an honest user.
\item[\OBTAIN.] Enables the adversary to play the role of a dishonest issuer, by
  letting it interact with honest users who want to receive credentials.
\item[\ISSUE.] Allows the adversary to play the role of dishonest users,
  requesting an honest issuer to produce credentials for them.
\item[\SIGN.] Lets the adversary get signatures using credentials from honest
  users.
\item[\OPEN.] Given an honestly produced signature, outputs the result of the
  opening function, along with a correctness proof.
\item[\OBTCHALb.] Upon receiving a target credential identifier, two challenge
  users and credential sets, an honest issuer identifier, and a set of
  attributes, issues a credential for the challenge user and credential set
  defined by the bit $b$. 
\item[\CHALb.] Upon receiving two challenge users and credential sets, a common
  singing evaluation function and a message, returns a signature produced by one
  of these two user and credential sets, defined by the bit $b$.
\end{description}

{%\setlength\intextsep{\sep}
  \begin{figure*}[ht!]
    \centering
    \scalebox{0.85}{

      \begin{minipage}[t]{0.55\textwidth}

        % \procedure{$\IGEN(\iid,\fissue)$}{%
        %   \pcif \iid \in \HI \lor \iid \in \CI: \pcreturn \bot \\
        %   \pcif \fissue \notin \famfissue: \pcreturn \bot \\
        %   (\ipk,\isk) \gets \IKeyGen(\parm) \\
        %   \IK[\iid] \gets ((\ipk,\fissue),\isk) \\
        %   \HI \gets \HI \cup \lbrace \iid \rbrace \\
        %   \pcreturn \ipk \\
        % }

        % \procedure{$\ICORR(\iid)$}{%
        %   \pcif \iid \in \CI \lor \iid \notin \HI: \pcreturn \bot \\
        %   \HI \gets \HI \setminus \lbrace \iid \rbrace \\
        %   \CI \gets \CI \cup \lbrace \iid \rbrace \\
        %   \pcreturn \isk \\
        % }        

        % \procedure{$\HUGEN(\uid)$}{%
        %   \pcif \uid \in \HU \lor \uid \in \CU: \pcreturn \bot \\
        %   (\upk,\usk) \gets \UKeyGen(\parm) \\
        %   \UK[\uid] \gets (\upk,\usk);
        %   \HU \gets \HU \cup \lbrace  \uid \rbrace \\
        %   \pcreturn \top \\
        % }

        \procedure{$\HUGEN(\uid)$}{%
          \pcif \uid \in \HU \lor \uid \in \CU: \pcreturn \bot \\
          (\upk,\usk) \gets \KeyGen(\parm) \\
          \UK[\uid] \gets (\upk,\usk) \\
          \HU \gets \HU \cup \lbrace \uid \rbrace \\
          \pcreturn \upk \\
        }
        
        \procedure{$\UCORR(\uid)$}{%
          \pcif \uid \in \CU \lor \uid \notin \HU: \pcreturn \bot \\
          \pcif \uid \in \HI \cup \CI: \pcreturn \bot \\
          \HU \gets \HU \setminus \lbrace \uid \rbrace \\
          \CU \gets \CU \cup \lbrace \uid \rbrace \\
          \pcreturn (\PRVUK[\uid],\CRED[\uid]) \\
        }
        
        \procedure{$\ICORR(\uid)$}{%
          \pcif \uid \notin \HI: \pcreturn \bot \\
          \HI \gets \HI \setminus \lbrace \uid \rbrace \\
          \CI \gets \CI \cup \lbrace \uid \rbrace \\
          \pcreturn(\PRVUK[\uid],\CRED[\uid]) \\
        }

        \procedure{$\OGEN(\oid,\finsp)$}{%
          \pcif \oid \in \HO \lor \oid \in \CO: \pcreturn \bot \\
          \pcif \finsp \notin \famfinsp: \pcreturn \bot \\
          (\opk,\osk) \gets \OKeyGen(\parm) \\
          \OK[\oid] \gets ((\opk,\finsp),\osk) \\
          \HO \gets \HO \cup \lbrace \oid \rbrace \\
          \pcreturn \opk
        }
        
      \end{minipage}
    }
    \scalebox{0.85}{
      
      \begin{minipage}[t]{.5\textwidth}

        \procedure{$\CUGEN(\uid,\upk)$}{%          
          \pcif \uid \in \HU \lor \CU: \pcreturn \bot \\
          \CU \gets \CU \cup \lbrace \uid \rbrace \\          
          \UK[\uid] = (\upk,\bot) \\          
          \pcreturn \top \\
        }

        \procedure{$\ISET(\uid,\fissue)$}{%
          \pcif \uid \notin \HU \cup \CU: \pcreturn \bot \\
          \pcif \uid \in \HI \cup \CI: \pcreturn \bot \\
          \pcif \fissue \notin \famfissue: \pcreturn \bot \\
          \ipk \gets \ISet(\PUBUK[\uid],\PRVUK[\uid],\fissue) \\
          \IK[\uid] \gets ((\ipk,\fissue),\PRVUK[\uid]) \\
          \pcif \uid \in \HU: \HI \gets \HI \cup \lbrace \uid \rbrace \\
          \pcif \uid \in \CU: \CI \gets \CI \cup \lbrace \uid \rbrace \\
          \pcreturn \ipk \\
        }        
        
        \procedure{$\OCORR(\oid)$}{%
          \pcif \oid \in \CO \lor \oid \notin \HO: \pcreturn \bot \\
          \pcif \exists (\oid,\cdot,\cdot,\cdot,\cdot,
          \cdot,\cdot,\cdot,\cdot) \in \CSIG: \pcreturn \bot \\
          \HO \gets \HO \setminus \lbrace \oid \rbrace \\
          \CO \gets \CO \cup \lbrace \oid \rbrace \\
          \pcreturn \osk \\
        }

        \procedure{$\RREG(i)$}{%
          \pcreturn \trans[i] \\
        }                

        \procedure{$\WREG(i,\rho)$}{%
          \trans[i] \gets \rho
        }        
        
      \end{minipage}
      
    }

    \caption{Detailed oracles available in our model (1/2). Oracles for
      generating key material for users, issuers, and openers.}
    \label{fig:oracles1}
  \end{figure*}
}

{%\setlength\intextsep{\sep}
  \begin{figure*}[htp!]
    \centering
    \scalebox{0.85}{

      \begin{minipage}[t]{0.58\textwidth}

        \procedure{$\OBTISS(\stackrel{\cid}{\pcbox{(\cidi,\cidu)}},\uid,\iid,\attrs,
          \lbrace (\cid_i,\iid_i) \rbrace_{i \in [n]})$}{%
          \pcif \uid \notin \HU \lor \iid \notin \HI: \pcreturn \bot \\
          \pcif \exists i \in [n]~\suchthat~\cid_i \in \CCRED: \pcreturn \bot \\
          \pcif \CRED[\cid] \neq \bot \lor \CCRED[\cid] \neq \bot:
          \pcreturn \bot \\
          \langle \Cred, R \rangle \gets
          \langle \Obtain(\UK[\uid],\cidu,\CRED[\lbrace \cid_i\rbrace_{i\in[n]}],\attrs), \\
          \hspace*{50pt} \Issue(\PRVIK[\iid],\cidi,\ISR[\lbrace \cid_i\rbrace_{i\in[n]}],\attrs)
          \rangle \\
          \trans[\cid] \gets R \\
          \CRED[\cid] \gets (\uid, \cred, \iid, \attrs, n,
          \lbrace(\cid_i,\iid_i)\rbrace_{i\in[n]}) \\
          \pcreturn \top \\
        }

        \procedure{$\ISSUE(\cidi,\uid,\iid,\attrs,\siid=
          \lbrace \iid_i\rbrace_{i\in[n]})$}{%
          \pcif \uid \notin \CU \lor \iid \notin \HI: \pcreturn \bot \\
          \pcif \CRED[(\cidi,\cdot)] \neq \bot \lor \CCRED[(\cidi,\cdot)]
          \neq \bot: \\
          \pcind \pcreturn \bot \\
          \langle \cdot, R \rangle \gets
          \langle \adv, 
          \Issue(\PRVIK[\iid],\cidi,\siid,\attrs) \rangle \\
          \trans[(\cidi,\cdot)] \gets R \\
          \CRED[(\cidi,\cdot)] \gets (\uid,\cdot,\iid,\attrs,n,\lbrace(\cdot,
          \iid_i)
          \rbrace_{i\in[n]}) \\
          \pcreturn \top \\          
        }

        \procedure{$\SIGN(\oid,\scid=\lbrace\cid_i\rbrace_{i\in[n]},\msg,
          \feval)$}{%
          \uid \gets \OWNR[\scid] \\
          \pcif \uid \notin \HU \lor \feval \notin \famfeval: \pcreturn \bot \\
          \pcif \exists i \neq j \in [n]~\suchthat~\cid_i \in \CRED \land
          \cid_j \in \CCRED: \\
          \pcind \pcreturn \bot \\
          \Sig \gets \Sign(\UK[\uid],\PUBOK[\oid],\scid,\msg,\feval) \\
          \Yeval=(\yeval^0,\yeval^1) \gets \feval(\PUBUK[\uid],\scid,\msg) \\
          \SIG[\uid] \gets \SIG[\uid] \cup
          \lbrace (\oid,\scid,\Sig,\Yeval,\msg,\feval) \rbrace \\
          \pcreturn \Sig \\
        }        

        \procedure{$\OPEN(\oid,\Sig,\msg)$}{%
          \textrm{Let}~\uid~\textrm{be s.t.}~(\cdot,\scid,\Sig,\Yeval,\cdot,
          \feval)
          \in \SIG[\uid] \\
          (\yinsp,\iproof) \gets
          \Open(\PRVOK[\oid],\PUBIK[\scid],\Sig,\msg,\feval) \\
          \pcif \CSIG[\Sig] \neq \bot: \\
          \pcind \textrm{Parse $\CSIG[\Sig]$ as $(\oid,\cuid_b,\scid_b,
            \Yeval,\msg,\feval$} \\          
          \hspace*{83pt}\cuid_{1-b},\cSig_{1-b},\scid_{1-b},
          \TYeval) \\
          \pcind (\tyinsp,\tiproof) \gets
          \Open(\PRVOK[\oid],\PUBIK[\scid],\\
          \hspace*{107pt} \cSig_{1-b},\msg,\feval) \\
          \pcind \pcif \tyinsp \neq \yinsp: \pcreturn \bot \\
          \pcreturn (\yinsp,\iproof)
        }
        
      \end{minipage}
    }
    \scalebox{0.85}{
      
      \begin{minipage}[t]{.5\textwidth}

        \procedure{$\OBTAIN(\cidu,\uid,\iid,\attrs,\lbrace (\cid_i,\iid_i)
          \rbrace_{i\in[n]})$}{%
          \pcif \uid \notin \HU \lor \iid \notin \CI: \pcreturn \bot \\
          \pcif \exists i \in [n]~\suchthat~\cid_i \in \CCRED: \pcreturn \bot \\
          \pcif \CRED[(\cdot,\cidu)] \neq \bot \lor \CCRED[(\cidu,\cdot)] \neq
          \bot: \\
          \pcind \pcreturn \bot \\
          \langle \Cred, \cdot \rangle \gets
          \langle \Obtain(\UK[\uid],\cidu,\PUBIK[\iid],\lbrace \cid_i\rbrace_{[n]},
          \attrs),\adv \rangle \\
          \CRED[(\cdot,\cidu)] \gets (\uid,\cred,\iid,\attrs,n,\lbrace(\cid_i,
          \iid_i) \rbrace_{i\in[n]}) \\
          \pcreturn \top \\
        }

        \procedure{$\OBTCHALb(\cidu,\cuid_{0,1},\iid,\attrs,
          \stackrel{\cscid_{0,1}}{\pcbox{\lbrace(\ccid_{0,i},\ccid_{1,i})
            \rbrace_{i\in[n]}}})$}{%
          \pcif \cuid_0 \notin \HU \lor \cuid_1 \notin \HU: \pcreturn \bot \\
          \pcif \iid \notin \CI: \pcreturn \bot \\
          \pcif \CRED[(\cdot,\cidu)] \neq \bot \lor
          \CCRED[(\cdot,\cidu)] \neq \bot: \pcreturn \bot \\
          \pcif \exists i\in[n]~\suchthat~
          \PUBIK[\cscid_{0,i}] \neq \PUBIK[\cscid_{1,i}]: \pcreturn \bot \\
          \pcif \pcfor d \in \bin,~ \exists \cid' \in \cscid_d~\suchthat~\cid'
          \in \CRED: \\
          \pcind \pcreturn \bot \\
          \textrm{Parse}~\PUBIK[\iid]~\textrm{as}~((\cdot,\fissue),\cdot) \\
          \pcif 0(\fissue(\PUBUK[\cuid_0],(\cdot,\cidu),\attrs,\lbrace (\ccid_{0,i},\ATTR[\ccid_{0,i}])\rbrace_{i\in[n]})) \neq \\
          \pcind 0(\fissue(\PUBUK[\cuid_1],(\cdot,\cidu),\attrs,\lbrace (\ccid_{1,i},\ATTR[\ccid_{1,i}])\rbrace_{i\in[n]})): \\
          \pcind \pcreturn \bot \\
          \langle \Cred, \cdot \rangle \gets
          \langle \Obtain(\PRVUK[\cuid_b],\cidu,\PUBIK[\iid],\cscid_b,\attrs),
          \adv \rangle \\
          \CCRED[(\cdot,\cidu)] \gets (\cuid_b,\cred,\iid,\attrs,\cscid_b,\siid) \\
          \pcreturn \top \\
        }

        \procedure{$\CHALb(\oid,\stackrel{\cscid_{0,1}}{\pcbox{
            \lbrace (\ccid_{0,i},\ccid_{1,i})
            \rbrace_{i\in[n]}}},\msg,\feval)$}{%
          \pcfor d\in\bin: \cuid_d \gets \OWNR[\cscid_d] \\
          \pcif \cuid_0 \notin \HU \lor \cuid_1 \notin \HU: \pcreturn \bot \\
          \pcif \exists i\in[n]~\suchthat~
          \PUBIK[\cscid_{0,i}] \neq \PUBIK[\cscid_{1,i}]: \\
          \pcind \pcreturn \bot \\
          \pcif \feval \notin \famfeval: \pcreturn \bot \\
          \Yeval = (\yeval^0,\yeval^1) \gets \feval(\PUBUK[\cuid_0],\cscid_0,
          \msg) \\
          \TYeval = (\tyeval^0,\tyeval^1) \gets
          \feval(\PUBUK[\cuid_1],\cscid_1,\msg) \\
          \pcif \yeval^0 \neq \tyeval^0: \pcreturn \bot \\   
          \cSig_b \gets \Sign(\PRVUK[\cuid_b],\PUBOK[\oid],\cscid_b,\msg,
          \feval) \\
          \cSig_{1-b} \gets \Sign(\PRVUK[\cuid_{1-b}],\PUBOK[\oid],\cscid_{1-b},
          \msg,\feval) \\          
          \CSIG[\cSig_b] \gets 
          \lbrace (\oid,\cuid_b,\cscid_b,\Yeval,\msg,\feval,\\
          \hspace*{74pt}\cuid_{1-b},\cSig_{1-b},\cscid_{1-b},\TYeval)\rbrace \\
          \pcreturn \cSig_b
        }
        
      \end{minipage}
      
    }

    \caption{Detailed oracles available in our model (2/2). Oracles for
      obtaining credentials, signatures, and processing them.
    \markulf{No concurrent issuing. \adv~is stateful.}}
    \label{fig:oracles2}
  \end{figure*}
}

\paragraph{Helper functions \SimSetup, \ExtractIssue, and \ExtractSign.}
We assume the existence of these helper functions. They are not functions
available in the actual scheme, but rather to the challenger in the experiments
we use to formalize security of \UAS schemes. We introduce them here, and define
they later for our construction.

\begin{description}
\item[$\SimSetup(1^\secpar) \rightarrow (\parm,\trap)$.] Given a security
  parameter, outputs global parameters \parm whose distribution is
  indistinguishable to that produced by the \Setup algorithm, as well as a
  trapdoor \trap.
\item[$\ExtractIssue(\trap,\utrans) \rightarrow (\upk,\usk,\sCred=
  \lbrace(\cid_i,\attrs_i,\cred_i) \rbrace_{i \in [n]})$.]
  Receives trapdoor \trap and an $\langle \Obtain, \Issue \rangle$ transcript,
  and returns the credential set \sCred, if any, involved in the request. It
  needs an honest issuer as, otherwise, the transcripts won't be available. 
\item[$\ExtractSign(\trap,\opk,\lbrace \ipk_i \rbrace_{i \in [n]},\Sig,\msg,
  \feval) \rightarrow (\upk,\usk,\sCred=\lbrace(\cid_i,\attrs_i,\cred_i)
  \rbrace_{i \in [n]},\yeval^1,\yinsp)$.] Receives a trapdoor \trap, a signature
  \Sig, the opener public key \opk, and the public keys $\ipk_i$
  issuers of the credentials used to produce the signature over \msg, and for
  \feval. It outputs the user secret key and credential set \sCred used to
  generate the signature, and the $\yeval^1$ and \yinsp values. For notational
  convenience, we overload this function and use \oid and \iid instead of the
  actual keys.
% \item[$\IdentifyCred(\trap,\usk,\attrs_{\cred},\cred,\ipk)$.] Returns $1$ if
%   \cred has been issued over attributes $\attrs_{\cred}$ and for a user with
%   secret key \usk, by honest issuer with public key \ipk. Otherwise, it returns
%   $0$.

%   The \IdentifyCred function defined by \UAS constructions must satisfy that
%   for any \cred obtained as the result of an $\langle \Obtain,\Issue \rangle$
%   interaction with an honest issuer, there exists \emph{exactly one} set of
%   $(\usk,\attrs_{\cred})$ such that \IdentifyCred equals $1$.
%   %In order to be meaningful, this requires that,
%   %for every $(\attrs_{\cred},\cred)$ pair, there is at most one \usk that makes
%   \IdentifyCred return $1$.
% \item[$\IdentifySig(\trap,\usk,\scred,\Sig)$.] Returns $1$ is $(\usk,\scred)$
%   are the secret key and credential set used to produce \Sig, otherwise, returns
%   $0$.

%   The \IdentifySig function defined by \UAS constructions must satisfy that, for
%   signatures accepted by \Verify, there must exist \emph{exactly one} $(\usk,
%   \scred)$ combination that makes \IdentifySig return $1$.
%   % . This is trivial for honest users, for which there must be a one-to-one
%   % relationship between {\uid}s and {\usk}s. For corrupt users, \IdentifyUK has
%   % to iterate through the $\langle\Obtain,\Issue\rangle$ transcripts associated
%   % to \uid, extract the used secret key, and check if there is a match. In the
%   % latter case, there is no guarantee of getting a one-to-one relationship
%   % between \usk and \uid. Also, when used for corrupt users, this can only be
%   % used when the issuer is honest, as transcripts are needed. 
\end{description}

% Note that, for all the helper functions, in the case of credentials, transcripts,
% and signatures by honest users, it is enough to have access to the corresponding
% state information (described below) maintained by the challenger in our
% experiments. For credentials and join transcripts of corrupt users, or
% dishonestly produced signatures, we do need to perform actual extraction.
% Certainly, the challenger
% needs special knowledge/power such as decryption trapdoors, the ability to
% rewind the game, or program random oracles. The approach needs thus to depend on
% the concrete construction. \jesus{Although, for the case of \ExtractIssue and
%   \IdentifyUK, online extractability (or alternative requirements, such as
%   non-parallel or logarithmic number of joins) is necessary.}

\paragraph{Correctness.} %
Correctness of \UAS schemes is formalized through the experiment in
\figref{fig:exp-uas-corr}. It states that a signature over any arbitrary message
and valid function \feval, produced honestly leveraging credential set \scid,
owned by user \uid, is accepted by \Verify. Moreover, all the credentials in
\scid meet the conditions set by the corresponding \fissue defined by the issuer
which issued each credential. Similarly, the output of \feval matches the
value produced by \Sign alongside with \sig; and the value produced by \Open
is accepted by \Judge, and matches the output of applying \finsp on \Yeval, the
credentials, user key, and message.

\begin{definition}{(Correctness of \UAS)}
  \label{def:correctness-uas}
  An \UAS scheme is correct if, for any p.p.t. adversary $\adv$,
  $\ExpCorrect(1^\secpar)$ outputs 1 with negligible probability.
\end{definition}

\begin{figure}[htp!]
  \centering
  \scalebox{0.85}{
    \procedure[linenumbering]{$\ExpCorrect(1^\secpar)$}{%
      \parm \gets \Setup(1^\secpar) \\
      (\uid,\oid,\scid,\msg,\feval)
      \gets \adv^{\HUGEN,\OGEN,\ISET,\OBTISS,\RREG}(\parm) \\
      \pcif \feval \notin \famfeval \lor \OWNR[\scid] \neq \uid: \pcreturn 0 \\
      (\Sig = (\sig,\yeval)) \gets \Sign(\PRVUK[\uid],\PUBOK[\oid],\scid,\msg,
      \feval) \\
      \pcif \Verify(\PUBOK[\oid],\PUBIK[\scid],\Sig,\msg,\feval) = 0: \pcreturn 1 \\
      \pcfor \cid \in \scid \pcdo: \\
      \pcind \textrm{Parse}~\CRED[\cid]~\textrm{as}~
      (\cdot,\cdot,\cdot,\attrs,n,\lbrace(\cid_i,\cdot)\rbrace_{i\in[n]})) \\
%      \pcind \textrm{Let}~\scid^{\cid}~\textrm{be the {\cid}s used to obtain}
%      ~\cid;~\textrm{Parse}~\PUBIK[\ISR[\cid]]~\textrm{as}~((\cdot,
%      \fissue^{\cid}),\cdot)\\
      \pcind \textrm{Parse}~\trans[\cid]~\textrm{as}~(\yissue,\utrans);
      \PUBIK[\cid]~\textrm{as}~((\cdot,\fissue),\cdot) \\
      \pcind \pcif \fissue(\PUBUK[\uid],\cid,\attrs,
      (\lbrace(\cid_i,\ATTR[\cid_i])\rbrace_{i\in[n]})) \neq \yissue:
      \pcreturn 1 \\
      (\yeval^0,\yeval^1) \gets \feval(\PUBUK[\uid],(\scid,\ATTR[\scid]),\msg) \\
      \pcif \yeval^0 \neq \yeval: \pcreturn 1 \\
      (\yinsp,\iproof) \gets \Open(\PRVOK[\oid],\PUBIK[\scid],\Sig,\msg,\feval) \\
      \textrm{Parse}~\PUBOK[\oid]~\textrm{as}~((\cdot,\finsp),\cdot) \\
      \pcif \Judge(\PUBOK[\oid],\PUBIK[\scid],\yinsp,\iproof,\Sig,\msg,\feval)
      = 0~\lor \\
      \pcind \yinsp \neq \finsp((\yeval,\yeval^1),
      \PUBUK[\uid],(\scid,\ATTR[\scid]),\msg)): \\
      \pcind \pcreturn 1 \\
      \pcreturn 0
    }
  }
  \caption{Correctness experiment for \UAS schemes.}
  \label{fig:exp-uas-corr}
\end{figure}

\subsubsection{Security Properties}
\label{sssec:security}
%
Security of an \UAS scheme is defined in terms of anonymity, unforgeability and
non-frameability. We now introduce and formally define the corresponding
properties.
% In addition, we define two auxiliary properties for defining
% the expected behaviour of the \ExtractIssue and \ExtractSign functions.
% \todo{The following may need to be moved elsewhere and/or re-written.}
% For instance, the extraction type are used in
% \cite{lnpy21,nps22}, and functions of the identify type are used in
% \cite{bfg+11,cdl16,gl19,dl21,fgl21}. Indeed, it seems hard to avoid resorting to
% these techniques when there is no traditional notion of opening. Since, mostly
% the unforgeability and non-frameability properties build on the extractability
% and identifiability ones, we define them first. Then, we proceed with the usual
% notions.

% \todo{Maybe do some drawing of the cred tree.}

% In the following, we use some custom notation to refer to the tree-like
% relationships that may be built between credentials and, more concretely, their
% related data (like {\usk}s, {\cid}s, and attribute sets {\attrs}s) when a user
% leverages previously obtained credentials in order to obtain new ones. To
% facilitate the explanation, we refer to \figref{fig:cred-tree}. In a nutshell,
% we use $tree_{\cid}$ to refer to the whole tree of {\cid}s that have been used
% to produce the credential with identifier \cid -- and, similarly, $tree_{\usk}$
% for {\usk}s, and $tree_{\attrs}$ for attribute sets. 

% \begin{figure}[htp!]
%   \centering
%   \includegraphics[width=0.5\textwidth]{figures/cred-tree.png}
%   \caption{Credential trees, and their corresponding notation.
%     We use $Tree_x$, where $x \in \lbrace \usk,\cid,\attrs \rbrace$ to
%     denote the whole tree of {\usk}s, {\cid}s, and {\attrs}s. \\
%     \todo{Move to Tikz.}}
%   \label{fig:cred-tree}
% \end{figure}

% \paragraph{Extractability.} %
% We require that the witnesses used to produce each credential and signature can
% be extracted from the corresponding \utrans and signature, respectively.
% Furthermore, in order for our generalized notion of utility to be sound, it
% is required that, whenever a credential is issued by an honest issuer, \fissue
% accepts the extracted witnesses; and whenever a signature is accepted by
% \Verify, the extracted witnesses match the expected outputs by \feval and
% \finsp. We capture this in the \ExpExtractIssue and \ExpExtractSign games, which
% are crucial in the unforgeability and non-frameability requirements.

% In the extractability variant for credentials, \ExpExtractIssue, the adversary
% wins if it manages to get a credential produced by an honest issuer, such that
% the issuance predicate \fissue rejects the extracted witnesses, or if some of
% the involved credentials is associated to a different \usk.
% %
% In the variant for signatures, \ExpExtractSign, the adversary wins if the
% witnesses extracted from a signature accepted by \Verify make \feval and \finsp
% output inconsistent values.
% %
% The oracles available in \ExpExtractIssue is, $\OExt \gets (\lbrace\HU,\CU
% \rbrace\GEN,\IGEN,\OGEN,\OCORR,\OBTISS,\ISSUE,\RREG,\SIGN,\OPEN)$. Note that,
% for \ExpExtractIssue, honest issuers are required, as we rely on the
% availability of $\langle \Obtain,\Issue \rangle$ transcripts to assist on the
% extraction. On the other hand, for \ExpExtractSign, as we extract directly from
% signatures, honest issuers are not a requirement, so the adversary is given
% access to $\ICORR$ too.

% \begin{figure*}[htp!]
%   \centering
%   \scalebox{0.85}{
%     \begin{minipage}[t]{0.6\textwidth}
%       \procedure[linenumbering]{$\ExpExtractIssue(1^\secpar)$}{%
%         (\parm, \trap) \gets  \SimSetup(1^\secpar) \\
%         \cid \gets \adv^{\OExt}(\parm) \\
%         (\usk,\lbrace(\cid_i,\attrs_i,\cdot)\rbrace_{i \in [n]}) \gets
%         \ExtractIssue(\trap,\trans[\cid]) \\
%         \pcfor i \in [n]: (\usk_i,\cdot) \gets \ExtractIssue(\trap,
%         \trans[\cid_i]) \\
%         \pcif \exists i \in [n]~\suchthat~\usk \neq \usk_i: \pcreturn 1 \\
%         \pcif \fissue(\usk,\ATTR[\cid],\lbrace \cid_i \rbrace_{i \in [n]},
%         \lbrace\attrs_i\rbrace_{i \in [n]}) = 0: \\
%         \pcind \pcreturn 1 \\
%         \pcreturn 0
%       }
%     \end{minipage}
%     \vspace*{0.5em}
    
%     \begin{minipage}[t]{0.5\textwidth}
%       \procedure[linenumbering]{$\ExpExtractSign(1^\secpar)$}{%
%         (\parm, \trap) \gets \SimSetup(1^\secpar) \\
% 	(\oid,\siid,\Sig=(\sig,\yeval),\msg,\feval) \gets
%         \adv^{\OExt,\ICORR}(\parm) \\
% 	\pcif \Verify(\oid,\siid,\Sig,\msg,\feval) = 0: \pcreturn 0 \\
% 	(\usk,\lbrace (\cid_i,\attrs_{\cid_i},\cdot) \rbrace_{i\in[n]},
%         \yeval^1,\yinsp) \gets \ExtractSign(\trap,\oid,\siid,\Sig,\msg,\feval) \\
%         (\yeval^0,\yeval^1) \gets \feval(\usk,\lbrace\cid_i\rbrace_{i \in [n]},
%         \lbrace\attrs_i\rbrace_{i \in [n]}, \msg) \\
%         \pcif \yeval \neq \yeval^0 \lor \yeval^1 \neq \tyeval^1:
%         \pcreturn 1 \\
%         \pcif \finsp((\yeval^0,\yeval^1),\usk,\lbrace\cid_i\rbrace_{i \in [n]},
%         \lbrace\attrs_i\rbrace_{i \in [n]},\msg) \neq \yinsp:
%         \pcreturn 1 \\
% 	\pcreturn 0
%       }
%     \end{minipage}
%   }
%   \caption{Extractability experiments for \UAS schemes.}
%   \label{fig:exp-uas-extract}
% \end{figure*}

% \paragraph{Identifiability.} %
% On their own, the extractability properties only ensure that credentials and
% signatures have been produced by leveraging knowledge of some witnesses.
% However, they do not establish any relationship between those witnesses and
% users. While the actual technicalities of doing so is dependent on the
% construction, we can, modelling-wise, enforce constraints that associate
% user identifiers ({\uid}s, tracked by the game environment) with potential
% witnesses. Namely, we require that it must be possible to associate any
% credential (obtained from an honest issuer), or any signature accepted by
% \Verify, with exactly one user identifier.

% As for extractability, we define two variants. For credentials, in
% \ExpIdentifyCred we require the adversary to output the identifier of a
% credential obtained from an honest issuer. The adversary wins if, given the
% witnesses extracted from the corresponding transcript, the \IdentifyCred helper
% function outputs a set \suid of user identifiers with cardinality different than
% $1$.
% %
% Similarly, for signatures, the adversary wins if it is able to produce a
% signature from which the extracted witnesses, when passed to \IdentifySig,
% output a set \suid of user identifiers with cardinality different than $1$.
% %
% The oracles are as in the extractability experiments. Namely, in the
% \ExpIdentifyCred game, the adversary has access to $\OId \gets (\lbrace\HU,\CU
% \rbrace\GEN,\IGEN,\OGEN,\OCORR,\OBTISS,\ISSUE,\RREG,\SIGN,\OPEN)$, while in
% \ExpIdentifySign it also has access to \ICORR. The same reasoning applies.

% \begin{figure*}[htp!]
%   \centering
%   \scalebox{0.85}{
%     \begin{minipage}[t]{0.6\textwidth}
%       \procedure[linenumbering]{$\ExpIdentifyCred(1^\secpar)$}{%
%         (\parm, \trap) \gets  \SimSetup(1^\secpar) \\
%         \cid \gets \adv^{\OId}(\parm) \\
%         (\usk,\scred,\attrs_{\scred}) \gets \ExtractIssue(\trap,\trans[\cid]) \\
%         \pcfor \cred \in \scred: \\
%         \pcind \suid \gets \IdentifyCred(\trap,\usk,\attrs_{\cred},\cred,\ipk_{\cred}) \\
%         \pcind \pcif |\suid| \neq 1: \pcreturn 1 \\
%         \pcind \pcif \suid~\textrm{differs from previous iterations}: \\
%         \pcind \pcind \pcreturn 1 \\
%         \pcreturn 0
%       }
%     \end{minipage}
%     \vspace*{0.5em}
    
%     \begin{minipage}[t]{0.5\textwidth}
%       \procedure[linenumbering]{$\ExpIdentifySign(1^\secpar)$}{%
%         (\parm, \trap) \gets \SimSetup(1^\secpar) \\
% 	(\oid,\siid,\Sig,\msg,\feval) \gets \adv^{\OId,\ICORR}(\parm) \\
% 	\pcif \Verify(\oid,\siid,\Sig,\msg,\feval) = 0: \pcreturn 0 \\
% 	(\usk,\scred,\attrs_{\scred},\yeval^1,\yinsp) \gets
%         \ExtractSign(\trap,\oid,\siid,\Sig,\msg,\feval) \\
% 	\suid \gets \IdentifySig(\trap,\usk,\scred,\Sig) \\
% 	\pcif |\suid| \neq 1: \pcreturn 1 \\
% 	\pcreturn 0
%       }
%     \end{minipage}
%   }
%   \caption{Identifiability experiments for \UAS schemes.}
%   \label{fig:exp-uas-identify}
% \end{figure*}

% \begin{definition}{(Identifiable credentials in \UAS)}
%   \label{def:identify-cred-uas}  
%   We define the advantage \AdvIdCred of $\adv$ against \ExpIdentifyCred as
%   $\AdvIdCred=|\Pr\lbrack\ExpIdentifyCred(1^\secpar)=1\rbrack-
%   \Pr\lbrack\ExpIdentifyCred(1^\secpar)=1\rbrack|$.
%   %
%   An \UAS scheme \emph{with extractable issuance} satisfies identifiable
%   credentials if, for any p.p.t. adversary $\adv$, \AdvIdCred is a negligible
%   function of $1^\secpar$.
% \end{definition}

% \begin{definition}{(Identifiable signatures in \UAS)}
%   \label{def:identify-sig-uas}  
%   We define the advantage \AdvIdSign of $\adv$ against \ExpIdentifySign as
%   $\AdvIdSign=|\Pr\lbrack\ExpIdentifySign(1^\secpar)=1\rbrack-
%   \Pr\lbrack\ExpIdentifySign(1^\secpar)=1\rbrack|$.
%   %
%   An \UAS scheme \emph{with extractable signatures} satisfies identifiable
%   signature if, for any p.p.t. adversary $\adv$, \AdvIdSign is a negligible
%   function of $1^\secpar$.
% \end{definition}

\paragraph{Anonymity.} %
Users may see their privacy compromised through their interactions with issuers
to request a credential, or via the signatures they produce. Thus, we define two
games to define the privacy expected in those situations.

The issuance anonymity game captures that, during credential issuance
interactions, the adversary gains no information about the
user(s) behind them. For this, we allow the adversary to control targetted
issuers and openers (although it may also add honest ones), and add honest and
corrupt users. The adversary can also obtain credentials, produce signatures,
and open them. We need to make some limitations to prevent trivial wins: first,
when querying the oracle for obtaining a challenge credential out of two
possible user-credential set pairs, the issuance protocol must either succeed or
fail for both; also, the adversary cannot mix challenge and non-challenge
credentials in the same call to the \SIGN oracle -- but can otherwise open
any signature. With these restrictions, if the adversary cannot distinguish
arbitrary runs with all oracles when he gets challenge credentials
$\cred_b$, from runs with credentials $\cred_{1-b}$, then the issuance protocol
is privacy-preserving.

Signature anonymity captures that the signatures produced by system users do not
leak information
about their identity beyond what is already revealed via $\yeval^0$ and what
may be revealed via \yinsp. Concretely, the adversary can interact with oracles
as in the issuance anonymity game, except that instead of obtaining challenge
credentials, it obtains challenge signatures. These signatures must have been
produced via the \CHALb oracle, which ensures that the $\yeval^0$ value is the
same for both input sets -- otherwise, rejects creating the signature. We also
allow opening signatures; even challenge $\cSig_b$ signatures, as long as the
\yinsp value of the counterpart $\cSig_{1-b}$ is the same. Note that this is
stronger than the traditional CCA-like security of group signatures, where no
challenge signature can be open.

The formal specification of the anonymity games is given in
\figref{fig:exp-uas-anonb}.

\begin{figure*}[htp!]
  \centering
  \scalebox{0.85}{
    \begin{minipage}[t]{0.5\textwidth}
      \procedure[linenumbering]{$\ExpIssAnonb(1^\secpar)$}{%
        (\parm,\trap) \gets \SimSetup(1^\secpar) \\
        b^* \gets \adv^{\OAnon,\OBTCHALb} (\parm) \\
        \pcreturn b^*
      }
    \end{minipage}
    
    \begin{minipage}[t]{0.5\textwidth}
      \procedure[linenumbering]{$\ExpSigAnonb(1^\secpar)$}{%
        (\parm,\trap) \gets \SimSetup(1^\secpar) \\
        b^* \gets \adv^{\OAnon,\CHALb} (\parm) \\
        \pcreturn b^*
      }
    \end{minipage}
  }
  \caption{Issuance and signature anonymity experiments for \UAS schemes.
    $\OAnon \gets (\lbrace\OO,\HU,\CU\rbrace\GEN,\ISET,\lbrace\II,
    \OO,\UU\rbrace\CORR,\OBTAIN,\WREG,\SIGN,\OPEN)$.}
  \label{fig:exp-uas-anonb}
\end{figure*}

\begin{definition}{(Issuance anonymity in \UAS)}
  \label{def:issue-anonymity-uas}  
  We define the advantage \AdvIssAnon of $\adv$ against \ExpIssAnonb as
  $\AdvIssAnon=|\Pr\lbrack\ExpIssAnono(1^\secpar)=1\rbrack-
  \Pr\lbrack\ExpIssAnonz(1^\secpar)=1\rbrack|$.
  %
  An \UAS scheme satisfies issuance anonymity if, for any p.p.t. adversary
  $\adv$, \AdvIssAnon is a negligible function of $1^\secpar$.
\end{definition}

\begin{definition}{(Signature anonymity in \UAS)}
  \label{def:sign-anonymity-uas}  
  We define the advantage \AdvSigAnon of $\adv$ against \ExpSigAnonb as
  $\AdvSigAnon=|\Pr\lbrack\ExpSigAnono(1^\secpar)=1\rbrack-
  \Pr\lbrack\ExpSigAnonz(1^\secpar)=1\rbrack|$.
  %
  An \UAS scheme satisfies signature anonymity if, for any p.p.t. adversary
  $\adv$, \AdvSigAnon is a negligible function of $1^\secpar$.
\end{definition}

\paragraph{Unforgeability.} \UAS inherits from AC schemes the notion that no
adversary can prove claims unless it owns credentials with the proper
attributes -- although, in \UAS, claims can be proven at issuance time, and
at signing time; from GS schemes, that only credential owners can produce valid
signatures. \UAS also has verifiable openings, and we must ensure that the
values output by \Open are correct and trace back to a user with consistent
credentials. All the previous is captured by an unforgeability property. We
define it by allowing the adversary to call any oracle, except the one for
corrupting issuers. The adversary wins if it produces a valid signature that:
(1) the produced signature leveraged a credential for
which the conditions required by \fissue were not satisfied; (2), opens to a
wrong value, or to a value that cannot be processed by \Judge; (3), is not
consistent with the expected \Yeval value; or (4), cannot be associated to
known credentials owned by a known user.
%
Note that, under this definition, we do not consider a forgery a credential that
was issued without meeting the issuance policy unless it is used to produce
a signature accepted by \Verify. Indeed, obtaining credentials that cannot be
used later does not seem to pose a threat in the real world. This approach,
which greatly simplifies the modelling, has also been used before (e.g.
\cite{ckl+15}).
%
\ExpForge is formally defined in \figref{fig:exp-uas-unfor}).

\begin{figure}[htp!]
  \centering
  \scalebox{0.85}{
    \begin{minipage}[t]{\textwidth}
%       \procedure[linenumbering]{$\ExpForgeIssue(1^\secpar)$}{%
%         (\parm,\trap) \gets \SimSetup(1^\secpar) \\
%         \cid \gets \adv^{\Oforgeissue}(\parm) \\
%         \pcif \trans[\cid] = \bot \lor \CRED[\cid] = \bot:
%         \pcreturn 0 \\
%         \textrm{Parse}~\trans[\cid]~\textrm{as}~(\yissue,\utrans);
%         \PUBIK[\cid]~\textrm{as}~((\cdot,\fissue),\cdot) \\
%         % (\usk,\sCred) \gets \ExtractIssue(\trap,\trans[\cid]) \\
%         ((\upk,\usk),\lbrace(\cid_i,\attrs_i,\cdot)\rbrace_{i \in [n]})
%         \gets \ExtractIssue(\trap,\utrans) \\
%         % \pcfor i \in [n]: (\usk_i,\cdot) \gets \ExtractIssue(\trap,
%         % \trans[\cid_i]) \\
%         % \pcif \exists i \in [n]~\suchthat~\usk \neq \usk_i: \pcreturn 1 \\
%         \pcif \fissue(\upk,\ATTR[\cid],\lbrace (\cid_i,\attrs_i)
%         \rbrace_{i\in[n]}) \neq \yissue:
%         \pcreturn 1 \\
%         \pcif \OWNR[\lbrace\cid_i\rbrace_{i\in[n]}\cup\cid] \notin \HU \cup \CU:
%         \pcreturn 1 \\
% %        \pcif \nexists \uid~\suchthat~\PUBUK[\uid]=\upk \land
% %        \uid \in \HU \cup \CU: \pcreturn 1 \\
% %        \pcif \OWNR[\cid] \notin \HU \cup \CU: \pcreturn 1 \\
%         \pcreturn 0
%       }
%       \vspace*{0.5em}
      
    % \end{minipage}    
    % \begin{minipage}[t]{\textwidth}
      \procedure[linenumbering]{$\ExpForge(1^\secpar)$}{%
        (\parm,\trap) \gets \SimSetup(1^\secpar) \\
        (\oid,\siid,\Sig=(\sig,\yeval),\msg,\feval) \gets \adv^{\Oforge}(\parm) \\
        \pcif \exists \uid~\suchthat~(\cdot,\cdot,\Sig,\cdot,\msg,\feval) \in
        \SIG[\uid]: \pcreturn 0 \\
        \pcif \Verify(\PUBOK[\oid],\PUBIK[\siid],\Sig,\msg,\feval) = 0:
        \pcreturn 0 \\
        (\yinsp,\iproof) \gets \Open(\PRVOK[\oid],\siid,\Sig,\msg) \\
        \pcif \Judge(\PUBOK[\oid],\PUBIK[\siid],\yinsp,\iproof,\Sig,\msg,\feval)
        = 0: \pcreturn 1 \\
        % (\usk,\sCred,\tyeval^1,\yinsp') \gets
        % \ExtractSign(\trap,\oid,\siid,\Sig,\msg,\feval) \\
        % \pcif \yinsp \neq \yinsp': \pcreturn 1 \\
        % \pcreturn 0
	(\upk,\usk,\lbrace(\cid_i,\attrs_i,\cdot)\rbrace_{i\in[n]},
        \yeval^1,\yinsp') \gets \ExtractSign(\trap,\oid,\siid,\Sig,\msg,\feval) \\
        \pcif \exists i\in[n]~\suchthat~
        \fissue(\upk,\cid_i,\attrs_i,\lbrace(\cid_{i,j},\attrs_{i,j})
        \rbrace_{j\in[n_i]}) \neq \yissue^i \lor
        \OWNR[\cid_i \cup \lbrace\cid_{i,j}\rbrace_{j\in[n_i]}]\notin \HU \cup \CU, \\
        \pcind \textrm{where}~(\yissue^i,\utrans) \gets \trans[\cid_i]~\textrm{and}~
        (\cdot,\cdot,\lbrace(\cid_{i,j},\attrs_{i,j},\cred_{i,j})
        \rbrace_{j\in[n_i]}) \gets \ExtractIssue(\trap,\utrans): \\
        \pcind \pcreturn 1 \\        
        (\yeval^0,\yeval^1) \gets \feval(\upk,\lbrace(\cid_i,\attrs_i)
        \rbrace_{i\in[n]}, \msg) \\
        \pcif \yeval \neq \yeval^0 \lor \yeval^1 \neq \tyeval^1:
        \pcreturn 1 \\
        \pcif \finsp((\yeval^0,\yeval^1),\upk,\lbrace(\cid_i,\attrs_i)
        \rbrace_{i\in[n]},\msg)
        \neq \yinsp \lor \yinsp \neq \yinsp':
        \pcreturn 1 \\
%        \textrm{Let~}\scid \gets \lbrace \cid_i \rbrace_{i\in[n]};
        \pcif \OWNR[\lbrace \cid_i \rbrace_{i\in[n]}] \notin \HU \cup \CU:
        \pcreturn 1 \\        
        \pcreturn 0        
      }      
    \end{minipage}
  }
  \caption{Unforgeability experiments in \UAS schemes.
    $\Oforge \gets \lbrace\OO,\HU,\CU\rbrace\GEN,\ISET,\lbrace\OO,\UU\rbrace
    \CORR,\OBTISS,\ISSUE,\RREG,\SIGN,\OPEN$.}
  \label{fig:exp-uas-unfor}
\end{figure}    

% \begin{figure}[htp!]
%     \procedure[linenumbering]{$\ExpForgeSign(1^\secpar)$}{%
%       (\parm,\trap) \gets \Setup(1^\secpar) \\
%       (\oid,\siid,\Sig=(\sig,\yeval),\msg,\feval) \gets \adv^{\Oforgesign}(\parm) \\
%       \pcif \exists \uid~\suchthat~(\cdot,\cdot,\Sig,\cdot,\msg,\feval) \in
%       \SIG[\uid]: \pcreturn 0 \\
%       \pcif \Verify(\PUBOK[\oid],\PUBIK[\siid],\Sig,\msg,\feval) = 0:
%       \pcreturn 0 \\
%       (\yinsp,\iproof) \gets \Open(\PRVOK[\oid],\siid,\Sig,\msg) \\
%       \pcif \Judge(\PUBOK[\oid],\PUBIK[\siid],\yinsp,\iproof,\Sig,\msg,\feval)
%       = 0: \pcreturn 1 \\
%       (\usk,\scred,\attrs_{\scred},\tyeval^1,\yinsp') \gets
%       \ExtractSign(\trap,\oid,\siid,\Sig,\msg,\feval) \\
%       % \Yeval=(\yeval^0,\yeval^1) \gets \feval(\usk,\scred,\msg) \\
%       % \pcif \yeval \neq \yeval^0 \lor \yeval^1 \neq \tyeval^1:
%       % \pcreturn 1 \\
%       % \pcif \finsp((\yeval^0,\yeval^1),\usk,\scred,\msg) \neq \yinsp:
%       % \pcreturn 1 \\
%       \uid \gets \IdentifyCred(\trap,\usk,\attrs_{\cred},\cred,\ipk_{\cred}) \\
%       \uid' \gets \IdentifySig(\trap,\usk,\scred,\Sig) \\
%       \pcif \uid \neq \uid' \lor \uid \notin \HU \cup \CU: \pcreturn 1 \\
%       %\pcif \exists \cred \in \scred~\suchthat~
% %      \IdentifyCred(\tau,\usk,\attrs_{\cred},\cred,\ipk_{\cred}) = 0:
%       % \pcreturn 1 \\
%       % \pcif \nexists \uid~\suchthat~\IdentifySig(\trap,\usk,\scred,\Sig) = 1:
%       % \pcreturn 1 \pccomment{\todo{\uid-\usk}} \\
%       \pcreturn 0
%     }
%   \caption{Experiment for unforgeability of signatures in \UAS schemes.}
%   \label{fig:exp-uas-unfor-sign}
% \end{figure}

% \begin{definition}{(Unforgeable issuance of \UAS)}
%   \label{def:issue-forge-uas}  
%   We define the advantage \AdvForgeIssue of $\adv$ against \ExpForgeIssue as
%   $\AdvForgeIssue=\Pr\lbrack\ExpForgeIssue(1^\secpar)=1\rbrack$.
%   %
%   A \UAS scheme has unforgeable issuance if, for any p.p.t. adversary $\adv$,
%   \AdvForgeIssue is a negligible function of $1^\secpar$.
% \end{definition}

% \begin{definition}{(Unforgeable signing of \UAS)}
%   \label{def:sign-forge-uas}  
%   We define the advantage \AdvForgeSign of $\adv$ against \ExpForgeSign as
%   $\AdvForgeSign=\Pr\lbrack\ExpForgeSign(1^\secpar)=1\rbrack$.
%   %
%   A \UAS scheme has unforgeable signing if, for any p.p.t. adversary $\adv$,
%   \AdvForgeSign is a negligible function of $1^\secpar$.
% \end{definition}

% For short, we say that an \UAS scheme that has both unforgeable issuance and
% signing, is an unforgeable \UAS scheme.

\begin{definition}{(Unforgeability of \UAS)}
  \label{def:forge-uas}  
  We define advantage \AdvForge of $\adv$ against \ExpForge as $\AdvForge=
  \Pr\lbrack\ExpForge(1^\secpar)=1\rbrack$.
  %
  A \UAS scheme is unforgeable if, for any p.p.t. adversary $\adv$, \AdvForge is
  a negligible function of $1^\secpar$.
\end{definition}

\paragraph{Non-frameability.} %
The notion of non-frameability in \UAS schemes is unavoidably more subtle than
in group signatures\footnote{As far as we know, non-frameability has not been
  considered in anonymous credential schemes. Thus, \UAS is the first scheme
  that concretely models what can we expect, unforgeability-wise, in the
  presence of malicious issuers in the AC domain.}. To see
this, note that, by allowing arbitrary evaluation and open functions to be used,
it can be perfectly valid to have a signature produced by a corrupted user
output the same \yeval or \yinsp values than the ones output when evaluating or
opening a signature by an honest user.
%
More generally, since the issuer is dishonest in non-frameability properties
and, in \UAS, the value produced by \Open may depend on the attributes
included in user credentials, the adversary may even be able to just produce
``legitimate'' openings that output any desired value. Note anyway that this is
a relevant property, as it tells us the minimal unforgeability expectations we
can have, even against malicious issuers and openers.

In the non-frameability definition for \UAS, given in experiment \ExpNonframe in
\figref{fig:exp-uas-frame}, the adversary is challenged to produce a signature
and opening proof that is accepted by \Verify and \Judge, respectively. From
the signature, we then extract the secret data used to generate it. The
adversary wins if the signature and opening proof are accepted, but the \yeval
or \yinsp values do not match what they should be based on the extracted data;
or if the signature can be associated to the secret key of an honest user who
did not produce it (i.e., no matching call to \SIGN exists).

\begin{figure}[htp!]  
  \centering
  \scalebox{0.85}{
    \procedure[linenumbering]{$\ExpNonframe(1^\secpar)$}{%
      (\parm,\trap) \gets \SimSetup(1^\secpar) \\
      (\oid,\siid,\Sig=(\sig,\yeval),\msg,\feval,\yinsp,\iproof) \gets
      \adv^{\Oframe}(\parm) \\
      \pcif \exists \uid~\suchthat~(\cdot,\cdot,\Sig,\msg,\feval) \in
      \SIG[\uid]: \pcreturn 0 \\
      \pcif \Verify(\PUBOK[\oid],\PUBIK[\siid],\Sig,\msg,\feval) = 0:
      \pcreturn 0 \\
      \pcif \Judge(\PUBOK[\oid],\PUBIK[\siid],\yinsp,\iproof,\Sig,\msg) = 0:
      \pcreturn 0 \\
      ((\upk,\usk),\lbrace(\cid_i,\attrs_i,\cdot)\rbrace_{i\in[n]},\tyeval^1,\yinsp') \gets
      \ExtractSign(\trap,\oid,\siid,\Sig,\msg,\feval) \\
      % \Yeval=(\yeval^0,\yeval^1) \gets \feval(\usk,\scred,\msg) \\
      % \pcif \yeval \neq \yeval^0 \lor \tyeval^1 \neq \yeval^1: \pcreturn 1 \\
      % \pcif \finsp(\Yeval,\usk,\scred,\msg) \neq \yinsp
      % \lor \yinsp \neq \yinsp': \pcreturn 1 \\
      \Yeval=(\yeval^0,\yeval^1) \gets \feval(\upk,\lbrace (\cid_i,
      \attrs_i)\rbrace_i{i\in[n]}, \msg) \\
      \pcif \yeval \neq \yeval^0 \lor \yeval^1 \neq \tyeval^1:
      \pcreturn 1 \\
      \pcif \finsp((\yeval^0,\yeval^1),\upk,\lbrace(\cid_i,\attrs_i)
      \rbrace_{i\in[n]},\msg)
      \neq \yinsp \lor \yinsp \neq \yinsp': \\
      \pcind \pcreturn 1 \\
      %\textrm{Let~}\scid \gets \lbrace \cid_i \rbrace_{i\in[n]};
      \pcif \OWNR[\lbrace \cid_i \rbrace_{i\in[n]}] \in \HU: % \land
      %(\cdot,\cdot,\Sig,\Yeval,\msg,\feval) \notin \SIG[\OWNR[\scid]]: \\
      \pcreturn 1 \\
      \pcreturn 0
    }
  }
  \caption{Experiment for non-frameability on \UAS schemes.
    $\Oframe \gets \lbrace\OO,\HU,\CU\rbrace\GEN,\ISET,\lbrace\II,\OO,\UU\rbrace
    \CORR,\WREG,\OBTAIN,\SIGN$.}
  \label{fig:exp-uas-frame}
\end{figure}

\begin{definition}{(Non-frameability of \UAS)}
  \label{def:frame-uas}
  We define the advantage \AdvNonframe of $\adv$ against \ExpNonframe as
  $\AdvNonframe=\Pr\lbrack\ExpNonframe(1^\secpar)=1\rbrack$.
  %
  An \UAS scheme satisfies non-frameability if, for any p.p.t. adversary $\adv$,
  \AdvNonframe is a negligible function of $1^\secpar$.
\end{definition}

% \paragraph{Tradeoffs in privacy and security.} %
% Note that, depending on how granular the behaviour and output of the \fissue,
% \feval and \finsp functions are, the less private the resulting \UAS
% instantiation would be, and vice versa. In some sense, this is captured in the
% model as, the more granular the outputs are, the more constrained is the
% adversary.
% %
% For instance, a \feval function that reveals all the attributes of the signing
% credentials provides even less privacy than a conventional signature scheme. Or
% a scheme that reveals all those attributes via \finsp is even more accountable
% that a vanilla group signature scheme, as it directly gives away more personal
% information than a public key.
% %
% Equivalent reasoning happens with \fissue, although there the behaviour (whether
% a request is accepted or not) is what is more telling, rather than the output
% of the function on its own.

% Similarly, unforgeability and non-frameability in \UAS cannot just be concerned
% on whether a signature is produced by a (set of) legitimately obtained
% credentials. It must also worry about whether the values output by \feval and
% \finsp are consistent. That is, a user who does not have a credential proving
% some claim, should not be able to prove it. Conversely, if a user does not own
% a credential that can produce some concrete \yeval or \yinsp values, should not
% be ``suspicious'' of having produced a signature with those values. Moreover,
% it may be possible that more than one user produces signatures evaluating (via
% \yeval) or opening (via \yinsp) to the same values -- and it does not mean that
% any of those users is being framed.

\subsection{\CUASGen: A Generic \UAS Construction}
\label{ssec:generic-construction-uas}

In this section, we give a generic construction of an \UAS scheme, based on
generic building blocks. We use three different NP relations:
\RelIss, \RelSig, and \RelIns, described next
and specified in CS notation \cite{cs97} in \figref{fig:nizkrels}.

\begin{description}
\item[\RelIss:] For NIZK proofs at issuance time. Requires users to
  prove knowledge of \usk and the related \upk. It also requires that any
  additional credential supporting the request be a valid credential (signed by
  some issuer) and bound to \upk, and enforces the corresponding \fissue policy.
\item[\RelSig:] For NIZK proofs at signing time. Ensures that
  signatures ``encode'' the correct signature evaluation and opening values, and
  that any credential used to create the signature is bound to the same \upk.
\item[\RelIns:] For NIZK proofs at opening time. Ensures that the
  utility information extracted by the \Open algorithm is correct.
\end{description}

\begin{figure}[ht!]
  \centering
  \scalebox{0.85}{
    \input{figures/nizk.tex}
  }
  \caption{CS specification of the NP relations used in \CUASGen.
    % $\boxed{x}$ means the issuer learns $x$, \dboxed{$y$} means the verifier
    % learns $y$, and \dotboxed{z} means the opener reveals $z$.
  }
  \label{fig:nizkrels}
\end{figure}

From them, we build \CUASGen as follows.

\paragraph{$\parm \gets \Setup(\secpar)$.} %
The setup process essentially generates the public parameters for all the
building blocks. It runs $\Cparm \gets \CSetup(\secpar)$, $\SBCMparm \gets
\SBCMSetup(\secpar)$, $\Eparm \gets \ESetup(\secpar)$, $\NIZKcrs_{\Issue} \gets
\NIZKSetup^{\NIZKRel_{\Issue}}(\secpar)$, $\NIZKcrs_{\Sign} \gets
\NIZKSetup^{\NIZKRel_{\Sign}}(\secpar)$, and $\NIZKcrs_{\Open} \gets
\NIZKSetup^{\NIZKRel_{\Open}}(\secpar)$. Return $(\Cparm,\SBCMparm,\Eparm,
\NIZKcrs_{\Issue},\NIZKcrs_{\Sign},\NIZKcrs_{\Open})$.

% \paragraph{$(\ipk,\isk) \gets \IKeyGen(\parm,\fissue)$.} %
% Each issuer first parses \parm as $(\cdot,\SBCMparm,
% \Sparm,\cdot,\cdot,\cdot,\cdot,\cdot)$. Then, runs $(\Svk,\Ssk) \gets
% \SKeyGen(\Sparm)$, $(\SBCMvk,\SBCMsk) \gets \SBCMKeyGen(\SBCMparm)$,
% $\sig_{\fissue} \gets \SSign(\Ssk,\fissue)$, $\ipk \gets (\SBCMparm,\Svk,
% \fissue,\sig_{\fissue})$, $\isk \gets \Ssk$ and return $(\ipk,\isk)$.

\paragraph{$(\upk,\usk) \gets \KeyGen(\parm)$.} %
Each user first parses \parm as $(\cdot,\SBCMparm,\cdot,\cdot,\cdot,\cdot)$.
Then, runs $(\SBCMvk,\SBCMsk) \gets \SBCMKeyGen(\SBCMparm)$, $\upk \gets (\parm,
\SBCMvk)$, $\usk \gets \SBCMsk$, and returns $(\upk,\usk)$.

\paragraph{$(\opk,\osk) \gets \OKeyGen(\parm,\finsp)$.} %
Each opener parses \parm as $(\cdot,\cdot,\Eparm,\cdot,\cdot,\cdot)$.
Then, runs $(\Eek,\Edk) \gets \EKeyGen(\Eparm)$, and sets, $\opk \gets (\Eek,
\finsp)$, and $\osk \gets \Edk$.

\paragraph{$\ipk \gets \ISet((\upk,\usk),\fissue)$.} %
A user willing to become an issuer just sets $\ipk \gets (\upk,\fissue)$, and
publishes \ipk. We assume that {\ipk}s are published in some properly (probably
authenticated) way.

\paragraph{$\langle \cred/\bot,\utrans/\bot \rangle \gets
  \langle\Obtain(\usk,\cidu,\ipk,\lbrace (\cid_i,\cattrs_i,\cred_i) \rbrace_{i\in[n]},
  \attrs),\Issue(\isk,\cidi,\lbrace \ipk_i \rbrace_{i\in[n]},\attrs)\rangle$.} %
The protocol is run between an issuer with key pair $(\ipk,\isk)$, and a user
with secret key \usk and credentials $\lbrace \cred_i \rbrace_{i\in[n]}$, where
each $\cred_i$ is issued by an issuer with public key $\ipk_i$, and
attests attributes $\cattrs_i$. The user requests a signature on a commitment to
the user key, as well as on $\cid=(\cidi,\cidu)$ and the attributes in \attrs.
In addition, the user proves correct computation of the \fissue function set by
the issuer based on the $\cred_i$ credentials and its user public key.
This is essentially achieved through an execution of an \SBCM interactive
signing protocol with \RelIss as NP relation. Since \fissue is
evaluated by the user, but depends on the \cidi value chosen by the issuer, the
issuer first needs to send \cidi.
Then both interact to produce the \SBCM signature, where the
user runs $\SBCMCom^{\NIZKRel_{\Issue}}(\ipk,\usk,(\cid,\attrs),\lbrace (\cid_i,
\cattrs_i,\cred_i)\rbrace_{i\in[n]},\lbrace \ipk_i \rbrace_{i\in[n]})$, and the
issuer runs $\SBCMSign^{\NIZKRel_{\Issue}}(\isk,(\cid,\attrs),\lbrace\ipk_i
\rbrace_{i\in[n]})$. Observe that, within this protocol, the user sends a NIZK
proof $\NIZKproof_{\Issue}$ ensuring that it knows a valid witness $(\upk,\usk,
\lbrace (\cid_i,\cattrs_i,\cred_i)\rbrace_{i \in [n]},r)$ for the relation
\RelIss. The credential \cred produced by the user is the result of
the interactive signing protocol, whereas the issuer produces $(\yissue,
\utrans)$, where \yissue is the output of \fissue, and \utrans is the
communication transcript of the signing protocol.% , which is a $(\Ccom,(\cid,\attrs),\lbrace
% \ipk_i \rbrace_{i\in[n]},\cred,\pi)$ tuple (see \appref{sapp:sbcm} for details).

\paragraph{$\Sig \gets \Sign(\usk,\opk,
  \sCred=(\lbrace (\cid_i,\cattrs_i,\cred_i,\ipk_i)\rbrace_{i\in[n]}),
  \msg,\feval)$.} %
In the signing algorithm, we make use of relation \RelSig.
% 
The user first evaluates $\Yeval = (\yeval^0,\yeval^1) \gets \feval (\upk,
\lbrace(\cid_i,\cattrs_i)\rbrace_{i\in[n]},\msg)$. Then, parses \opk as $(\Eek,
\finsp)$, computes $\yinsp \gets \finsp((\yeval^0,\yeval^1),\upk,
\lbrace(\cid_i,\cattrs_i)\rbrace_{i\in[n]},\msg)$, and encrypts
\yinsp by running $\cinsp \gets \EEnc(\Eek,\yinsp; r')$ for some fresh
randomness $r'$. Finally, the user
computes $\NIZKproof \gets \NIZKProve^{\NIZKRel_{\Sign}}(\NIZKcrs_{\Sign},(\usk,
\lbrace(\cid_i,\cattrs_i,\cred_i)\rbrace_{i\in[n]},\yeval^1,\yinsp,r),(\msg,
\feval,\yeval^0,\cinsp,\lbrace \ipk_i\rbrace_{i\in[n]},\Eek))$ and outputs
$(\sig = (\NIZKproof,\cinsp),\yeval^0)$. Note that, depending on the value of
\Yeval and \yinsp, the user may decide to abort
the signing if the resulting values are too privacy-threatening.

\paragraph{$1/0 \gets \Verify(\opk,\sipk=\lbrace\ipk_i\rbrace_{i\in[n]},
  \Sig,\msg,\feval)$.} %
The ``cryptographic'' side of the verification consists on checking
the NIZK proof. That is, parse \Sig as $(\sig = (\NIZKproof,\cinsp),\yeval)$ and
check whether $\NIZKVerify(\NIZKcrs,\NIZKproof,(\msg,\feval,\yeval,
\cinsp,\sipk,\opk)) = 1$. In addition, the verifier may further check
whether \yeval meets its needs.

\paragraph{$(\yinsp,\NIZKproof)/\bot \gets
  \Open(\osk,\sipk,\Sig,\msg,\feval)$.} %
Here we leverage relation \RelIns.
%
To open a signature, the opener first verifies the signature by running $\Verify
(\opk,\sipk, \Sig,\msg,\feval)$. If verification succeeds, it parses
\Sig as $(\sig=(\NIZKproof,\cinsp),\yeval)$, decrypts \Ec by running $\yinsp
\gets \EDec(\osk,\cinsp)$, and computes $\NIZKproof_{\Open} \gets
\NIZKProve^{\NIZKRel_{\Open}}(\NIZKcrs_{\Open},\osk,(\cinsp,\yinsp))$. It
returns $(\yinsp,\NIZKproof_{\Open})$.

\paragraph{$1/0 \gets \Judge(\opk,\yinsp,\NIZKproof,\Sig,\msg)$.} %
To assess the validity of an opening proof, first check the signature
by running $\Verify(\opk,\sipk,\Sig,\msg,\feval)$. If the check succeeds,
parse \Sig as $((\cdot,\cinsp),\cdot)$ and verify \NIZKproof with
$\NIZKVerify(\NIZKcrs_{\Open},\NIZKproof,(\cinsp,\yinsp))$. Accept it the NIZK
verification passes, and reject otherwise.

\subsection{Correctness and Security of \CUASGen}
\label{ssec:security-uas}

We state the correctness and security theorems next. For lack of space, we defer
the proofs to \appref{app:uas-proofs}.

\begin{theorem}[Correctness of \CUASGen]
  \label{thm:correctness-uas}
  If the underlying schemes for public-key encryption and \SBCM are correct, as
  well as the NIZKs for \RelIss, \RelSig,
  and \RelIns, our generic construction \CUASGen satisfies
  correctness as defined in \defref{def:correctness-uas}, except with negligible
  probability.
\end{theorem}

\begin{theorem}[Issuance anonymity of \CUASGen]
  \label{thm:issue-anonymity-uas}
  If the \SBCM scheme is blinding, the NIZK system used for \RelIss 
  is zero-knowledge, and \fissue is a \UAS-acceptable function, our \CUASGen
  construction satisfies issuance anonymity as defined in
  \defref{def:issue-anonymity-uas}, except with negligible probability.
\end{theorem}

\begin{theorem}[Signature anonymity of \CUASGen]
  \label{thm:sign-anonymity-uas}
  If the NIZK system used for \RelSig is zero-knowledge, and the
  public-key encryption scheme is IND-CCA secure, our \CUASGen construction
  satisfies signature anonymity as defined in \defref{def:sign-anonymity-uas},
  except with negligible probability.
\end{theorem}

% \begin{theorem}[Issuance unforgeability of \CUASGen]
%   \label{thm:issue-forge-uas}
%   If the underlying NIZK used for \RelIss is zero-knowledge,
%   simulation extractable and sound, then our \CUASGen construction satisfies
%   issuance unforgeability as defined in \defref{def:issue-forge-uas}.
% \end{theorem}

% \begin{theorem}[Signing unforgeability of \CUASGen]
%   \label{thm:sign-forge-uas}
%   If the underlying NIZK scheme for \RelSig is simulation
%   extractable, the scheme for \RelIns is complete, the public key
%   encryption algorithm is correct, and the \SBCM scheme is correct and one-more
%   unforgeable, then our \CUASGen construction satisfies signing unforgeability
%   as defined in \defref{def:sign-forge-uas}, except with negligible probability.
% \end{theorem}

\begin{theorem}[Unforgeability of \CUASGen]
  \label{thm:forge-uas}
  If the underlying NIZK system for \RelSig is simulation extractable, the NIZK
  system for \RelIns is complete, the public key encryption algorithm is
  correct, and the \SBCM scheme is correct and one-more unforgeable, then our
  \CUASGen construction satisfies unforgeability as defined in
  \defref{def:forge-uas}, except with negligible probability.
\end{theorem}

\begin{theorem}[Non-frameability of \CUASGen]
  \label{thm:frame-uas}
  If the underlying NIZK system for \RelSig is zero-knowledge and simulation
  extractable, the NIZK system for \RelIns is simulation-extractable, and the
  \SBCM scheme is blind, then our \CUASGen
  construction satisfies non-frameability as defined in \defref{def:frame-uas},
  except with negligible probability.
\end{theorem}

\markulf{Put proofs here for XXXX?}\jesus{I can't parse XXXX.}

\subsection{\CUASGen variants}
\label{ssec:variants}

In previous subsections, we have described our main construction \CUASGen. 
However, alternative constructions are of course possible that, while
still meeting the \UAS model, may differ from \CUASGen. We describe one such
variant next \CUASGenHideIss, that we leverage to build related schemes.
%
Similarly, we describe \CUASGenInt which transforms \CUASGen by turning the
non-interactive signature and verification processes into an interactive
protocol. Strictly speaking, the model changes, but the needed modifications
are minimal.
%
Security proofs are deferred to \appref{app:uas-proofs}.

\paragraph{\CUASGenHideIss: \RelSig with issuer hiding.} %
In \CUASGen it is required that the identity of the
issuer of each credential involved in a signature is revealed. This seems
reasonable for usual situations since, intuitively, it seems hard that a
verifier accepts a signature produced with a credential without knowing if the
credential's issuer is trustworthy. However, there may be cases in which
relaxations are acceptable. For instance, it may be enough to know that the
issuer belongs to some set of well-known issuers. Beyond practical applications,
this extension is also interesting from a theoretical point of view, as it
allows us to prove that ring signatures can be seen as a special case of a \UAS
scheme (cf. \secref{ssec:related-models-rs}). 

We show the modified NIZK relation for signing in \figref{fig:nizk-ring}. For
notational simplicity, we restrict to just one credential per signature.
%
Modelling-wise, no changes are needed. Perhaps notably, even in this case, the
anonymity property is still required to enforce that both challenge signatures
are associated to the same set of (potential) issuers -- otherwise, it is
trivial to distinguish signatures. Security for \CUASGenHideIss, based on
security of \CUASGen, is sketched in \appref{sapp:sec-hide-iss}.

\begin{figure}[ht!]
  \scalebox{0.85}{
    \input{figures/nizk-ring.tex}
  }
  \caption{$\NIZKRel^{hide-iss}_{\Sign}$ relation for \CUASGenHideIss.}
  \label{fig:nizk-ring}
\end{figure}

\paragraph{\CUASGenInt: Interactive Credential Presentations with replay
  protection.}
%
In group signatures, signing and verification are non-interactive processes;
whereas in anonymous credentials, they are an interactive protocol. \CUASGen
targets the non-interactive approach. Now, we sketch how to transform this into
an interactive protocol that ensures replay protection.

Modelling-wise, this requires to replace the \Sign and \Verify functions with
an interactive protocol $\langle 1/0,(\yeval,\utrans_{\Sig})/\bot \rangle \gets
\langle\Sign(\usk,\opk,\sCred,\msg,\feval), \Verify(\opk,\sipk,\msg,\feval)
\rangle$,
where $\utrans_{\Sig}$ is the transcript of the protocol, and is logged now in
an equivalent of the \SIG table (\CSIG for challenge transcripts). The \SIGN
and \CHALb oracles now also accept a random value from the adversary, but
are otherwise adapted in the natural way, where the signer is always honest, but
the verifier is played by the adversary (e.g., similar to the \OBTAIN oracle).

The construction is also simple. Basically, prior to signing the message, we
require that the verifier sends to the user a number picked uniformly at random
from an appropriate domain, which must be concatenated to the signed message. If
there is no need to actually sign a message, then the message is set to an empty
string, and the user only signs the random number.
%
If the logic within the \feval and \finsp functions needs to ignore the random
value $rnd$ sent by the verifier, note that it is trivial to transform these
functions so that they treat the message concatenated with $rnd$ as a pair
$(\msg,rnd)$, and simply ignore $rnd$.

We sketch security of \CUASGenInt in \appref{sapp:sec-interactive} assuming
the same security properties as in \UAS. Note that extra properties may be
needed in some scenarios. For instance, informally, the non-interactive version
does not provide deniability and, thus, our transform to the interactive case
does not provide it either. On the other hand, transferability is possible in
both cases, which may be useful, e.g., in situations where chaining multiple
requests is needed.
%
However, since probably the most common use of interactive presentations simply
worry about preventing replay attacks, we leave a more detailed analysis of
possible transforms (still meeting the \UAS model) out of scope.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "uas-paper"
%%% End:
