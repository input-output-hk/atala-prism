\section{Formalizing \UAS}
\label{sec:formal-uas}

% [11 pages max]

Next we formalize our notion of Universal Anonymous Signatures
(\UAS). We define its syntax, model, and give a generic construction, which
we prove secure according to our model. 

The main contribution of this section is giving a simple syntax and model that
still allow spanning a wide variety of related schemes. We combine aspects of GS
and AC schemes, generalizing whenever possible. Like in ACs, there are multiple
issuers, and each user can get one or more credentials from any of them; and,
also, use more than one credential simultaneously to produce a signature. We
incorporate openers, as in GSs, but there is no tight relationship between
issuer and opener. As a consequence, signers (potentially along with verifiers)
may choose, on a per-signature basis, the policies governing the utility
information extractable from a signature. Finally, we incorporate functions that
allow tweaking the conditions checked at credential issuance and signature
generation times, including the information that an opener will be able to
extract from a signature. This flexibilizes the scheme even beyond the loose
relationship between issuer and opener.

\subsection{Syntax}
\label{ssec:syntax-uas}

An \UAS scheme is composed by the following algorithms:

\begin{description}
\item[$\Setup(\secpar) \rightarrow \parm$.] Given a security parameter \secpar,
  returns a global system parameter variable \parm. We assume that \parm are
  available to all the other functions, even if not explicitly listed in their
  input parameters.
\item[$\IKeyGen(\parm,\fissue) \rightarrow (\ipk,\isk)$.] Given \parm, and the
  function \fissue for checking that credential requestors meet the conditions
  to be issued a credential, an issuer runs \IKeyGen to generate its issuing key
  pair. 
\item[$\OKeyGen(\parm,\finsp) \rightarrow (\opk,\osk)$.] Given \parm, and the
  function \finsp, an opener runs \OKeyGen to generate its opening key pair.
  The function \finsp defines the type of utility that will be extractable from
  signatures.
\item[$\UKeyGen(\parm) \rightarrow \usk$.] Given \parm, returns a user's secret
  key.
\item[$\langle
  \Obtain(\usk,\ipk,\scred,\attrs),
  \Issue(\isk,\sipk,\attrs))
  \rangle \rightarrow \langle \cred/\bot,\utrans/\bot \rangle$.] %
  This interactive protocol lets a user with key \usk running the \Obtain
  process, receive a credential \cred from an issuer in the system, on attribute
  set $\attrs$. The user leverages a set of credentials \scred, each with a
  matching issuer key in \sipk (ommitted in \Obtain for readability). The user
  outputs the produced credential \cred, while the issuer outputs the protocol
  transcript \utrans for the produced credential.
\item[$\Sign(\usk,\opk,\scred,\msg,\feval) \rightarrow (\sig,\yeval)$.] %
  Upon receiving a user secret key \usk, opener public key \opk, a set of
  credentials \scred, a message \msg and evaluation function \feval, returns
  signature \sig, and a plaintext value \yeval. For readability, we assume
  that, for each $\cred \in \scred$, we can get the corresponding issuer public
  key \ipk; also, we use use \Sig to denote the tuple $(\sig,\yeval)$.
\item[$\Verify(\opk, \sipk,\Sig,\msg,\feval) \rightarrow 1/0$.]
  Checks whether $\Sig = (\sig,\yeval)$ is a valid signature
  over message \msg, from a user with credentials issued by issuers with public
  keys in \sipk, for evaluation function \feval and opener key \opk.
\item[$\Open(\osk,\sipk,\Sig,\msg,\feval) \rightarrow
  (\yinsp,\iproof)/\bot$.]
  Executed by the opener with private key \osk. Receives a signature $\Sig=
  (\sig,\yeval)$ over message \msg and evaluation function \feval,
  generated using credentials issued by the issuers with public keys in \sipk.
  If \Sig is valid, the function outputs a value $\yinsp$, and a proof of
  correct opening \iproof.
\item[$\Judge(\opk,\sipk,\yinsp,\iproof,\Sig,\msg,\feval) \rightarrow 1/0$.] %
  Checks if \iproof is a valid opening correctness proof for the value \yinsp,
  obtained by applying \Open to the the signature $\Sig = (\sig,\yeval)$
  over message \msg, and for evaluation function \feval. 
\end{description}

\paragraph{Issuance, evaluation, and opening functions.} %
We introduce three functions in our syntax and model. Through them,
it is possible to modulate the behaviour of the resulting instantiation, by
controling the conditions upon which a new credential can be issued, or the
information revealed at signing time, or after signing. In all cases, it is
the user who computes them, and has to prove correctness of such computation.
We give concrete examples in \secref{sec:relationships}, and define them next:

\begin{description}
\item[$\fissue: (\usk,\attrs_{\scred},\attrs)
  \rightarrow 0/1$.] Chosen by each issuer within a family of functions
  \famfissue, the issuance function defines the customized conditions required
  by the issuer to grant a credential over attributes \attrs, when requested by
  a user with secret key \usk, potentially leveraging a set of previously
  obtained credentials with attributes $\attrs_\scred$. \fissue returns $1$ to
  accept a request, $0$ to reject it.
\item[$\feval: (\usk,\attrs_{\scred},\msg)
  \rightarrow (\yeval^0,\yeval^1)$.] Signing evaluation functions, from a
  family of functions \famfeval, can be set on a per-signature basis. They
  receive the user secret key \usk, a set $\attrs_{\scred}$ of attributes in the
  credenetial used for signing, and message to be signed
  \msg. \feval outputs two values, $\yeval^0$ and $\yeval^1$, where the former
  is revealed in plaintext along with the signature, and $\yeval^1$ is
  encrypted. Both can be used to modulate the bevahiour of \finsp, and must
  belong in a well defined set \rngfeval. For readability, we write $\Yeval =
  (\yeval^0,\yeval^1)$.
\item[$\finsp: (\Yeval,\usk,\attrs_{\scred},\msg) \rightarrow \yinsp$.]
  Chosen by openers from a family of functions \famfinsp. The opening
  functions define what utility value, derived from the user's secret key,
  credentials used for signing, and signed message, should be extractable by an
  opener. Its behaviour can be modulated by \Yeval, and it outputs a value
  \yinsp, which must belong in a well defined set \rngfinsp.
\end{description}

\feval and \finsp may seem redundant. However, observe that the former is chosen
on a per-signature basis, probably after negotiation between signer and
verifier. As such, it governs the information revealed at signing time. On the
other hand, \finsp governs the information that may be revealed after signing.
Moreover, it is defined by openers, and even though signers and verifiers
may negotiate to use any opener for a given signature, it is not possible for
an opener to change the chosen function.

\begin{definition}{(\CUASGen restrictions)}
  \label{def:uas-restrictions}
  Let \CUASGen be a construction of an \UAS scheme, secure according to
  the model defined in \secref{ssec:model-uas}, and three functions $\fissue^a$,
  $\feval^b$, $\finsp^c$ compatible with the previous definitions. We say that
  \CUASGen, instantiated with $\fissue^a$, $\feval^b$, and $\finsp^c$, is a
  $(\fissue^a,\feval^b,\finsp^c)$-restriction of \CUASGen.
\end{definition}

% To summarize the previous, we depict in \figref{fig:uas-signature} the structure
% of an \UAS signature, including its main components and how they enable the
% previously stated generalization claims.

% \begin{figure}[ht!]
%   \centering
%   %\input{figures/uas-signature.tex}
%   \caption{Structure of an \UAS signature.}
%   \label{fig:uas-signature}
% \end{figure}

\subsection{Security Model}
\label{ssec:model-uas}

We define the security expected from an \UAS scheme using a game-based approach.
An \UAS scheme must ensure privacy at credential issuance, meaning that two
runs of the credential issuance protocol should not leak any information beyond
necessary about the user requesting the credential. Note that this is now
crucial for privacy since, as AC schemes, \UAS allows multiple credentials per
user -- thus, knowing what user is requesting which credential can lead to user
profiling. It must also ensure signature privacy, meaning that no information
can be learned by third parties from a signature, beyond what the user chooses
to reveal, and what may be extractable by the chosen opener. Issuance
unforgeability requires that \UAS schemes ensure that the claims used to support
a credential request cannot be falsified (issuance unforgeability). Similarly,
signature unforgeability requires that no adversary should be able to falsify
the correctness proofs for the claims included in the signatures. In both cases
(issuance and signature unforgeability), we require all credentials involved in
the corresponding process to be associated to a known user. Finally, \UAS
schemes inherit the useful non-frameability property of GS schemes where even
the issuer is corrupt. In this case, we can ensure that no honest user
can be framed with having created a signature that s/he did not create --
although the concept may get a bit blurred, as there is no traditional opening.
%
We describe next the global variables and oracles that we use in our modelling.

\paragraph{Global Variables.} %
Users are referred to with user identifiers, \uid; for credentials, we use \cid;
for issuers, \iid; and for openers, \oid. In all cases, we use bold font to
denote sets: e.g., \scid and \siid denote sets of credential and issuer
identifiers. All tables/sets are initialized as empty tables/sets.

\begin{description}
\item[$\mathsf{H}\lbrace\mathsf{U},\mathsf{I},\mathsf{O} \rbrace$.] Keep
  track of honest users/issuers/openers. They are sets of
  {\uid}s/{\iid}s/{\oid}s.
\item[$\mathsf{C}\lbrace\mathsf{U},\mathsf{I},\mathsf{O} \rbrace$.] Keep
  track of corrupt users/issuers/openers. They are sets of
  {\uid}s/{\iid}s/{\oid}s.    
\item[\UK.] \UK maintains user keys $\usk$. To refer to the key of a specific
  user, we use $\UK[\uid]$. 
\item[\IK, \PUBIK and \PRVIK.] \IK maintains issuer key pairs, where
  $\IK[\iid]$ refers to the key pair of the issuer with identifier \iid. We
  use \PUBIK to refer to the public component, which also includes the \fissue
  function; and \PRVIK refers to the private component of the key pair.
\item[\OK, \PUBOK, \PRVOK.] Same as \IK, but for opener key pairs. Instead
  of \fissue, \OK includes the \finsp function.
\item[\CRED.] Stores information related to credentials obtained by users in
  the system. Thus, it is indexable by \cid. More specifically, it stores
  tuples of the form $(\uid,\cred,\iid,\attrs,\scid,\siid)$, where \uid is the
  identity of the owner of the credential, \cred (when available) is the
  credential itself, \iid is the identifier of the credential issuer, \attrs
  are the attributes included in \cred, \scid are the identifiers of the
  credentials (if any) that \uid used to request \cred, and \siid the issuers
  of those credentials. For notational
  convenience, we may use $\CRED[\scid]$ to refer to $\CRED[\cid]$ for all
  $\cid \in \scid$. Also, when clear from context, we sometimes use
  $\CRED[\cid]$ (resp. $\CRED[\scid]$ to mean \cred (resp. \scred) in
  $\CRED[\cid] = (\cdot,\cred,\cdot,\cdot,\cdot)$ (resp. $\CRED[\scid]$).
\item[\CCRED.] Like \CRED, but keeps track of challenge credentials in the
  issuance anonymity game.
\item[\OWNR.] For notational convenience, when we write $\OWNR[\cid]$ we mean
  ``\uid such that $\CRED[\cid] = (\uid, \cdot, \cdot, \cdot, \cdot)$''.
\item[\ATTR.] For notational convenience, when we write $\ATTR[\cid]$ we mean
  ``\attrs such that $\CRED[\cid] = (\cdot, \cdot, \cdot, \attrs, \cdot)$''.
\item[\ISR.] For notational convenience, when we write $\ISR[\cid]$ we mean
  ``\iid such that $\CRED[\cid] = (\cdot, \iid, \cdot, \cdot, \cdot)$''.
\item[\SIG.] Maintains signatures generated via the \SIGN oracle. Entries of
  this table are $(\oid,\scid,\sig,\Yeval,\msg,\feval)$ tuples, where \oid is
  the opener, \scid is the set of credentials used for
  signing, \feval is the signing evaluation function, and \sig and \msg are the
  produced signature and signed message.
\item[\CSIG.] Maintains challenge signatures output to the adversary in the
  signature anonymity game, and is indexable by challenge signatures \csig.
  Each entry contains also $\cuid_b$ and $\cscid_b$, respectively the challenge
  user  and credential identifiers set used to produce \csig; as well as the
  corresponding challenge user and credential set indexed by the complementary
  $1-b$; the signed message \msg and signing evaluation function \feval, the
  result of \feval, \Yeval, and the opener identifier \oid.
\end{description}

\paragraph{Oracles.} %
In the game-based definitions of our \UAS model, we leverage the following
oracles, which are formally defined in \figref{fig:oracles1} and
\figref{fig:oracles2}. 

\begin{description}
\item[\IGEN.] Adds a new issuer to the game, generating its keypair and setting
  the associated issuance function.
\item[\OGEN.] Adds a new opener to the game, generating its key pair and
  setting the associated evaluation and inspection functions.
\item[\ICORR.] Corrupts an existing (and honest) issuer, by giving its secret
  key to the adversary.
\item[\OCORR.] Corrupts an existing (and honest) opener, by giving its secret
  key to the adversary.  
\item[\HUGEN.] Adds a new honest user to the game, by honestly generating
  the user's key pair.
\item[\CUGEN.] Adds a new corrupt user to the game or, if the specified
  user already exists and is honest, corrupts it, leaking its key and
  credentials.
\item[\RREG.] Reads the given transcript table entry.
\item[\WREG.] Sets a transcript table entry to the given value.
\item[\OBTISS.] Lets the adversary add a new honestly generated credential to
  the game, on behalf of an honest user.
\item[\OBTAIN.] Enables the adversary to play the role of a dishonest issuer, by
  letting it interact with honest users who want to receive credentials.
\item[\ISSUE.] Allows the adversary to play the role of dishonest users,
  requesting an honest issuer to produce credentials for them.
\item[\SIGN.] Lets the adversary get signatures from credentials belonging
  to honest users.
\item[\OPEN.] Given an honestly produced signature, outputs the result of the
  opening function, along with a correctness proof.
\item[\OBTCHALb.] Upon receiving a target credential identifier, two challenge
  users and credential sets, an honest issuer identifier, and a set of
  attributes, issues a credential for the challenge user and credential set
  defined by the bit $b$. 
\item[\CHALb.] Upon receiving two challenge users and credential sets, a common
  singing evaluation function and a message, returns a signature produced by one
  of these two user and credential sets, defined by the bit $b$.
\end{description}

{%\setlength\intextsep{\sep}
  \begin{figure*}[htp!]
    \centering
    \scalebox{0.9}{

      \begin{minipage}[t]{0.55\textwidth}

        \procedure{$\IGEN(\iid,\fissue)$}{%
          \pcif \iid \in \HI \lor \iid \in \CI: \pcreturn \bot \\
          \pcif \fissue \notin \famfissue: \pcreturn \bot \\
          (\ipk,\isk) \gets \IKeyGen(\parm) \\
          \IK[\iid] \gets ((\ipk,\fissue),\isk) \\
          \HI \gets \HI \cup \lbrace \iid \rbrace \\
          \pcreturn \ipk \\
        }

        \procedure{$\ICORR(\iid)$}{%
          \pcif \iid \in \CI \lor \iid \notin \HI: \pcreturn \bot \\
          \HI \gets \HI \setminus \lbrace \iid \rbrace \\
          \CI \gets \CI \cup \lbrace \iid \rbrace \\
          \pcreturn \isk \\
        }        

        \procedure{$\HUGEN(\uid)$}{%
          \pcif \uid \in \HU \lor \uid \in \CU: \pcreturn \bot \\
          \usk \gets \UKeyGen(\parm) \\
          \UK[\uid] \gets \usk;
          \HU \gets \HU \cup \lbrace  \uid \rbrace \\
          \pcreturn \top \\
        }

        \procedure{$\RREG(i)$}{%
          \pcreturn \trans[i]
        }        
        
      \end{minipage}
    }
    \scalebox{0.9}{
      
      \begin{minipage}[t]{.5\textwidth}

        \procedure{$\OGEN(\oid,\finsp)$}{%
          \pcif \oid \in \HO \lor \oid \in \CO: \pcreturn \bot \\
          \pcif \finsp \notin \famfinsp: \pcreturn \bot \\
          (\opk,\osk) \gets \OKeyGen(\parm) \\
          \OK[\oid] \gets ((\opk,\finsp),\osk) \\
          \HO \gets \HO \cup \lbrace \oid \rbrace \\
          \pcreturn \opk \\
        }

        \procedure{$\OCORR(\oid)$}{%
          \pcif \oid \in \CO \lor \oid \notin \HO: \pcreturn \bot \\
          \pcif \exists (\oid,\cdot,\cdot,\cdot,\cdot,
          \cdot,\cdot,\cdot,\cdot) \in \CSIG: \pcreturn \bot \\
          \HO \gets \HO \setminus \lbrace \oid \rbrace \\
          \CO \gets \CO \cup \lbrace \oid \rbrace \\
          \pcreturn \osk \\
        }        
        
        \procedure{$\CUGEN(\uid)$}{%          
          \pcif \uid \in \CU: \pcreturn \bot \\
          \CU \gets \CU \cup \lbrace \uid \rbrace \\          
          \pcif \uid \in \HU: \\
          \pcind \HU \gets \HU \setminus \lbrace \uid \rbrace; \\
          \pcind \pcreturn (\UK[\uid],\CRED[\uid]) \\
          \pcelse: \UK[\uid] = \bot \\          
          \pcreturn \top \\
        }

        \procedure{$\WREG(i,\rho)$}{%
          \trans[i] \gets \rho
        }        
        
      \end{minipage}
      
    }

    \caption{Detailed oracles available in our model (1/2). Oracles for
      generating key material for users, issuers, and openers.}
    \label{fig:oracles1}
  \end{figure*}
}

{%\setlength\intextsep{\sep}
  \begin{figure*}[htp!]
    \centering
    \scalebox{0.9}{

      \begin{minipage}[t]{0.55\textwidth}

        \procedure{$\OBTISS(\cid,\uid,\iid,\attrs,\scid)$}{%
          \pcif \uid \notin \HU: \pcreturn \bot \\
          \pcif \iid \notin \HI: \pcreturn \bot \\
          \pcif \exists \cid' \in \scid~\suchthat~\cid' \in \CCRED: \pcreturn \bot \\
          \pcif \CRED[\cid] \neq \bot \lor \CCRED[\cid] \neq \bot: \pcreturn \bot \\
          \langle \cred, \utrans \rangle \gets
          \langle \Obtain(\UK[\uid],\CRED[\scid],\attrs), \\
          \hspace*{60pt} \Issue(\PRVIK[\iid],\ISR[\scid],\attrs)
          \rangle \\
          \trans[\cid] \gets \utrans \\
          \CRED[\cid] \gets (\uid, \cred, \iid, \attrs, \scid, \siid) \\
          \pcreturn \top \\
        }

        \procedure{$\ISSUE(\cid,\uid,\iid,\attrs,\siid)$}{%
          \pcif \uid \notin \CU: \pcreturn \bot \\          
          \pcif \iid \notin \HI: \pcreturn \bot \\
          \pcif \CRED[\cid] \neq \bot \lor \CCRED[\cid] \neq \bot: \pcreturn \bot \\
          \langle \cdot, \utrans \rangle \gets
          \langle \adv, 
          \Issue(\PRVIK[\iid],\siid,\attrs) \rangle \\
          \trans[\cid] \gets \utrans \\
          \CRED[\cid] \gets (\uid, \cdot, \iid, \attrs, \cdot, \siid) \\
          \pcreturn \top \\          
        }

        \procedure{$\SIGN(\uid,\oid,\scid,\msg,\feval)$}{%
          \pcif \uid \notin \HU: \pcreturn \bot \\
          \pcif \exists \cid,\cid' \in \scid~\suchthat~\cid \in \CRED \land
          \cid' \in \CCRED: \\
          \pcind \pcreturn \bot \\
          \pcif \feval \notin \famfeval: \pcreturn \bot \\
          \Sig \gets \Sign(\UK[\uid],\PUBOK[\oid],\CRED[\scid],\msg,\feval) \\
          \Yeval=(\yeval^0,\yeval^1) \gets \feval(\UK[\uid],\CRED[\scid],\msg) \\
          \pcif \Yeval \notin \rngfeval: \pcreturn \bot \\
          \SIG[\uid] \gets \SIG[\uid] \cup
          \lbrace (\oid,\scid,\Sig,\Yeval,\msg,\feval) \rbrace \\
          \pcreturn \Sig \\
        }        

        \procedure{$\OPEN(\oid,\Sig,\msg)$}{%
          \textrm{Let}~\uid~\textrm{be s.t.}~(\oid,\scid,\Sig,\Yeval,\msg,\feval)
          \in \SIG[\uid] \\
          (\yinsp,\iproof) \gets
          \Open(\PRVOK[\oid],\PUBIK[\scid],\Sig,\msg,\feval) \\
          \pcif \CSIG[\Sig] \neq \bot: \\
          \pcind \textrm{Parse $\CSIG[\Sig]$ as $(\oid,\cuid_b,\scid_b,
            \Yeval,\msg,\feval$} \\          
          \hspace*{83pt}\cuid_{1-b},\cSig_{1-b},\scid_{1-b},
          \TYeval) \\
          \pcind (\tyinsp,\tiproof) \gets
          \Open(\PRVOK[\oid],\IK[\siid],\\
          \hspace*{107pt} \cSig_{1-b},\msg,\feval) \\
          \pcind \pcif \tyinsp \neq \yinsp: \pcreturn \bot \\
          \pcreturn (\yinsp,\iproof)
        }
        
      \end{minipage}
    }
    \scalebox{0.9}{
      
      \begin{minipage}[t]{.5\textwidth}

        \procedure{$\OBTAIN(\cid,\uid,\iid,\attrs,\scid)$}{%
          \pcif \uid \notin \HU: \pcreturn \bot \\
          \pcif \iid \notin \CI: \pcreturn \bot \\
          \pcif \exists \cid' \in \scid~\suchthat~\cid' \in \CCRED: \pcreturn \bot \\
          \pcif \CRED[\cid] \neq \bot \lor \CCRED[\cid] \neq \bot: \pcreturn \bot \\
          \langle \cred, \cdot \rangle \gets
          \langle \Obtain(\UK[\uid],\PUBIK[\iid],\CRED[\scid],\attrs),\adv \rangle \\
          \CRED[\cid] \gets (\uid, \cred, \iid, \attrs, \scid, \siid) \\
          \pcreturn \top \\
        }

        \procedure{$\OBTCHALb(\cid,\cuid_{0,1},\iid,\attrs,\cscid_{0,1})$}{%
          \pcif \cuid_0 \notin \HU \lor \cuid_1 \notin \HU: \pcreturn \bot \\
          \pcif \iid \notin \CI: \pcreturn \bot \\
          \pcif \CRED[\cid] \neq \bot: \pcreturn \bot \\
          \pcif \pcfor d \in \bin,~ \exists \cid' \in \cscid_d~\suchthat~\cid'
          \in \CRED: \\
          \pcind \pcreturn \bot \\
          \pcif \PUBIK[\cscid_0] \neq \PUBIK[\cscid_1]: \pcreturn \bot \\
          \textrm{Parse}~\PUBIK[\iid]~\textrm{as}~((\cdot,\fissue),\cdot) \\
          \pcif \fissue(\UK[\cuid_0],\cscid_0,\attrs) \neq
          \fissue(\UK[\cuid_1],\cscid_1,\attrs) \\
          \langle \cred, \cdot \rangle \gets
          \langle \Obtain(\UK[\cuid_b],\PUBIK[\iid],\CRED[\cscid_b],\attrs),\adv \rangle \\
          \CCRED[\cid] \gets (\cuid_b, \cred, \iid, \attrs, \cscid_b, \siid) \\
          \pcreturn \top \\
        }

        \procedure{$\CHALb(\cuid_{0,1},\oid,\cscid_{0,1},\msg,\feval)$}{%
          \pcif \cuid_0 \notin \HU \lor \cuid_1 \notin \HU: \pcreturn \bot \\
          \pcif \pcfor d \in \bin~ \exists \cid,\cid' \in \scid_d~\suchthat \\
          \pcind \cid \in \CRED \land \cid' \in \CCRED: \pcreturn \bot \\
          \pcif \oid \in \CO: \pcreturn \bot \\
          \pcif \feval \notin \famfeval: \pcreturn \bot \\          
          \Yeval = (\yeval^0,\yeval^1) \gets \feval(\UK[\cuid_0],\CRED[\cscid_0],
          \msg) \\
          \TYeval = (\tyeval^0,\tyeval^1) \gets
          \feval(\UK[\cuid_1],\CRED[\cscid_1],\msg) \\
          \pcif \yeval^0 \neq \tyeval^0: \pcreturn \bot \\
          \pcif \Yeval \notin \rngfeval \lor \TYeval \notin \rngfeval:
          \pcreturn \bot \\
          \pcif \PUBIK[\cscid_0] \neq \PUBIK[\cscid_1]: \pcreturn \bot \\
          \cSig_b \gets \Sign(\UK[\cuid_b],\PUBOK[\oid], \\
          \hspace*{71pt}\CRED[\cscid_b],\msg,\feval) \\
          \cSig_{1-b} \gets \Sign(\UK[\cuid_{1-b}],\PUBOK[\oid], \\
          \hspace*{80pt}\CRED[\cscid_{1-b}],\msg,\feval) \\          
          \CSIG[\cSig_b] \gets 
          \lbrace (\oid,\cuid_b,\cscid_b,\Yeval,\msg,\feval,\\
          \hspace*{74pt}\cuid_{1-b},\cSig_{1-b},\cscid_{1-b},\TYeval)\rbrace \\
          \pcreturn \cSig_b
        }
        
      \end{minipage}
      
    }

    \caption{Detailed oracles available in our model (2/2). Oracles for
      obtaining credentials, signatures, and processing them.}
    \label{fig:oracles2}
  \end{figure*}
}

\paragraph{Helper functions \SimSetup, \ExtractIssue, \ExtractSign,
  \IdentifyCred, and \IdentifySig.} We assume the existence of these helper
functions. They are not functions available in the actual scheme, but rather to
the challenger in the experiments we use to formalize security of \UAS schemes.
Consequently, while we introduce them here and specify some conditions they need
to meet, their full definition is dependent on the construction. We fully define
them for our generic construction \CUASGen in \appref{app:uas-proofs}. Similar
techniques have been used before to prove security in privacy-preserving schemes
with some sort of accountability, but that do not offer conventional opening as
vanilla group signatures. For instance, see related works on DAA
\cite{bfg+11,cdl16} and group signature variants \cite{dl21,fgl21,gl19,lnpy21}.
More concretely, these functions are as follows:

\begin{description}
\item[$\SimSetup(1^\secpar) \rightarrow (\parm,\trap)$.] Given a security
  parameter, outputs global (simulated) parameters \parm whose distribution is
  indistinguishable to that produced by the \Setup algorithm, as well as a
  trapdoor \trap.
\item[$\ExtractIssue(\trap,\utrans) \rightarrow (\usk,\attrs_{\scred},\scred)$.]
  Receives trapdoor \trap and an $\langle \Obtain, \Issue \rangle$ transcript,
  and returns the credentials (if any) and their attributes involved in the
  request. It needs an honest issuer as, otherwise, the transcripts won't be
  available. 
\item[$\ExtractSign(\trap,\oid,\siid,\Sig,\msg,\feval) \rightarrow (\usk,
  \scred,\attrs_{\scred},\yeval^1,\yinsp)$.] Receives a trapdoor \trap, a
  signature \Sig,
  as well as the opener identifier \oid, and the identifiers of all issuers of
  the credentials used to produce the signature over \msg, and for \feval.
  It outputs the user secret key and credentials (with their attributes) used to
  generate the signature, and the $\yeval^1$ and \yinsp values.
\item[$\IdentifyCred(\trap,\usk,\attrs_{\cred},\cred,\ipk)$.] Returns $1$ if
  \cred has been issued over attributes $\attrs_{\cred}$ and for a user with
  secret key \usk, by honest issuer with public key \ipk. Otherwise, it returns
  $0$.

  The \IdentifyCred function defined by \UAS constructions must satisfy that
  for any \cred obtained as the result of an $\langle \Obtain,\Issue \rangle$
  interaction with an honest issuer, there exists \emph{exactly one} set of
  $(\usk,\attrs_{\cred})$ such that \IdentifyCred equals $1$.
  %In order to be meaningful, this requires that,
  %for every $(\attrs_{\cred},\cred)$ pair, there is at most one \usk that makes
  \IdentifyCred return $1$.
\item[$\IdentifySig(\trap,\usk,\scred,\Sig)$.] Returns $1$ is $(\usk,\scred)$
  are the secret key and credential set used to produce \Sig, otherwise, returns
  $0$.

  The \IdentifySig function defined by \UAS constructions must satisfy that, for
  signatures accepted by \Verify, there must exist \emph{exactly one} $(\usk,
  \scred)$ combination that makes \IdentifySig return $1$.
  % . This is trivial for honest users, for which there must be a one-to-one
  % relationship between {\uid}s and {\usk}s. For corrupt users, \IdentifyUK has
  % to iterate through the $\langle\Obtain,\Issue\rangle$ transcripts associated
  % to \uid, extract the used secret key, and check if there is a match. In the
  % latter case, there is no guarantee of getting a one-to-one relationship
  % between \usk and \uid. Also, when used for corrupt users, this can only be
  % used when the issuer is honest, as transcripts are needed. 
\end{description}

% Note that, for all the helper functions, in the case of credentials, transcripts,
% and signatures by honest users, it is enough to have access to the corresponding
% state information (described below) maintained by the challenger in our
% experiments. For credentials and join transcripts of corrupt users, or
% dishonestly produced signatures, we do need to perform actual extraction.
% Certainly, the challenger
% needs special knowledge/power such as decryption trapdoors, the ability to
% rewind the game, or program random oracles. The approach needs thus to depend on
% the concrete construction. \jdv{Although, for the case of \ExtractIssue and
%   \IdentifyUK, online extractability (or alternative requirements, such as
%   non-parallel or logarithmic number of joins) is necessary.}

\paragraph{Correctness.} %
Correctness of \UAS schemes is formalized through the experiment in
\figref{fig:exp-uas-corr}. It states that a signature over any arbitrary message
and valid function \feval, produced honestly leveraging credential set \scid,
owned by user \uid, is accepted by \Verify. Moreover, all the credentials in
\scid meet the conditions set by the corresponding \fissue defined by the issuer
which issued each credential. Similarly, the output of \feval matches the
value produced by \Sign alongside with \sig; and the value produced by \Open
is accepted by \Judge, and matches the output of applying \finsp on \Yeval, the
credentials, user key, and message.

\begin{definition}{(Correctness of \UAS)}
  \label{def:correctness-uas}
  An \UAS scheme is correct if, for any p.p.t. adversary $\adv$,
  $\ExpCorrect(1^\secpar)$ outputs 1 with negligible probability.
\end{definition}

\begin{figure}[htp!]
  \procedure[linenumbering]{$\ExpCorrect(1^\secpar)$}{%
    \parm \gets \Setup(1^\secpar) \\
    (\uid,\oid,\scid,\msg,\feval)
    \gets \adv^{\IGEN,\OGEN,\HUGEN,\OBTISS,\RREG}(\parm) \\
    \pcif \feval \notin \famfeval: \pcreturn 0 \\
    \pcif \OWNR[\scid] \neq \uid: \pcreturn 0 \\
    (\Sig = (\sig,\yeval)) \gets \Sign(\UK[\uid],\PUBOK[\oid],\scid,\msg,
    \feval) \\
    \pcif \Verify(\PUBOK[\oid],\PUBIK[\scid],\Sig,\msg,\feval) = 0: \pcreturn 1 \\
    \pcfor \cid \in \scid \pcdo: \\
    \pcind \textrm{Let}~\scred^{\cid}~\textrm{be the credentials used to obtain}
    ~\cid;~\textrm{Parse}~\PUBIK[\ISR[\cid]]~\textrm{as}~((\cdot,\fissue^{\cid}),\cdot)\\
    \pcind \pcif \fissue^{\cid}(\UK[\uid],\scred^{\cid},\ATTR[\cid]) = 0: \pcreturn 1 \\
    (\yeval^0,\yeval^1) \gets \feval(\UK[\uid],\CRED[\scid],\msg) \\
    \pcif \yeval^0 \neq \yeval: \pcreturn 1 \\
    (\yinsp,\iproof) \gets \Open(\PRVOK[\gid],\PUBIK[\scid],\Sig,\msg,\feval) \\
    \pcif \Judge(\PUBOK[\oid],\PUBIK[\scid],\yinsp,\iproof,\Sig,\msg,\feval)
    = 0~\lor \\
    \pcind \yinsp \neq \finsp^\gid((\yeval,\yeval^1),\UK[\uid],\CRED[\scid],\msg)): \\
    \pcind \pcreturn 1 \\
    \pcreturn 0
  }  
  \caption{Correctness experiment for \UAS schemes.}
  \label{fig:exp-uas-corr}
\end{figure}

\subsubsection{Security Properties}
\label{sssec:security}

Security of an \UAS scheme is defined in terms of anonymity, unforgeability and
non-frameability. Where the first two have variants covering issuance and
signatures \todo{argue why issuance non-frameability does not make sense}.
%
However, as stated, we make use of some helper functions: \ExtractIssue and
\ExtractSign, which let us recover the witnesses used to produce a credential
or a signautre; and \IdentifyCred, and \IdentifySig, which associate credentials
and signatures to user identifiers \uid. Both types of functions have been used
before. For instance, the extraction-type are used in \cite{lnpy21,nps22}, and
functions of the identify-type are used in \cite{bfg+11,cdl16,gl19,dl21,fgl21}.
\todo{Re-write after done.} Indeed, it seems hard to avoid resorting to these
techniques when there is no traditional notion of opening.

\paragraph{Extractability.} %
We require that the witnesses used to produce each credential and signature can
be extracted from the corresponding \utrans and signature, respectively.
Furthermore, in order for our generalized notion of utility to have meaning, it
is required that, whenever a credential is issued by an honest issuer, or a
signature is accepted by \Verify, the extracted values produce the same value as
the chosen \fissue, \feval and \finsp functions. We capture this in the
\ExpExtractIssue and \ExpExtractSign games, which are crucial in the
unforgeability and non-frameability requirements.

\begin{figure*}[htp!]
  \centering
  \scalebox{0.9}{
    \begin{minipage}[t]{0.6\textwidth}
      \procedure[linenumbering]{$\ExpExtractIssue(1^\secpar)$}{%
        (\parm, \trap) \gets  \SimSetup(1^\secpar) \\
        \cid \gets \adv^{\todo{\OExtIss}}(\parm) \\
        (\usk,\scred,\attrs_{\scred}) \gets \ExtractIssue(\trap,\trans[\cid]) \\
        \pcif \fissue(\usk,\scred,\ATTR[\cid]) = 0: \pcreturn 1 \\
        \pcreturn 0
      }
    \end{minipage}
    \vspace*{0.5em}
    
    \begin{minipage}[t]{0.5\textwidth}
      \procedure[linenumbering]{$\ExpExtractSign(1^\secpar)$}{%
        (\parm, \trap) \gets \SimSetup(1^\secpar) \\
	(\oid,\siid,\Sig=(\sig,\yeval),\msg,\feval) \gets
        \adv^{\todo{\OExtSig}}(\parm) \\
	\pcif \Verify(\oid,\siid,\Sig,\msg,\feval) = 0: \pcreturn 0 \\
	(\usk,\scred,\attrs_{\scred},\yeval^1,\yinsp) \gets        
        \ExtractSign(\trap,\oid,\siid,\Sig,\msg,\feval) \\
        (\yeval^0,\yeval^1) \gets \feval(\usk,\scred,\msg) \\
        \pcif \yeval \neq \yeval^0 \lor \yeval^1 \neq \tyeval^1:
        \pcreturn 1 \\
        \pcif \finsp((\yeval^0,\yeval^1),\usk,\scred,\msg) \neq \yinsp:
        \pcreturn 1 \\
	\pcreturn 0
      }
    \end{minipage}
  }
  \caption{Extractability experiments for \UAS schemes.}
  \label{fig:exp-uas-extract}
\end{figure*}

\paragraph{Identifiability.} %
On their own, the extractability properties only ensure that the produced
credentials and signatures have been produced by leveraging knowledge of some
witnesses. However, they do not establish any relationship between those
witnesses and the identity of their owner(s). While the way in which witnesses
are associated to user identifiers\footnote{We avoid the term \emph{user
    identity}, as that is very context-specific.} is dependent on the
construction, we impose some constraints that all schemes need to satisfy.
Namely, it must be possible to associate any credential (obtained from an honest
issuer), or any signature accepted by \Verify, to exactly one user identifier.

\begin{figure*}[htp!]
  \centering
  \scalebox{0.9}{
    \begin{minipage}[t]{0.6\textwidth}
      \procedure[linenumbering]{$\ExpIdentifyCred(1^\secpar)$}{%
        (\parm, \trap) \gets  \SimSetup(1^\secpar) \\
        \cid \gets \adv^{\todo{\OIdCred}}(\parm) \\
        (\usk,\scred,\attrs_{\scred}) \gets \ExtractIssue(\trap,\trans[\cid]) \\
        \suid \gets \IdentifyCred(\trap,\usk,\scred,\attrs_{\scred},\ipk_{\cred}) \\
        \pcif |\suid| \neq 1: \pcreturn 1 \\
        \pcreturn 0
      }
    \end{minipage}
    \vspace*{0.5em}
    
    \begin{minipage}[t]{0.5\textwidth}
      \procedure[linenumbering]{$\ExpIdentifySign(1^\secpar)$}{%
        (\parm, \trap) \gets \SimSetup(1^\secpar) \\
	(\oid,\siid,\Sig,\msg,\feval) \gets \adv^{\todo{\OIdSig}}(\parm) \\
	\pcif \Verify(\oid,\siid,\Sig,\msg,\feval) = 0: \pcreturn 0 \\
	(\usk,\scred,\attrs_{\scred},\yeval^1,\yinsp) \gets
        \ExtractSign(\trap,\oid,\siid,\Sig,\msg,\feval) \\
	\suid \gets \IdentifySig(\trap,\usk,\scred,\Sig) \\
	\pcif |\suid| \neq 1: \pcreturn 1 \\
	\pcreturn 0
      }
    \end{minipage}
  }
  \caption{Identifiability experiments for \UAS schemes.}
  \label{fig:exp-uas-identify}
\end{figure*}

\begin{definition}{(Identifiable credentials in \UAS)}
  \label{def:identify-cred-uas}  
  We define the advantage \AdvIdCred of $\adv$ against \ExpIdentifyCred as
  $\AdvIdCred=|\Pr\lbrack\ExpIdentifyCred(1^\secpar)=1\rbrack-
  \Pr\lbrack\ExpIdentifyCred(1^\secpar)=1\rbrack|$.
  %
  An \UAS scheme satisfies identifiable credentials if, for any p.p.t. adversary
  $\adv$, \AdvIdentifyCred is a negligible function of $1^\secpar$.
\end{definition}

\begin{definition}{(Identifiable signatures in \UAS)}
  \label{def:identify-sig-uas}  
  We define the advantage \AdvIdSig of $\adv$ against \ExpIdentifySign as
  $\AdvIdSig=|\Pr\lbrack\ExpIdentifySign(1^\secpar)=1\rbrack-
  \Pr\lbrack\ExpIdentifySign(1^\secpar)=1\rbrack|$.
  %
  An \UAS scheme satisfies identifiable signature if, for any p.p.t. adversary
  $\adv$, \AdvIdSig is a negligible function of $1^\secpar$.
\end{definition}

\paragraph{Anonymity.} %
Users may see their privacy compromised through their interactions with issuers
to request a credential, or via the signatures they produce. Thus, we define two
games to define the privacy expected in those situations.

The issuance anonymity game captures that, given polymomially many
credential issuance interactions, the adversary gains no information about the
user(s) behind them. For this, we allow the adversary to control targetted
issuers and openers (although it may also add honest ones), and add honest and
corrupt users. The adversary can also obtain credentials, produce signatures,
and open them. We need to make some limitations to prevent trivial wins: first,
when querying the oracle for obtaining a challenge credential out of two
possible user-credential set pairs, the issuance protocol must either succeed or
fail for both; also, the adversary can open signatures produced with credential
sets containing challenge credentials $\cred_b$, only if the output of \Open is
the same as with the complementary $\cred_{1-b}$ (note that any other signature
can be open).
Intuitively, if the adversary cannot distinguish arbitrary runs with all oracles
(provided the previous constraint) when he gets challenge credentials $\cred_b$
from runs with credentials $\cred_{1-b}$, then the issuance protocol is
privacy-preserving.

The signature anonymity game is similar to the traditional one in GS schemes.
It captures that the signatures produced by system users do not leak information
about their identity beyond what is already revealed via $\yeval^0$ and what
may be revealed via \yinsp. Concretely, the adversary can interact with oracles
as in the issuance anonymity game, except that instead of obtaining challenge
credentials, it obtains challenge signatures. These signatures must have been
produced via the \CHALb oracle, which ensures that the $\yeval^0$ value is the
same for both input sets -- otherwise, rejects creating the signature. We also
allow opening signatures; even challenge $\cSig_b$ signatures, as long as the
\yinsp value of the counterpart $\cSig_{1-b}$ is the same. Note that this is
stronger than the traditional CCA-like security of group signatures, where no
challenge signature can be open.

The formal specification of the anonymity games is given in
\figref{fig:exp-uas-anonb}, where
$\OIssAnon \gets (\lbrace\HU,\CU\rbrace\GEN,\lbrace\II,\OO\rbrace\GEN,\lbrace\II,
\OO\rbrace\CORR,\OBTAIN,\WREG,\SIGN,\OPEN,\OBTCHALb)$, and $\OSigAnon
\gets (\lbrace\HU,\CU\rbrace\GEN,\lbrace\II,\OO\rbrace\GEN,\lbrace\II,\OO\rbrace
\CORR,\OBTAIN,\WREG,\SIGN,\OPEN,\CHALb)$.

\begin{figure*}[htp!]
  \centering
  \scalebox{0.9}{
    \begin{minipage}[t]{0.5\textwidth}
      \procedure[linenumbering]{$\ExpIssAnonb(1^\secpar)$}{%
        (\parm,\trap) \gets \SimSetup(1^\secpar) \\
        b^* \gets \adv^{\OIssAnon} (\parm) \\
        \pcreturn b^*
      }
    \end{minipage}
    
    \begin{minipage}[t]{0.5\textwidth}
      \procedure[linenumbering]{$\ExpSigAnonb(1^\secpar)$}{%
        (\parm,\trap) \gets \SimSetup(1^\secpar) \\
        b^* \gets \adv^{\OSigAnon} (\parm) \\
        \pcreturn b^*
      }
    \end{minipage}
  }
  \caption{Issuance and signature anonymity experiments for \UAS schemes.}
  \label{fig:exp-uas-anonb}
\end{figure*}

\begin{definition}{(Issuance anonymity in \UAS)}
  \label{def:issue-anonymity-uas}  
  We define the advantage \AdvIssAnon of $\adv$ against \ExpIssAnonb as
  $\AdvIssAnon=|\Pr\lbrack\ExpIssAnono(1^\secpar)=1\rbrack-
  \Pr\lbrack\ExpIssAnonz(1^\secpar)=1\rbrack|$.
  %
  An \UAS scheme satisfies issuance anonymity if, for any p.p.t. adversary
  $\adv$, \AdvIssAnon is a negligible function of $1^\secpar$.
\end{definition}

\begin{definition}{(Signature anonymity in \UAS)}
  \label{def:sign-anonymity-uas}  
  We define the advantage \AdvSigAnon of $\adv$ against \ExpSigAnonb as
  $\AdvSigAnon=|\Pr\lbrack\ExpSigAnono(1^\secpar)=1\rbrack-
  \Pr\lbrack\ExpSigAnonz(1^\secpar)=1\rbrack|$.
  %
  An \UAS scheme satisfies signature anonymity if, for any p.p.t. adversary
  $\adv$, \AdvSigAnon is a negligible function of $1^\secpar$.
\end{definition}

\paragraph{On the generality of anonymity in \UAS schemes.} %
From the point of view of the achieved privacy, depending on how one defines
\fissue, \feval and \finsp, it is easy to see that the resulting scheme would
have different privacy level. For instance, a scheme that has very granular
\feval outputs barely provides privacy. Or a scheme for which most signatures
include the same \finsp value has less accountability, but higher privacy.
%
This is a natural consequence of the fact that, with different choices of those
functions, one can mimic the behaviour of (more restricted) schemes. For
instance, by setting \finsp to output the signer's public key, and \feval to
output nothing, one gets the same anonymity as in vanilla group signatures
(concretely, no challenge signature can be opened). Or, if \feval outputs any
arbitrary subset of the attributes in the used credential(s), and \finsp outputs
any constant value, then we get the same anonymity as in conventional selective
disclosure anonymous credential schemes, where any pair of users with different
subset of revealed attributes are clearly distinguishable. The impact of \fissue
is somehow orthogonal to the previous, but can be seen as a kind of equivalent
to \feval, at issuance time.
%
Importantly, note that the model is agnostic to the concrete instantiation of
these functions, and just cares about whether their outputs are equal or not,
in order to avoid trivial wins by the adversary.

\paragraph{Unforgeability.} \UAS inherits from AC and GS schemes two different
notions of unforgeability: from AC schemes, the notion that no adversary can
prove claims unless it owns credentials with the proper attributes; from GS
schemes, that only credential owners can produce valid signatures. \UAS also
has verifiable openings as some group signature schemes, which sits somewhere
in between, and we must ensure that the values output by \Open are correct and
trace back to a user with consistent credentials. All the previous is captured
by a signature unforgeability property. We define this by allowing the adversary
to call any oracle, except the one for corrupting issuers. The adversary wins if
it produces a valid signature over some message that: (1), opens to a wrong
value, or to a value that cannot be processed by \Judge; (2), is not consistent
with the expected \Yeval value; or (3), cannot be associated to known
credentials owned by a known user.

Again, since \UAS schemes (may) require proving claims at issuance time, we
need to ensure that those claims cannot be forged by an adversary without the
proper attributes. In this case, since we (need to) assume trusted issuers, we
can condition on having the $\langle \Obtain,\Issue \rangle$ transcripts
available for analysis. Thus, the adversary -- with access to the same oracles
as above -- is challenged to output a credential identifier for a credential
that exists in \CRED and (1), the conditions required by \fissue were not
satisfied, or some of the credentials used to support the request does not
belong to the requesting user; or (2) all credentials used to support the
request are bound to the same secret key, but that secret key does not belong
to any known user. The issuance unforgeability notion formalizes this.

For both \ExpForgeIssue (in \figref{fig:exp-uas-unfor-issue}) and \ExpForgeSign
(in \figref{fig:exp-uas-unfor-sign}), the adversary is given access to the
oracle set $\Oforgeissue = \Oforgesign \gets \lbrace\HU,\CU\rbrace\GEN,\IGEN,
\OGEN,\OCORR,\OBTISS,\ISSUE,\RREG,\SIGN,\OPEN$.

\begin{figure}[htp!]
    \procedure[linenumbering]{$\ExpForgeIssue(1^\secpar)$}{%
      (\parm,\trap) \gets \SimSetup(1^\secpar) \\
      \cid \gets \adv^{\Oforgeissue}(\parm) \\
      \pcif \trans[\cid] = \bot \lor \CRED[\cid] = \bot: \pcreturn 0 \\
      \textrm{Parse}~\CRED[\cid]~\textrm{as}~(\cdot,\cdot,\iid,\cdot,\cdot);~
      \IK[\iid]~\textrm{as}~((\ipk,\fissue),\cdot) \\
      (\usk,\scred,\attrs_{\scred}) \gets \ExtractIssue(\trap,\trans[\cid]) \\
      \pcif \fissue(\usk,\scred,\ATTR[\cid]) = 0 \lor
      \exists \cred \in \scred~\suchthat~\IdentifyCred(\trap,\usk,
      \attrs_{\cred},\cred,\ipk) = 0: \\
      \pcind \pcreturn 1 \\
      \pcreturn 0
    }
  \caption{Experiment for unforgeability of credential issuance in \UAS schemes.}
  \label{fig:exp-uas-unfor-issue}
\end{figure}    

\begin{figure}[htp!]
    \procedure[linenumbering]{$\ExpForgeSign(1^\secpar)$}{%
      (\parm,\trap) \gets \Setup(1^\secpar) \\
      (\oid,\siid,\Sig=(\sig,\yeval),\msg,\feval) \gets \adv^{\Oforgesign}(\parm) \\
      \pcif \exists \uid~\suchthat~(\cdot,\cdot,\Sig,\cdot,\msg,\feval) \in
      \SIG[\uid]: \pcreturn 0 \\
      \pcif \Verify(\PUBOK[\oid],\PUBIK[\siid],\Sig,\msg,\feval) = 0:
      \pcreturn 0 \\
      (\yinsp,\iproof) \gets \Open(\PRVOK[\oid],\siid,\Sig,\msg) \\
      \pcif \Judge(\PUBOK[\oid],\PUBIK[\siid],\yinsp,\iproof,\Sig,\msg,\feval)
      = 0: \pcreturn 1 \\
      (\usk,\scred,\attrs_{\scred},\tyeval^1,\yinsp',r) \gets
      \ExtractSign(\trap,\oid,\siid,\Sig,\msg,\feval) \\
      \Yeval=(\yeval^0,\yeval^1) \gets \feval(\usk,\scred,\msg) \\
      \pcif \yeval \neq \yeval^0 \lor \yeval^1 \neq \tyeval^1:
      \pcreturn 1 \\
      \pcif \finsp((\yeval^0,\yeval^1),\usk,\scred,\msg) \neq \yinsp:
      \pcreturn 1 \\
      \pcif \exists \cred \in \scred~\suchthat~
      \IdentifyCred(\tau,\usk,\attrs_{\cred},\cred,\ipk_{\cred}) = 0:
      \pcreturn 1 \\
      \pcif \nexists \uid~\suchthat~\IdentifySig(\trap,\usk,\scred,\Sig) = 1:
      \pcreturn 1 \pccomment{\todo{\uid-\usk}} \\
      \pcreturn 0
    }
  \caption{Experiment for unforgeability of signatures in \UAS schemes.}
  \label{fig:exp-uas-unfor-sign}
\end{figure}

\begin{definition}{(Unforgeable issuance of \UAS)}
  \label{def:issue-forge-uas}  
  We define the advantage \AdvForgeIssue of $\adv$ against \ExpForgeIssue as
  $\AdvForgeIssue=\Pr\lbrack\ExpForgeIssue(1^\secpar)=1\rbrack$.
  %
  A \UAS scheme has unforgeable issuance if, for any p.p.t. adversary $\adv$,
  \AdvForgeIssue is a negligible function of $1^\secpar$.
\end{definition}

\begin{definition}{(Unforgeable signing of \UAS)}
  \label{def:sign-forge-uas}  
  We define the advantage \AdvForgeSign of $\adv$ against \ExpForgeSign as
  $\AdvForgeSign=\Pr\lbrack\ExpForgeSign(1^\secpar)=1\rbrack$.
  %
  A \UAS scheme has unforgeable signing if, for any p.p.t. adversary $\adv$,
  \AdvForgeSign is a negligible function of $1^\secpar$.
\end{definition}

For short, we say that an \UAS scheme that has both unforgeable issuance and
signing, is an unforgeable \UAS scheme.

\paragraph{On the generality of unforgeability in \UAS schemes.} %
Regarding the information revealed at signature time ($\yeval^0$), \UAS's
unforgeability notion is equivalent to that of known AC schemes. It is the
generalization of the information output at opening time ($\yinsp$), only
present up to know in MPS \needcite what makes the notion of unforgeability more
subtle. The fact that multiple users may produce signatures opening to the same
value necessarily forces to generalize what is a forgery -- and, certainly,
resorting to extraction-based techniques seems unavoidable.

As for anonymity, note that by tweaking the \fissue, \feval and \finsp
functions, one can easily mimic behaviour of more restricted schemes. For
instance, \feval, along with the $\yeval^0$ output, allows revealing
authenticated attribute-related information alongside the signatures, as in AC
schemes. Or, with \fissue, rules for delegation can be easily encoded, leading
to delegatable schemes.

\paragraph{Non-frameability.} %
The notion of non-frameability in \UAS schemes is unavoidably more subtle than
in group signatures. To see this, we note that, by allowing arbitrary
evaluation and open functions to be used, it can be perfectly valid to
have a signature produced by a corrupted user output the same \yeval or \yinsp
values than the ones output when evaluating or opening a signature by an honest
user.
%
More generally, since the issuer is dishonest in non-frameability properties
and, in \UAS, the value produced by \Open may depend on the attributes
included in user credentials, the adversary may even be able to just produce
``legitimate'' openings that output any desired value. Note that this is a
relevant property, as it tells us the minimal unforgeability expectations we
can have, even against malicious issuers and openers.

In the non-frameability definition for \UAS, given in experiment \ExpNonframe in
\figref{fig:exp-uas-frame}, the adversary is challenged to produce a signature
and opening proof that is accepted by \Verify and \Judge, respectively. From
the signature, we then extract the secret data used to generate it. The
adversary wins if the signature and opening proof are accepted, but the \yeval
or \yinsp values do not match what they should be based on the extracted data;
or if the signature can be associated to the secret key of an honest user who
did not produce it (i.e., no matching call to \SIGN exists). In the game, the
adversary has access to the oracles in $\Oframe \gets
\lbrace\HU,\CU\rbrace\GEN, \lbrace\II,\OO\rbrace\GEN,\lbrace\II,\OO\rbrace\CORR,
\WREG,\OBTAIN,\SIGN$.

\begin{figure}[htp!]
  \centering
  \procedure[linenumbering]{$\ExpNonframe(1^\secpar)$}{%
    (\parm,\trap) \gets \SimSetup(1^\secpar) \\
    (\oid,\siid,\Sig=(\sig,\yeval),\msg,\feval,\yinsp,\iproof) \gets
    \adv^{\Oframe}(\parm) \\
    \pcif \Verify(\PUBOK[\oid],\PUBIK[\siid],\Sig,\msg,\feval) = 0:
    \pcreturn 0 \\
    \pcif \Judge(\PUBOK[\oid],\PUBIK[\siid],\yinsp,\iproof,\Sig,\msg) = 0:
    \pcreturn 0 \\
    (\usk,\scred,\attrs_{\scred},\tyeval^1,\yinsp') \gets
    \ExtractSign(\trap,\oid,\siid,\Sig,\msg,\feval) \\
    \Yeval=(\yeval^0,\yeval^1) \gets \feval(\usk,\scred,\msg) \\
    \pcif \yeval \neq \yeval^0 \lor \tyeval^1 \neq \yeval^1: \pcreturn 1 \\
    \pcif \finsp(\Yeval,\usk,\scred,\msg) \neq \yinsp
    \lor \yinsp \neq \yinsp': \pcreturn 1 \\   
    \pcif \exists \uid \in \HU~\suchthat~\UK[\uid] = \usk \land
    (\cdot,\cdot,\Sig,\Yeval,\msg,\feval) \notin \SIG[\uid]: \\
    \pcind \pcreturn 1 \\
    \pcreturn 0
  }
  \caption{Experiment for non-frameability on \UAS schemes.}
  \label{fig:exp-uas-frame}
\end{figure}

\begin{definition}{(Non-frameability of \UAS)}
  \label{def:frame-uas}
  We define the advantage \AdvNonframe of $\adv$ against \ExpNonframe as
  $\AdvNonframe=\Pr\lbrack\ExpNonframe(1^\secpar)=1\rbrack$.
  %
  An \UAS scheme satisfies non-frameability if, for any p.p.t. adversary $\adv$,
  \AdvNonframe is a negligible function of $1^\secpar$.
\end{definition}

\paragraph{On the generality of non-frameability in \UAS schemes.} %
The notion captured in \UAS is a sort of extension of the non-frameability
notion in group signatures, in two aspects. First, by defining a very granular
\finsp function (one that outputs the signers public key, or equivalent),
we get a scheme in which it is not possible to frame a user at all. Yet, by
defining a coarser \finsp function (e.g., one that outputs the nationality of
the signer), while framing a single user is still not possible (the checks in
lines 9 an 10 avoid it), in practice, there will be a set of ``potential
candidates to frame'' (e.g., all users of the given nationality). This can be
seen as a useful feature in many use cases, though.
%
The second aspect follows a similar reasoning, but through \feval. However, this
type of functionality revealing information at signing time is not available in
group signatures. Also, even though it is available in anonymous credentials, no
equivalent property has been considered, to the best of our knowledge. Thus,
through \UAS schemes, we extend the unforgeability expectations against corrupt
issuers, to the AC domain.

% Anonymous credentials do not have non-frameability property and, thus, it is
% hard to make a comparison. However, we can draw some connections with AC schemes
% that support revocation, as revocation is somehow equivalent to linking, which
% is a type of inspection available in group signatures. In this sense, note that
% basic revocation (without straight deanonymization) can be trivially achieved
% through our generic \Open function. For instance, one could set \finsp to
% be a pseudorandom number seeded with the user's public key (or credential). In
% this sense, \Open could be essentially seen as a Verifiable Random Function.
% If we compare with group signatures, our notion is also more general than the
% conventional one, again for the same reason as sign unforgeability (i.e., \Open
% can return any value, not just the signer's identity). Thus, the need to extract
% the signer's data in order to detect if a framing has taken place.

\subsection{\CUASGen: A Generic \UAS Construction}
\label{ssec:generic-construction-uas}

In this section, we give a generic construction of an \UAS scheme, based on
generic building blocks. We use three different NP relations in our generic
construction. Namely:

\begin{description}
\item[$\NIZKRel_{\Issue}$:] For NIZK proofs at issuance time. It is defined as
  $\NIZKRel_{\Issue} = \lbrace
  (\usk,\scred,\attrs_{\scred},r), (\Ccom,\attrs,\sipk_{\scred}): \Ccom =
  \CCommit(usk;r) \land \forall \cred \in \scred,\SBCMVerify(\ipk_{\cred},\cred,
  \usk,\attrs_{\cred}) = 1 \land \fissue(\usk,\scred,\attrs) = 1 \rbrace$,
  where for readability we write $\attrs_{\scred}$ as abbreviation for $\lbrace
  \attrs_{\cred} \rbrace_{\cred \in \scred}$, and similarly for $\sipk_{\scred}$.
  The relation requires that the owner commits to, and proves knowledge of,
  \usk. It also requires that any additional credential supporting the request
  be a valid credential (signed by some other issuer) and bound to \usk.
  Finally, the policy defined by \fissue needs to be satisfied.
\item[$\NIZKRel_{\Sign}$:] For NIZK proofs at signing time. It is defined as
  $\NIZKRel_{\Sign} = \lbrace (\usk,\scred,
  \attrs_{\scred},\yeval^1,\yinsp,r,r'),(\msg,\feval,\yeval^0,\ceval,\cinsp,
  \sipk_{\scred},\Eek,\widetilde{\Eek}): \ceval = \EEnc(\widetilde{\Eek},\yeval^1;r)
  \land \cinsp= \EEnc (\Eek,\yinsp;r') \land (\yeval^0,\yeval^1) = \feval(\usk,
  \scred,\msg) \land \yinsp = \finsp((\yeval^0,\yeval^1),\usk,\scred,\msg) \land
  \forall \cred \in \scred, \SBCMVerify(\ipk_{\cred},\cred,\usk,\attrs_{\cred})
  = 1) \rbrace$, with $\attrs_{\scred}$ and $\sipk_{\scred}$ as in
  $\NIZKRel_{\Issue}$. This relation ensures that signatures will produce the
  correct signature evaluation and opening values, and that any credential used
  to create the signature is bound to the same \usk key.
\item[$\NIZKRel_{\Open}$:] For NIZK proofs at opening time. Ensures that the
  utility information extracted by the \Open algorithm is correct. It is defined
  as $\NIZKRel_{\Open} =
  \lbrace (\osk),(\Ec,\yinsp): \yinsp = \EDec(\osk,\Ec) \rbrace$.
\end{description}

Note that, besides the extensibility introduced via \fissue, \feval and
\finsp, some aspects of the previous functions could be modified (e.g., one
could require issuer public keys to be kept private). However, the previous
relations seem generic enough for a wide variety of applications.
%
From the previous relations, we define the functionality as follows:

\paragraph{$\parm \gets \Setup(\secpar,\AttrSpace)$.} %
The setup process essentially generates the public parameters for all the
building blocks. It parses \secpar as $(\Csecpar,\NIZKsecpar,\SBCMsecpar,
\Esecpar)$. Then, run $\Cparm \gets
\CSetup(\Csecpar)$, $\SBCMparm \gets  \SBCMSetup(\SBCMsecpar)$, $\Sparm \gets
\SSetup(\Ssecpar)$, $\Eparm \gets \ESetup(\Esecpar)$, $\NIZKcrs_{\Issue} \gets
\NIZKSetup^{\NIZKRel_{\Issue}}(\NIZKsecpar)$, $\NIZKcrs_{\Sign} \gets
\NIZKSetup^{\NIZKRel_{\Sign}}(\NIZKsecpar)$, and $\NIZKcrs_{\Open} \gets
\NIZKSetup^{\NIZKRel_{\Open}}(\NIZKsecpar)$. Return $(\Cparm,\SBCMparm,
\Sparm,\Eparm,\NIZKcrs_{\Issue},\NIZKcrs_{\Sign},\NIZKcrs_{\Open},
\AttrSpace)$. Many of these parameter setup algorithms can
actually be run by separate entities. For simplicity of exposition, we bundle
them together here.

\paragraph{$(\ipk,\isk) \gets \IKeyGen(\parm,\fissue)$.} %
Each issuer first parses \parm as $(\cdot,\SBCMparm,
\Sparm,\cdot,\cdot,\cdot,\cdot,\cdot)$. Then, runs $(\Svk,\Ssk) \gets
\SKeyGen(\Sparm)$, $(\SBCMvk,\SBCMsk) \gets \SBCMKeyGen(\SBCMparm)$,
$\sig_{\fissue} \gets \SSign(\Ssk,\fissue)$, $\ipk \gets (\Svk,\fissue,
\sig_{\fissue})$, $\isk \gets \Ssk$ and return $(\ipk,\isk)$.

\paragraph{$(\opk,\osk) \gets \OKeyGen(\parm,\finsp)$.} %
Each opener first parses \parm as $(\cdot,\cdot,
\cdot,\Eparm,\cdot,\cdot,\cdot,\cdot)$. Then, runs $(\Svk,\Ssk) \gets \SKeyGen
(\Sparm)$, $(\Eek,\Edk) \gets \EKeyGen(\Eparm)$, $\sig_{\finsp} \gets \SSign
(\Ssk,\finsp)$, $\opk \gets (\Svk,\Eek,\finsp,\sig_{\finsp})$, and $\osk \gets
(\Ssk,\Edk)$.

\paragraph{$\usk \gets \UKeyGen(\parm)$.} %
Each user, prior to requesting credentials, generates his secret key by parsing
\parm as $(\cdot,\cdot,\cdot,\cdot,\cdot,\AttrSpace)$, and picking randomly
$\usk \getr \AttrSpace$.

\paragraph{$\langle \cred/\bot,\utrans/\bot \rangle \gets
  \langle\Obtain(\usk,\ipk,\scred,\attrs),\Issue(\isk,\sipk,\attrs)\rangle$.} %
The protocol is run between an issuer with key pair $(\ipk,\isk)$, and a user
with secret key \usk and credentials \scred, where each $\cred \in \scred$ is
issued by an issuer with public key $\ipk_{\cred} \in \sipk$ (which we assume
that the user can easily retrieve,
e.g., from secure storage, given \cred), and attests attributes
$\attrs_{\cred}$. The user requests a signature on a commitment to the user key,
as well as on the attributes in \attrs. In addition, the user proves that the
issuance function \fissue established by the issuer is satisfied by the
credentials in $\scred$
and its user secret key. For this, we use relation $\NIZKRel_{\Issue}$, as
defined above. The interactive protocol for a user to obtain a credential from
an issuer of the system is then simply an execution of the interactive signing
protocol of an \SBCM scheme, where the user runs $\SBCMCom(\ipk,\usk,\attrs)$,
and the issuer runs $\SBCMSign(\isk,\attrs)$; in both cases, using
$\NIZKRel_{\Issue}$ as \NIZK relation. The credential \cred produced by the user
is the result of the interactive signing protocol, and the \utrans entry for
the issuer is its transcript, which is a $(\Ccom,\attrs,\sipk,\cred,\pi)$ tuple.

\paragraph{$\Sig \gets \Sign(\usk,\opk,\scred,\msg,\feval)$.} %
In the signing algorithm, we make use of relation $\NIZKRel_{\Sign}$.
% 
The user first evaluates $(\yeval^0,\yeval^1) \gets \feval (\usk,\scred,\msg)$,
and computes a random encryption key pair with $(\widetilde{\Eek},
\widetilde{\Edk}) \gets \EKeyGen(\Eparm)$. Then, the user parses \opk as $(\Svk,\Eek,
\finsp,\sig_{\finsp})$ and checks that $\Verify(\Svk,\sig_{\finsp},\finsp) = 1$
(this step may be cached), to compute $\yinsp \gets \finsp((\yeval^0,
\yeval^1),\usk,\scred,\msg)$, and separately encrypts both $\yeval^1$ and
\yinsp by running $\ceval \gets \EEnc(\widetilde{\Eek},\yeval^1;r)$ and $\cinsp \gets
\EEnc(\Eek,\yinsp; r')$ for some fresh randomness $r,r'$. Finally, the user
computes $\NIZKproof \gets \NIZKProve^{\NIZKRel_{\Sign}}(\NIZKcrs_{\Sign},(\usk,
\scred, \attrs_{\scred},\yeval^1,\yinsp,r,r'),(\msg,\feval,\yeval^0,\ceval,\cinsp,
\sipk_{\scred},\Eek,\widetilde{\Eek}))$ and outputs $(\sig = (\NIZKproof,\ceval,
\cinsp),\yeval^0)$. Note that, depending on the value of \Yeval and \yinsp, the
user may decide to abort the signing if the resulting values are too
privacy-threatening.

\paragraph{$1/0 \gets \Verify(\opk,\sipk,\Sig,\msg,\feval)$.} %
The ``cryptographic'' side of the verification consists on checking
the NIZK proof. That is, parse \Sig as $(\sig = (\NIZKproof,\cinsp),\yeval,
\ceval)$ and check whether $\NIZKVerify(\NIZKcrs,\NIZKproof,(\msg,\feval,\yeval,
\ceval,\cinsp,\sipk,\opk)) = 1$. In addition, the verifier may further check
whether \yeval meets its needs.

\paragraph{$(\yinsp,\NIZKproof)/\bot \gets
  \Open(\osk,\sipk,\Sig,\msg,\feval)$.} %
Here we leverage relation $\NIZKRel_{\Open}$.
%
To open a signature, the opener first verifies the signature by running $\Verify
(\opk,\sipk, \Sig,\msg,\feval)$. If verification succeeds, it parses
\Sig as $(\sig=(\NIZKproof,\cinsp),\yeval,\ceval)$, decrypts \Ec by running $\yinsp
\gets \EDec(\osk,\cinsp)$, and computes $\NIZKproof_{\Open} \gets
\NIZKProve^{\NIZKRel_{\Open}}(\NIZKcrs_{\Open},\osk,(\cinsp,\yinsp))$. It
returns $(\yinsp,\NIZKproof_{\Open})$.

\paragraph{$1/0 \gets \Judge(\opk,\yinsp,\NIZKproof,\Sig,\msg)$.} %
To assess the validity of an opening proof, first check the signature
by running $\Verify(\opk,\sipk,\Sig,\msg,\feval)$. If the check succeeds,
parse \Sig as $((\cdot,\cinsp),\cdot,\cdot)$ and verify \NIZKproof with
$\NIZKVerify(\NIZKcrs_{\Open},\NIZKproof,(\cinsp,\yinsp))$. Accept it the NIZK
verification passes, and reject otherwise.

\paragraph{Interactive Credential Presentation.} In \appref{app:interactive-uas}
we show how to convert the non-interactive signing and verification processes
into an interactive protocol. While the transformation is quite straightforward,
it is of high relevance for real world use cases.

\subsection{Correctness and Security of \CUASGen}
\label{ssec:security-uas}

We state the correctness and security theorems next. For lack of space, we defer
the proofs to \appref{app:uas-proofs}.

\begin{theorem}[Correctness of \CUASGen]
  \label{thm:correctness-uas}
  If the underlying schemes for commitments, public-key encryption and \SBCM,
  are correct, as well as the NIZKs for $\NIZKRel_{\Issue}$, $\NIZKRel_{\Sign}$,
  and $\NIZKRel_{\Open}$, our generic construction \CUASGen satisfies
  correctness as defined in \defref{def:correctness-uas}.
\end{theorem}

\begin{theorem}[Issuance anonymity of \CUASGen]
  \label{thm:issue-anonymity-uas}
  If the NIZK systems used for $\NIZKRel_{\Issue}$ and $\NIZKRel_{\Sign}$ are
  zero-knowledge, our \CUASGen construction satisfies issuance anonymity as
  defined in \defref{def:issue-anonymity-uas}.
\end{theorem}

\begin{theorem}[Signature anonymity of \CUASGen]
  \label{thm:sign-anonymity-uas}
  If the NIZK system used for $\NIZKRel_{\Sign}$ is zero-knowledge, and the
  public-key encryption scheme is IND-CCA secure, our \CUASGen construction
  satisfies signature anonymity as defined in \defref{def:sign-anonymity-uas}.
\end{theorem}

\begin{theorem}[Issuance unforgeability of \CUASGen]
  \label{thm:issue-forge-uas}
  If the underlying NIZK used for $\NIZKRel_{\Issue}$ is zero-knowledge,
  simulation extractable and sound, then our \CUASGen construction satisfies
  issuance unforgeability as defined in \defref{def:issue-forge-uas}.
\end{theorem}

\begin{theorem}[Signing unforgeability of \CUASGen]
  \label{thm:sign-forge-uas}
  If the underlying NIZK scheme for $\NIZKRel_{\Sign}$ is simulation
  extractable,the NIZK scheme for $\NIZKRel_{\Open}$ is complete, the public-key
  encryption scheme is correct, and \SBCM is correct and one-more unforgeable,
  then our \CUASGen construction satisfies signing unforgeability as defined in
  \defref{def:sign-forge-uas}, except with negligible probability.
\end{theorem}

\begin{theorem}[Non-frameability of \CUASGen]
  \label{thm:frame-uas}
  If the underlying scheme for $\NIZK^{\Sign}$ is zero-knowledge and simulation
  extractable, the scheme for $\NIZK^{\Open}$ is simulation-extractable, and
  \SBCM scheme is blind, then our \CUASGen construction satisfies
  non-frameability as defined in \defref{def:frame-uas}, except with negligible
  probability.
\end{theorem}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "uas-paper"
%%% End:
