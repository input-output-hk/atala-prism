\section{Relationships with More Schemes}
\label{app:related-extra}

\subsection{Group Signatures with Message Dependent Opening}
\label{sapp:related-models-gsmdo}

We cannot build the exact same functionality, nor follow the exact same security
model as in the group signatures with message dependent opening (GS-MDO) scheme
described in \cite{ehk+19}. Simply because, therein, the opening functionality
is divided in two authorities: the admitter, who decides which messages are
subject to be opened or not, and generates a token that enables opening
signatures over such messages; and the opener, who performs the actual opening,
but cannot do it without the tokens generated by the admitter. Intuitively,
this can be seen as a sort of ``distribution'' of the opening capability. We
define a variant in which the admitter and opener are combined
back into one entity (the opener), who can only open signatures over predefined
messages, but cannot open any other signature.
% Moreover, our variant directly supports the
% scenario of multiple such openers, each being able to open only signatures
% over different messages.
Although we leave it for future work, note that it should still be possible to
apply thresholding techniques to extend this case so that our ``unified'' opener
role is shared across multiple entities, who have to cooperate in order to open
a signature \cite{cdl+20}, thus achieving something very close ``in spirit'' to
the scheme in \cite{ehk+19}. In addition, while \cite{ehk+19} follows the static
group signature setting, we move to the dynamic one.

Informally, our variant of GS-MDO is composed of the same algorithms as the
group signature model in \secref{ssec:related-models-gs}, with the exception
that the $KeyGen$ algorithm also receives the $\finsp^{\smsg}$ function, defined
as in \eref{eq:finspmsg}, and used to set up the opener.

\begin{align}
  & \finsp^{\smsg}(\cdot,\upk,\cdot,\msg) \coloneqq
    \pcif \msg \in \smsg: \pcreturn \upk;~\pcelse \pcreturn 0
    \label{eq:finspmsg}
\end{align}

The model is exactly the same as in
\figref{fig:model-gs}. Note that this directly constraints anonymity in a
similar way than \cite{ehk+19}: therein, anonymity (against admitter and opener,
in respective properties that we unify since we do not distinguish the roles) is
ensured only for messages that have not been ``disallowed''. In our case, as
specified next, a message is disallowed by adding it to the \smsg set given to
$KeyGen$ via $\finsp^{\smsg}$. Thus, if the adversary calls \oracle{Open} with a
signature over a message that has been disallowed, \oracle{Open} rejects the
query, as it would otherwise return different values for each challenge user
(cf. \figref{fig:oracles2}); otherwise, if the message is allowed, the oracle
returns the result of \Open -- just as in \cite{ehk+19}.

For simplicity and to build upon our \CUASGS construction, we
describe a variant where the set of messages to disallow is defined once via
$KeyGen$. However, separating this into a dedicated \OKeyGen function that can
be called multiple times, and thus allowing multiple openers, each with a
different set of disallowed messages, is trivial -- and again, our definition
of the \oracle{Open} oracle takes care of everything, as every challenge
signature is produced over the same opener key.

% \begin{figure}[ht!]
%   \centering
%   \scalebox{0.9}{      
%     \begin{minipage}[t]{0.45\textwidth}        
%       \procedure[linenumbering]{$\Exp^{anon-b}_{\adv,gsmdo}(1^\secpar)$}{%
%         (\gpk,\isk,\osk) \gets KeyGen(1^\secpar) \\
%         b^* \gets \adv^{\mathcal{O}_{anon}}(\gpk,\isk) \\
%         \pcreturn b^*
%       }
      
%       \vspace*{5em}
      
%       \procedure[linenumbering]{$\Exp^{frame}_{\adv,gsmdo}(1^\secpar)$}{%
%         (\gpk,\isk,\osk) \gets KeyGen(1^\secpar) \\
%         (\msg,\sig,\upk,\tau) \gets \adv^{\mathcal{O}_{frame}}
%         (\gpk,\osk,\isk) \\
%         \pcif \Verify(\gpk,\msg,\sig) = 0: \pcreturn 0 \\
%         \pcreturn \upk \in \HU \land \PRVUK[\upk] \neq \bot \land
%         \Judge(\gpk,\upk,\msg,\sig,\tau) = 1~\land \\
%         \pcind \adv~\textrm{did not query}~USK(\upk)~\textrm{or}~
%         GSig(\PRVUK[\upk],\msg)
%       }       
%     \end{minipage}
%   }
%   \scalebox{0.9}{      
%     \begin{minipage}[t]{.55\textwidth}
%       \procedure[linenumbering]{$\Exp^{trace}_{\adv,gsmdo}(1^\secpar)$}{%
%         (\gpk,\isk,\osk) \gets KeyGen(1^\secpar) \\
%         (\msg,\sig) \gets \adv^{\mathcal{O}_{trace}}
%         (\gpk,\osk) \\
%         \pcif \Verify(\gpk,\msg,\sig) = 0: \pcreturn 0 \\
%         (\upk, \tau) \gets \Open(\gpk,\osk,\trans,\msg,\sig) \\
%         \pcreturn \upk \notin \HU \cup \CU \lor
%         \Judge(\gpk,\upk,\msg,\sig,\tau) = 0
%       }       
%     \end{minipage}      
%   }
%   \caption{Security games for our GS-MDO variant.
%     $\mathcal{O}^{anon} \gets \lbrace \OGEN^{\smsg},\HUGEN,\CUGEN,\WREG,
%     \OBTAIN,\SIGN,\OPEN,\CHALb \rbrace$; $\mathcal{O}^{trace} \gets \lbrace
%     \OGEN,\HUGEN,\CUGEN,\ISSUE,\OBTISS,\RREG,\SIGN \rbrace$;
%     $\mathcal{O}^{frame} \gets \lbrace \OGEN,\HUGEN,\CUGEN,\WREG,
%     \OBTAIN,\SIGN \rbrace$. $\OGEN^{\smsg}$ is like \OGEN, but only accepting
%     functions of type $\finsp^{\smsg}$.
%   }
%   \label{fig:model-gsmdo}  
% \end{figure}

\subsubsection{\CUASGSMDO construction.} %
Our \CUASGSMDO construction is essentially a $(\fissue^{single,H,I},\feval^0,
\finsp^{\smsg})$-\CUASGen restriction, where $\fissue^{single,H,I}$ and
$\feval^0$ are as in \figref{fig:func-restrictions}, and $\finsp^{\smsg}$, is as
described in \eref{eq:finspmsg}. Since the construction is essentially a variant
of our \CUASGen-based construction for group signatures, we describe it making
reference to \CUASGS, in \secref{ssec:related-models-gs}:

\begin{description}
\item[$(\gpk,\isk,\osk) \gets KeyGen(1^\secpar,\finsp)$.] Runs exactly as in
  \CUASGS, except that it now receives an opening function, which must be of
  the type $\finsp^{\smsg}$, for some \smsg.
\item[$(\upk,\usk) \gets UKG(1^\secpar)$.] Like in \CUASGS.  
\item[$\langle \cred,\utrans \rangle \gets
  \langle\Obtain(\usk,\ipk),\Issue(\isk,\upk)\rangle$.] Like in \CUASGS.
\item[$\sig \gets \Sign(\gpk,\cred,\msg)$.] Like in \CUASGS.
\item[$1/0 \gets \Verify(\gpk,\sig,\msg)$.] Like in \CUASGS.
\item[$(\upk,\pi) \gets \Open(\gpk,\osk,\trans,\sig,\msg)$.] Like in
  \CUASGS.
\item[$1/0 \gets \Judge(\gpk,\pi,\upk,\sig,\msg)$.] Like in \CUASGen. Note that
  \gpk includes an \opk with an opening function of type $\finsp^{\smsg}$.
\end{description}

\paragraph{Security of \CUASGSMDO.} %
Our \CUASGSMDO construction is a secure group signature scheme, if the
underlying \CUASGen construction is secure.
%
Note that our construction for group signatures, \CUASGS, is a restriction to
the construction of \CUASGen and, in turn, \CUASGSMDO is a restriction of
\CUASGS, where we only accept opening functions of type $\finsp^{\smsg}$ --
more constrained than the $\finsp^{\upk}$ functions used in \CUASGS. Thus, the
security arguments given for \CUASGS in \appref{app:related-proofs}, apply
directly here.

\subsection{Multimodal Private Signatures}
\label{ssec:related-models-mps}

Multimodal Private Signatures (or, rather, a close relative, see next) are
directly implementable as a $(\fissue^{single,H,I},\feval^{F,MPS},
\finsp^{G,MPS})$-\CUASGen restriction. Concretely, this restricts to a \UAS
system with one credential per user and no attributes in the credentials.

There are some differences, though. On the one hand, our signature anonymity
property is somehow in the middle of MPS's privacy-1 and privacy-2 variants.
Their privacy-1 variant is the traditional anonymity property of group
signatures, in which the opener is honest and the adversary can call the opening
oracle except for challenge signatures. In their privacy-2 variant, the opener
is fully corrupt (i.e., \adv~ receives \osk), but the adversary can only be
challenged with signatures that produce the same \yinsp value ($G_{j_b}(id_b)$
in MPS). In our \UAS model, we allow the adversary to corrupt openers at will
(getting their \osk), but the challenge signatures must have been generated using
the key of an uncorrupted opener; still, \adv~can call the open oracle for
challenge signatures, as long as they have the same \yinsp value. We believe
that these differences are mostly of theoretical interest, though. In practice,
what matters is that any variant of \feval and \finsp functions ($F$ and $G_j$
in MPS) that has too much granularity in their ranges, will lead to a barely
private system. This is a known issue, for instance, in functional encryption
\cite{bsw11}.

On the other hand, anonymous issuance and the capability to customise issuance
policies are unachievable by MPS. Anonymous issuance simply does not make sense
in MPS, as it only supports one credential (without attributes) per user, and
customised issuance is achieved in \UAS via the \fissue functions, with no
equivalent in MPS -- instead, MPS can be seen as having the fixed policy of
``proving knowledge of a user secret key''. These extensions are not trivial
from a modelling point of view, and also have a big impact in the practicality
of the resulting system. Also, MPS does not include verifiable openings. While
this is easy to add, we consider it to be essential, given that the proposed
generalisation of opening allows the opener to output any value. Hence, the
need to ensure that the produced value is the legitimate one seems to be more
necessary than ever. Finally, our \feval function is a generalisation of $F$ in
MPS, as it allows two outputs: one will be returned in the clear along with the
signature, and the other will be encrypted. Indeed, making part of the output
unencrypted allows implementing very useful variants such as anonymous
credentials with selective disclosure, as shown before.

For the model of MPS schemes, we refer to the original paper \cite{ngsy22}.

\subsubsection{\CUASMPS construction.} %
As mentioned, a $(\fissue^{single,H,I},\feval^{F,MPS},
\finsp^{G,MPS})$-restriction implements an MPS scheme where
$\fissue^{single,H,I}$ is as in \figref{fig:func-restrictions}, $\feval^{F,MPS}$
equals MPS's $F$ function, and MPS's $G$ function equals $\finsp^{G,MPS}$, both
as defined in \esref{eq:funcs-mps}.

\begin{align}
  \feval^{F,MPS}(\upk,\lbrace (\cid_i,\attrs_i) \rbrace_{i\in[n]},\msg)
  \coloneqq & \nonumber \\
  & \hspace*{-10em} \pcif F(\upk,\lbrace (\cid_i,\attrs_i) \rbrace_{i\in[n]},
    \msg) = 0: \pcreturn \bot \nonumber \\
  & \hspace*{-10em} \pcelse: \pcreturn (\ast,F(\upk,\lbrace(\cid_i,\attrs_i)
    \rbrace_{i\in[n]},\msg)) \nonumber \\
  \finsp^{G,MPS}((\cdot,\yeval^1),\upk,\cid,\attrs,\cdot) \coloneqq
  & \nonumber \\
  & \hspace*{-10em} \pcreturn G(\yeval^1,\upk,\cid,\attrs)
    \label{eq:funcs-mps}
\end{align}

With these functions, the construction is direct. \CUASMPS's setup runs
\CUASGen's \Setup, \OKeyGen, and generates the issuer key pair by running
\KeyGen and \ISet (with $\fissue^{single,H,I}$). For MPS's join, \CUASMPS runs
first \KeyGen to generate the user key pair, and then proceeds as in \CUASGen.
\Sign, \Verify and \Open, are as in \CUASGen -- where, in \Open, we simply
ignore the opening proof.

Finally, note that, in MPS, $G$ is further parameterised with a value $j$, which
essentially is the result of applying $F$ to the message and signer identity,
and is not leaked to the opener nor any other third party. The equivalent in
\UAS is the $\yeval^1$ value which, in \CUASGen, is encrypted with a single-use
key pair, and is an input to \finsp.

\paragraph{Security of \CUASMPS.} %
We restrict to privacy-1 of MPS (although, as
discussed, we actually achieve something slightly stronger). Unforgeability-1 in
MPS is implied by signature unforgeability in \UAS.
Unforgeability-2 in MPS is equivalent to non-frameability in \UAS (where the
latter also includes framing via verifiable openings). Finally note that, in
UAS, we do not explicitly model extractability, but rather make it an inherent
requirement in the unforgeability and non-frameability definitions. Thus, our
\CUASMPS construction also ensures MPS-extractability.

\begin{theorem}[Privacy-1 of \CUASMPS]
  If the base \CUASGen construction has signature anonymity according to
  \defref{def:sign-anonymity-uas}, then \CUASMPS satisfies privacy-1
  according to \cite{ngsy22}.
\end{theorem}

\begin{proof}  
  Note that the privacy-1 game in MPS and the signature anonymity game in \UAS
  are, in essence, equivalent. Thus, given an adversary \adv~that breaks
  privacy-1 of \CUASMPS as defined for MPS, it is easy to build an adversary
  \advB breaking signature anonymity of the underlying \CUASGen construction, as
  defined in \UAS.

  \advB simply leverages its own oracles in order to answer oracle queries from
  \adv: $\mathcal{O}_{read},\mathcal{O}_{write},\mathcal{O}_{CU},\mathcal{O}_{HU},
  \mathcal{O}_{sig},\mathcal{O}_{open}$ in MPS correspond to \RREG, \WREG,
  \CUGEN, \HUGEN, \OBTAIN, \SIGN and \OPEN in \UAS, respectively. The output
  given by \adv~in the first stage of the MPS game is then directly used as
  input to \advB's \CHALb oracle. Finally, \advB outputs whatever \adv~outputs.

  Since the simulation is direct, it is easy to see that, whenever \adv~wins,
  so does \advB.
  % 
  \qed
\end{proof}

\begin{theorem}[Extractability of \CUASMPS]
  If the base \CUASGen construction has non-frameability according to
  \defref{def:frame-uas}, then \CUASMPS is an extractable MPS scheme.
\end{theorem}

\begin{proof}  
  The proof is direct, as the winning conditions in the extractability
  experiment in MPS are also winning conditions in the non-frameability
  experiment for \UAS. That is, an adversary \adv~against extractability of
  \CUASMPS, as defined in MPS, can be used to build an adversary \advB breaking
  non-frameability of \CUASGen, as defined in the \UAS model.

  \advB simulates \adv's game essentially as in the privacy-1 proof. Note also
  that \adv~receives the issuer's secret key. This can be obtained by \advB via
  its \ICORR oracle. Eventually, \adv~outputs a $(F,M,\Sigma)$ tuple, which
  corresponds to $(\feval^{F,MPS},\msg,\Sig)$ in \CUASGen,
  which \advB outputs in its own game. In addition, \advB outputs as $(\yinsp,
  \pi)$ values the output of \Open over $(\Sig,\msg)$ -- which internally
  computes $\finsp^{G,MPS}$.
  % 
  Note that the $\feval^{F,MPS}$ and $\finsp^{G,MPS}$ functions in \CUASMPS
  mimic the behaviour of MPS's $F$ and $G$, respectively. Thus, if \adv wins
  because $F$ returns $0$ when evaluated on the extracted values, then \advB
  wins at line 7 of the non-frameability game, as a legitimately computed
  $\feval^{F,MSP}$ function cannot output $0$. Similarly, if \adv~wins because
  the value returned by an honestly computed open function over the adversarial
  $(F,M,\Sigma)$ tuple does not match the output of $G$ over the extracted
  values, \advB wins at line 9: note that \advB returns the \yinsp value that
  \Open outputs (when computed honestly over \adv's output), whereas
  $\finsp^{G,MSP}=G$; thus, if both values differ in \adv's game, then they also
  differ in \advB's game.
  %
  \qed
\end{proof}

\begin{theorem}[Unforgeability-1 of \CUASMPS]
  If the base \CUASGen construction has signature unforgeability according to
  \defref{def:sign-forge-uas}, then \CUASMPS satisfies unforgeability-1 as
  defined in \cite{ngsy22}.
\end{theorem}

\begin{proof}
  Given an adversary \adv~against unforgeability-1 of \CUASMPS, as defined in
  the MPS model, we build \advB that breaks signature unforgeability of the
  underlying \CUASGen, as defined for \UAS.

  Simulation of \adv's oracles by \advB is again direct (as in previous proofs).
  Now, suppose that \adv~wins -- i.e., the identity extracted by \adv~does not
  belong to the set of corrupt users in \adv's game. By construction of \advB
  (identities in \adv's game map to a \cid for \advB), $\OWNR[\cid] \notin
  \CU$ in \advB's unforgeability game either.
  % 
  However, in order for \advB to win in its own game, we need to prove also that
  the produced identity does not belong to a user in \HU either. Suppose that it
  does. Simulation extractability ensures that the credentials extracted by
  \adv~all belong to the same user (by assumption, in \HU) -- i.e., they are
  bound to its \usk. But, since \adv~wins its game, the signature output by
  \adv~has not been obtained via its \SIGN oracle. But, given that the user is
  honest, its \usk has been produced uniformly at random, and has not been
  leaked to \adv~(as the issuer is also honest). Thus, the probability that
  the extracted credentials belong to an honest user is negligible and, if
  \adv~wins its game, \advB also does.
  %
  \qed
\end{proof}

\begin{theorem}[Unforgeability-2 of \CUASMPS]
  If the base \CUASGen construction has non-frameability according to
  \defref{def:frame-uas}, then \CUASMPS satisfies unforgeability-2 as
  defined in \cite{ngsy22}.
\end{theorem}

\begin{proof}
  Given an adversary \adv~against unforgeability-2 of \CUASMPS, as defined in
  the MPS model, we build \advB that breaks non-frameability of the underlying
  \CUASGen, as defined for \UAS.

  Simulation of \adv's oracles by \advB is as in the unforgeability-1 proof
  (leveraging the \OBTAIN oracle instead of \OBTISS or \ISSUE).
  \advB outputs whatever \adv~outputs, adding a $(\yinsp,\iproof)$ pair, honestly
  generated from \adv's output. Note that the winning condition of \adv~
  requires that the produced signature belongs to an honest user, without
  having been produced via a call to the signing oracle. By construction of
  \advB, this directly makes \advB win in line 11 of the non-frameability game.
  %
  \qed
\end{proof}

% \begin{theorem}[Privacy-1 of \CUASMPS]
%   If the base \CUASGen construction has signature anonymity according to
%   \defref{def:sign-anonymity-uas}, then \CUASMPS satisfies privacy-1
%   according to \cite{ngsy22}.
% \end{theorem}

% \begin{theorem}[Extractability of \CUASMPS]
%   If the base \CUASGen construction is unforgeable according to
%   \defref{def:forge-uas}, then it is an extractable MPS scheme.
% \end{theorem}

% \begin{theorem}[Unforgeability-1 of \CUASMPS]
%   If the base \CUASGen construction is unforgeable according to
%   \defref{def:forge-uas}, then \CUASMPS satisfies unforgeability-1 as
%   defined in \cite{ngsy22}.
% \end{theorem}

% \begin{theorem}[Unforgeability-2 of \CUASMPS]
%   If the base \CUASGen construction has non-frameability according to
%   \defref{def:frame-uas}, then \CUASMPS satisfies unforgeability-2 as
%   defined in \cite{ngsy22}.
% \end{theorem}

\subsection{Revocable Anonymous Credentials}
\label{ssec:related-models-rac}

In \cite{cks10,ckl+15}, revocable anonymous credentials are proposed. We first
give a simple model in \figref{fig:model-rac}, extending that in
\secref{ssec:related-models-ac}. Concretely, to the functionality in
\secref{ssec:related-models-ac}, we now explicitly add the $OKeyGen$ function,
which generates the opener key pair, extend $Verify$ to receive also a list $L$
of revoked credential identifiers, and we add a function (and corresponding
oracle) $cid/\bot \gets RetrieveCredId(\osk,\utrans)$ that can extract an
identifier of the credential used in a presentation transcript \utrans. For
simplicity, we do not include the equivalent to verifiable openings, but this
would be straightforward.

\begin{figure}[ht!]
  \centering
  \scalebox{0.85}{      
    \begin{minipage}[t]{0.43\textwidth}
      \procedure[linenumbering]{$\Exp^{anon-b}_{\adv,rac}(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        (\opk,\osk) \gets \OKeyGen(\parm) \\        
        (\ipk,\isk) \gets IssKeyGen(\parm) \\        
        b^* \gets \adv^{\mathcal{O}_{rac},\oracle{LoR}}(\parm,\ipk,\opk) \\
        \pcreturn b^*
      }
    \end{minipage}
  }
  \scalebox{0.85}{      
    \begin{minipage}[t]{.57\textwidth}
      \procedure[linenumbering]{$\Exp^{forge}_{\adv,rac}(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        (\opk,\osk) \gets \OKeyGen(\parm) \\        
        (\ipk,\isk) \gets IssKeyGen(\parm) \\
        (\cid,D,L,\st) \gets
        \adv^{\mathcal{O}_{rac}}(\parm,\ipk,\opk) \\
        \langle \cdot,(b_0,\utrans_0)\rangle
        \gets \langle \adv(\st),\Verify(\ipk,D,L)\rangle \\
        \langle \cdot,(b_1,\utrans_1)\rangle
        \gets \langle Show(\ipk,\ATTR[\cid],D,\CRED[\cid]), \\
        \hspace*{7.25em}\Verify(\ipk,D,L)\rangle \\
        \pcif \OWNR[\cid] \notin \HU \lor
        D \not\subseteq \ATTR[\cid]: \pcreturn 0 \\
        \pcif b_0 = 1 \land \nexists j~\suchthat~(\OWNR[j] \in \CU
        \land D \subseteq \ATTR[j]): \\
        \pcind \pcreturn 1 \\
        h_{\bin} \gets RetrieveCredHandle(\osk,\utrans_{\bin}) \\
        \pcreturn h_0 \in L \lor (h_1 \notin L \land b_1 = 0)
      }       
    \end{minipage}      
  }
  \caption{Security games for revocable anonymous credentials with selective
    disclosure based on \cite{fhs19}. 
    $\mathcal{O}_{rac} \gets \lbrace \oracle{HU},\oracle{CU},\oracle{Obtain},
    \oracle{Issue},\oracle{ObtIss},\oracle{Show},\oracle{ReqCredHandle}\rbrace$.
    $\oracle{ReqCredHandle}$ is
    equivalent to \OPEN, operating on transcripts \utrans instead of signatures
    but, in addition, keeps a list of revoked users (per verifier), based on the
    queries it receives. In $\Exp^{forge}_{\adv,rac}$, \adv~wins if it
    authenticates using a revoked credential or despite not having the required
    attributes, or if it prevents an honest user from authenticating using a
    non-revoked credential.}
  \label{fig:model-rac}  
\end{figure}

\subsubsection{\CUASRAC Construction.} %
Briefly, this is achieved via a $(\fissue^1,\feval^{\dattrs,H,V,L},
\finsp^{H})$-\CUASGenInt restriction, where $\fissue^1$ is as in
\figref{fig:func-restrictions}, and $\feval^{\dattrs,H,V,L}$ and $\finsp^{H}$
are as specified in \esref{eq:funcs-rac}.

\begin{align}
  \feval^{\dattrs,H,V,L}(\upk,((\cidi,\cidu),\attrs),\cdot) \coloneqq &
    \nonumber \\
  & \hspace*{-10em} \pcif H(V,\cidi) \in L \lor H(V,\cidu) \in L: \pcreturn \bot
  \nonumber \\
  & \hspace*{-10em} \pcelse \pcreturn (\lbrace \attrs_i \rbrace_{i\in \dattrs},V) \nonumber \\
  \finsp^{H}((\cdot,\yeval^1),\cdot,((\cidi,\cidu),\attrs),\cdot)
  \coloneqq  & \nonumber \\
  & \hspace*{-10em} \pcreturn (H(\yeval^1,\cidi),H(\yeval^1,\cidu))
  \label{eq:funcs-rac}
\end{align}

Concretely, $\feval^{\dattrs,H,V,L}$ is defined via a set of attributes \dattrs
to reveal, a PRF $H$, a string identifying the verifier $V$
and a list $L$ of revocation handles by $V$. Note that, these ``extra
parameters'' can be hardcoded, though: $H$ can be a fixed PRF for all verifiers,
\dattrs and $V$ are also fixed (per verifier), and $L$ can be updated per
verifier with some reasonable frequency -- e.g., daily -- so that the cost of
recomputing $\feval^{\dattrs,H,V,L}$ is not high (of course, revocation of a
credential is not effectuve until $L$, and the function, is updated).
%
Since credentials in \CUASGenInt have two identifiers (\cidi, chosen by the
issuer; and \cidu, chosen by the user), $\feval^{\dattrs,H,V,L}$ internally
computes $H(V,\cidi)$ and $H(V,\cidu)$. If either appears in $L$, \feval aborts.
Otherwise, it sets $\yeval^0 \gets \lbrace \attrs_i \rbrace_{i\in\dattrs}$ and
$\yeval^1 \gets V$. $\yeval^1$ is
then used by $\finsp^H$ to compute $\yinsp \gets (H(\yeval^1,\cidi),
H(\yeval^1,\cidu))$. Thus, if the verifier $V$ wants to revoke a credential, all
it has to do is ask the opener to decrypt $\yinsp$, via $RetrieveCredHandle$,
and add it to its list $L$.
%
In more detail, the algorithms are as follows:

\begin{description}
\item[$\parm \gets \Setup(1^\secpar)$.] Runs $\Setup(1^\secpar)$ as in
  \CUASGenInt.
\item[$(\ipk,\isk) \gets IssKeyGen(\parm)$.] Runs \KeyGen+\ISet from
  \CUASGenInt, setting $\fissue^1$ as issuance function.
\item[$(\ipk,\isk) \gets OKeyGen(\parm)$.] Runs \OKeyGen from \CUASGenInt,
  setting $\finsp^F$ as opening function.
\item[$(\upk,\usk) \gets UserKeyGen(\ipk)$.] Runs \KeyGen from \CUASGenInt.
\item[$\langle \cred/\bot,\top/\bot \rangle \gets
  \langle \Obtain(\usk,\ipk,\attrs),\Issue(\isk,\upk,\attrs) \rangle$.]
  Runs the $\langle \Obtain,\Issue \rangle$ protocol from \CUASGenInt, using
  $\fissue^1$ as issuance function.
\item[$\langle 1/0,(\yeval,\utrans)/(0,\utrans)\rangle \gets \langle Show(\ipk,
  \attrs,\dattrs,\cred),
  \Verify(\ipk,\dattrs) \rangle$.]
  Runs the interactive $\langle\Sign,\Verify\rangle$ of \CUASGenInt,
  using $\feval^{\dattrs,H,V,L}$ as signature evaluation function, and
  $\finsp^H$ as open function. The \yeval value output by the verifier, when
  it accepts, is the $\yeval^0$ value produced by \Sign in \CUASGenInt.
\item[$h/\bot \gets RetrieveCredHandle(\osk,\utrans)$.]
  Gets $(\sig,\yeval^0)$ from the $\langle Show,\Verify\rangle$ transcript
  \utrans, and runs \Open from \CUASGenInt. This returns $(H(V,\cidi),
  H(V,\cidu))$, which the verifier can add to its revocation list $L$.
\end{description}

\paragraph{Security of \CUASRAC.} %
We prove that \CUASRAC is an anonymous and unforgeable anonymous credential
scheme, according to the model in \figref{fig:model-rac}, if the underlying
\CUASGen construction has signature anonymity and is unforgeable.
%
As for \CUASAC, we reduce to security of \CUASGen rather than to
\CUASGenInt. The ``translation'' between \CUASGen and \CUASGenInt is
again trivial.

\begin{theorem}[Anonymity of \CUASRAC]
  \label{thm:anon-cuasrac}
  If the base \CUASGen construction has signature anonymity according to
  \defref{def:sign-anonymity-uas}, then \CUASAC is an anonymous AC scheme
  according to the model in \figref{fig:model-rac}.
\end{theorem}

\begin{proof}
  Given \adv~ against anonymity of \CUASRAC as defined in
  \figref{fig:model-rac}, we build an adversary \advB against anonymity of
  \CUASGen as defined in \defref{def:sign-anonymity-uas}.
  %
  But, first observe that, since the revocation oracle is basically an extension
  of the \OPEN oracle -- also keeping track of the revoked users per verifier --
  queries involving challenge users are rejected if the revocation handle does
  not match for both challenge users.
  
  To simulate oracle calls by \adv, \advB simply redirects to its corresponding
  oracle, i.e.: for calls to \oracle{HU}, \oracle{CU}, \oracle{Obtain},
  \oracle{Show}, \oracle{LoR}, \oracle{ReqCredHandle}, \advB
  redirects to \HUGEN, \CUGEN, \OBTAIN, \SIGN, \CHALb, or \OPEN (in this case,
  also keeping track of the queries, per verifier), respectively.
  Note that ``translating'' the inputs from the former into inputs for the
  latter is trivial. Also, observe that $ReqCredHandle$/\OPEN essentially
  refuses to open transcripts from challenge users (signatures, in the
  non-interactive equivalent), as $F(V,\ccidi_0) \neq F(V,\ccidi_1)$ (and,
  similarly, for $\ccidu_b$) with overwhelming probability (see the $\tyinsp
  \neq \yinsp$) check in \figref{fig:oracles2}. Obviously, if \adv~wins in its
  anonymity game, then so does \advB with the same probability.
  % 
  \qed
\end{proof}

\begin{theorem}[Unforgeability of \CUASRAC]
  If the base \CUASGen construction has signature unforgeability according to
  \defref{def:sign-forge-uas}, and $H$ is a secure PRF, then \CUASRAC is an
  unforgeable RAC scheme.
\end{theorem}

\begin{proof}
  Given \adv~against unforgeability of \CUASRAC as defined in
  \figref{fig:model-rac}, we build an adversary \advB against signature
  unforgeability of \CUASGen as defined in \defref{def:sign-forge-uas}.

  To simulate oracle calls by \adv, \advB acts as in the anonymity proof
  (leveraging \OBTISS and \ISSUE oracles instead of \OBTAIN). Assume that \adv~
  wins its game via the winning condition of line 9 in the RAC unforgeability
  game. The same reasoning as in \CUASAC applies here. Next, note that the
  probability of \adv~winning its game via condition $h_0 \in L$ at line 11 is
  negligible, due to simulation extractability of the NIZK for \RelSig.
  Moreover, simulation extractability of the NIZK for \RelSig as well as
  randomness of $H$ ensure that, if $h_1 \notin L$, then $b_1 = 1$. Namely, even
  when given $H(V,\cidi),H(V,\cidu)$ for a credential identified by
  $(\cidi,\cidu)$ owned by an honest user, and some (potentially malicious) $V$,
  it is not possible to generate $H(V',\cidi)$ nor $H(V',\cidu)$, for $V'=V$.
  % 
  \qed
\end{proof}

Note that, if we aim at global credential (resp. user) revocation rather than
verifier-local revocation, we can have \finsp just output the $(\cidi,\cidu)$
pair (resp., \upk), and no assumption regarding $H$ is needed.

\subsection{Delegatable Anonymous Credentials}
\label{sapp:related-models-dac}

We give a simple definition for a Delegatable Anonymous Credentials (DAC)
scheme, extending \cite{fhs19} and inspired by \cite{bcc+09}. Unlike the latter,
our simple scheme built from \CUASGenInt does not ensure privacy of the
delegation chain, which means that only actions by users with the same
delegation chain are indistinguishable -- this can make sense, for instance,
for organisations composed by many members. Delegation chain privacy could be
achieved by making \feval output projective proofs like in \cite{bcc+09} (or,
to some extent, building on \CUASGenHideIss rather than on \CUASGen), but we
leave that out of scope for brevity. Our simple scheme
does, however, ensure that a (not top-level) issuer can only delegate attributes
contained in a credential it owns. Also, for simplicity, we restrict to the case
of using one credential per signature/interactive credential presentation, and
assume that all parties use the same opener and \finsp function.
%
The syntax is thus defined almost as in \secref{ssec:related-models-ac},
i.e., we have a $Setup$ algorithm, and $\langle Obtain,Issue\rangle$
and $\langle Show,Verify \rangle$ interactive protocols; but we do not have
$IssKeyGen$, as now, as in \cite{bcc+09} (and our \UAS model), issuers collapse
with users -- instead, we have an $KG$ and $ISet$ algorithms, with the same
meaning as in \UAS.
%
In the model for this setting, since there are multiple issuers, in addition
to the oracles in \secref{ssec:related-models-ac}, we use $HI$ and $CI$ oracles,
for creating honest and corrupt issuers, which can be simulated via \HUGEN,
\CUGEN, \ISET and \ICORR in our \UAS model.
%
The issuance and sign anonymity properties are direct, constraining the
adversary to output challenge credentials and signatures with the same
delegation chain. For unforgeability, we still require that no adversary can
authenticate using a set of attributes that have not been issued to a corrupt
user. In addition, we require that for any successful authentication using a
level-$l$ credential, we can extract a chain of credentials of length $l$ such
that each level-$i$ credential can be used successfully to authenticate the
level-$(i+1)$ credential, all the way down to the level-$l$ credential, and the
attributes revealed in the level-$l$ authentication are contained in all the
credentials up the chain. For this extraction, we assume in the model the
existence of a helper function $(\ipk_0,\lbrace (\ipk_i,\cred_i)
\rbrace_{i\in[1,l]}) \gets \helper{ExtractChain}(\utrans)$ that outputs a
sequence of public keys and credentials from the root issuer $\ipk_0$ to the
actual credential used to sign $(\ipk_l,\cred_l)$.

\begin{figure}[ht!]
  \centering
  \scalebox{0.9}{      
    \begin{minipage}[t]{0.45\textwidth}
      \procedure[linenumbering]{$\Exp^{iss-anon-b}_{\adv,dac}(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        b^* \gets \adv^{\mathcal{O}_{dac},\oracle{IssLoR}}(\parm) \\
        \pccomment{Abort if challenge creds belong to} \\
        \pccomment{users with different delegation chains} \\
        \pcreturn b^*
      }
      \vspace*{0.5em}

      \procedure[linenumbering]{$\Exp^{sig-anon-b}_{\adv,dac}(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        b^* \gets \adv^{\mathcal{O}_{dac,\oracle{SigLoR}}}(\parm) \\
        \pccomment{Abort if challenge sigs belong to} \\
        \pccomment{users with different delegation chains} \\
        \pcreturn b^*
      }        
    \end{minipage}
  }
  \scalebox{0.9}{      
    \begin{minipage}[t]{.55\textwidth}
      \procedure[linenumbering]{$\Exp^{forge}_{\adv,dac}(1^\secpar)$}{%
        \parm \gets \SimSetup(1^\secpar) \\
        (D=(l,D'),\ipk_l,\st) \gets
        \adv^{\mathcal{O}_{dac}}(\parm) \\
        \langle\cdot,(b,\utrans)\rangle \gets
        \langle \adv(\st),\Verify(\ipk_l,D)\rangle \\
        \pcif b = 0: \pcreturn 0 \\
        \pcif \nexists j~\suchthat~(\OWNR[j] \in \CU
        \land D \subseteq \ATTR[j]): \pcreturn 1 \\        
        (ipk_0, \lbrace (\ipk_i,\cred_i) \rbrace_{i \in [1,l]})
        \gets ExtractChain(\utrans) \\ 
        \pcif \exists i \in [1,l]~\suchthat~
        \iid = \ISR[\ipk_{i-1}] \notin \CI~\land \\
        \pcind D' \not\subseteq \ATTR[\iid]: \\
        \pcind \pcreturn 1 \\
        \pcreturn 0
      }       
    \end{minipage}      
  }
  \caption{Security games for delegatable anonymous credentials with selective
    disclosure based on \cite{fhs19}. $\mathcal{O}_{dac} \gets \lbrace
    \oracle{HI},\oracle{CI},\oracle{Obtain},\oracle{Issue},\oracle{ObtIss},
    \oracle{Show}\rbrace$. $\oracle{IssLor}$ corresponds to \OBTCHALb in \UAS,
    whereas $\oracle{SigLor}$ corresponds to \CHALb. Also, \OWNR
    and \ATTR tables are essentially as in \secref{ssec:model-uas}.
    $\ISR[\ipk]$, in this case, returns the identifier of the issuer with public
    key \ipk. With $D = (l,D')$ we mean that the first attribute in the revealed
    set $D$ is $l$, which denotes the level of the credential used for
    authentication.}
  \label{fig:model-dac}  
\end{figure}

\subsubsection{\CUASDAC Construction.} %
We next give a construction of a delegatable AC (DAC) scheme, in the shape of
a $(\fissue^{l,D},\feval^{l,\dattrs},\finsp^0)$-\CUASGenInt
restriction, where the $\finsp^0$ function is as defined in
\figref{fig:func-restrictions}, and the \fissue and \feval variants are as
defined next:

\begin{align}
  & \fissue^{l,D}(\cdot,\attrs,(\cid,\cattrs)) \coloneqq
    \pcreturn \cattrs_1 = l \land \attrs_1 = l+1
    \land \cattrs \subseteq D \land \attrs_{[2..n]} \subseteq \cattrs \nonumber \\
  & \feval^{l,\dattrs}(\cdot,(\cid,\attrs),\cdot) \coloneqq
    \pcreturn((\attrs_1,\lbrace\attrs_i\rbrace_{i\in\dattrs}),\ast)
    \label{eq:funcs-dac}
\end{align}

In a DAC scheme, all users are (or may be) also issuers. We only
distinguish between top-level issuers, who have level $l=0$, and lower-level
issuers, who have level $l>0$. In our \CUASDAC scheme, we assume that the first
attribute (after the user's secret key and credential identifiers) encodes the
level of the credential. That is, $\attrs_1=l$, for a credential of level $l$.
In addition, all users (with $l>0$) who want to delegate have to publicly
list:

\begin{enumerate}
\item The level $l$ of the credential they delegate.
\item Their public key \ipk.
\item An \UAS signature proving knowledge of a credential of level $l$, and over
  the attributes $D$ that this level-$l$ issuer is delegating.
\item The \ipk of the parent issuer.
\item The $\fissue^{l,D}$ function they will require for delegating.
\item An $\feval^{l,D}$ function used to produce the signature at item 3.
\end{enumerate}

We assume that, from an \ipk, it is possible to find the corresponding issuer
(e.g., using the previously mentioned public list). The
$\fissue^{l,D}$ functions must follow the pattern in \figref{fig:func-restrictions}.
Namely, the issuance function checks that the first requested attribute equals
$l+1$, and that the remaining attributes are a subset of the attribute set
D being delegated by the level-$l$ issuer. In addition, signature
evaluation functions $\feval^{l,D}$, also shown in \figref{fig:func-restrictions},
must reveal the level of the credential used to produce the \UAS signature at
item 3, as well as the set of attributes \dattrs that the level-$l$ issuer
delegates. Verifiers can then trivially check if the set of revealed attributes
are contained within the attributes delegatable by the parent issuer%
\footnote{Additional checks may be added in both functions, but this is
  the bare minimum.} -- this $\feval^{l,D}$ function is just the same as the
$\feval^{l,\dattrs}$ function in \esref{eq:funcs-dac}, but where $D=\dattrs$,
which is required to verify the \UAS signature produced at step 3.
%
From this high-level description, we define the concrete algorithms of \CUASDAC:

\begin{description}
\item[$\parm \gets \Setup(1^\secpar)$.]  Runs $\parm' \gets \Setup(1^\secpar)$
  and $(\opk,\osk) \gets \OKeyGen(\parm',\finsp^0)$ from our
  \CUASGenInt construction. Returns $\parm \gets (\parm',\opk)$. Note
  that $\finsp^0$ can be replaced by any desired opening function.
\item[$(\upk,\usk) \gets KG(\parm)$.] As in \CUASGenInt.
\item[$\ipk \gets ISet(\upk,\usk,\fissue^{l,D})$.] If $l = 0$, then just
  run $\ipk \gets \ISet(\upk,\usk,\fissue^{l,D})$, and publish $(0,\ipk,\bot,
  \bot,\fissue,\bot)$, for any \fissue function required by the level-$0$
  issuer. Else,  
  if $l > 0$ (the entity running the algorithm owns a level-$l$ credential
  issued by a level-$(l-1)$ issuer, containing attributes $D$) run $\ipk' \gets
  \ISet(\upk,\usk,\fissue^{l,D})$ as in \CUASGenInt. Then, obtain $\Sig \gets
  \CUASGenInt.\Sign(\usk,\opk,\Cred,\msg,\feval^{l,D})$, where \opk is the
  opener public key in \parm, \msg is some random message, and \Cred is the
  level-$l$ credential owned by the current issuer. Then, set
  $\ipk \gets (l,\ipk',\Sig,\ipk^{l-1},\fissue^{l,D},\feval^{l,D})$, where
  $\ipk^{l-1}$ is the public key of the level-$(l-1)$ issuer.
\item[$\langle \cred/\bot,\top/\bot \rangle \gets
  \langle \Obtain(\usk,\ipk,\attrs),\Issue(\isk,\upk,\attrs) \rangle$.]
  The user first finds the corresponding $(l,\ipk,\Sig,\ipk^{n-1},\fissue^{l,D},
  \feval^{l,D})$ tuple. If $l>0$, the user checks \Sig running \Verify as in
  \CUASGenInt (with the retrieved $\feval^{l,D}$) and then, user and level-$l$
  issuer run $\langle\Obtain,\Issue\rangle$ as in \CUASGenInt, using
  $\fissue^{l,D}$ as issuance function. If $l=0$, then user and issuer
  run $\langle\Obtain,\Issue\rangle$ as in \CUASGenInt, using the \fissue
  function specified in the issuer's tuple.
\item[$\langle 1/0,(1,\utrans)/(0,\utrans)\rangle
  \gets \langle Show(\opk,\attrs,\dattrs,\cred),
  \Verify(\opk,\dattrs) \rangle$.] As in \CUASGenInt.
\end{description}

\paragraph{Security of \CUASDAC.} % 
We prove that \CUASDAC is an anonymous and unforgeable DAC scheme, according to
the model in \figref{fig:model-dac}, if the underlying \CUASGenInt construction
has anonymous issuance and signing, and is unforgeable.

\begin{theorem}[Issuance anonymity of \CUASDAC]
  If the base \CUASGenInt construction has issuance anonymity according to
  (the interactive version of) \defref{def:issue-anonymity-uas}, then \CUASDAC
  also has issuance anonymity.
\end{theorem}

\begin{proof}
  Given \adv~against issuance anonymity of \CUASDAC as defined in
  $\Exp^{iss-anon-b}_{\adv,dac}(1^\secpar)$, we build an adversary \advB against
  issuance anonymity of \CUASGenInt.

  To simulate oracle calls by \adv, \advB simply redirects to its corresponding
  oracle, i.e.: for calls to \oracle{HU},\oracle{CU},\oracle{Obtain},
  \oracle{Show},\oracle{IssLoR}, \advB redirects to the \CUASGenInt oracles
  \HUGEN,\CUGEN,\OBTAIN,\SIGN,\OBTCHALb, respectively. \oracle{HI} (resp.
  \oracle{CI}) is simulated by calling \HUGEN (resp. \CUGEN) and \ISET
  sequentially and for the same \uid, plus a call to \SIGN in the case of
  honest issuers of level $l>0$, to generate the signature \Sig that the
  (honest) issuer has to publish.
  %
  If \adv~wins in its issuance anonymity game, then so does \advB with the same
  probability, as the simulation is perfect.
  % 
  \qed
\end{proof}

\begin{theorem}[Signature anonymity of \CUASDAC]
  If the base \CUASGenInt construction has signature anonymity according to
  (the interactive version of) \defref{def:sign-anonymity-uas}, then \CUASDAC
  also has signature anonymity.
\end{theorem}

\begin{proof}
  Given \adv~ against signature anonymity of \CUASDAC as defined in
  $\Exp^{sig-anon-b}_{\adv,dac}(1^\secpar)$, we build an adversary \advB against
  signature anonymity of \CUASGenInt.
  %
  \adv's oracles are simulated as in the proof for issuance anonymity of
  \CUASDAC -- in this case, \adv's \oracle{SigLoR} oracle corresponds to \advB's
  \CHALb. Again, the simulation is perfect, and whenever \adv~wins its
  $\Exp^{sig-anon-b}$ game, so does \advB.
  % 
  \qed
\end{proof}

\begin{theorem}[Unforgeability of \CUASDAC]
  If the base \CUASGenInt construction has issuance unforgeability according to
  (the interactive version of) \defref{def:issue-forge-uas}, signature
  unforgeability according to (the interactive version of)
  \defref{def:sign-forge-uas}, and is non-frameable according to (the
  interactive version of) \defref{def:frame-uas}, then \CUASDAC is an
  unforgeable DAC scheme.
\end{theorem}

\begin{proof}
  First, we define the $ExtractChain(\utrans)$ function for our construction.
  Note that \utrans is a tuple $(r,\Sig)$\footnote{This follows for the approach
    to transform non-interactive signature and verification in \UAS to
    interactive presentations, as described in \secref{ssec:variants}.}, where
  $r$ is a fresh random number specified by the adversary,
  and \Sig is a \CUASGen signature over $r$. Thus, $ExtractChain$ leverages
  \ExtractSign from \CUASGen (see \secref{ssec:security-uas}) to get the
  credential and associated \ipk used to produce \Sig. Note that, for this
  \ipk (of level $n$), $\ipk = \ipk_{n-1}$ in $\Exp^{forge}_{\adv,dac}$. In
  \CUASDAC, we can leverage $\ipk_{n-1}$ to fetch from the public list a
  signature $\Sig_{n-1}$ generated by the issuer owner of $\ipk_{n-1}$. Again,
  we apply \ExtractSign from \CUASGen, to get the credential one layer up in the
  chain. \helper{ExtractChain} repeats this step, until reaching the top level
  credential, issued by $\ipk_0$.

  From the previous, the same reasoning as in \thmref{thm:forge-cuasac} applies
  to an adversary \adv~winning at line 5 of $\Exp^{forge}_{\adv,dac}$. Next,
  suppose that from \utrans, $ExtractChain$ outputs at line 6 a
  delegation chain that makes \adv~win at line 9. This means that an
  uncorrupted issuer at position $i-1$ of the chain did not own a credential
  containing $D'$, but the issuer at position $i$ does. Then, either of the
  following must happen:

  \begin{itemize}
  \item The credential of the issuer at position $i$ is a forgery, meaning that
    it is a valid signature by the issuer at position $i-1$, who did not produce
    it. This can be used to break signature non-frameability of \CUASGenInt.
  \item The credential of the issuer at position $i$ is not a forgery, meaning
    that it is a valid signature by the issuer at position $i-1$, who did
    produce it. But this contradicts the conditions required by $\fissue^{n,D}$,
    and therefore breaks issuance unforgeability of \CUASGenInt.
  \end{itemize}
  %
  \qed
\end{proof}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "uas-paper"
%%% End:
