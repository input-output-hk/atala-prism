\section{Relationships with More Schemes}
\label{app:related-extra}

\subsection{Group Signatures with Message Dependent Opening}
\label{sapp:related-models-gsmdo}

We cannot build the exact same functionality, nor follow the exact same security
model as in the group signatures with message dependent opening (GS-MDO) scheme
described in \cite{ehk+19}. Simply because, therein, the opening functionality
is divided in two authorities: the admitter, who decides which messages are
subject to be opened or not, and generates a token that enables opening
signatures over such messages; and the opener, who performs the actual opening,
but cannot do it without the tokens generated by the admitter. Intuitively, this
can be seen as a sort of ``distribution'' of the opening capability. We define
a variant of this model in which the admitter and opener are combined back into
one entity (the opener), who can only open signatures over predefined messages,
but cannot open any other signature. Moreover, our variant directly supports the
scenario of multiple such openers, each being able to open only signatures
over different messages. Note that it would not be hard to apply thresholding
techniques to extend this case so that our ``unified'' opener role is shared
across multiple entities, who have to cooperate in order to open a signature
\needcite, thus achieving something very close ``in spirit'' to the scheme in
\cite{ehk+19}. In addition, while \cite{ehk+19} follows the static group
signature setting, we move to the dynamic one. Informally, our variant of GS-MDO
is composed of the following algorithms: \Setup,
\IKeyGen, \OKeyGen, \UKeyGen, \Sign, \Verify, \Open; as well as the $\langle
\Obtain, \Issue \rangle$ interactive protocol. \OKeyGen generates an opening
key pair which is already configured to open signatures only over some fixed
(but arbitrary) set of messages. The remaining algorithms are as usual, so we
defer a more detailed description to the construction. The oracles are the same
as in \UAS. The resulting security model is given in \figref{fig:model-gsmdo},
which we adapt from \cite{ehk+19}.

\begin{figure}[ht!]
  \centering
  \scalebox{0.9}{      
    \begin{minipage}[t]{0.45\textwidth}        
      \procedure[linenumbering]{$\Exp^{anon-b}_{\adv,gsmdo}(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        (\ipk,\isk) \gets \IKeyGen(\parm) \\
        b^* \gets \adv^{\mathcal{O}^{anon}}(\parm,\ipk) \\
        \pcreturn b^*
      }
      
      \vspace*{5em}
      
      \procedure[linenumbering]{$\Exp^{frame}_{\adv,gsmdo}(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        (\ipk,\isk) \gets \IKeyGen(\parm) \\
        (\msg,\sig,\upk,\tau) \gets \adv^{\mathcal{O}^{frame}}
        (\ipk,\isk) \\
        \pcif \Verify(\gpk,\msg,\sig) = 0: \pcreturn 0 \\
        \pcreturn 1~\pcif \upk \in \HU \land \PRVUK[\upk] \neq \bot \land
        \Judge(\gpk,\upk,\msg,\sig,\tau) = 1~\land \\
        \pcind \adv~\textrm{did not query}~USK(\upk)~\textrm{or}~
        GSig(\PRVUK[\upk],\msg) \\
        \pcreturn 0
      }       
    \end{minipage}
  }
  \scalebox{0.9}{      
    \begin{minipage}[t]{.55\textwidth}
      \procedure[linenumbering]{$\Exp^{trace}_{\adv,gsmdo}(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        (\ipk,\isk) \gets \IKeyGen(\parm) \\
        (\msg,\sig,\upk,\tau) \gets \adv^{\mathcal{O}^{trace}}
        (\ipk,\opk,\osk) \\
        \pcif \Verify(\gpk,\msg,\sig) = 0: \pcreturn 0 \\
        (\upk, \tau) \gets \Open(\gpk,\osk,\trans,\msg,\sig) \\
        \pcif \upk \notin \HU \cup \CU \lor \Judge(\gpk,\upk,\msg,\sig,\tau)
        = 0: \\ 
        \pcind \pcreturn 1 \\
        \pcreturn 0
      }       
    \end{minipage}      
  }
  \caption{Security games for our GS-MDO variant.
    $\mathcal{O}^{anon} \gets \lbrace \OGEN^{\smsg},\HUGEN,\CUGEN,\WREG,
    \OBTAIN,\SIGN,\OPEN,\CHALb \rbrace$; $\mathcal{O}^{trace} \gets \lbrace
    \OGEN,\HUGEN,\CUGEN,\ISSUE,\OBTISS,\RREG,\SIGN \rbrace$;
    $\mathcal{O}^{frame} \gets \lbrace \OGEN,\HUGEN,\CUGEN,\WREG,
    \OBTAIN,\SIGN \rbrace$. $\OGEN^{\smsg}$ is like \OGEN, but only accepting
    functions of type $\finsp^{\smsg}$.
  }
  \label{fig:model-gsmdo}  
\end{figure}

\subsubsection{\CUASGSMDO construction.} %
We show that, as specified in \tabref{tab:uas-alt-funcs}, our \CUASGen
construction for \UAS, restricted to $\fissue^1$ as issuance function,
$\feval^0$ as signature evaluation function, and $\finsp^{\smsg}$ as opening
function, is a secure group signature scheme with message dependent opening
as modelled in \figref{fig:model-gsmdo}. We first quickly define the algorithms,
and then prove security.

\begin{description}
\item[$\parm \gets \Setup(1^\secpar)$.] Like in vanilla \CUASGen.
\item[$(\upk,\usk) \gets \UKeyGen(1^\secpar)$.] Like the \UKeyGen function for
  \CUASGS, in \secref{sapp:related-models-gs}.
\item[$\langle \cred,\utrans \rangle \gets
  \langle\Obtain(\usk,\ipk),\Issue(\isk,\upk)\rangle$.] Like the corresponding
  protocol in in vanilla \CUASGS, \secref{sapp:related-model-gs}.
\item[$\sig \gets \Sign(\gpk,\cred,\msg)$.] Like in vanilla \CUASGen, limited
  on evaluation functions $\feval^0$ and opening functions $\finsp^{\smsg}$.
\item[$1/0 \gets \Verify(\gpk,\sig,\msg)$.] Like in vanilla \CUASGen.
\item[$(\upk,\pi) \gets \Open(\gpk,\osk,\trans,\sig,\msg)$.] Like in vanilla
  \CUASGen.
\item[$1/0 \gets \Judge(\gpk,\pi,\upk,\sig,\msg)$.] Like in vanilla \CUASGen.
\end{description}

\paragraph{Security of \CUASGSMDO.} %
Our \CUASGSMDO construction is a secure group signature scheme,
according to the model in \figref{fig:model-gsmdo}, if the underlying \CUASGen
construction is secure.

Note that both  model construction are essentially restrictions to the model
and construction of \CUASGen. Thus, security directly follows from security of
\CUASGen.

% \begin{theorem}[Anonymity of \CUASGSMDO]
%   If the base \CUASGen construction is anonymous according to
%   \defref{def:anonymity-uas}, then \CUASGSMDO is an anonymous group signature
%   scheme.
% \end{theorem}

% \begin{proof}
  
%   \qed
% \end{proof}

% \begin{theorem}[Traceability of \CUASGSMDO]
%   If the base \CUASGen construction has unforgeable signing according to
%   \defref{def:sign-forge-uas}, then \CUASGSMDO is a traceable group signature
%   scheme.
% \end{theorem}

% \begin{proof}
%   Traceability follows directly from the corresponding proof for \CUASGS.
%   \qed
% \end{proof}

% \begin{theorem}[Non-frameability of \CUASGSMDO]
%   If the base \CUASGen construction is non-frameable according to
%   \defref{def:frame-uas}, then \CUASGSMDO is a non-frameable group signature
%   scheme.
% \end{theorem}

% \begin{proof}
%   Non-frameability follows directly from the corresponding proof for \CUASGS.
%   \qed
% \end{proof}

\subsection{Delegatable Anonymous Credentials}
\label{sapp:related-models-dac}

We give a simple definition for a Delegatable Anonymous Credentials (DAC)
scheme, extending \cite{fhs19} and inspired by \cite{bcc+09}. Unlike the latter,
our simple scheme built from $\CUASGen^{usr-iss}$ does not ensure privacy of the
delegation chain -- which could be achieved by making \feval output projective
proofs like in \cite{bcc+09}, but since our goal is to showcase the feasibility
of building DAC from \UAS, we leave that out for brevity. Our simple scheme
does, however, ensure that a (not top-level) issuer can only delegate attributes
contained in a credential it owns. Also, for simplicity, we restrict to the case
of using one credential per signature/interactive credential presentation, and
assume that all parties use the same opener and \finsp function.
%
The functionality is thus defined almost as in \secref{ssec:related-models-ac},
i.e., we have $Setup$, $IssKeyGen$ algorithms, and $\langle Obtain,Issue\rangle$
and $\langle Show,Verify \rangle$ interactive protocols; but we do not have
$UserKeyGen$, as this collapses with $IssKeyGen$.
%
In the model for this setting, since there are multiple issuers, in addition
to the oracles in \secref{ssec:related-models-ac}, we use $HI$ and $CI$ oracles,
equivalent to \IGEN and \ICORR in our \UAS model, which allow adding honest
issuers, and corrupt existing ones, respectively. The issuance and sign
anonymity properties are direct, constraining the adversary to output challenge
credentials and signatures with the same delegation chain. For unforgeability,
we still require that no adversary can authenticate using a set of attributes
that have not been issued to a corrupt user. In addition, we require that for
any successful authentication using a level-$l$ credential, we
can extract a chain of credentials of length $l$ such that each level-$i$
credential can be used successfully to authenticate a level-$(i+1)$ credential
down to the level-$l$ credential, and the attributes revealed in the
level-$l$ authentication are contained in all the credentials up the chain.

\begin{figure}[ht!]
  \centering
  \scalebox{0.9}{      
    \begin{minipage}[t]{0.45\textwidth}
      \procedure[linenumbering]{$\Exp^{iss-anon-b}_{\adv,dac}(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        b^* \gets \adv^{\mathcal{O}_{iss-anon}}(\parm) \\
        \pccomment{Abort if challenge creds belong to} \\
        \pccomment{users with different delegation chains} \\
        \pcreturn b^*
      }
      \vspace*{0.5em}

      \procedure[linenumbering]{$\Exp^{sig-anon-b}_{\adv,dac}(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        b^* \gets \adv^{\mathcal{O}_{sig-anon}}(\parm) \\
        \pccomment{Abort if challenge sigs belong to} \\
        \pccomment{users with different delegation chains} \\
        \pcreturn b^*
      }        
    \end{minipage}
  }
  \scalebox{0.9}{      
    \begin{minipage}[t]{.55\textwidth}
      \procedure[linenumbering]{$\Exp^{forge}_{\adv,dac}(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        (D=(l,D'),\ipk_l,\st) \gets
        \adv^{\mathcal{O}_{forge}}(\parm) \\
        \langle\cdot,(b,\utrans)\rangle \gets
        \langle \adv(\st),\Verify(\ipk_l,D)\rangle \\
        \pcif b = 0: \pcreturn 0 \\
        \pcif \nexists j~\suchthat~(\OWNR[j] \in \CU
        \land D \subseteq \ATTR[j]): \pcreturn 1 \\        
        (ipk_0, \lbrace (\ipk_i,\cred_i) \rbrace_{i \in [1,l]})
        \gets ExtractChain(\utrans) \\ 
        \pcif \exists i \in [1,l]~\suchthat~
        \iid = \ISR[\ipk_{i-1}] \notin \CI~\land \\
        \pcind D' \not\subseteq \ATTR[\iid]) \land
        D' \subseteq \ATTR[\ISR[\ipk_i]]: \\
        \pcind \pcreturn 1 \\
        \pcreturn 0
      }       
    \end{minipage}      
  }
  \caption{Security games for delegatable anonymous credentials with selective
    disclosure based on \cite{fhs19}. $\mathcal{O}_{iss-anon} \gets \lbrace HI,
    CI,Obtain,Issue,ObtIss,Show,IssLoR\rbrace$, $\mathcal{O}_{sig-anon} \gets
    \lbrace HI,CI,Obtain,Issue,ObtIss,Show,SigLoR\rbrace$. $\mathcal{O}_{forge}
    \gets \lbrace HI,CI,Obtain,ObtIss,Issue,Show\rbrace$. $IssLor$ corresponds
    to \OBTCHALb in \UAS, whereas $SigLor$ corresponds to \CHALb. Also, \OWNR
    and \ATTR tables are essentially as in \secref{ssec:model-uas}.
    $\ISR[\ipk]$, in this case, returns the identifier of the issuer with public
    key \ipk. With $D = (l,D')$ we mean that the first attribute in the revealed
    set $D$ is $l$, which denotes the level of the credential used for
    authentication.}
  \label{fig:model-dac}  
\end{figure}

\subsubsection{\CUASDAC Construction.} %
We next give a construction of a delegatable AC (DAC) scheme, in the shape of
a $(\fissue^{l,\dattrs},\feval^{l,\dattrs},\finsp^0)$-$\CUASGen^{usr-iss}$
restriction, where the $\finsp^0$ function is as defined in
\figref{fig:func-restrictions}, and the \fissue and \feval variants are as
defined next:

\begin{align}
  & \fissue^{l,\dattrs}(\cdot,\attrs,(\cid,\cattrs)) \coloneqq
    \pcreturn (\attrs_1 = l+1 \land \attrs \subseteq
    \cup_{i\in\dattrs} \cattrs_i) \nonumber
  & \feval^{l,\dattrs}(\cdot,(\cid,\attrs),\cdot) \coloneqq
    \pcreturn((\attrs_1,\lbrace\attrs_i\rbrace_{i\in\dattrs}),\ast)
    \label{eq:funcs-rac}
\end{align}

. In a DAC scheme, all users are (or may be) also issuers. We only
distinguish between top-level issuers, who have level $l=0$, and lower-level
issuers, who have level $l>0$. In our \CUASDAC scheme, we assume that the first
attribute (after the user's secret key) encodes the level of the credential.
That is, $\attrs_1=l$, for a credential of level $l$. In addition, all users
(i.e., with $l>0$) who want to delegate have to publicly list:

\begin{enumerate}
\item The level $l$ of the credential they delegate.
\item Their public key \ipk.
\item An \UAS signature proving knowledge of a credential of level $l$, and over
  the attributes that this level-$l$ issuer is delegating.
\item The \ipk of the parent issuer.
\item The $\fissue^{l,\dattrs}$ function they will require for delegating.
\item An $\feval^{l,\dattrs}$ function used to produce the signature at item 3.
\end{enumerate}

We assume that, from an \ipk, it is possible to find the corresponding issuer
(e.g., using the previously mentioned public list). The mentioned
$\fissue^{l,\dattrs}$ functions must follow the pattern in \figref{fig:func-restrictions}.
Namely, the issuance function checks that the first requested attribute equals
$l+1$, and that all requested attributes are a subset of the attribute set
\dattrs being delegated by the level-$l$ issuer. In addition, signature
evaluation functions $\feval^{l,\dattrs}$, also shown in \figref{fig:func-restrictions},
must reveal the level of the credential used to produce the \UAS signature at
item 2, as well as the set of attributes \dattrs that the level-$l$ issuer
delegates. Verifiers can then trivially check if the set of revealed attributes
are contained within the attributes delegatable by the parent issuer%
\footnote{Additional checks may be added in both functions, but this is
  the bare minimum.}.
%
From this high-level description, we define the algorithms of \CUASDAC:

\begin{description}
\item[$\parm \gets \Setup(1^\secpar)$.]  Runs $\parm' \gets \Setup(1^\secpar)$
  and $(\opk,\osk) \gets \OKeyGen(\parm',\finsp^0)$ from our
  $\CUASGen^{usr-iss}$ construction. Returns $\parm \gets (\parm',\opk)$. Note
  that $\finsp^0$ can be replaced by any desired opening function.
\item[$(\ipk,\isk) \gets IssKeyGen(\parm)$.] If $l=0$, simply run \IKeyGen as
  in $\CUASGen^{usr-iss}$. If $l>0$, this level-$l$ issuer picks a random
  message $r$ and computes $\Sig = (\sig,\yeval) \gets \Sign(\usk,\opk,\cred,r,
  \feval^{l,\dattrs})$, for the \dattrs set it wants to reveal -- which must
  include the attributes to delegate, and the credential level. It then
  publishes $(l,\ipk,\Sig,\ipk^{l-1},\fissue^{l,\dattrs},\feval^{l,\dattrs})$,
  where $\ipk^{l-1}$ is the public key of the parent issuer,
  $\fissue^{l,\dattrs}$ is an issuance function as described in
  \figref{fig:func-restrictions}, and $\feval^{l,\dattrs}$ is also as in
  \figref{fig:func-restrictions}, revealing the attributes that the issuer is
  willing to delegate.
% \item[$(\upk,\usk) \gets UserKeyGen(\opk)$.] All users in this scheme are
%   also issuers. Thus, a new user runs first \IKeyGen as in \CUASGen. Then, sets
%   $\usk \gets \isk$ and stores \ipk, which may be needed to delegate obtained
%   credentials. Note that this does not affect security, as long as
%   $\isk \getr \AttrSpace$.
\item[$\langle \cred/\bot,\top/\bot \rangle \gets
  \langle \Obtain(\usk,\ipk,\attrs),\Issue(\isk,\upk,\attrs) \rangle$.]
  If $l>0$, the user first finds the corresponding $(l,\ipk,\Sig,\ipk^{n-1},
  \fissue^{l,\dattrs},\feval^{l,\dattrs})$ tuple, and checks \Sig running
  \Verify as in $\CUASGen^{usr-iss}$ (with the retrieved $\feval^{l,\dattrs}$).
  Then, user and level-$l$ issuer run $\langle\Obtain,\Issue\rangle$ as in
  $\CUASGen^{usr-iss}$, using $\fissue^{l,\dattrs}$ as issuance function. If
  $l=0$, then both run $\langle\Obtain,\Issue\rangle$ as in
  $\CUASGen^{usr-iss}$, using the \fissue function required by the issuer.
\item[$\langle 1/0,(1,\utrans)/(0,\utrans)\rangle
  \gets \langle Show(\opk,\attrs,\dattrs,\cred),
  \Verify(\opk,\dattrs) \rangle$.] As in the interactive variant of
  $\CUASGen^{usr-iss}$.  
\end{description}

\paragraph{Security of \CUASDAC.} % 
We prove that \CUASDAC is an anonymous and unforgeable DAC scheme, according to
the model in \figref{fig:model-dac}, if the underlying \CUASGen construction has
anonymous issuance and signing, and has unforgeable issuance and signing. 

\begin{theorem}[Issuance anonymity of \CUASDAC]
  If the base \CUASGen construction has issuance anonymity according to
  \defref{def:issue-anonymity-uas}, then \CUASDAC also has issuance anonymity.
\end{theorem}

\begin{proof}
  Given \adv~ against issuance anonymity of \CUASDAC as defined in
  $\Exp^{iss-anon-b}_{\adv,dac}(1^\secpar)$, we build an adversary \advB against
  issuance anonymity of \CUASGen as defined in \defref{def:issue-anonymity-uas}.

  To simulate oracle calls by \adv, \advB simply redirects to its corresponding
  oracle, i.e.: for calls to $HU,CU,HI,CI,Obtain,Show,IssLoR$, \advB redirects
  to \HUGEN,\CUGEN,\IGEN,\ICORR,\OBTAIN,\SIGN,\OBTCHALb, respectively. Note that
  ``translating'' the inputs from the former into inputs for the latter is
  trivial. Obviously, if \adv~ wins in its issuance anonymity game, then so does
  \advB with the  same probability.
  % 
  \qed
\end{proof}

\begin{theorem}[Signature anonymity of \CUASDAC]
  If the base \CUASGen construction has signature anonymity according to
  \defref{def:sign-anonymity-uas}, then \CUASDAC also has signature anonymity.
\end{theorem}

\begin{proof}
  This is the same as in \thmref{thm:anon-cuasac}.
  % 
  \qed
\end{proof}

\begin{theorem}[Unforgeability of \CUASAC]
  If the base \CUASGen construction has issuance and signature unforgeability
  according to \defref{def:issue-forge-uas} and \defref{def:sign-forge-uas}, and
  non-frameability according to \defref{def:frame-uas}, then \CUASAC is an
  unforgeable AC scheme.
\end{theorem}

\begin{proof}
  First, we define the $ExtractChain(\utrans)$ function for our construction.
  Note that \utrans is a tuple $(r,\Sig)$\footnote{This follows for the approach
    to transform non-interactive signature and verification in \UAS to interactive
    presentations, as described in \secref{ssec:variants-gsac}.}, where $r$ is a
  fresh random number produced by the environment (acting as honest verifier),
  and \Sig is a \CUASGen signature over $r$. Thus, $ExtractChain$ leverages
  \ExtractSign from \CUASGen (see \secref{ssec:security-uas}) to get the
  credential and associated \ipk used to produce \Sig. Note that, for this
  \ipk, $\ipk = \ipk_{n-1}$ in $\Exp^{forge}_{\adv,dac}$. In \CUASDAC, we can
  leverage $\ipk_{n-1}$ to fetch from the public list a signature $\Sig_{n-1}$
  generated by the issuer owner of $\ipk_{n-1}$. Again, we apply \ExtractSign
  from \CUASGen, to get the credential one layer up in the chain.
  $ExtractChain$ repeats this step, until reaching the top level credential,
  issued by $\ipk_0$.

  For the proof, we first replace within $Setup$ the $\NIZKSetup$ algorithms for
  issuance and signing with their corresponding $\NIZKSetup$. Due to their
  zero-knowledge property, the resulting game is indistinguishable. Also, note
  that $ExtractChain$ succeeds to extract the corresponding credential chain,
  due to simulation extractability of the NIZKs. 

  From the previous, the same reasoning as in \thmref{thm:forge-cuasac} applies
  to an adversary \adv~winning at line 5 of $\Exp^{forge}_{\adv,dac}$. Next,
  suppose that, from \utrans obtained at line 6, $ExtractChain$ outputs a
  delegation chain that makes \adv~win at line 10. This means that an
  uncorrupted issuer at position $i-1$ of the chain did not own a credential
  containing $D'$, but the issuer at position $i$ does. Then, either of the
  following must happen:

  \begin{itemize}
  \item The credential of the issuer at position $i$ is a forgery, meaning that
    it is a valid signature by the issuer at position $i-1$, who did not produce
    it. This can be used to break signature non-frameability of \CUASGen.
  \item The credential of the issuer at position $i$ is not a forgery, meaning
    that it is a valid signature by the issuer at position $i-1$, who produced
    it. But this contradicts the conditions required by $\fissue^{n,\dattrs}$,
    and therefore breaks issuance unforgeability of \CUASGen.
  \end{itemize}
  %
  \qed
\end{proof}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "uas-paper"
%%% End:
