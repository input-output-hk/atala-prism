\section{Relationships with More Schemes}
\label{app:related-extra}

\subsection{Group Signatures with Message Dependent Opening}
\label{sapp:related-models-gsmdo}

We cannot build the exact same functionality, nor follow the exact same security
model as in the group signatures with message dependent opening (GS-MDO) scheme
described in \cite{ehk+19}. Simply because, therein, the opening functionality
is divided in two authorities: the admitter, who decides which messages are
subject to be opened or not, and generates a token that enables opening
signatures over such messages; and the opener, who performs the actual opening,
but cannot do it without the tokens generated by the admitter. Intuitively,
this can be seen as a sort of ``distribution'' of the opening capability. We
define a variant in which the admitter and opener are combined
back into one entity (the opener), who can only open signatures over predefined
messages, but cannot open any other signature.
% Moreover, our variant directly supports the
% scenario of multiple such openers, each being able to open only signatures
% over different messages.
Note that it should still be possible to apply
thresholding techniques to extend this case so that our ``unified'' opener role
is shared across multiple entities, who have to cooperate in order to open a
signature \cite{cdl+20}, thus achieving something very close ``in spirit'' to
the scheme in \cite{ehk+19}. In addition, while \cite{ehk+19} follows the static
group signature setting, we move to the dynamic one.

Informally, our variant of GS-MDO is composed of the same algorithms as the
group signature model in \secref{ssec:related-models-gs}, with the exception
that the $KeyGen$ algorithm also receives the $\finsp^{\smsg}$ function, defined
as in \eref{eq:finspmsg}, and used to set up the opener.

\begin{align}
  & \finsp^{\smsg}(\cdot,\upk,\cdot,\msg) \coloneqq
    \pcif \msg \in \smsg: \pcreturn \upk;~\pcelse \pcreturn 0
    \label{eq:finspmsg}
\end{align}

The model is exactly the same as in
\figref{fig:model-gs}. Note that this directly constraints anonymity in a
similar way than \cite{ehk+19}: therein, anonymity (against admitter and opener,
in respective properties that we unify since we do not distinguish the roles) is
ensured only for messages that have not been ``disallowed''. In our case, as
specified next, a message is disallowed by adding it to the \smsg set given to
$KeyGen$ via $\finsp^{\smsg}$. Thus, if the adversary calls \oracle{Open} with a
signature over a message that has been disallowed, \oracle{Open} rejects the
query, as it would otherwise return different values for each challenge user
(cf. \figref{fig:oracles2}); otherwise, if the message is allowed, the oracle
returns the result of \Open -- just as in \cite{ehk+19}.

Note that, for simplicity and to build upon our \CUASGS construction, we
describe a variant where the set of messages to disallow is defined once via
$KeyGen$. However, separating this into a dedicated \OKeyGen function that can
be called multiple times, and thus allowing multiple openers, each with a
different set of disallowed messages, is trivial -- and again, our definition
of the \oracle{Open} oracle takes care of everything, as every challenge
signature is produced over the same opener key.

% \begin{figure}[ht!]
%   \centering
%   \scalebox{0.9}{      
%     \begin{minipage}[t]{0.45\textwidth}        
%       \procedure[linenumbering]{$\Exp^{anon-b}_{\adv,gsmdo}(1^\secpar)$}{%
%         (\gpk,\isk,\osk) \gets KeyGen(1^\secpar) \\
%         b^* \gets \adv^{\mathcal{O}_{anon}}(\gpk,\isk) \\
%         \pcreturn b^*
%       }
      
%       \vspace*{5em}
      
%       \procedure[linenumbering]{$\Exp^{frame}_{\adv,gsmdo}(1^\secpar)$}{%
%         (\gpk,\isk,\osk) \gets KeyGen(1^\secpar) \\
%         (\msg,\sig,\upk,\tau) \gets \adv^{\mathcal{O}_{frame}}
%         (\gpk,\osk,\isk) \\
%         \pcif \Verify(\gpk,\msg,\sig) = 0: \pcreturn 0 \\
%         \pcreturn \upk \in \HU \land \PRVUK[\upk] \neq \bot \land
%         \Judge(\gpk,\upk,\msg,\sig,\tau) = 1~\land \\
%         \pcind \adv~\textrm{did not query}~USK(\upk)~\textrm{or}~
%         GSig(\PRVUK[\upk],\msg)
%       }       
%     \end{minipage}
%   }
%   \scalebox{0.9}{      
%     \begin{minipage}[t]{.55\textwidth}
%       \procedure[linenumbering]{$\Exp^{trace}_{\adv,gsmdo}(1^\secpar)$}{%
%         (\gpk,\isk,\osk) \gets KeyGen(1^\secpar) \\
%         (\msg,\sig) \gets \adv^{\mathcal{O}_{trace}}
%         (\gpk,\osk) \\
%         \pcif \Verify(\gpk,\msg,\sig) = 0: \pcreturn 0 \\
%         (\upk, \tau) \gets \Open(\gpk,\osk,\trans,\msg,\sig) \\
%         \pcreturn \upk \notin \HU \cup \CU \lor
%         \Judge(\gpk,\upk,\msg,\sig,\tau) = 0
%       }       
%     \end{minipage}      
%   }
%   \caption{Security games for our GS-MDO variant.
%     $\mathcal{O}^{anon} \gets \lbrace \OGEN^{\smsg},\HUGEN,\CUGEN,\WREG,
%     \OBTAIN,\SIGN,\OPEN,\CHALb \rbrace$; $\mathcal{O}^{trace} \gets \lbrace
%     \OGEN,\HUGEN,\CUGEN,\ISSUE,\OBTISS,\RREG,\SIGN \rbrace$;
%     $\mathcal{O}^{frame} \gets \lbrace \OGEN,\HUGEN,\CUGEN,\WREG,
%     \OBTAIN,\SIGN \rbrace$. $\OGEN^{\smsg}$ is like \OGEN, but only accepting
%     functions of type $\finsp^{\smsg}$.
%   }
%   \label{fig:model-gsmdo}  
% \end{figure}

\subsubsection{\CUASGSMDO construction.} %
Our \CUASGSMDO construction is essentially a $(\fissue^{single,F,I},\feval^0,
\finsp^{\smsg})$-\CUASGen restriction, where $\fissue^{single,F,I}$ and
$\feval^0$ are as in \figref{fig:func-restrictions}, and $\finsp^{\smsg}$, is as
described in \eref{eq:finspmsg}. Since the construction is essentially a variant
of our \CUASGen-based construction for group signatures, we describe it making
reference to \CUASGS, in \secref{ssec:related-models-gs}:

\begin{description}
\item[$(\gpk,\isk,\osk) \gets KeyGen(1^\secpar,\finsp)$.] Runs exactly as in
  \CUASGS, except that it now receives an opening function, which must be of
  the type $\finsp^{\smsg}$, for some \smsg.
\item[$(\upk,\usk) \gets UKG(1^\secpar)$.] Like in \CUASGS.  
\item[$\langle \cred,\utrans \rangle \gets
  \langle\Obtain(\usk,\ipk),\Issue(\isk,\upk)\rangle$.] Like in \CUASGS.
\item[$\sig \gets \Sign(\gpk,\cred,\msg)$.] Like in \CUASGS.
\item[$1/0 \gets \Verify(\gpk,\sig,\msg)$.] Like in \CUASGS.
\item[$(\upk,\pi) \gets \Open(\gpk,\osk,\trans,\sig,\msg)$.] Like in
  \CUASGS.
\item[$1/0 \gets \Judge(\gpk,\pi,\upk,\sig,\msg)$.] Like in \CUASGen. Note that
  \gpk includes an \opk with an opening fuction of type $\finsp^{\smsg}$.
\end{description}

\paragraph{Security of \CUASGSMDO.} %
Our \CUASGSMDO construction is a secure group signature scheme, if the
underlying \CUASGen construction is secure.
%
Note that our construction for group signatures, \CUASGS, is a restriction to
the construction of \CUASGen and, in turn, \CUASGSMDO is a restriction of
\CUASGS, where we only accept opening functions of type $\finsp^{\smsg}$ --
more constrained than the $\finsp^{\upk}$ functions used in \CUASGS. Thus, the
security arguments given for \CUASGS in \appref{app:related-proofs}, apply
directly here.

\subsection{Delegatable Anonymous Credentials}
\label{sapp:related-models-dac}

We give a simple definition for a Delegatable Anonymous Credentials (DAC)
scheme, extending \cite{fhs19} and inspired by \cite{bcc+09}. Unlike the latter,
our simple scheme built from \CUASGenInt does not ensure privacy of the
delegation chain, which means that only actions by users with the same
delegation chain are indistinguishable -- this can make sense, for instance,
for organisations composed by many members. Delegation chain privacy could be
achieved by making \feval output projective proofs like in \cite{bcc+09}, but we
leave that out of scope for brevity. Our simple scheme
does, however, ensure that a (not top-level) issuer can only delegate attributes
contained in a credential it owns. Also, for simplicity, we restrict to the case
of using one credential per signature/interactive credential presentation, and
assume that all parties use the same opener and \finsp function.
%
The syntax is thus defined almost as in \secref{ssec:related-models-ac},
i.e., we have a $Setup$ algorithm, and $\langle Obtain,Issue\rangle$
and $\langle Show,Verify \rangle$ interactive protocols; but we do not have
$IssKeyGen$, as now, as in \cite{bcc+09} (and our \UAS model), issuers collapse
with users -- instead, we have an $KG$ and $ISet$ algorithms, with the same
meaning as in \UAS.
%
In the model for this setting, since there are multiple issuers, in addition
to the oracles in \secref{ssec:related-models-ac}, we use $HI$ and $CI$ oracles,
for creating honest and corrupt issuers, which can be simulated via \HUGEN,
\CUGEN, \ISET and \ICORR in our \UAS model.
%
The issuance and sign anonymity properties are direct, constraining the
adversary to output challenge credentials and signatures with the same
delegation chain. For unforgeability, we still require that no adversary can
authenticate using a set of attributes that have not been issued to a corrupt
user. In addition, we require that for any successful authentication using a
level-$l$ credential, we can extract a chain of credentials of length $l$ such
that each level-$i$ credential can be used successfully to authenticate the
level-$(i+1)$ credential, all the way down to the level-$l$ credential, and the
attributes revealed in the level-$l$ authentication are contained in all the
credentials up the chain. For this extraction, we assume in the model the
existence of a helper function $(\ipk_0,\lbrace (\ipk_i,\cred_i)
\rbrace_{i\in[1,l]}) \gets ExtractChain(\utrans)$ that outputs a sequence of
public keys and credentials from the root issuer $\ipk_0$ to the actual
credential used to sign $(\ipk_l,\cred_l)$.

\begin{figure}[ht!]
  \centering
  \scalebox{0.9}{      
    \begin{minipage}[t]{0.45\textwidth}
      \procedure[linenumbering]{$\Exp^{iss-anon-b}_{\adv,dac}(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        b^* \gets \adv^{\mathcal{O}_{dac},\oracle{IssLoR}}(\parm) \\
        \pccomment{Abort if challenge creds belong to} \\
        \pccomment{users with different delegation chains} \\
        \pcreturn b^*
      }
      \vspace*{0.5em}

      \procedure[linenumbering]{$\Exp^{sig-anon-b}_{\adv,dac}(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        b^* \gets \adv^{\mathcal{O}_{dac,\oracle{SigLoR}}}(\parm) \\
        \pccomment{Abort if challenge sigs belong to} \\
        \pccomment{users with different delegation chains} \\
        \pcreturn b^*
      }        
    \end{minipage}
  }
  \scalebox{0.9}{      
    \begin{minipage}[t]{.55\textwidth}
      \procedure[linenumbering]{$\Exp^{forge}_{\adv,dac}(1^\secpar)$}{%
        \parm \gets \SimSetup(1^\secpar) \\
        (D=(l,D'),\ipk_l,\st) \gets
        \adv^{\mathcal{O}_{dac}}(\parm) \\
        \langle\cdot,(b,\utrans)\rangle \gets
        \langle \adv(\st),\Verify(\ipk_l,D)\rangle \\
        \pcif b = 0: \pcreturn 0 \\
        \pcif \nexists j~\suchthat~(\OWNR[j] \in \CU
        \land D \subseteq \ATTR[j]): \pcreturn 1 \\        
        (ipk_0, \lbrace (\ipk_i,\cred_i) \rbrace_{i \in [1,l]})
        \gets ExtractChain(\utrans) \\ 
        \pcif \exists i \in [1,l]~\suchthat~
        \iid = \ISR[\ipk_{i-1}] \notin \CI~\land \\
        \pcind D' \not\subseteq \ATTR[\iid]: \\
        \pcind \pcreturn 1 \\
        \pcreturn 0
      }       
    \end{minipage}      
  }
  \caption{Security games for delegatable anonymous credentials with selective
    disclosure based on \cite{fhs19}. $\mathcal{O}_{dac} \gets \lbrace
    \oracle{HI},\oracle{CI},\oracle{Obtain},\oracle{Issue},\oracle{ObtIss},
    \oracle{Show}\rbrace$. $\oracle{IssLor}$ corresponds to \OBTCHALb in \UAS,
    whereas $\oracle{SigLor}$ corresponds to \CHALb. Also, \OWNR
    and \ATTR tables are essentially as in \secref{ssec:model-uas}.
    $\ISR[\ipk]$, in this case, returns the identifier of the issuer with public
    key \ipk. With $D = (l,D')$ we mean that the first attribute in the revealed
    set $D$ is $l$, which denotes the level of the credential used for
    authentication.}
  \label{fig:model-dac}  
\end{figure}

\subsubsection{\CUASDAC Construction.} %
We next give a construction of a delegatable AC (DAC) scheme, in the shape of
a $(\fissue^{l,D},\feval^{l,\dattrs},\finsp^0)$-\CUASGenInt
restriction, where the $\finsp^0$ function is as defined in
\figref{fig:func-restrictions}, and the \fissue and \feval variants are as
defined next:

\begin{align}
  & \fissue^{l,D}(\cdot,\attrs,(\cid,\cattrs)) \coloneqq
    \pcreturn \attrs_1 = l+1 \land \cattrs \subseteq D \nonumber \\
  & \feval^{l,\dattrs}(\cdot,(\cid,\attrs),\cdot) \coloneqq
    \pcreturn((\attrs_1,\lbrace\attrs_i\rbrace_{i\in\dattrs}),\ast)
    \label{eq:funcs-dac}
\end{align}

In a DAC scheme, all users are (or may be) also issuers. We only
distinguish between top-level issuers, who have level $l=0$, and lower-level
issuers, who have level $l>0$. In our \CUASDAC scheme, we assume that the first
attribute (after the user's secret key and credential identifiers) encodes the
level of the credential. That is, $\attrs_1=l$, for a credential of level $l$.
In addition, all users (i.e., with $l>0$) who want to delegate have to publicly
list:

\begin{enumerate}
\item The level $l$ of the credential they delegate.
\item Their public key \ipk.
\item An \UAS signature proving knowledge of a credential of level $l$, and over
  the attributes $D$ that this level-$l$ issuer is delegating.
\item The \ipk of the parent issuer.
\item The $\fissue^{l,D}$ function they will require for delegating.
\item An $\feval^{l,D}$ function used to produce the signature at item 3.
\end{enumerate}

We assume that, from an \ipk, it is possible to find the corresponding issuer
(e.g., using the previously mentioned public list). The
$\fissue^{l,D}$ functions must follow the pattern in \figref{fig:func-restrictions}.
Namely, the issuance function checks that the first requested attribute equals
$l+1$, and that the remaining attributes are a subset of the attribute set
D being delegated by the level-$l$ issuer. In addition, signature
evaluation functions $\feval^{l,D}$, also shown in \figref{fig:func-restrictions},
must reveal the level of the credential used to produce the \UAS signature at
item 3, as well as the set of attributes \dattrs that the level-$l$ issuer
delegates. Verifiers can then trivially check if the set of revealed attributes
are contained within the attributes delegatable by the parent issuer%
\footnote{Additional checks may be added in both functions, but this is
  the bare minimum.} -- this $\feval^{l,D}$ function is just the same as the
$\feval^{l,\dattrs}$ function in \esref{eq:funcs-dac}, but where $D=\dattrs$,
which is required to verify the \UAS signature produced at step 3.
%
From this high-level description, we define the concrete algorithms of \CUASDAC:

\begin{description}
\item[$\parm \gets \Setup(1^\secpar)$.]  Runs $\parm' \gets \Setup(1^\secpar)$
  and $(\opk,\osk) \gets \OKeyGen(\parm',\finsp^0)$ from our
  $\CUASGen^{usr-iss}$ construction. Returns $\parm \gets (\parm',\opk)$. Note
  that $\finsp^0$ can be replaced by any desired opening function.
\item[$(\upk,\usk) \gets KG(\parm)$.] As in \CUASGenInt.
\item[$\ipk \gets ISet(\upk,\usk,\fissue^{l,D})$.] If $l = 0$, then just
  run $\ipk \gets \ISet(\upk,\usk,\fissue^{l,D})$, and publish $(0,\ipk,\bot,
  \bot,\fissue,\bot)$, for any \fissue function required by the level-$0$
  issuer. Else,  
  if $l > 0$ (the entity running the algorithm owns a level-$l$ credential
  issued by a level-$(l-1)$ issuer, containing attributes $D$) run $\ipk' \gets
  \ISet(\upk,\usk,\fissue^{l,D})$ as in \CUASGenInt. Then, obtain $\Sig \gets
  \CUASGenInt.\Sign(\usk,\opk,\Cred,\msg,\feval^{l,D})$, where \opk is the
  opener public key in \parm, \msg is some random message, and \Cred is the
  level-$l$ credential owned by the current issuer. Then, set
  $\ipk \gets (l,\ipk',\Sig,\ipk^{l-1},\fissue^{l,D},\feval^{l,D})$, where
  $\ipk^{l-1}$ is the public key of the level-$(l-1)$ issuer.
\item[$\langle \cred/\bot,\top/\bot \rangle \gets
  \langle \Obtain(\usk,\ipk,\attrs),\Issue(\isk,\upk,\attrs) \rangle$.]
  The user first finds the corresponding $(l,\ipk,\Sig,\ipk^{n-1},\fissue^{l,D},
  \feval^{l,D})$ tuple. If $l>0$, the user checks \Sig running \Verify as in
  \CUASGenInt (with the retrieved $\feval^{l,D}$) and then, user and level-$l$
  issuer run $\langle\Obtain,\Issue\rangle$ as in \CUASGenInt, using
  $\fissue^{l,D}$ as issuance function. If $l=0$, then user and issuer
  run $\langle\Obtain,\Issue\rangle$ as in \CUASGenInt, using the \fissue
  function specified in the issuer's tuple.
\item[$\langle 1/0,(1,\utrans)/(0,\utrans)\rangle
  \gets \langle Show(\opk,\attrs,\dattrs,\cred),
  \Verify(\opk,\dattrs) \rangle$.] As in \CUASGenInt.
\end{description}

\paragraph{Security of \CUASDAC.} % 
We prove that \CUASDAC is an anonymous and unforgeable DAC scheme, according to
the (interactive version of the) model in \figref{fig:model-dac}, if the
underlying \CUASGenInt construction has anonymous issuance and signing, and is
unforgeable.

\begin{theorem}[Issuance anonymity of \CUASDAC]
  If the base \CUASGenInt construction has issuance anonymity according to
  (the interactive version of) \defref{def:issue-anonymity-uas}, then \CUASDAC
  also has issuance anonymity.
\end{theorem}

\begin{proof}
  Given \adv~against issuance anonymity of \CUASDAC as defined in
  $\Exp^{iss-anon-b}_{\adv,dac}(1^\secpar)$, we build an adversary \advB against
  issuance anonymity of \CUASGenInt.

  To simulate oracle calls by \adv, \advB simply redirects to its corresponding
  oracle, i.e.: for calls to \oracle{HU},\oracle{CU},\oracle{Obtain},
  \oracle{Show},\oracle{IssLoR}, \advB redirects to the \CUASGenInt oracles
  \HUGEN,\CUGEN,\OBTAIN,\SIGN,\OBTCHALb, respectively. \oracle{HI} (resp.
  \oracle{CI}) is simulated by calling \HUGEN (resp. \CUGEN) and \ISET
  sequentially and for the same \uid, plus a call to \SIGN in the case of
  honest issuers of level $l>0$, to generate the signature \Sig that the
  (honest) issuer has to publish.
  %
  If \adv~wins in its issuance anonymity game, then so does \advB with the same
  probability, as the simulation is perfect.
  % 
  \qed
\end{proof}

\begin{theorem}[Signature anonymity of \CUASDAC]
  If the base \CUASGenInt construction has signature anonymity according to
  (the interactive version of) \defref{def:sign-anonymity-uas}, then \CUASDAC
  also has signature anonymity.
\end{theorem}

\begin{proof}
  Given \adv~ against signature anonymity of \CUASDAC as defined in
  $\Exp^{sig-anon-b}_{\adv,dac}(1^\secpar)$, we build an adversary \advB against
  signature anonymity of \CUASGenInt.
  %
  \adv's oracles are simulated as in the proof for issuance anonymity of
  \CUASDAC -- in this case, \adv's \oracle{SigLoR} oracle corresonds to \advB's
  \CHALb. Again, the simulation is perfect, and whenever \adv~wins its
  $\Exp^{sig-anon-b}$ game, so does \advB.
  % 
  \qed
\end{proof}

\begin{theorem}[Unforgeability of \CUASAC]
  If the base \CUASGenInt construction is unforgeable according to (the
  interactive version of) \defref{def:forge-uas}, and non-frameabile according
  to (the interactive version of) \defref{def:frame-uas}, then \CUASAC is an
  unforgeable AC scheme.
\end{theorem}

\begin{proof}
  First, we define the $ExtractChain(\utrans)$ function for our construction.
  Note that \utrans is a tuple $(r,\Sig)$\footnote{This follows for the approach
    to transform non-interactive signature and verification in \UAS to
    interactive presentations, as described in \secref{ssec:variants}.}, where
  $r$ is a fresh random number specified by the adversary,
  and \Sig is a \CUASGen signature over $r$. Thus, $ExtractChain$ leverages
  \ExtractSign from \CUASGen (see \secref{ssec:security-uas}) to get the
  credential and associated \ipk used to produce \Sig. Note that, for this
  \ipk, $\ipk = \ipk_{n-1}$ in $\Exp^{forge}_{\adv,dac}$. In \CUASDAC, we can
  leverage $\ipk_{n-1}$ to fetch from the public list a signature $\Sig_{n-1}$
  generated by the issuer owner of $\ipk_{n-1}$. Again, we apply \ExtractSign
  from \CUASGen, to get the credential one layer up in the chain.
  $ExtractChain$ repeats this step, until reaching the top level credential,
  issued by $\ipk_0$.

  From the previous, the same reasoning as in \thmref{thm:forge-cuasac} applies
  to an adversary \adv~winning at line 5 of $\Exp^{forge}_{\adv,dac}$. Next,
  suppose that, from \utrans obtained at line 6, $ExtractChain$ outputs a
  delegation chain that makes \adv~win at line 10. This means that an
  uncorrupted issuer at position $i-1$ of the chain did not own a credential
  containing $D'$, but the issuer at position $i$ does. Then, either of the
  following must happen:

  \begin{itemize}
  \item The credential of the issuer at position $i$ is a forgery, meaning that
    it is a valid signature by the issuer at position $i-1$, who did not produce
    it. This can be used to break signature non-frameability of \CUASGenInt.
  \item The credential of the issuer at position $i$ is not a forgery, meaning
    that it is a valid signature by the issuer at position $i-1$, who did
    produce it. But this contradicts the conditions required by $\fissue^{n,D}$,
    and therefore breaks unforgeability of \CUASGenInt.
  \end{itemize}
  %
  \qed
\end{proof}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "uas-paper"
%%% End:
