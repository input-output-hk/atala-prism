\section{Relationships with More Schemes}
\label{app:related-extra}

\subsection{Group Signatures with Message Dependent Opening}
\label{sapp:related-models-gsmdo}

We cannot build the exact same functionality, nor follow the exact same security
model as in the group signatures with message dependent opening (GS-MDO) scheme
described in \cite{ehk+19}. Simply because, therein, the opening functionality
is divided in two authorities: the admitter, who decides which messages are
subject to be opened or not, and generates a token that enables opening
signatures over such messages; and the opener, who performs the actual opening,
but cannot do it without the tokens generated by the admitter. Intuitively, this
can be seen as a sort of ``distribution'' of the opening capability. We define
a variant of this model in which the admitter and opener are combined back into
one entity (the opener), who can only open signatures over predefined messages,
but cannot open any other signature. Moreover, our variant directly supports the
scenario of multiple such openers, each being able to open only signatures
over different messages. Note that it would not be hard to apply thresholding
techniques to extend this case so that our ``unified'' opener role is shared
across multiple entities, who have to cooperate in order to open a signature
\needcite, thus achieving something very close ``in spirit'' to the scheme in
\cite{ehk+19}. In addition, while \cite{ehk+19} follows the static group
signature setting, we move to the dynamic one. Informally, our variant of GS-MDO
is composed of the following algorithms: \Setup,
\IKeyGen, \OKeyGen, \UKeyGen, \Sign, \Verify, \Open; as well as the $\langle
\Obtain, \Issue \rangle$ interactive protocol. \OKeyGen generates an opening
key pair which is already configured to open signatures only over some fixed
(but arbitrary) set of messages. The remaining algorithms are as usual, so we
defer a more detailed description to the construction. The oracles are the same
as in \UAS. The resulting security model is given in \figref{fig:model-gsmdo},
which we adapt from \cite{ehk+19}.

\begin{figure}[ht!]
  \centering
  \scalebox{0.9}{      
    \begin{minipage}[t]{0.45\textwidth}        
      \procedure[linenumbering]{$\Exp^{anon-b}_{\adv,gsmdo}(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        (\ipk,\isk) \gets \IKeyGen(\parm) \\
        b^* \gets \adv^{\mathcal{O}^{anon}}(\parm,\ipk) \\
        \pcreturn b^*
      }
      
      \vspace*{5em}
      
      \procedure[linenumbering]{$\Exp^{frame}_{\adv,gsmdo}(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        (\ipk,\isk) \gets \IKeyGen(\parm) \\
        (\msg,\sig,\upk,\tau) \gets \adv^{\mathcal{O}^{frame}}
        (\ipk,\isk) \\
        \pcif \Verify(\gpk,\msg,\sig) = 0: \pcreturn 0 \\
        \pcreturn 1~\pcif \upk \in \HU \land \PRVUK[\upk] \neq \bot \land
        \Judge(\gpk,\upk,\msg,\sig,\tau) = 1~\land \\
        \pcind \adv~\textrm{did not query}~USK(\upk)~\textrm{or}~
        GSig(\PRVUK[\upk],\msg) \\
        \pcreturn 0
      }       
    \end{minipage}
  }
  \scalebox{0.9}{      
    \begin{minipage}[t]{.55\textwidth}
      \procedure[linenumbering]{$\Exp^{trace}_{\adv,gsmdo}(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        (\ipk,\isk) \gets \IKeyGen(\parm) \\
        (\msg,\sig,\upk,\tau) \gets \adv^{\mathcal{O}^{trace}}
        (\ipk,\opk,\osk) \\
        \pcif \Verify(\gpk,\msg,\sig) = 0: \pcreturn 0 \\
        (\upk, \tau) \gets \Open(\gpk,\osk,\trans,\msg,\sig) \\
        \pcif \upk \notin \HU \cup \CU \lor \Judge(\gpk,\upk,\msg,\sig,\tau)
        = 0: \\ 
        \pcind \pcreturn 1 \\
        \pcreturn 0
      }       
    \end{minipage}      
  }
  \caption{Security games for our GS-MDO variant.
    $\mathcal{O}^{anon} \gets \lbrace \OGEN^{\smsg},\HUGEN,\CUGEN,\WREG,
    \OBTAIN,\SIGN,\OPEN,\CHALb \rbrace$; $\mathcal{O}^{trace} \gets \lbrace
    \OGEN,\HUGEN,\CUGEN,\ISSUE,\OBTISS,\RREG,\SIGN \rbrace$;
    $\mathcal{O}^{frame} \gets \lbrace \OGEN,\HUGEN,\CUGEN,\WREG,
    \OBTAIN,\SIGN \rbrace$. $\OGEN^{\smsg}$ is like \OGEN, but only accepting
    functions of type $\finsp^{\smsg}$.
  }
  \label{fig:model-gsmdo}  
\end{figure}

\subsubsection{\CUASGSMDO construction.} %
We show that, as specified in \tabref{tab:uas-alt-funcs}, our \CUASGen
construction for \UAS, restricted to $\fissue^1$ as issuance function,
$\feval^0$ as signature evaluation function, and $\finsp^{\smsg}$ as opening
function, is a secure group signature scheme with message dependent opening
as modelled in \figref{fig:model-gsmdo}. We first quickly define the algorithms,
and then prove security.

\begin{description}
\item[$\parm \gets \Setup(1^\secpar)$.] Like in vanilla \CUASGen.
\item[$(\upk,\usk) \gets \UKeyGen(1^\secpar)$.] Like the \UKeyGen function for
  \CUASGS, in \secref{sapp:related-models-gs}.
\item[$\langle \cred,\utrans \rangle \gets
  \langle\Obtain(\usk,\ipk),\Issue(\isk,\upk)\rangle$.] Like the corresponding
  protocol in in vanilla \CUASGS, \secref{sapp:related-model-gs}.
\item[$\sig \gets \Sign(\gpk,\cred,\msg)$.] Like in vanilla \CUASGen, limited
  on evaluation functions $\feval^0$ and opening functions $\finsp^{\smsg}$.
\item[$1/0 \gets \Verify(\gpk,\sig,\msg)$.] Like in vanilla \CUASGen.
\item[$(\upk,\pi) \gets \Open(\gpk,\osk,\trans,\sig,\msg)$.] Like in vanilla
  \CUASGen.
\item[$1/0 \gets \Judge(\gpk,\pi,\upk,\sig,\msg)$.] Like in vanilla \CUASGen.
\end{description}

\paragraph{Security of \CUASGSMDO.} %
Our \CUASGSMDO construction is a secure group signature scheme,
according to the model in \figref{fig:model-gsmdo}, if the underlying \CUASGen
construction is secure.

Note that both  model construction are essentially restrictions to the model
and construction of \CUASGen. Thus, security directly follows from security of
\CUASGen.

% \begin{theorem}[Anonymity of \CUASGSMDO]
%   If the base \CUASGen construction is anonymous according to
%   \defref{def:anonymity-uas}, then \CUASGSMDO is an anonymous group signature
%   scheme.
% \end{theorem}

% \begin{proof}
  
%   \qed
% \end{proof}

% \begin{theorem}[Traceability of \CUASGSMDO]
%   If the base \CUASGen construction has unforgeable signing according to
%   \defref{def:sign-forge-uas}, then \CUASGSMDO is a traceable group signature
%   scheme.
% \end{theorem}

% \begin{proof}
%   Traceability follows directly from the corresponding proof for \CUASGS.
%   \qed
% \end{proof}

% \begin{theorem}[Non-frameability of \CUASGSMDO]
%   If the base \CUASGen construction is non-frameable according to
%   \defref{def:frame-uas}, then \CUASGSMDO is a non-frameable group signature
%   scheme.
% \end{theorem}

% \begin{proof}
%   Non-frameability follows directly from the corresponding proof for \CUASGS.
%   \qed
% \end{proof}

\subsection{Revocable Anonymous Credentials}
\label{sapp:related-models-rac}

In \cite{cks10}, revocable anonymous credentials are proposed. From \CUASGen, it
is straightforward to build an AC system with verifier local revocation, like in
\cite{bs04}. Basically, all credentials get an identifier as first attribute,
and \feval functions prove that the opener can retrieve that identifier. Then,
in case of needing to revoke a concrete credential, any verifier can interact
with the opener to add an identifier to its own revocation list (alternatively,
there can be a public list of revoked credentials). Having \feval functions
prove that the credential identifier does not belong to that list thus directly
implements privacy-preserving revocation. We first give a simple model in
\figref{fig:model-rac}, extending that in \appref{sapp:related-models-ac}. As
before, for simplicity we assume only one credential is used per authentication
(the extension being direct). To the functionality in
\appref{sapp:related-models-ac}, we now explicitly add the $OKeyGen$ function
(equivalent to \OKeyGen, with a fixed \finsp function),
which generates the opener key pair, extend $Verify$ to receive also a list $L$
of revoked identifiers, and we add a function (and corresponding oracle) $id/\bot
\gets RetrieveCredId(\osk,\utrans)$ that can extract the identifier of the
credential used in a presentation transcript \utrans -- and which is essentially
equivalent to \Open in \UAS. For simplicity, we do not include the equivalent to
verifiable openings, but this would be straightforward.

\begin{figure}[ht!]
  \centering
  \scalebox{0.9}{      
    \begin{minipage}[t]{0.45\textwidth}
      \procedure[linenumbering]{$\Exp^{anon-b}_{\adv,rac}(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        (\opk,\osk) \gets \OKeyGen(\parm) \\        
        (\ipk,\isk) \gets IssKeyGen(\parm) \\        
        b^* \gets \adv^{\mathcal{O}_{anon}}(\parm,\ipk,\opk) \\
        \pcreturn b^*
      }        
    \end{minipage}
  }
  \scalebox{0.9}{      
    \begin{minipage}[t]{.55\textwidth}
      \procedure[linenumbering]{$\Exp^{forge}_{\adv,rac}(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        (\opk,\osk) \gets \OKeyGen(\parm) \\        
        (\ipk,\isk) \gets IssKeyGen(\parm) \\
        (D,L,\st) \gets
        \adv^{\mathcal{O}_{forge}}(\parm,\ipk) \\
        \langle \cdot,(b,\utrans)\rangle
        \gets \langle \adv(\st),\Verify(\ipk,D,L)\rangle \\
        \pcif b = 0: \pcreturn 0 \\
        \pcif \nexists j~\suchthat~(\OWNR[j] \in \CU
        \land D \subseteq \ATTR[j]): \pcreturn 1 \\    
        h \gets RetrieveCredHandle(\osk,\utrans) \\
        \pcif h \in L \lor h = \bot: \pcreturn 1 \\
        \pcreturn 0
      }       
    \end{minipage}      
  }
  \caption{Security games for revocable anonymous credentials with selective
    disclosure based on \cite{fhs19}. 
    $\mathcal{O}_{anon} \gets \lbrace HU,CU,Obtain,Issue,ObtIss,Show,
    ReqCredHandle,LoR\rbrace$. $\mathcal{O}_{forge} \gets \lbrace HU,CU,
    Obtain,ObtIss,Issue,Show,ReqCredHandle \rbrace$. $ReqCredHandle$ is
    equivalent to \OPEN, operating on transcripts \utrans instead of signatures.
    Also, \OWNR and \ATTR tables are essentially as in \secref{ssec:model-uas}.}
  \label{fig:model-rac}  
\end{figure}

\subsubsection{\CUASRAC Construction.} %

For our RAC construction, we define signature evaluation and opening functions
as follows:

\begin{align}
  & \feval^{\dattrs,F,V,L}(\usk,\cred,\msg) \coloneqq
    \lbrace
    \pcif F(V,\attrs_1(\cred)) \in L: \pcreturn (0,0);
    \pcelse \pcreturn (\dattrs(\cred),V)
    \rbrace \nonumber \\
  & \finsp^{F}((\yeval^0,\yeval^1),\usk,\cred,\msg) \coloneqq
    \lbrace
    \pcif \yeval^0 \neq 0: \pcreturn F(\yeval^1,\attrs_1(\cred));
    \pcelse \pcreturn 0
     \rbrace
  \label{eq:funcs-rac}
\end{align}

Where, $\feval^{\dattrs,F,V,L}$ is parameterized with a one-way and
collision-resistant function $F$
(e.g., a cryptographic hash), some constant subset \dattrs of attributes to be
selectively disclosed by signers, a string identifying the verifier $V$ and a
list $L$ of ``revocation handles'' by this verifier. If the credential used for
signing has been revoked (i.e., if $F(V,id) \in L$), then \feval returns $0$, as
an indication that the signature should be rejected by the verifier. Otherwise,
it sets $\yeval^0 \gets \dattrs(\cred)$, and $\yeval^1 \gets V$ -- note that
$\yeval^1$ will be encrypted with a single-use key pair.
%
On the other hand, $\finsp^{F}$ outputs $F(\yeval^1,\attrs_1(\cred))$, allowing
valid signatures to be locally revocable by $V$ at a later stage, since
$\yeval^1=V$.

\begin{description}
\item[$\parm \gets \Setup(1^\secpar)$.] Runs $\Setup(1^\secpar)$ as in
  \CUASGen.
\item[$(\ipk,\isk) \gets IssKeyGen(\parm)$.] Runs \IKeyGen from our
  \CUASGen construction, setting $\fissue^1$ as issuance function.
\item[$(\ipk,\isk) \gets OKeyGen(\parm)$.] Runs \OKeyGen from our
  \CUASGen construction, setting $\finsp^F$ as opening function.
\item[$(\upk,\usk) \gets UserKeyGen(\ipk)$.] Runs \UKeyGen from the
  \CUASGen construction, and computes $\CCommit(\usk;0)$ as \upk.
\item[$\langle \cred/\bot,\top/\bot \rangle \gets
  \langle \Obtain(\usk,\ipk,\attrs),\Issue(\isk,\upk,\attrs) \rangle$.]
  Runs the $\langle \Obtain,\Issue \rangle$ protocol from \CUASGen, using
  $\fissue^1$ as issuance function.
\item[$\langle 1/0,(1,\utrans)/(0,\utrans)\rangle \gets \langle Show(\ipk,\attrs,\dattrs,\cred),
  \Verify(\ipk,\dattrs) \rangle$.]
  Runs the interactive extension of \Sign and \Verify of the \CUASGen protocol,
  using $\feval^{\dattrs,F,V,L}$ as signature evaluation function, and
  $\finsp^F$ as open function.
\item[$h/\bot \gets RetrieveCredHandle(\osk,\utrans)$.]
  Outputs the revocation handle $h$ for the credential used in the interactive
  presentation associated to \utrans. Note that $h$ is verifier-dependent.
\end{description}

\paragraph{Security of \CUASRAC.} %
We prove that \CUASRAC is an anonymous and unforgeable anonymous credential
scheme, according to \cite{fhs19}, if the underlying \CUASGen construction
is anonymous and has unforgeable signing. Note that issuance unforgeability
of \CUASGen is not needed, as the model in \cite{fhs19} does not allow
leveraging other credentials not any fixed custom issuance policy. Thus,
signature unforgeability from \UAS is enough. Note that AC schemes modelled
as in \cite{fhs19} do not have issuance anonymity, as the user public key
is passed to the issuer.

\begin{theorem}[Anonymity of \CUASRAC]
  \label{thm:anon-cuasac}
  If the base \CUASGen construction has signature anonymity according to
  \defref{def:sign-anonymity-uas}, and $F$ is one-way and collision-resistant,
  then \CUASAC is an anonymous AC scheme according to \cite{fhs19}.
\end{theorem}

\begin{proof}
  Given \adv~ against anonymity of \CUASRAC as defined in
  \figref{fig:model-rac}, we build an adversary \advB against anonymity of
  \CUASGen as defined in \defref{def:sign-anonymity-uas}.

  First observe that, given a revocation handle $F(V,id)$ extracted from any
  credential showing, it is not possible to extract $id$, as $F$ is one-way
  and collision-resistant.
  
  To simulate oracle calls by \adv, \advB simply redirects to its corresponding
  oracle, i.e.: for calls to $HU,CU,Obtain,Show,LoR,ReqCredHandle$, \advB
  redirects to \HUGEN, \CUGEN, \OBTAIN, \SIGN, \CHALb, of \OPEN respectively.
  Note that ``translating'' the inputs from the former into inputs for the
  latter is trivial. Also, observe that $ReqCredHandle$ essentially refuses to
  open transcripts from challenge users (signatures, in the non-interactive
  equivalent), as $F(V,\attrs_1(\ccid_0) \neq F(V,\attrs_1(\ccid_1)$ with
  overwhelming probability (see the $\tyinsp \neq \yinsp$) check in
  \figref{fig:oracles2}. Obviously, if \adv~ wins in its anonymity game, then
  so does \advB with the same probability.
  % 
  \qed
\end{proof}

\begin{theorem}[Unforgeability of \CUASRAC]
  If the base \CUASGen construction has sign unforgeability according to
  \defref{def:sign-forge-uas}, and $F$ is one-way and collision-resistant, then
  \CUASRAC is an unforgeable RAC scheme.
\end{theorem}

\begin{proof}
  Given \adv~ against unforgeability of \CUASRAC as defined in
  \figref{fig:model-rac}, we build an adversary \advB against sign
  unforgeability of \CUASGen as defined in \defref{def:sign-forge-uas}.

  To simulate oracle calls by \adv, \advB acts as in the anonymity proof. Assume
  that \adv~ wins its game via the winning condition of line 6 in the RAC
  unforgeability game. The same reasoning as in \CUASAC applies here. Next, note
  that the probability of \adv~ winning its game via the winning condition at
  line 9 is negligible, due to soundness of the NIZK scheme used for signing,
  and the one-wayness and collision-resistance of $F$ in
  $\feval^{\dattrs,F,V,L}$ and $\finsp^{F}$.
  % 
  \qed
\end{proof}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "uas-paper"
%%% End:
