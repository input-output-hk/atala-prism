\section{Preliminaries}
\label{sec:preliminaries}

\iffalse
\subsection{Related Work}
\label{ssec:related}

\paragraph{Group Signatures and Anonymous Credentials.} %
\todo{Brief summary of GS and AC here. Maybe split them in different
  paragraphs.}

\paragraph{Attribute-Based Group Signatures.} %
The closest related works to our \GSAC are the series of Attribute-Based Group
Signature schemes (ABGS) published between 2007 and 2014. The initial proposals
\cite{khad07a,khad07b} defined a variant of group signatures in which membership
credentials contained attributes. Yet, there are some
crucial differences that make ABGS too rigid for practice. Ignoring that the
first works \cite{khad07a,khad07b} are modelled as static group signatures
(i.e., they do not allow dynamic joins of new members), each group has a static
``attribute access tree'' associated to it. This tree defines what combinations
of attributes make a signature valid. For instance, an example given in
\cite{khad07b} requires group signatures to originate from an employee who is
``a member of the IT department, and either at least a junior manager from the
cryptography group, or a senior manager from the biometrics team''. If,
eventually, a different attribute access tree is needed, a new group needs to
be created. Additionally, only revocation is considered in \cite{khad07b},
which is a subset of the accountability flavours that can be reached through
the open function of conventional GS schemes. These schemes also lack formalism
in their definitions. For instance, correctness does not cover correctness of
revocation, and the anonymity definition does not seem to consider trivial wins
by the adversary in which the adversary can revoke one of the two challenge
users.
%
\cite{emo09} follows the attribute access tree aproach, but generalizes it so
that attributes can be removed from the access tree, or the required conditions
can be modified -- e.g., in \cite{emo09}, we could remove the ``or a senior
manager from the biometrics team'' condition in the previous example. It also
allows dynamic joins, and models open rather than just revocation. However,
it does not
allow adding new attributes; in that case, a new group has to be created. It
also deviates from the conventional group signatures model, by introducing a
\emph{collision-resistance} property that prevents different users from
combining their membership credentials. While this is just a modelling choice
with no impact in the actual functionality, it seems that this could be
integrated within the existing traceability property, leading to a cleaner
model. \todo{How does removing attributes or changing the access rules affect
  anonymity? Is this considered?}
%
Finally, and as far as we know, \cite{aa14} is the last work in this ABGS line.
They support dynamic joins, open and verifier-local revocation (hence, their
variant is named VLR-ABGS). Furthermore, they include backwards unlinkability,
meaning that a compromise of a user key at epoch $t$ does not affect anonymity
of signatures on previous epochs by that same user. This scheme is still based
on attribute access trees -- concretely, those in \cite{emo09}, and thus
inherits its constraints. It also resorts to many properties, deviating from the
cleaner approaches of GS schemes. Specifically, it defines security of VLR-ABGS
by means of attribute anonymity (which is not formally defined),
backwards-unlinkability user anonymity, traceability, non-frameability,
attribute unforgeability, and collision resistance of attributes. Again, this
are just modelling choices, but it would seem that several of these properties
could be collapsed, hence leading to a cleaner model, much easier to evaluate
(e.g., traceability, attribute unforgeability and collision resistance of
attributes all seem similar).

In summary, the previous line of ABGS seems to lack the flexibility of AC
schemes in regards to what can be proven with attribute-based credentials.
Restricting to AC with selective disclosure, one can get essentially the same
functionality as with ABGS, but with flexible policies. That is, just let
the verifier specify the policy that users need to meet depending on the
situation, and only users revealing a matching subset of attributes will be
accepted. In this respect, anonymity and unforgeability of ACs are equivalent to
anonymity and traceability/unforgeability properties of ABGS. Still, an ABGS
group is tied up to one concrete policy, while a single AC scheme spans
arbitrarily many.
%
On the other hand, what ABGS (or, rather, some of its variants) adds with
respect to AC schemes is the non-frameability property of group signatures,
which opens the possibility to easily incorporate accountability notions.
%
In addition to what we have already mentioned, none of the ABGS works allows
a group member to obtain multiple credentials -- not even from the same issuer.
While obtaining multiple credentials in the setting of GS is not useful, it is
if we include attributes and realize that the same user may have multiple
attributes. This is certainly the case in multiple real life scenarios. For
instance, the same person may obtain two different degrees within the same
university; or an employee of a bank can also be a client. Both situations
require attribute credentials issued by the same entity (the university, or
the bank), none of them being a proper subset of the other, but still being
associated to the same person.

% One difference between our current approach to GSAC, and the existing ABGS
% works, is that in ABGS each group member can only get one credential. On the
% other hand, we are trying to let any group member obtain as many credentials
% as he wishes, possibly with different attributes, albeit all of them related to
% the same user key pair (if a different user key pair is employed, then this is
% considered as a different user).
\fi

\subsection{Cryptographic Building Blocks}
\label{ssec:cryptobblocks}

Next we introduce the main building blocks we will be using in our
constructions. More detailed definitions and references appear in
\appref{app:crypto-building-blocks}.

\paragraph{Digital Signatures.} %
Defined as a tuple (\SSetup,\SKeyGen,\SSign,\SVerify). Algorithm $\parm \gets
\SSetup(\secpar)$ produces public parameters for the other algorithms.
$(\vk,\sk) \gets \SKeyGen(\parm)$ generates the verification-signing key
pair, algorithm $\sig \gets \SSign(\sk,\msg)$ signs message \msg with
signing key \Ssk, producing signature \Ssig, and $1/0 \gets \SVerify(\vk,
\sig,\msg)$ checks whether \Ssig is a valid signature over \msg, under
verification key \Svk. We rely on existentially unforgeable digital signature
schemes.

\paragraph{Public-Key Encryption.} %
Defined as a tuple (\ESetup,\EKeyGen,\EEnc,\EDec). Algorithm $\parm \gets
\ESetup(\secpar)$ produces public parameters for the other algorithms.
$(\ek,\dk) \gets \EKeyGen(\parm)$ generates the encryption-decryption key
pair, algorithm $\Ec \gets \EEnc(\ek,\msg)$ encrypts message \msg with
encryption key \Eek, producing ciphertext \Ec, and $\msg/\bot \gets \EDec(\dk,
\Ec)$ decrypts ciphertexts using decryption key \Edk. We rely on IND-CCA
public-key encryption schemes.

\paragraph{(Block) Commitment Schemes.} %
Defined as a tuple (\CSetup,\CCommit). Algorithm $\parm \gets
\CSetup(\secpar)$ produces the parameters for committing to values. $\Ccom
\gets \CCommit(\parm, \smsg; r)$ produces a commitment \Ccom over a set of
messages \smsg, using randomness $r$ (which we may omit when explicitly
stating it is not necessary). We will further use commitment schemes that
allow committing to vectors of messages. Therein, the \CCommit algorithm simply
receives a block of messages. In both cases, we require hiding and binding
(block) commitment schemes.

\paragraph{Non-Interactive Zero-Knowledge.} %
We use non-interactive zero-knowledge proofs of knowledge (NIZK), in the CRS
model. Informally, a NIZK scheme over an NP relation \NIZKRel is defined as a
tuple ($\NIZKSetupRel$,$\NIZKProveRel$,$\NIZKVerify^\NIZKRel$).
Algorithm $\NIZKcrs \gets \NIZKSetupRel(\NIZKsecpar)$ produces the common
reference string \NIZKcrs. $\NIZKproof/\bot \gets \NIZKProveRel(\NIZKcrs,
\NIZKx,\NIZKw)$ creates a NIZK proof of knowledge of witness \NIZKw for \NIZKx
such that $(\NIZKw,\NIZKx) \in \NIZKRel$. $1/0 \gets \NIZKVerifyRel
(\NIZKcrs,\NIZKx,\NIZKproof)$ verifies the proof. Within NIZK systems, we
further need schemes that provide simulation-extractability, which in a nutshell
means that no adversary can produce a proof from which we cannot extract a
witness, even after seeing polynomially many simulated proofs. To model
simulation-extractable NIZKs, we further need algorithms \NIZKSimSetup,
\NIZKSim, and \NIZKExtract, that allow simulating proofs and extracting
witnesses. The properties we build on are completeness, soundness,
zero-knowledgeness, and simulation-extractability.

\paragraph{Signatures over Blocks of Committed Messages, with proofs.} %
We use signature schemes that allow signing blocks of messages, or commitments
to blocks of messages, and which are furthermore compatible with (efficient)
proof systems over the produced signature and signed (commitments to) messages.
For this purpose, we define such schemes as a tuple (\SBCMSetup,\SBCMKeyGen,
\SBCMCom,\SBCMSign,\SBCMVerify). Algorithm $\parm \gets \SBCMSetup(\secpar)$
produces the public parameters for the scheme. %
$(\vk,\sk) \gets \SBCMKeyGen(\parm)$ produces a verification-signing
key pair. $\sig/\bot \gets\langle \SBCMCom(\vk,\overline{\smsg},\smsg),
  \SBCMSign(\sk,\smsg) \rangle$ is an interactive protocol between a user, who
runs \SBCMCom and has a set of messages $\overline{\smsg}$ to be block-committed,
and a signer, who owns signing key \sk; both also receive common input a
block of messages \smsg. The output of the protocol is a signature over
$\overline{\smsg} \cup \smsg$. Algorithm $1/0 \gets \SBCMVerify(\vk,
\sig,\overline{\smsg},\smsg)$ verifies a signature \sig over message set
$\overline{\smsg} \cup \smsg$. In addition, the
produced signatures must be compatible with (efficient) NIZK proofs of knowledge
of a signature, and of (arbitrary) claims over the signed (committed) messages.
An \SBCM scheme must provide one-more-forgery type of security.

\subsection{Notation}
\label{ssec:notation}

We follow common notation habits. $y \gets A(x)$ means that algorithm $A$, on
input $x$, produces output $y$. When $A$ is a probabilistic process, and we want
to make explicit the randomness $r$, we use $y \gets A(x;r)$. $\langle y_A,y_B
\gets \langle A(x_A),B(x_B)\rangle$ denotes algorithms $A$ and $B$, running an
interactive protocol, where $A$ receives $x_A$ as input and produces $y_A$ as
output, and $B$ receives $x_B$ and produces $y_B$.
%
Our generic constructions
rely on the previously defined building blocks, which share common (but different
tokens): e.g., we will resort to several NIZK proofs instances. To distinguish
them, we may use subscripts or superscripts: e.g., $\NIZKRel_A$ denotes the
NP relation used within some algorithm $A$, $\NIZKSetupRel$ means that
the setup algorithm of an underlying NIZK system is performed associated to
relation $\NIZKRel$; $\SBCMparm$ are the public parameters for an \SBCM scheme,
and $\Eparm$ are the public parameters for an encryption scheme. Variables
written in bold font denote sets, e.g., while we use \ipk to denote a single
issuer public key, \sipk denotes a set of issuer's public keys. To refer to
a specific element of a set, we use subindexes, e.g., $\sipk_i$ is the $i$-th
\ipk within \sipk.
%
We also assume the existence of a well defined attribute space over which
issuers in our schemes can issue credentials on. We denote this set with
\AttrSpace.

% \todo{Attribute space. Used in generic construction of GSAC for now. Define it
%   to be the set of bitstrings of some length.}

% \todo{\attrs and \dattrs (in \secref{ssec:construction-gsac}, they are treated
%   as indices, but I think that's not the case elsewhere).}

% \todo{In \secref{ssec:construction-gsac}, we assume that all messages and
%   attributes can be encoded as elements in $\ZZ^*_p$.}

% \todo{In \secref{ssec:generic-construction-uas} we use $\usk \in \cred$ to
%   denote the claim ``\usk is an attribute attested in \cred''.}

% \todo{In GSAC traceability proof, we use $\negl(\cdot)$ to denote negligible
%   functions.}
  

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "uas"
%%% End:
