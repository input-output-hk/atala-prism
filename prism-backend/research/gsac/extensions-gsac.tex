\subsection{\GSAC Variants}
\label{ssec:variants-gsac}

\paragraph{\GSAC with interactive presentations.} %
In group signatures, the signing and verification process is non-interactive.
That is, a group member produces a signature and eventually sends it to the
verifier, who can check it without further interaction. Nevertheless, in
anonymous credentials, this process is typically interactive, and consists of
at least one round-trip. This can be useful, for instance, when some notion of
freshness is necessary.

The approach to turn our non-interactive singing-verification into an
interactive protocol that ensures freshness is evident: prior to signing the
message, we require that the honest verifier sends to the user a number picked
uniformly at random from an appropriate domain, which must be concatenated to
the signed message. If there is no need to actually sign a message, then the
message is set to an empty string, and the user only signs the random number.
%
Syntactically, instead of having non-interactive $\sig \gets \Sign(\gpk,\usk,
\cred,\dattrs,\msg)$ and $1/0 \gets \Verify(\gpk,\sig,\dattrs,\msg)$ algorithms,
we have a $1/0 \gets \langle \Sign(\gpk,\usk,\cred,\dattrs),\Verify(\gpk,
\dattrs) \rangle$ interactive protocol.
%
We sketch a proof for why does this result in a secure
\GSAC scheme with interactive signing and verification in
\appref{ssap:interactive-gsac}

\paragraph{Comparing \GSAC with group signatures and anonymous
  credentials.} %

\GSAC is a direct combination of group signatures and anonymous credentials.
%
On the one hand, by restricting to credentials without attributes (i.e., where
the only attribute is the user secret key), we get a vanilla group signature
scheme. Although, strictly, our scheme allows users to fetch more than one
credential -- which goes beyond vanilla group signatures -- this can be
trivially ``compensated'' by requiring users to prove ownership of a
conventional digital identity during the $\langle \Obtain,\Issue \rangle$
protocol\footnote{This is indeed common practice, but also frequently ommitted
  in research papers.}.
%
On the other hand, by instantiating a \GSAC scheme and simply
throwing out the opener's key pair (thus, making \Open and \Judge useless), one
gets a vanilla anonymous credential system. Or, keeping \osk, one can build an
anonymous credential system with blacklisting, which can be directly built via
the \Open function -- although at the cost of fully de-anonymizing blacklisted
credentials, which is much more invasive than just blacklisting.

\jdv{Should we do formal proofs here of $GSAC \implies$ GS and $GSAC \implies
  AC$? Is it worth it?}

\iffalse
\todo{Modelling choices: HU and CU lists are typically updated in join protocols
  in the GS literature. Here, it is best to follow the AC literature, as a same
  user (key) may be associated to multiple join protocols. So there are HUGEN
  and CUGEN oracles.}

\todo{Other modelling choice: We could return the full set of attributes
  contained in the credential used for creating an opened signature, but that
  would require either complicating the proof, or access to the transcripts log
  at open time, which I opted to avoid for better compatibility with \UAS.}

\todo{It would be nice to prove that a \GSAC scheme to which we remove the
  \Open/\Judge functions becomes an AC scheme. And conversely, a \GSAC scheme
  where all credentials have no attributes, and where we restrict to only
  one credential per user, becomes a conventional GS scheme.}
\fi

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "uas"
%%% End:
