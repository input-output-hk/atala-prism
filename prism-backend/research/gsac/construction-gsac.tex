\subsection{\GSACGen: A Generic Construction for \GSAC}
\label{ssec:generic-gsac}

In a nutshell, our generic \GSAC construction leverages a signature scheme
on blocks of (committed) messages, where each message to be signed is an
attribute in the produced credential; with the exception of the user secret key,
which is treated as a special attribute. Moreover, the user secret key is also
the only ``attribute'' signed in committed form, to prevent the issuer from
learning it. On top of that, we make use of NIZKs to: (1) during credential
issuance, have users prove knowledge of the secret key; (2) during signing,
have users prove knowledge of the user secret key, unrevealed attributes, and
a credential including all (revealed and unrevealed) attributes; and (3), during
open, to have the opener prove correctness of the decryption of the user
``public'' key and credential attributes. Concerning the user public keys, they
are mere commitments to the user secret key (with $0$ as randomness -- although
could be any fixed value), that serve to univocally identify a user, without
revealing its secret key.

In more detail, in the following algorithms, we make use of three different NP
relations for \NIZK proof systems:

\begin{description}
\item[$\NIZKRel_{\Issue}$:] Produced by users requesting a credential. It is
  defined as $\NIZKRel_{\Issue} = \lbrace \usk, \Ccom :
  \Ccom = \CCommit(\usk; r) \rbrace$.
\item[$\NIZKRel_{\Sign}$:] Produced by users when signing a message. It is
  defined as $\NIZKRel_{\Sign} = \lbrace (\usk,\Ccom,\attrs,\msg,\SBCMsig),
  (\Cmsg,\Ec,\sEc^{\attrs},\dattrs,n) : \Cmsg = \CCommit(\msg) \land \Ccom =
  \CCommit(\usk; 0) \land \Ec = \EEnc(\opk,\Ccom) \land
  \sEc_1^{\attrs} = \EEnc(\opk,\attrs_1) \land \dots
  \sEc_n^{\attrs} = \EEnc(\opk,\attrs_n) \land
  \land \SBCMVerify(\ipk,\SBCMsig,\usk,\attrs) = 1
  \land \dattrs \subseteq \attrs \rbrace$.
\item[$\NIZKRel_{\Open}$:] Used by the opener when opening a signature. It
  is defined as $\NIZKRel_{\Open} = \lbrace (\osk), (\Ec,\msg) :
  \msg = \EDec(\osk,\Ec) \rbrace$.
\end{description}

With the help of those \NIZK proof systems, we build the algorithms for
\GSACGen as follows:

\paragraph{$\Setup(\secpar,\nattrs) \rightarrow \parm$.} %
Sets up the public parameters. Namely: $\Cparm \gets \CSetup(\secpar)$, $\Eparm
\gets \ESetup(\secpar)$, $\SBCMparm \gets \SBCMSetup(\secpar)$,
$\NIZKcrs_{\Issue} \gets \NIZKSetup^{\NIZKRel_{\Issue}}(\secpar)$,
$\NIZKcrs_{\Sign} \gets \NIZKSetup^{\NIZKRel_{\Sign}} (\secpar)$,
$\NIZKcrs_{\Open}\gets \NIZKSetup^{\NIZKRel_{\Open}}(\secpar)$.
Outputs $\parm \gets (\Cparm,\SBCMparm,\Eparm,\NIZKcrs_{\Issue},\NIZKcrs_{\Sign},
\NIZKcrs_{\Open})$. Note that parts of this process can be left to individual
parties (e.g., \SBCMSetup, $\NIZKSetup^{\Issue}$ to the issuer, or \ESetup and
$\NIZKSetup^{\Open}$ to the opener) who later publish the output, but we
concentrate them in \Setup for readability.

\paragraph{$\IKeyGen(\parm) \rightarrow (\ipk,\isk)$.} %
Generates the signing key pair for the issuer, by parsing \parm as
$(\cdot,\SBCMparm,\cdot,\cdot)$ and running $(\ipk,\isk) \gets
\SBCMKeyGen(\SBCMparm)$.

\paragraph{$\OKeyGen(\parm) \rightarrow (\opk,\osk)$.} %
Generates the encryption key pair for the opener, by parsing \parm as
$(\cdot,\SBCMparm,\Eparm,\cdot)$ and running $(\opk,\osk) \gets
\EKeyGen(\Eparm)$.

\paragraph{$\UKeyGen(\parm) \rightarrow (\upk,\usk)$.} %
Generates users' key pairs by choosing a random value within the attribute space
\AttrSpace, and committing to it. Concretely: $\usk \getr \AttrSpace$, $\upk
\gets \CCommit(\usk; 0)$.

\paragraph{$\langle \Obtain(\gpk,\usk,\attrs),\Issue(\gpk,\isk,\attrs) \rangle
  \rightarrow \langle \cred/\bot,\utrans/\bot \rangle$.} %
In a nutshell, the user requests a signature over his public key (a commitment
of its user key), as well as the attributes in \attrs. The user proves knowledge
of the committed value, and the issuer sends the signature (credential) in return.
This is directly an execution of the interactive signing protocol of an \SBCM
scheme, in which the user parses \gpk as $(\ipk,\opk)$ and runs $\SBCMCom(\ipk,
\usk,\attrs)$, and the issuer runs $\SBCMSign(\isk,\attrs)$; in both cases,
using $\NIZKRel_{\Issue}$ as \NIZK relation. The credential \cred output to the
user is the signature produced by the interactive signing protocol, and the
\utrans entry obtained by the issuer is the transcript of the protocol, namely
a $(\Ccom,\attrs,\cred,\pi)$ tuple.

\iffalse

\todo{This is not consistent with the $\langle \SBCMCom,\SBCMSign \rangle$
  definition...}
  
\begin{itemize}
\item \underline{User}: Commit to the user secret key by running $\Ccom \gets
  \CCommit(\usk)$. Generate proof $\NIZKproof \gets
  \NIZKProve^{\NIZKRel_{\Issue}}(\NIZKcrs,\usk,\Ccom)$. Send $(\Ccom,
  \NIZKproof)$ to the issuer.
\item \underline{Issuer}: Run $\NIZKVerify^{\NIZKRel_{\Issue}}(\NIZKcrs,
  \C,\NIZKproof)$, and return $\bot$ if it fails. Else, create the credential
  by computing $\SBCMsig \gets \SBCMSign(\isk,\C,\attrs)$. Send \SBCMsig to the
  user, and output $\utrans \gets (\C,\SBCMsig,\attrs,\NIZKproof)$.
\item \underline{User}: Check the signature by running $\SBCMVerify(\ipk,
  \SBCMsig,\attrs \cup \lbrace \usk \rbrace)$, and return $\bot$ if
  verification fails. Otherwise, return $\cred \gets \SBCMsig$.
\end{itemize}
\fi

\paragraph{$\Sign(\gpk,\usk,\cred,\dattrs,\msg) \rightarrow \sig$.} %
Commit to the message and recompute the user public key by running
$\Cmsg \gets \CCommit(\msg), \Ccom \gets \CCommit(\usk; 0)$.
Encrypt \Ccom as $\Ec \gets \EEnc(\opk,\Ccom)$, each attribute $\attrs_i \in
\attrs$ as $\sEc^{\attrs}_i \gets \EEnc(\opk,\attrs_i)$ for $i \in n =
|\attrs|$, and compute  $\NIZKproof \gets
\NIZKProve^{\NIZKRel_{\Sign}}(\NIZKcrs,(\usk,\Ccom,\attrs,\msg,\cred),(\Cmsg,
\Ec,\dattrs,\sEc^{\attrs},n))$. Output $\sig \gets (\Ec,\sEc^{\attrs},
\NIZKproof)$.

\paragraph{$\Verify(\gpk,\sig,\dattrs,\msg) \rightarrow 1/0$.} %
Parse \sig as $(\Ec,\sEc^{\attrs},\NIZKproof)$, compute $\Cmsg \gets
\CCommit(\msg)$ and return $\NIZKVerify^{\NIZKRel_{\Sign}}(\NIZKcrs,(\Cmsg,\Ec,
\dattrs,\sEc^{\attrs},n),\NIZKproof)$, where $n=|\sEc^{\attrs}|$.

\paragraph{$\Open(\gpk,\osk,\trans,\sig,\dattrs,\msg)
  \rightarrow (\upk,\attrs,\oproof)/\bot$.} %
First, verify the signature with $\Verify(\gpk,\sig,\dattrs,\msg)$ and
return $\bot$ if verification fails. Else, parse \sig as $(\Ec,\sEc^{\attrs},
\NIZKproof)$ and run $\upk \gets \EDec(\osk,\Ec)$, $\attrs_1 \gets \EDec(\osk,
\sEc_1^{\attrs}), \dots, \attrs_n \gets \EDec(\osk,\sEc_n^{\attrs})$. Compute
proof of correct decryption for all encrypted values as
$\oproof_{\Open} \gets (\NIZKProve^{\NIZKRel_{\Open}}(\NIZKcrs,\osk,(\Ec,
\upk)),\NIZKProve^{\NIZKRel_{\Open}}(\NIZKcrs,\osk,(\sEc_1^{\attrs},\attrs_1),
\dots,\NIZKProve^{\NIZKRel_{\Open}}(\NIZKcrs,\osk,(\sEc_n^{\attrs},\attrs_n))$.
Return $(\upk,\attrs,\oproof_{\Open})$.

\paragraph{$\Judge(\gpk,\upk,\attrs,\oproof,\sig,\dattrs,\msg)
  \rightarrow 1/0$.} %
First, verify the signature with $\Verify(\gpk,\sig,\dattrs,\msg)$ and
return $\bot$ if verification fails. If verification suceeds, parse
\sig as $(\Ec,\sEc^{\attrs},\cdot)$ and return
$\NIZKVerify^{\NIZKRel_{\Open}}(\NIZKcrs,(\Ec,\upk)) \land
\NIZKVerify^{\NIZKRel_{\Open}}(\NIZKcrs,(\sEc_1^{\attrs},\attrs_1)) \land
\dots \land
\NIZKVerify^{\NIZKRel_{\Open}}(\NIZKcrs,(\sEc_n^{\attrs},\attrs_n))$.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "uas"
%%% End:
