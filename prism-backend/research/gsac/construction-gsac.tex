\subsection{\GSACGen: A Generic Construction for \GSAC}
\label{ssec:generic-gsac}

\todo{Do we mention earlier that GSAC only supports selective disclosure?}

\subsubsection{Definition}
\label{sssec:generic-gsac-definition}

In the following algorithms, we make use of three different NP relations for
\NIZK proof systems:

\begin{description}
\item[$\NIZKRel_{\Issue}$:] Produced by users requesting a credential. It is
  defined as $\NIZKRel_{\Issue} = \lbrace \usk, \Ccom :
  \Ccom = \CCommit(\usk; r) \rbrace$.
\item[$\NIZKRel_{\Sign}$:] Produced by users when signing a message. It is
  defined as $\NIZKRel_{\Sign} = \lbrace (\usk,\Ccom,\Attrs,\msg,\SBCMsig),
  (\Cmsg,\Ec,\DAttrs) : \Cmsg = \CCommit(\msg) \land \Ccom =
  \CCommit(\usk; 0) \land \Ec = \EEnc(\opk,\Ccom)
  \land \SBCMVerify(\ipk,\SBCMsig,\Attrs \cup \lbrace \usk \rbrace) = 1
  \land \DAttrs \subseteq \Attrs \rbrace$.
\item[$\NIZKRel_{\Open}$:] Used by the opener when opening a signature. It
  is defined as $\NIZKRel_{\Open} = \lbrace (\osk), (\Ec,\msg) :
  \msg = \EDec(\osk,\Ec) \rbrace$.
\end{description}

In a nutshell \todo{describe high-level approach}.

\paragraph{$\Setup(\secpar,\nattrs) \rightarrow \parm$.} %
Sets up the public parameters \todo{can be distributed across responsible
  parties?}. Namely: $\Cparm \gets \CSetup(\secpar)$, $\Eparm \gets
\ESetup(\secpar)$, $\SBCMparm \gets \SBCMSetup(\secpar)$, $\NIZKcrs \gets
\NIZKSetup(\secpar)$. Outputs $\parm \gets (\Cparm,\SBCMparm,\Eparm,\NIZKcrs)$.

\paragraph{$\IKeyGen(\parm) \rightarrow (\ipk,\isk)$.} %
Generates the signing key pair for the issuer, by parsing \parm as
$(\cdot,\SBCMparm,\cdot,\cdot)$ and running $(\ipk,\isk) \gets
\SBCMKeyGen(\SBCMparm)$.

\paragraph{$\OKeyGen(\parm) \rightarrow (\opk,\osk)$.} %
Generates the encryption key pair for the opener, by parsing \parm as
$(\cdot,\SBCMparm,\Eparm,\cdot)$ and running $(\opk,\osk) \gets
\EKeyGen(\Eparm)$.

\paragraph{$\UKeyGen(\parm) \rightarrow (\upk,\usk)$.} %
Generates users' key pairs by choosing a random value within the attribute space
\AttrSpace, and committing to it. Concretely: $\usk \getr \AttrSpace$, $\upk
\gets \CCommit(\usk; 0)$.

\paragraph{$\langle \Obtain(\gpk,\usk,\Attrs),\Issue(\gpk,\isk,\Attrs) \rangle
  \rightarrow \langle \cred/\bot,\utrans/\bot \rangle$.} %
In a nutshell, the user commits to a random credential identifier, and requests
a signature over commitments of its user secret key and credential identifier,
as well as the attributes in \Attrs. The user proves knowledge of the committed
values, and the issuer sends the signature (credential) in return. More
concretely:

\begin{itemize}
\item \underline{User}: Commit to the user secret key by running $\Ccom \gets
  \CCommit(\usk)$. Generate proof $\NIZKproof \gets
  \NIZKProve^{\NIZKRel_{\Issue}}(\NIZKcrs,\usk,\Ccom)$. Send $(\Ccom,
  \NIZKproof)$ to the issuer.
\item \underline{Issuer}: Run $\NIZKVerify^{\NIZKRel_{\Issue}}(\NIZKcrs,
  \C,\NIZKproof)$, and return $\bot$ if it fails. Else, create the credential
  by computing $\SBCMsig \gets \SBCMSign(\isk,\C,\Attrs)$. Send \SBCMsig to the
  user, and output $\utrans \gets (\C,\SBCMsig,\Attrs,\NIZKproof)$.
\item \underline{User}: Check the signature by running $\SBCMVerify(\ipk,
  \SBCMsig,\Attrs \cup \lbrace \usk \rbrace)$, and return $\bot$ if
  verification fails. Otherwise, return $\cred \gets \SBCMsig$.
\end{itemize}

\paragraph{$\Sign(\gpk,\usk,\cred,\DAttrs,\msg) \rightarrow \sig$.} %
Commit to the message and recompute the user public key by running
$\Cmsg \gets \CCommit(\msg), \Ccom \gets \CCommit(\usk; 0)$.
Encrypt \Ccom as $\Ec \gets \EEnc(\opk,\Ccom)$ and create a NIZK proof using
$\NIZKRel_{\Sign}$ as $\NIZKproof \gets \NIZKProve^{\NIZKRel_{\Sign}}
(\NIZKcrs,(\usk,\Ccom,\Attrs,\msg,\cred),
(\Cmsg,\Ec,\DAttrs))$. Output $\sig \gets (\Ec,\NIZKproof)$.

\paragraph{$\Verify(\gpk,\sig,\DAttrs,\msg) \rightarrow 1/0$.} %
Parse \sig as $(\Ec,\NIZKproof)$, compute $\Cmsg \gets \CCommit(\msg)$ and
return $\NIZKVerify^{\NIZKRel_{\Sign}}(\NIZKcrs,(\Cmsg,\Ec,\DAttrs),
\NIZKproof)$.

\paragraph{$\Open(\gpk,\osk,\trans,\sig,\DAttrs,\msg)
  \rightarrow (\upk,\oproof)/\bot$.} %
First, verify the signature with $\Verify(\gpk,\sig,\DAttrs,\msg)$ and
return $\bot$ if verification fails. Else, parse \sig as $(\Ec,\NIZKproof)$
and run $\upk \gets \EDec(\osk,\Ec)$. Compute proof of correct decryption
as $\oproof_{\Open} \gets \NIZKProve^{\NIZKRel_{\Open}}(\NIZKcrs,\osk,(\Ec,
\upk))$. Return $(\upk,\oproof_{\Open})$.

\paragraph{$\Judge(\gpk,\upk,\Attrs,\oproof,\sig,\DAttrs,\msg)
  \rightarrow 1/0$.} %
First, verify the signature with $\Verify(\gpk,\sig,\DAttrs,\msg)$ and
return $\bot$ if verification fails. If verification suceeds, parse
\sig as $(\Ec,\cdot)$ and return $\NIZKVerify^{\NIZKRel_{\Open}}(\NIZKcrs,(\Ec,
\upk))$.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "uas"
%%% End:
