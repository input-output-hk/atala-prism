\subsection{\GSACGen: A Generic Construction for \GSAC}
\label{ssec:generic-gsac}

In a nutshell, our generic \GSAC construction leverages a signature scheme
on blocks of (committed) messages, where each message to be signed is an
attribute in the produced credential; with the exception of the user secret key,
which is treated as a special attribute. Moreover, the user secret key is also
the only ``attribute'' signed in committed form, to prevent the issuer from
learning it. On top of that, we make use of NIZKs to: (1) during credential
issuance, have users prove knowledge of the secret key; (2) during signing,
have users prove knowledge of the user secret key, unrevealed attributes, and
a credential including all (revealed and unrevealed) attributes; and (3), during
open, to have the opener prove correctness of the decryption of the user
``public'' key. Concerning the user public keys, they are mere commitments to
the user secret key (with $0$ as randomness -- although could be any fixed
value), that serve to univocally identify a user, without revealing its secret
key.

In more detail, in the following algorithms, we make use of three different NP
relations for \NIZK proof systems:

\begin{description}
\item[$\NIZKRel_{\Issue}$:] Produced by users requesting a credential. It is
  defined as $\NIZKRel_{\Issue} = \lbrace \usk, \Ccom :
  \Ccom = \CCommit(\usk; r) \rbrace$.
\item[$\NIZKRel_{\Sign}$:] Produced by users when signing a message. It is
  defined as $\NIZKRel_{\Sign} = \lbrace (\usk,\Ccom,\Attrs,\msg,\SBCMsig),
  (\Cmsg,\Ec,\DAttrs) : \Cmsg = \CCommit(\msg) \land \Ccom =
  \CCommit(\usk; 0) \land \Ec = \EEnc(\opk,\Ccom)
  \land \SBCMVerify(\ipk,\SBCMsig,\Attrs \cup \lbrace \usk \rbrace) = 1
  \land \DAttrs \subseteq \Attrs \rbrace$.
\item[$\NIZKRel_{\Open}$:] Used by the opener when opening a signature. It
  is defined as $\NIZKRel_{\Open} = \lbrace (\osk), (\Ec,\msg) :
  \msg = \EDec(\osk,\Ec) \rbrace$.
\end{description}

With the help of those \NIZK proof systems, we build the algorithms for
\GSACGen as follows:

\paragraph{$\Setup(\secpar,\nattrs) \rightarrow \parm$.} %
Sets up the public parameters. Namely: $\Cparm \gets \CSetup(\secpar)$, $\Eparm
\gets \ESetup(\secpar)$, $\SBCMparm \gets \SBCMSetup(\secpar)$,
$\NIZKcrs_{\Issue} \gets \NIZKSetup^{\Issue}(\secpar)$, $\NIZKcrs_{\Sign} \gets
\NIZKSetup^{\Sign} (\secpar)$, $\NIZKcrs_{\Open}\gets \NIZKSetup^{\Open}(\secpar)$.
Outputs $\parm \gets (\Cparm,\SBCMparm,\Eparm,\NIZKcrs_{\Issue},\NIZKcrs_{\Sign},
\NIZKcrs_{\Open})$. Note that parts of this process can be left to individual
parties (e.g., \SBCMSetup, $\NIZKSetup^{\Issue}$ to the issuer, or \ESetup and
$\NIZKSetup^{\Open}$ to the opener) who later publish the output, but we
concentrate them here in \Setup for readability.

\paragraph{$\IKeyGen(\parm) \rightarrow (\ipk,\isk)$.} %
Generates the signing key pair for the issuer, by parsing \parm as
$(\cdot,\SBCMparm,\cdot,\cdot)$ and running $(\ipk,\isk) \gets
\SBCMKeyGen(\SBCMparm)$.

\paragraph{$\OKeyGen(\parm) \rightarrow (\opk,\osk)$.} %
Generates the encryption key pair for the opener, by parsing \parm as
$(\cdot,\SBCMparm,\Eparm,\cdot)$ and running $(\opk,\osk) \gets
\EKeyGen(\Eparm)$.

\paragraph{$\UKeyGen(\parm) \rightarrow (\upk,\usk)$.} %
Generates users' key pairs by choosing a random value within the attribute space
\AttrSpace, and committing to it. Concretely: $\usk \getr \AttrSpace$, $\upk
\gets \CCommit(\usk; 0)$.

\paragraph{$\langle \Obtain(\gpk,\usk,\Attrs),\Issue(\gpk,\isk,\Attrs) \rangle
  \rightarrow \langle \cred/\bot,\utrans/\bot \rangle$.} %
In a nutshell, the user requests a signature over a commitment of its user
secret key, as well as the attributes in \Attrs. The user proves knowledge of
the committed value, and the issuer sends the signature (credential) in return.
More concretely:

\todo{This is not consistent with the $\langle \SBCMCom,\SBCMSign \rangle$
  definition...}
  
\begin{itemize}
\item \underline{User}: Commit to the user secret key by running $\Ccom \gets
  \CCommit(\usk)$. Generate proof $\NIZKproof \gets
  \NIZKProve^{\NIZKRel_{\Issue}}(\NIZKcrs,\usk,\Ccom)$. Send $(\Ccom,
  \NIZKproof)$ to the issuer.
\item \underline{Issuer}: Run $\NIZKVerify^{\NIZKRel_{\Issue}}(\NIZKcrs,
  \C,\NIZKproof)$, and return $\bot$ if it fails. Else, create the credential
  by computing $\SBCMsig \gets \SBCMSign(\isk,\C,\Attrs)$. Send \SBCMsig to the
  user, and output $\utrans \gets (\C,\SBCMsig,\Attrs,\NIZKproof)$.
\item \underline{User}: Check the signature by running $\SBCMVerify(\ipk,
  \SBCMsig,\Attrs \cup \lbrace \usk \rbrace)$, and return $\bot$ if
  verification fails. Otherwise, return $\cred \gets \SBCMsig$.
\end{itemize}

\paragraph{$\Sign(\gpk,\usk,\cred,\DAttrs,\msg) \rightarrow \sig$.} %
Commit to the message and recompute the user public key by running
$\Cmsg \gets \CCommit(\msg), \Ccom \gets \CCommit(\usk; 0)$.
Encrypt \Ccom as $\Ec \gets \EEnc(\opk,\Ccom)$ and create a NIZK proof using
$\NIZKRel_{\Sign}$ as $\NIZKproof \gets \NIZKProve^{\NIZKRel_{\Sign}}
(\NIZKcrs,(\usk,\Ccom,\Attrs,\msg,\cred),
(\Cmsg,\Ec,\DAttrs))$. Output $\sig \gets (\Ec,\NIZKproof)$.

\paragraph{$\Verify(\gpk,\sig,\DAttrs,\msg) \rightarrow 1/0$.} %
Parse \sig as $(\Ec,\NIZKproof)$, compute $\Cmsg \gets \CCommit(\msg)$ and
return $\NIZKVerify^{\NIZKRel_{\Sign}}(\NIZKcrs,(\Cmsg,\Ec,\DAttrs),
\NIZKproof)$.

\paragraph{$\Open(\gpk,\osk,\trans,\sig,\DAttrs,\msg)
  \rightarrow (\upk,\oproof)/\bot$.} %
First, verify the signature with $\Verify(\gpk,\sig,\DAttrs,\msg)$ and
return $\bot$ if verification fails. Else, parse \sig as $(\Ec,\NIZKproof)$
and run $\upk \gets \EDec(\osk,\Ec)$. Compute proof of correct decryption
as $\oproof_{\Open} \gets \NIZKProve^{\NIZKRel_{\Open}}(\NIZKcrs,\osk,(\Ec,
\upk))$. Return $(\upk,\oproof_{\Open})$.

\paragraph{$\Judge(\gpk,\upk,\Attrs,\oproof,\sig,\DAttrs,\msg)
  \rightarrow 1/0$.} %
First, verify the signature with $\Verify(\gpk,\sig,\DAttrs,\msg)$ and
return $\bot$ if verification fails. If verification suceeds, parse
\sig as $(\Ec,\cdot)$ and return $\NIZKVerify^{\NIZKRel_{\Open}}(\NIZKcrs,(\Ec,
\upk))$.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "uas"
%%% End:
