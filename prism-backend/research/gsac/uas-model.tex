\section{Model for \UAS Schemes}
\label{sec:model-uas}

Universal Anonymous Signatures.

\subsection{Syntax}
\label{ssec:syntax}

In the following, we assume a setting with multiple groups. For simplicity,
we assume that each has its own issuer and inspector.

\todo{Are generalizations where different groups can share issuer or inspector
  straight forward?}

\todo{The notation for multisets is not strictly correct. Still, leaving it as
  is for now.} 

\commentwho{Jesus}{I'm trying to define \Sign, \Verify, \Inspect and \Judge such
  that multiple credentials can be used to produce a single signature, proving
  claims over arbitrary subsets of all the credentials owned by a user. \Verify
  and, consequently, \Inspect and \Judge need to receive all the \gpk's.
  \Inspect only requires one inspector's secret key, though, and will thus only
  produce that inspector's function of the signature and message (this is to
  avoid complex interactive protocols between many inspectors). This, however,
  creates a quite annoying syntax. If this becomes unmanageable, it may just be
  easier to restrict signatures to claims over the attributes contained in
  \emph{one} credential.}

\commentwho{Jesus}{I'm moving to a syntax that applies arbitrary functions over
  the credentials, at different points (issuance, evaluation, and inspection).
  Concretely, I'm moving away from the selective disclosure type of syntax.
  However, it is my intention that selective disclosure becomes an especial case
  of this. That is, the syntax should support both credentials with plain
  selective attribute disclosure, and ``functional'' credentials.}

\begin{description}
\item[$\parm \gets \Setup(\secpar)$.] Given a security parameter \secpar,
  returns a global system parameter variable \parm.
\item[$(\ipk,\isk) \gets \IKeyGen(\parm,\fissue)$.] Given global system
  parameters \parm, and the function \fissue to be used to check that credential
  requestors meet the conditions to be issued a credential, an issuer runs
  \IKeyGen to generate its issuing key pair. Hereafter, we assume that the
  public part \ipk is added to the group public key \gpk, as well as \fissue.
\item[$(\opk,\osk) \gets \OKeyGen(\parm,\finsp)$.] Given global system
  parameters \parm, and function \finsp, an inspector runs \OKeyGen to generate
  its inspecting key pair. The function \finsp defines the type of utility that
  will be extractable from those pairs that do not meet conditions defined
  at signing time (typically, by verifiers). Hereafter, we assume that the
  public part \opk is added to the group public key \gpk, along with \finsp.
\item[$(\upk,\usk) \gets \UKeyGen(\parm)$.] Given global system parameters
  \parm, returns a user's key pair.
\item[$\langle \cred/\bot,\utrans/\bot \rangle \gets
  \langle
  \Obtain(\usk,\attrs,\ldblbrace (gpk_i,\cred_i)\rdblbrace_{i \in \Issuers}),
  \Issue(\isk,\upk,\attrs,\ldblbrace \gpk_i \rdblbrace_{i \in \Issuers})
  \rangle$.] %
  This interactive protocol lets a user with key pair (\upk,\usk) running the
  \Obtain process, obtain a credential \cred from an issuer in the system, on
  attribute set $\attrs$ plus, possibly, blinded attributes attested by
  previously obtained credentials $\cred_i$, from a multiset of other issuers
  (which may include the one to whom a new credential is being requested) with
  public keys $\gpk_i$. The user outputs the produced credential \cred, while
  the issuer outputs the protocol transcript \utrans for the produced
  credential. To ease notation, we assume that the group to which each
  credential belongs is available from the credential itself, and therefore
  omit the $\gpk_i$ values from the syntax, unless necessary to avoid ambiguity.
\item[$\sig \gets \Sign(\usk,\msg,\feval,
  \ldblbrace (\gpk_i,\cred_i)\rdblbrace_{i \in \Issuers})$.]
  The user with with secret key \usk, who obtained credentials $\cred_i$ from a
  multiset of issuers in the system, produces a signature \sig over message
  \msg, meeting the conditions defined by \feval. As in \Obtain and \Issue, we
  omit the credentials' group public keys when possible.
\item[$1/0 \gets
  \Verify(\sig,\msg,\ldblbrace \gpk_i \rdblbrace_{i \in \Issuers})$.]
  Checks whether \sig is a valid signature, over message \msg.
\item[$(\y,\iproof)/\bot \gets \Inspect(\osk,\trans,\sig,\msg,
  \ldblbrace \gpk_i \rdblbrace_{i \in \Issuers})$.] %
  Executed by the inspector with private key \osk. Receives a signature \sig
  over message \msg, produced by a set of credentials endorsed by a multiset of
  issuers with public keys $\gpk_i$. If \trans contains a set of valid
  transcripts corresponding to the $\langle\Obtain,\Issue\rangle$ interactive
  protocol executions that issued one or more credentials used to produced \sig,
  the function outputs a value $\y$ derived from the signer's public key,
  credentials, message, and signature, as well as a proof of correct inspection.
  We sometimes abuse notation, and write $\trans[\uid]$ to mean that the \Inspect
  function is operating only for the obtain transcripts related to user \uid. 
\item[$1/0 \gets \Judge(\y,\iproof,\sig,\msg,
  \ldblbrace \gpk_i\rdblbrace_{i \in \Issuers})$.] %
  Checks if \iproof is a valid inspection correctness proof for the value \y,
  obtained by applying \Inspect to the the signature \sig over message \msg. 
\end{description}

The correctness and security properties are defined with the help of the
following sets of oracles, and global variables that help oracles and games
keep consistent state.

\paragraph{Issuance, evaluation, and inspection functions.} %
We emphasize that, both in our syntax definition, as well as on the following
modelling, we make use of three different and abstract functions: \fissue,
\feval and \finsp. The three functions are introduced to allow customized
governance of the resulting instantiation of an \UAS scheme. They will be
defined by different parties, but in all cases, they are run by users (maybe,
on user-private data). Also, in all cases, the user has to prove correctness of
their computation. We introduce them next, \todo{and will give concrete examples
  in \secref{sec:uac-instantiation}.}

\begin{description}
\item[$\fissue: (\upk, \attrs,\scred) \rightarrow 0/1$.] Defined by issuers,
  governs what customized conditions an issuer requires in order to issue
  credentials, when receiving a request from user with public key \upk, for
  attributes \attrs. \fissue may run checks on a (possibly empty) set of
  additional credentials \scred, which may further be used for blind issuance
  \commentwho{Jesus}{can it?}. \fissue returns $1$ to accept a request, $0$ to
  reject it.  
\item[$\feval: (\upk,\scred,\msg) \rightarrow 0/1$.] Can be defined by any party,
  although we anticipate that this will typically be done by either singers,
  verifiers, or some governance organization. It defines customized conditions
  to be met by the owner of a user key \upk and set of credentials \scred, in
  order to sign a concrete message \msg. Returns $1$ to allow the signing,
  or $0$ to disallow it.
\item[$\finsp: (\upk,\scred,\msg,\sig) \rightarrow \bin^*$.] Defines what
  utility value, derived from the user's public key, credentials, signed
  message, and produced signature (or a subset thereof), should be extractable
  by the group inspector.
\end{description}

\paragraph{Helper Function \Identify.} In addition, we make use of a helper
function \Identify for some of our definitions. This function receives
a signature and a user secret key, and determines whether the latter was used
to produce the former. This is in line with previous works on DAA
\cite{bfg+11,cdl16} and group signatures without traditional open functions
\cite{dl21,fgl21,gl19}. More concretely, the \Identify function, defined as $1/0
\gets \Identify(\usk,\sig)$, conveys meaning to our non-frameability definition
conditioned on the fact that, given a signature \sig accepted by \Verify,
\Identify returns $1$ for exactly one \usk.

\paragraph{Global Variables.} %
The environment manages several global variables in the games posed to the
adversary. Users are referred to with user identifiers, \uid; for credentials,
we use \cid; for groups, \gid. For credentials and groups, we use bold font to
denote sets: i.e., \scid and \sgid denot sets of credential and group
identifiers. All tables/sets are initialized as empty tables/sets, denoted
with $\emptyset$.

\begin{description}
\item[Tables for parties]:
  \begin{description}
  \item[\HU and \CU.] Keep track of honest (\HU) and corrupted (\CU) users;
    i.e., they are sets of {\uid}s.
  \item[\HI and \CI.] Keep track of honest (\HI) and corrupted (\CI) issuers.
    Since we assume only one issuer per group, they are sets of {\gid}s.
  \item[\HO and \CO.] Keep track of honest (\HO) and corrupted (\CO) inspectors.
    Since we assume only one inspector per group, they are sets of {\gid}s.
  \end{description}
\item[Tables for keys]:
  \begin{description}
  \item[\UK, \PUBUK and \PRVUK.] \UK maintains user key pairs $(\upk,\usk)$.
    To refer to the key pair of a specific user, we use $\UK[\uid]$. \PUBUK
    is a shorthand to refer to the public part, and \PRVUK refers to the
    private part -- we may also index both by \uid.
  \item[\IK, \PUBIK and \PRVIK.] Same as \UK, but for issuer key pairs. In
    addition, \IK also includes the \fissue function, which is part of the
    public key.
  \item[\OK, \PUBOK, \PRVOK.] Same as \UK, but for inspector key pairs. In
    addition, \OK also includes the \finsp function, which is part of the
    public key.
  \item[\GK.] We bundle public keys for issuers and inspectors into a common
    public key for each group. We use the table \GK for that purpose which,
    consequently, can also be indexed by \gid.
  \end{description}
\item[Tables for credentials-related data]:
  \begin{description}
  \item[\CRED.] Stores credentials obtained by honest users. Thus, it is
    indexable by \cid. However, we slightly abuse notation and also use
    $\CRED[\uid]$ as a shorthand for all credentials obtained by honest user
    \uid, or $\CRED[\scid]$ to refer to a set of credentials with the
    identifiers in set \scid.
  \item[\OWNR.] Keeps track of which \uid is the owner of credentials obtained
    by honest users; i.e., $\OWNR[\cid]$ returns the \uid that obtained
    credential with identifier \cid.
  \item[\ATTR.] Keeps track of the attributes assigned to a credential, as well
    as the credential identifiers used to attest for any arbitrary claims
    required for issuance. This table can be indexed by credential identifier
    \cid.
  \item[\GRP.] Keeps track of the group to which a credential belongs to; i.e.,
    the group of the issuer who issued the credential. This table can be indexed
    by credential identifier \cid.
  \end{description}
\item[STables for signatures]:
  \begin{description}
  \item[\SIG.] Maintains signatures generated via the \SIGN oracle, on behalf
    of honest users.
  \item[\CSIG.] Maintains challenge signatures, generated via the \CHALb oracle,
    by one of the challenge users in the anonymity game.
  \end{description}
\end{description}

\paragraph{Oracles.} %
Oracles are the interface of the adversary with the corresponding games. In
other words: through these oracles, the game environment exposes to the adversary
functionality that could otherwise be executed only by honest parties with
private knowledge -- knowledge that would make the adversary capable of
trivially breaking the security properties formalized in the experiments.
In the game-based definitions of our \UAS model, we leverage the following
oracles, which are formally defined in \figref{fig:oracles1} and
\figref{fig:oracles2}. 

\begin{description}
\item[\IGEN.] Adds a new issuer to the game, generating its keypair and setting
  the associated issuance function.
\item[\OGEN.] Adds a new inspector to the game, generating its key pair and
  setting the associated evaluation and inspection functions.
\item[\ICORR.] Corrupts an existing (and honest) issuer, by giving its secret
  key to the adversary.
\item[\OCORR.] Corrupts an existing (and honest) inspector, by giving its secret
  key to the adversary.  
\item[\HUGEN.] Adds a new honest user to the game, by honestly generating
  the user's key pair.
\item[\CUGEN.] Adds a new corrupt user to the game or, if the specified
  user already exists and is honest, corrupts it.
\item[\OBTISS.] Lets the adversary add a new honestly generated credential to
  the game, on behalf of an honest user.
\item[\OBTAIN.] Enables the adversary to play the role of a dishonest issuer
  in games that support it, by letting it interact with honest users who want to
  receive credentials.
\item[\ISSUE.] Allows the adversary to play the role of dishonest users,
  requesting an honest issuer to produce credentials for them.
\item[\SIGN.] Lets the adversary get signatures from credentials belonging
  to honest users.
\item[\OPEN.] Given an honestly produced signature, lets the adversary learn
  which credential was used to produce it.
\item[\CHALb.] Upon receiving two challenge credentials, a common intersecting
  set of attributes, and a message, returns a signature produced by one of these
  two credentials, defined by the bit $b$, which is established in the anonymity
  game.
\end{description}

{%\setlength\intextsep{\sep}
  \begin{figure*}[htp!]
    \centering
    \scalebox{0.9}{

      \begin{minipage}[t]{0.55\textwidth}

        \procedure{$\IGEN(\gid,\fissue)$}{%
          \pcif \gid \in \HI \lor \gid \in \CI: \pcreturn \bot \\
          (\ipk,\isk) \gets \IKeyGen(\parm) \\
          \IK[\gid] \gets ((\ipk,\fissue),\isk) \\
          \HI \gets \HI \cup \lbrace \gid \rbrace \\
          \GK[\gid] \gets ((\ipk,\fissue),\cdot) \\
          \pcreturn \ipk \\
        }

        \procedure{$\ICORR(\gid)$}{%
          \pcif \gid \in \CI \lor \gid \notin \HI: \pcreturn \bot \\
          \HI \gets \HI \setminus \lbrace \gid \rbrace \\
          \CI \gets \CI \cup \lbrace \gid \rbrace \\
          \pcreturn \isk \\
        }        

        \procedure{$\HUGEN(\uid)$}{%
          \pcif \uid \in \HU \lor \uid \in \CU: \pcreturn \bot \\
          (\upk,\usk) \gets \UKeyGen(\parm) \\
          \UK[\uid] \gets (\upk,\usk);
          \HU \gets \HU \cup \lbrace  \uid \rbrace \\
          \pcreturn \top
        }        
        
      \end{minipage}
    }
    \scalebox{0.9}{
      
      \begin{minipage}[t]{.5\textwidth}

        \procedure{$\OGEN(\gid,\feval,\finsp)$}{%
          \pcif \gid \in \HO \lor \gid \in \CO: \pcreturn \bot \\
          (\opk,\osk) \gets \OKeyGen(\parm) \\
          \OK[\gid] \gets ((\opk,\finsp),\osk) \\
          \HO \gets \HO \cup \lbrace \gid \rbrace \\
          \GK[\gid] \gets (\cdot,(\opk,\finsp)) \\
          \pcreturn \opk \\
        }

        \procedure{$\OCORR(\gid)$}{%
          \pcif \gid \in \CO \lor \gid \notin \HO: \pcreturn \bot \\
          \HO \gets \HO \setminus \lbrace \gid \rbrace \\
          \CO \gets \CO \cup \lbrace \gid \rbrace \\
          \pcreturn \osk \\
        }        
        
        \procedure{$\CUGEN(\uid,\upk)$}{%          
          \pcif \uid \in \CU: \pcreturn \bot \\
          \CU \gets \CU \cup \lbrace \uid \rbrace \\          
          \pcif \uid \in \HU: \\
          \pcind \HU \gets \HU \setminus \lbrace \uid \rbrace; \\
          \pcind \pcreturn (\UK[\uid],\CRED[\uid]) \\
          \pcelse: \UK[\uid] = (\upk,\bot) \\          
          \pcreturn \top
        }
        
      \end{minipage}
      
    }

    \caption{Detailed oracles available in our model (1/2). Oracles for
      generating key material for users, issuers, and inspectors.}
    \label{fig:oracles1}
  \end{figure*}
}

{%\setlength\intextsep{\sep}
  \begin{figure*}[htp!]
    \centering
    \scalebox{0.9}{

      \begin{minipage}[t]{0.55\textwidth}

        \procedure{$\ISSUE(\cid,\uid,\gid,\attrs,\ldblbrace\scid\rdblbrace)$}{%
          \pcif \uid \notin \CU: \pcreturn \bot \\
          \pcif \gid \notin \HI: \pcreturn \bot \\
          \pcif \exists \gid' \in \sgid~\st~\gid' \notin \HI: \pcreturn \bot \\
          \pcif \exists \cid' \in \scid~\st~\CRED[\cid'] \neq \bot: \pcreturn \bot \\
          \langle \cdot, \utrans \rangle \gets
          \langle \adv, \\
          \hspace*{45pt}
          \Issue(\PRVIK[\gid],\PUBUK[\uid], \attrs,
          \ldblbrace \GK[\sgid] \rdblbrace) \rangle \\
          \trans[\cid] \gets \utrans;~\GRP[\cid] \gets \gid \\
          \OWNR[\cid] \gets \uid;~\ATTR[\cid] \gets (\scid, \attrs) \\
          \pcreturn \top \\          
        }                

        \procedure{$\OBTAIN(\cid,\uid,\gid,\attrs,\ldblbrace\scid\rdblbrace)$}{%
          \pcif \uid \notin \HU: \pcreturn \bot \\
          \pcif \exists \cid' \in \scid~\st~\CRED[\cid'] \neq \bot: \pcreturn \bot \\
          \langle \cred, \cdot \rangle \gets
          \langle \Obtain(\PRVUK[\uid],\attrs, 
          \ldblbrace \CRED[\scid] \rdblbrace), \\
          \hspace*{50pt} \adv \rangle \\
          \CRED[\cid] \gets \cred;~\GRP[\cid] \gets \gid \\
          \OWNR[\cid] \gets \uid;~\ATTR[\cid] \gets (\scid, \attrs) \\
          \pcreturn \top \\
        }

        \procedure{$\INSPECT(\gid,\sig,\msg)$}{%
          \textrm{Let}~\uid~\textrm{be s.t.}~(\sig,\msg,\scid,\uattrs,\dattrs,\sgid)
          \in \SIG[\uid] \\
          \pcif \sig \in \CSIG: \pcreturn \bot \\
          (\y,\oproof) \gets
          \Inspect(\PRVOK[\gid],\trans,\sig,\msg,\dattrs,\GK[\sgid]) \\
          \pcreturn (\y,\oproof)
        }
        
      \end{minipage}
    }
    \scalebox{0.9}{
      
      \begin{minipage}[t]{.5\textwidth}

        \procedure{$\OBTISS(\cid,\uid,\gid,\attrs,\ldblbrace\scid\rdblbrace)$}{%
          \pcif \uid \notin \HU: \pcreturn \bot \\
          \pcif \gid \notin \HI: \pcreturn \bot \\
          \pcif \exists \gid' \in \sgid~\st~\gid' \notin \HI: \pcreturn \bot \\
          \pcif \exists \cid' \in \scid~\st~\CRED[\cid'] \neq \bot:
          \pcreturn \bot \\
          \langle \cred, \utrans \rangle \gets
          \langle \Obtain(\PRVUK[\uid],\attrs,
          \ldblbrace \CRED[\scid] \rdblbrace), \\
          \hspace*{60pt} \Issue(\PRVIK[\gid],\PUBUK[\uid],\attrs,
          \ldblbrace \GK[\sgid] \rdblbrace ) \rangle \\
          \trans[\cid] \gets \utrans;~\CRED[\cid] \gets \cred \\
          \OWNR[\cid] \gets \uid;~\ATTR[\cid] \gets (\scid,\attrs) \\
          \GRP[\cid] \gets \gid \\
          \pcreturn \top \\
        }


        \procedure{$\SIGN(\uid,\msg,\feval,\ldblbrace\scid\rdblbrace )$}{%
          \pcif \uid \notin \HU: \pcreturn \bot \\
          \cred \gets \CRED[\cid] \\
          \sig \gets \Sign(\PRVUK[\uid],\msg,\ldblbrace\CRED[\scid]\rdblbrace) \\
          \SIG[\uid] \gets \SIG[\uid] \cup
          \lbrace (\sig,\msg,\feval,\scid) \rbrace \\
          \pcreturn \sig \\
        }                

        \procedure{$\CHALb(\uid_{0,1},\msg,\feval,
          \ldblbrace (\cscid_{0,1},\sgid) \rdblbrace))$}{%          
          \pcif \cuid_0 \notin \HU \lor \cuid_1 \notin \HU: \pcreturn \bot \\
          \pcif \exists \gid \in \sgid~\st~\gid \in \CO: \pcreturn \bot \\
          \pcif \feval(\PUBUK[\uid_0],\CRED[\scid_0],\msg) \neq \\
          \pcind \feval(\PUBUK[\uid_1],\CRED[\scid_1],\msg):
          \pcreturn \bot \\
          \csig \gets \Sign(\PRVUK[\uid_b],\msg,\feval, \\
          \hspace*{42pt}
          \ldblbrace (\GK[\sgid],\CRED[\scid_b]) \rdblbrace) \\
          \CSIG \gets \CSIG \cup
          \lbrace (\csig,\msg,\feval,\cscid_b,\sgid) \rbrace \\
          \pcreturn \csig
        }
        
      \end{minipage}
      
    }

    \caption{Detailed oracles available in our model (2/2). Oracles for
      obtaining credentials, signatures, and processing them.}
    \label{fig:oracles2}
  \end{figure*}
}

\paragraph{Correctness.} %
Correctness of \UAS schemes is formalized through the experiment in
\figref{fig:exp-uas-corr}. It states that a signature for some message \msg,
revealing attributes \dattrs, which was honestly produced through a (set of)
credentials obtained by an honest user interacting with honest issuer(s), with a
set of attributes \attrs such that $\dattrs \subseteq \attrs$, must be accepted
by \Verify. Moreover, an honestly produced correctness proof of opening for such
signature, revealing the public key pair of the user, must also be accepted by
\Judge.

\begin{figure}[htp!]
  \procedure{$\ExpCorrect(1^\secpar)$}{%
    \parm \gets \Setup(1^\secpar) \\
    (\uid,\msg,\feval,\ldblbrace \scid \rdblbrace)
    \gets \adv^{\IGEN,\OGEN,\HUGEN,\OBTISS}(\parm) \\
    \sig \gets \Sign(\PRVUK[\uid],\msg,\feval,
    \ldblbrace \CRED[\scid] \rdblbrace ) \\
    \pcif \Verify(\sig,\msg,\GK[\sgid]) = 0: \pcreturn 1~
    \pccomment{\sig fails to verify} \\
    \pcif \CorrectIssue(\uid,\ldblbrace \scid \rdblbrace)
    = 0: \pcreturn 1~
    \pccomment{Some \cid should not have been issued} \\
    \pcif \CorrectEval(\uid,\msg,\feval,\ldblbrace \scid \rdblbrace)
    = 0: \pcreturn 1~
    \pccomment{\msg should not have been signed}\\
    \pcif \CorrectInspect(\uid,\msg,\ldblbrace \scid \rdblbrace,
    \sig) = 0: \pcreturn 1~
    \pccomment{Some inspection of \sig is invalid}\\
    \pcreturn 0 \\
  }

  \procedure{$\CorrectIssue(\uid,\ldblbrace \scid \rdblbrace)$}{
    \forall \cid \in \scid~\textrm{parse}~\ATTR[\cid]~\textrm{as}~
    (\scid^\cid,\attrs^\cid) \\
    \forall \gid \in \GRP[\scid]~\textrm{parse}~\GK[\gid]~\textrm{as}~
    ((\cdot,\fissue^\gid),\cdot) \\        
    \pcif \exists \cid \in \scid, \gid \in \GRP[\scid]~\st~
    \fissue^\gid(\PUBUK[\uid],\attrs^\cid,\CRED[\scid]^\cid) = 0: 
    \pcreturn 0 \\
    \pcreturn 1 \\   
  }

  \procedure{$\CorrectEval(\uid,\msg,\feval,\ldblbrace \scid \rdblbrace)$}{
    \pcif \feval(\PUBUK[\uid],\CRED[\scid],\msg) = 0: \pcreturn 0 \\
    \pcreturn 1 \\
  }

  \procedure{$\CorrectInspect(\uid,\msg,\ldblbrace \scid \rdblbrace, \sig)$}{
    \textrm{Let}~\sgid \gets \GRP[\scid];~
    \forall \gid \in \sgid~\textrm{parse}~\GK[\sgid]~\textrm{as}~
    (\cdot,(\cdot,\finsp^\gid)) \\
    \pccomment{\sig cannot be inspected by a suitable inspector} \\
    \pcif \exists \gid \in \sgid~\st~
    \Inspect(\PRVOK[\gid],\trans,\sig,\msg,\GK[\sgid]) = \bot: \pcreturn 0 \\
    \pccomment{An $(\y,\iproof)$ pair is rejected by \Judge
      % \todo{This must be conditioned on \feval = 0!}
    } \\
    \pcif \exists \gid \in \sgid~\st~
    (\y,\iproof) \gets \Inspect(\PRVOK[\gid],\trans,\sig,\msg,\GK[\sgid]) \land \\
    \pcind
    \Judge(\y,\iproof,\sig,\msg,\GK[\sgid]) = 0):
    \pcreturn 0 \\
    \pccomment{\y is the wrong value for some $\finsp^\gid$} \\
    \pcif \exists \gid \in \sgid~\st~
    \y \neq \finsp^\gid(\PUBUK[\uid],\CRED[\scid],\msg,\sig)): \pcreturn 0 \\
  }
  
  \caption{Correctness experiment for \UAS schemes.}
  \label{fig:exp-uas-corr}
\end{figure}

\subsection{Security Properties}
\label{ssec:security}

\paragraph{Anonymity.} %
In group signatures, anonymity captures that no adversary must be able to learn,
from any group signature, the identity (e.g., member index) of its signer. In 
anonymous credentials, it requires that no adversary should learn anything about
the holder of a successfully shown credential, beyond that he owns a credential
attesting for the claimed function of the attributes it contains. In both GS and
AC, it is also typically required that
multiple signatures/presentations by the users are unlinkable. The approach to
formally state this property is in both cases frequently the same: the adversary
picks two (honest) users (or credentials in the AC case), the game randomly
chooses one of them, and lets the adversary request challenge
signatures/presentations from it. The adversary wins if it succeeds in guessing
which was the chosen user/credential better than guessing at random. In group
signatures, the game must also restrict the adversary from opening challenge
signatures. In anonymous credentials, the game must further constraint the
adversary to output credentials that have some common function of (a subset of)
its attributes.

In our notion of anonymity for \UAS, we need to merge the previous constraints.
Furthermore, a key difference with group signatures is that the game requires
the adversary to output credential identifiers, rather than user identifiers.
Specifically, this means that the adversary may actually output two credentials
that belong to the same user. Therefore, in some sense, the anonymity we get is
more general than that of group signatures. Moreover, in order to prevent
trivial wins by the adversary, we have to restrict that the challenge signatures
belong to a group that has been ``programmed'' with the same evaluation and
inspection functions, which is again a generalization over group signatures,
as discussed in the sequel. The formal specification of the anonymity game is
given in \figref{fig:exp-uas-anonb}, where $\Oanonc \gets (\lbrace\HU,\CU\rbrace
\GEN,\lbrace\II,\OO\rbrace\GEN,\lbrace\II,\OO\rbrace\CORR,\OBTAIN,\SIGN,
\INSPECT)$ and $\Oanong \gets (\lbrace\HU,\CU\rbrace\GEN,\lbrace\II,\OO\rbrace
\GEN,\lbrace\II,\OO\rbrace,\CORR,\OBTAIN,\SIGN,\INSPECT,\CHALb)$

\begin{figure}[htp!]
  \procedure{$\ExpAnonb(1^\secpar)$}{%
     \parm \gets \Setup(1^\secpar) \\
     (\cscid_0,\cscid_1,\status) \gets \adv^{\Oanonc}(\choose,\parm) \\
     b^* \gets \adv^{\Oanong} (\guess,\status) \\
     \pcreturn b^*
  }
  \caption{Anonymity experiment for \UAS schemes.}
  \label{fig:exp-uas-anonb}
\end{figure}

\begin{definition}{(Anonymity of \UAS)}
  We define the advantage \AdvAnon of $\adv$ against \ExpAnonb as
  $\AdvAnon=|\Pr\lbrack\ExpAnono(1^\secpar)=1\rbrack-
  \Pr\lbrack\ExpAnonz(1^\secpar)=1\rbrack|$.
  %
  An \UAS scheme satisfies anonymity if, for any p.p.t. adversary $\adv$,
  \AdvAnon is a negligible function of $1^\secpar$.
\end{definition}

\paragraph{Discussion on the generality of anonymity in \UAS schemes.} %
This notion of anonymity is more general than that of group signatures in the
sense that calls to the \INSPECT oracle reveal an arbitrary function of the
identity of the user -- which can certainly be the member index itself, as it
is frequent in group signatures, ore any other function computable from the
user public key, its credentials, and produced signature. \todo{Delve more in
  this.}

\paragraph{Traceability.} %
Traceability is one of the unforgeability-related properties in group
signatures. It captures that any signature accepted by \Verify needs to open
to one of the users that joined the group. While there is no traceability notion
in anonymous credentials, it is natural to map it to their unforgeability
property; if only because both require the issuer to be honest. Unforgeability
in anonymous credentials typically ensures that no adversary can get a verifier
to accept a credential presentation requiring a set of attributes that is not
contained in one of the credentials controlled by the adversary.

Our notion of traceability for \UAS is inspired by both. First, we restrict to
signatures that are accepted by \Verify. For any such signature, \Inspect has to
create a valid output (i.e., must not abort). The output of \Inspect has to be
accepted by \Judge too. Moreover, there must exist one user (either honest or
corrupt) who used his public key to obtain one or more credentials that allowed
him to produce a signature which, once inspected, returns \y. The formal
definition of the traceability experiment is given in \figref{fig:exp-uas-trace},
where $\Otrace \gets \lbrace\HU,\CU\rbrace\GEN,\IGEN,\OGEN,\OCORR,\OBTISS,
\ISSUE,\SIGN,\INSPECT$.

\begin{figure}[htp!]
%  \begin{minipage}[t]{\textwidth}
    \procedure{$\ExpTrace(1^\secpar)$}{%
      \parm \gets \Setup(1^\secpar) \\
      (\sig,\dattrs,\msg,\sgid) \gets
      \adv^{\Otrace}(\parm) \\
      \pcreturn 1~\pcif: \\
      \pcind \Verify(\sig,\msg,\dattrs,\GK[\sgid]) = 1~\land~(
      \IssueForge(\sig,\msg,\dattrs,\sgid) = 1~\lor \\
      \pcind \pcind \EvalForge(\sig,\msg,\dattrs,\sgid) = 1~\lor~
      \InspectForge(\sig,\msg,\dattrs,\sgid) = 1) \\
      \pcreturn 0 \\
    }
    
  % \end{minipage}
  % \begin{minipage}[t]{0.5\textwidth}
    \procedure{$\IssueForge(\sig,\msg,\dattrs,\sgid)$}{%
      \pcif \exists \uid~\st~\Identify(\uid,\sig) = 1 \land
      \fissue(\PUBUK[\uid],\attrs,\CRED[\uid]) = 0 \\
      \pcind \pcreturn 1 \\
      \pcelse \pcreturn 0 \\
    }
    
    \procedure{$\EvalForge(\sig,\msg,\dattrs,\sgid)$}{%
      \pccomment{\todo{This assumes that there is no $\cred \in \CRED[\uid]$ \st~
          $\feval(\PUBUK[\uid],\CRED[\uid],\msg) = 0$, but}} \\
      \pccomment{\todo{$\feval(\PUBUK[\uid],\CRED[\uid]\setminus \cred,\msg) = 1$}} \\
      \pcif \exists \uid~\st~\Identify(\uid,\sig) = 1 \land
      \feval(\PUBUK[\uid],\CRED[\uid],\msg) = 0 \\
      \pcind \pcreturn 1 \\
      \pcelse \pcreturn 0 \\
    }
    
    \procedure{$\InspectForge(\sig,\msg,\dattrs,\sgid)$}{%
      \pcreturn 1~\pcif: \\
      \pcind \pccomment{All \Obtain transcripts fail to inspect \sig} \\
      \pcind \nexists \gid \in \sgid:
      \Inspect(\PRVOK[\gid],\trans,\sig,\msg,\dattrs,\sgid) \neq \bot~\lor \\
      \pcind \pccomment{A valid transcript exists, but ...} \\
      \pcind \exists\gid \in \sgid, \exists \uid~\st~
      \Inspect(\PRVOK[\gid],\trans[\uid],\sig,\msg,\dattrs) =
      (\y,\iproof)~\land (\\
      \pcind \pcind \pccomment{... the proof is rejected by \Judge ...} \\
      \pcind \pcind \Judge(\y,\iproof,\sig,\msg,\dattrs,\GK[\sgid]) = 0~\lor \\
      \pcind \pcind \pccomment{... or \Judge accepts the proof, but \Inspect
      returns an invalid value \y} \\
      \pcind \pcind \y = \finsp(\PUBUK[\uid],\CRED[\uid],\msg,\sig) \\
      \pcind ) \\      
      \pcreturn 0
    }
%  \end{minipage}      
  \caption{Traceability experiment for \UAS schemes.}
  \label{fig:exp-uas-trace}
\end{figure}

\begin{definition}{(Traceability of \UAS)}
  We define the advantage \AdvTrace of $\adv$ against \ExpTrace as
  $\AdvTrace=\Pr\lbrack\ExpTrace(1^\secpar)=1\rbrack$.
  %
  A \UAS scheme satisfies traceability if, for any p.p.t. adversary $\adv$,
  \AdvTrace is a negligible function of $1^\secpar$.
\end{definition}

\paragraph{Discussion on the generality of traceability in \UAS schemes.} %
Note that this notion of traceability is, again, strictly more general than
both group signatures and anonymous credentials. On the group signatures side,
it all depends on the \Inspect function. If we set it to the traditional
inspection function, where it returns the identity (index) of the signer, then
our notion of traceability becomes exactly that of conventional group
signatures. On the other hand, \Inspect may be set to a non-injective function,
meaning that it can be possible that different user public keys, credentials and
signature tuples, may produce the same output. In that case, though, our notion
of traceability ensures that there must exist \emph{at least one} user capable
of issuing that signature.
%
On the anonymous credentials side, note that our definition allows that users
combine multiple credentials in a ``presentation''. However, in anonymous
credentials, it is frequent to require that all the attributes proven in a
presentation must be contained in a single credential. Note though that our
definition requires all credentials to be tied to the same user identity.
Therefore, it is a natural extension as (in the real life), it is very frequent
to combine multiple identifying documents to prove that you are entitled to
something. Moreover, any specific instantiation that restricts signatures
to be associated to just one credential directly leads to the previously
mentioned ``one credential per presentation'' rule.

Finally, note that we can only ensure consistency of the value returned by
\finsp, for all users, as long as the issuer is honest. This follows from the
fact that \finsp depends on the user key pair and the credentials that are
issued to each user. Therefore, a dishonest issuer could create untraceable
credentials (i.e., issue credentials without updating the \trans table), so that
the \finsp function outputs whatever desired value, yet it cannot be traced to
any registered user. That is, this minimality argument is just a generalization
of the one described in \cite[Section 4.3]{bsz05}. This is also consistent with
the unforgeability requirement of anonymous credentials systems, as a corrupt
issuer can grant arbitrary credentials to any user, and therefore honest
issuers are required.

\paragraph{Non-frameability.} %
Non-frameability variants are a core unforgeability-type property in group
signatures. However, no
similar property is modeled for anonymous credentials (\todo{see the discussion
  in \secref{sec:introduction} for further detail}). It is a quite strong
property, as it must be ensured even in the presence of dishonest issuer and
opener. Intuitively, it prevents the adversary from creating a signature that
frames an honest user. Depending on the inspection capabilities of the scheme,
this framing could be done in different ways; i.e., by convincing third parties
that signatures by different (possibly corrupt) users are linked, or directly
by having open proofs output the identity of a user who did not create the
signature being opened.
%
In \UAS schemes, in order for a user to be framed \todo{...}. The
non-frameability property for \UAS schemes is formally defined in
\figref{fig:exp-uas-frame}, where $\Oframe \gets \lbrace\HU,\CU\rbrace\GEN,
\lbrace\II,\OO\rbrace\GEN,\lbrace\II,\OO\rbrace\CORR,\OBTAIN,\SIGN$

\begin{figure}[htp!]
  \procedure{$\ExpNonframe(1^\secpar)$}{%
    \parm \gets \Setup(1^\secpar) \\
     (\sig,\dattrs,\msg,\sgid,\y,\iproof) \gets
     \adv^{\Oframe}(\parm) \\
     \pcreturn 1~\pcif \Verify(\sig,\msg,\dattrs,\GK[\sgid]) = 1 \land
     \Judge(\y,\iproof,\sig,\msg,\dattrs,\GK[\sgid]) = 1~\land \\
     \pcind \exists \uid \in \HU~\st~\Identify(\PRVUK[\uid],\sig) = 1 \land
     \sig \notin \SIG[\uid] \\
     \pcreturn 0
  }
  \caption{Non-frameability experiment for \UAS schemes.}
  \label{fig:exp-uas-frame}
\end{figure}

\begin{definition}{(Non-frameability of \GSAC)}
  We define the advantage \AdvNonframe of $\adv$ against \ExpNonframe as
  $\AdvNonframe=\Pr\lbrack\ExpNonframe(1^\secpar)=1\rbrack$.
  %
  A \GSAC scheme satisfies non-frameability if, for any p.p.t. adversary $\adv$,
  \AdvNonframe is a negligible function of $1^\secpar$.
\end{definition}

\paragraph{Discussion.} %
\todo{Argue that our properties cover (and augment) a direct combination
  (even if possible) of their GS and AC counterparts. Specifically, anonymity
  of \GSAC is stronger than anonymity in GS and AC, and the same for trace and
  non-frame.}

\todo{It would be nice to prove that a \GSAC scheme to which we remove the
  \Open/\Judge functions becomes an AC scheme. And conversely, a \GSAC scheme
  where all credentials have no attributes, and where we restrict to only
  one credential per user, becomes a conventional GS scheme.}

\subsection{Transformation to Interactive Presentations}
\label{ssec:interactivetransform}

\todo{Is it possible to give it in some generic sense?}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "gsac"
%%% End:
