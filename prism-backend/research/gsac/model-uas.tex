\section{Model for \UAS Schemes}
\label{sec:model-uas}

We now define our model for Universal Anonymous Signatures. At a very high
level, it is a combination of the main models for group signatures and
anonymous credentials -- we try to extract the most useful features from both.
Instead of considering just one group, as in group signatures, we directly and
explicitly include support for multiple issuers as in anonymous credentials.
Moreover, instead of letting each user own a single credential, we allow
multiple credentials per user, even within the same group. This of course
makes us put forward refined notions of anonymity, traceability and
non-frameability. Note that, property-wise, we keep the three main properties
from group signatures, rather than sticking to the two usual properties of
anonymous credentials (anonymity and unforgeability). This is a consequence
of keeping the inspection capability from group signatures, which we consider
crucial in order to ensure some sort of accountability even in very adversarial
contexts where the issuer may be corrupt.
%
But, as stated in the introduction, we go beyond just combining anonymous
credentials and group signatures, and include support for arbitrary policies
during issuance, signing, and inspection. Consequently, our model needs to
capture the flexibility that these policies provide. In short, manipulations of
the issuance policy are only considered forgeries if the adversary manages to
create a valid signature using a credential that was obtained by dishonestly
manipulating the issuance policy (we discuss this further in the traceability
definition). Signing policies are taken into account both in the anonymity
property, where we need to restrict that both credentials used to produce the
challenge signatures always satisfy the policy, and in traceability.
\commentwho{Jesus}{Think a bit more about the following claim, and update if
  needed.}
We cannot give any assurance on the signing policies when the issuers are
corrupt, and thus they are not considered in the non-frameability property.
Inspection policies are considered both in traceability and non-frameability,
where the adversary wins if it manages to somehow alter the correct output of
\Inspect. What is even suprising, is that given the possible non-injectivity of
the inspection function lets us reach an even stronger notion of anonymity.
Namely, \uline{we can allow the adversary to open challenge signatures, as
  long as the inspection function outputs the same value for both}. We give more
details on these aspects in the actual definitions of the security properties.
%
Finally, from a functional perspective, we require that both issuer and
inspector fix the issuance predicate \fissue and inspection function \finsp when
generating their public keys. Indeed, both will be part of the common group key.
This also makes our definitions easier, as supporting multiple issuance
predicate and inspection functions per group would require to consider many
special cases -- and, anyway, that would probably end up being equivalent to
just requiring that a new group needs to be created per each $(\fissue,\finsp)$
pair. On the other hand, signing policies can be defined at signing time (in
practice, most probably by the verifiers). This is in line with the usual
practice in anonymous credentials, that let users prove arbitrary claims on
their credentials, as long as they are met by the contained attributes.

\subsection{Syntax}
\label{ssec:syntax}

In the following, we assume a setting with multiple groups. For simplicity,
we assume that each has its own issuer and inspector.

\todo{Are generalizations where different groups can share issuer or inspector
  straight forward?}

\todo{The notation for multisets is not strictly correct. Still, leaving it as
  is for now.} 

\begin{description}
\item[$\parm \gets \Setup(\secpar)$.] Given a security parameter \secpar,
  returns a global system parameter variable \parm.
\item[$(\ipk,\isk) \gets \IKeyGen(\parm,\fissue)$.] Given global system
  parameters \parm, and the function \fissue to be used to check that credential
  requestors meet the conditions to be issued a credential, an issuer runs
  \IKeyGen to generate its issuing key pair. Hereafter, we assume that the
  public part \ipk is added to the group public key \gpk, as well as \fissue.
\item[$(\opk,\osk) \gets \OKeyGen(\parm,\finsp)$.] Given global system
  parameters \parm, and function \finsp, an inspector runs \OKeyGen to generate
  its inspecting key pair. The function \finsp defines the type of utility that
  will be extractable from those pairs that do not meet conditions defined
  at signing time (typically, by verifiers). Hereafter, we assume that the
  public part \opk is added to the group public key \gpk, along with \finsp.
\item[$(\upk,\usk) \gets \UKeyGen(\parm)$.] Given global system parameters
  \parm, returns a user's key pair.
\item[$\langle \cred/\bot,\utrans/\bot \rangle \gets
  \langle
  \Obtain(\usk,\attrs,\ldblbrace (gpk_i,\cred_i)\rdblbrace_{i \in \Issuers}),
  \Issue(\isk,\upk,\attrs,\ldblbrace \gpk_i) \rdblbrace_{i \in \Issuers})
  \rangle$.] %
  This interactive protocol lets a user with key pair (\upk,\usk) running the
  \Obtain process, obtain a credential \cred from an issuer in the system, on
  attribute set $\attrs$ plus, possibly, blinded attributes attested by
  previously obtained credentials $\cred_i$, from a multiset of other issuers
  (which may include the one to whom a new credential is being requested) with
  public keys $\gpk_i$. The user outputs the produced credential \cred, while
  the issuer outputs the protocol transcript \utrans for the produced
  credential. To ease notation, we assume that the group to which each
  credential belongs is available from the credential itself, and therefore
  omit the $\gpk_i$ values from the syntax, unless necessary to avoid ambiguity.
\item[$\sig \gets \Sign(\gpk,\usk,\cred,\msg,\feval)$.]
  The user with with secret key \usk and credential \cred, produces a signature
  \sig over message \msg, meeting the conditions defined by \feval.
\item[$1/0 \gets \Verify(\gpk,\sig,\msg,\feval)$.] Checks whether \sig is a
  valid signature, over message \msg, from a user in the group with public key
  \gpk, for signing function \feval.
\item[$(\y,\iproof)/\bot \gets \Inspect(\gpk,\osk,\trans,\sig,\msg,\feval)$.] %
  Executed by the inspector with private key \osk. Receives a signature \sig
  over message \msg and evaluation function \feval. If \trans contains a set of
  valid transcripts corresponding
  to the $\langle\Obtain,\Issue\rangle$ interactive protocol execution that
  issued the credential used to produce \sig, the function outputs a value $\y$
  derived from the signer's public key, credential, message, and signature, as
  well as a proof of correct inspection. We sometimes abuse notation, and write
  $\trans[\uid]$ to mean that the \Inspect function is operating only for the
  obtain transcripts related to user \uid.
\item[$1/0 \gets \Judge(\gpk,\y,\iproof,\sig,\msg,\feval)$.] %
  Checks if \iproof is a valid inspection correctness proof for the value \y,
  obtained by applying \Inspect to the the signature \sig over message \msg. 
\end{description}

The correctness and security properties are defined with the help of the
following sets of oracles, and global variables that help oracles and games
keep consistent state.

\paragraph{Issuance, evaluation, and inspection functions.} %
We emphasize that, both in our syntax definition, as well as on the following
modelling, we make use of three different and abstract functions: \fissue,
\feval and \finsp. The three functions are introduced to allow customized
governance of the resulting instantiation of an \UAS scheme. They will be
defined by different parties, but in all cases, they are run by users (maybe,
on user-private data). Also, in all cases, the user has to prove correctness of
their computation. We introduce them next, \todo{and will give concrete examples
  in \secref{sec:uac-instantiation}.}

\begin{description}
\item[$\fissue: (\upk, \attrs,\scred) \rightarrow 0/1$.] Defined by issuers,
  governs what customized conditions an issuer requires in order to issue
  credentials, when receiving a request from user with public key \upk, for
  attributes \attrs. \fissue may run checks on a (possibly empty) set of
  additional credentials \scred, which may further be used for blind issuance
  \commentwho{Jesus}{can it?}. \fissue returns $1$ to accept a request, $0$ to
  reject it.  
\item[$\feval: (\upk,\cred,\msg) \rightarrow \varrngfeval$.] Can be defined by any
  party, although we anticipate that this will typically be done by either
  signers, verifiers, or some governance organization. It defines customized
  conditions to be met by the owner of a user key \upk and credential \cred,
  in order to sign a concrete message \msg. Its outputs  $\varrngfeval$ must
  belong in a well defined set \rngfeval, with the restriction that it must
  return $0$ when the conditions for signing are not met.
\item[$\finsp: (\varrngfeval,\upk,\cred,\msg) \rightarrow \varrngfinsp$.]
  Defines what utility value, derived from the user's public key, credential,
  and message should be extractable by the group inspector. Note that \finsp
  also receives as input a value in the range of the \feval function, \rngfeval.
  This will allow inspection logic to depend on the value produced by the
  evaluation function. The output of \finsp is a value \varrngfinsp, which must
  belong in a well defined set \rngfinsp.
\end{description}

\paragraph{Helper Function \Identify.} In addition, we make use of a helper
function \Identify for some of our definitions. This function receives
a signature and a user secret key, and determines whether the latter was used
to produce the former. This is in line with previous works on DAA
\cite{bfg+11,cdl16} and group signatures without traditional open functions
\cite{dl21,fgl21,gl19}. More concretely, the \Identify function, defined as $1/0
\gets \Identify(\usk,\sig)$, conveys meaning to our definitions conditioned on
the fact that, given a signature \sig accepted by \Verify, \Identify returns $1$
for exactly one \usk.

\paragraph{Global Variables.} %
The environment manages several global variables in the games posed to the
adversary. Users are referred to with user identifiers, \uid; for credentials,
we use \cid; for groups, \gid. For credentials and groups, we use bold font to
denote sets: i.e., \scid and \sgid denote sets of credential and group
identifiers. All tables/sets are initialized as empty tables/sets, denoted
with $\emptyset$.

\begin{description}
\item[Tables for parties]:
  \begin{description}
  \item[\HU and \CU.] Keep track of honest (\HU) and corrupted (\CU) users;
    i.e., they are sets of {\uid}s.
  \item[\HI and \CI.] Keep track of honest (\HI) and corrupted (\CI) issuers.
    Since we assume only one issuer per group, they are sets of {\gid}s.
  \item[\HO and \CO.] Keep track of honest (\HO) and corrupted (\CO) inspectors.
    Since we assume only one inspector per group, they are sets of {\gid}s.
  \end{description}
\item[Tables for keys]:
  \begin{description}
  \item[\UK, \PUBUK and \PRVUK.] \UK maintains user key pairs $(\upk,\usk)$.
    To refer to the key pair of a specific user, we use $\UK[\uid]$. \PUBUK
    is a shorthand to refer to the public part, and \PRVUK refers to the
    private part -- we may also index both by \uid.
  \item[\IK, \PUBIK and \PRVIK.] Same as \UK, but for issuer key pairs. In
    addition, \IK also includes the \fissue function, which is part of the
    public key.
  \item[\OK, \PUBOK, \PRVOK.] Same as \UK, but for inspector key pairs. In
    addition, \OK also includes the \finsp function, which is part of the
    public key.
  \item[\GK.] We bundle public keys for issuers and inspectors into a common
    public key for each group. We use the table \GK for that purpose which,
    consequently, can also be indexed by \gid.
  \end{description}
\item[Tables for credentials-related data]:
  \begin{description}
  \item[\CRED.] Stores information related to credentials obtained by honest
    users. Thus, it is indexable by \cid. More specifically, it stores tuples of
    the form $(\uid,\cred,\gid,\attrs,\scid)$, where \uid is the identity of the
    owner of the credential, \cred (when available) is the credential itself,
    \gid is the identifier of the group to which the credential belongs, \attrs
    are the attributes included in \cred, and \scid are the identifiers of any
    additional credential that \uid used to request \cred.
  \item[\OWNR.] For notational convenience, when we write $\OWNR[\cid]$ we mean
    ``\uid such that $\CRED[\cid] = (\uid, \cdot, \cdot, \cdot, \cdot)$''.
  \item[\ATTR.] For notational convenience, when we write $\ATTR[\cid]$ we mean
    ``\attrs such that $\CRED[\cid] = (\cdot, \cdot, \cdot, \attrs, \cdot)$''.
  \item[\GRP.] For notational convenience, when we write $\GRP[\cid]$ we mean
    ``\gid such that $\CRED[\cid] = (\cdot, \gid, \cdot, \cdot, \cdot)$''.
  \end{description}
\item[Tables for signatures]:
  \begin{description}
  \item[\SIG.] Maintains signatures generated via the \SIGN oracle, on behalf
    of honest users.
  \item[\CSIG.] Maintains challenge signatures, generated via the \CHALb oracle,
    by one of the challenge users in the anonymity game.
  \end{description}
\end{description}

\paragraph{Oracles.} %
Oracles are the interface of the adversary with the corresponding games. In
other words: through these oracles, the game environment exposes to the adversary
functionality that could otherwise be executed only by honest parties with
private knowledge -- knowledge that would make the adversary capable of
trivially breaking the security properties formalized in the experiments.
In the game-based definitions of our \UAS model, we leverage the following
oracles, which are formally defined in \figref{fig:oracles1} and
\figref{fig:oracles2}. 

\begin{description}
\item[\IGEN.] Adds a new issuer to the game, generating its keypair and setting
  the associated issuance function.
\item[\OGEN.] Adds a new inspector to the game, generating its key pair and
  setting the associated evaluation and inspection functions.
\item[\ICORR.] Corrupts an existing (and honest) issuer, by giving its secret
  key to the adversary.
\item[\OCORR.] Corrupts an existing (and honest) inspector, by giving its secret
  key to the adversary.  
\item[\HUGEN.] Adds a new honest user to the game, by honestly generating
  the user's key pair.
\item[\CUGEN.] Adds a new corrupt user to the game or, if the specified
  user already exists and is honest, corrupts it.
\item[\OBTISS.] Lets the adversary add a new honestly generated credential to
  the game, on behalf of an honest user.
\item[\OBTAIN.] Enables the adversary to play the role of a dishonest issuer
  in games that support it, by letting it interact with honest users who want to
  receive credentials.
\item[\ISSUE.] Allows the adversary to play the role of dishonest users,
  requesting an honest issuer to produce credentials for them.
\item[\SIGN.] Lets the adversary get signatures from credentials belonging
  to honest users.
\item[\OPEN.] Given an honestly produced signature, lets the adversary learn
  which credential was used to produce it.
\item[\CHALb.] Upon receiving two challenge credentials, a common intersecting
  set of attributes, and a message, returns a signature produced by one of these
  two credentials, defined by the bit $b$, which is established in the anonymity
  game.
\end{description}

{%\setlength\intextsep{\sep}
  \begin{figure*}[htp!]
    \centering
    \scalebox{0.9}{

      \begin{minipage}[t]{0.55\textwidth}

        \procedure{$\IGEN(\gid,\fissue)$}{%
          \pcif \gid \in \HI \lor \gid \in \CI: \pcreturn \bot \\
          (\ipk,\isk) \gets \IKeyGen(\parm) \\
          \IK[\gid] \gets ((\ipk,\fissue),\isk) \\
          \HI \gets \HI \cup \lbrace \gid \rbrace \\
          \GK[\gid] \gets ((\ipk,\fissue),\cdot) \\
          \pcreturn \ipk \\
        }

        \procedure{$\ICORR(\gid)$}{%
          \pcif \gid \in \CI \lor \gid \notin \HI: \pcreturn \bot \\
          \HI \gets \HI \setminus \lbrace \gid \rbrace \\
          \CI \gets \CI \cup \lbrace \gid \rbrace \\
          \pcreturn \isk \\
        }        

        \procedure{$\HUGEN(\uid)$}{%
          \pcif \uid \in \HU \lor \uid \in \CU: \pcreturn \bot \\
          (\upk,\usk) \gets \UKeyGen(\parm) \\
          \UK[\uid] \gets (\upk,\usk);
          \HU \gets \HU \cup \lbrace  \uid \rbrace \\
          \pcreturn \top
        }        
        
      \end{minipage}
    }
    \scalebox{0.9}{
      
      \begin{minipage}[t]{.5\textwidth}

        \procedure{$\OGEN(\gid,\feval,\finsp)$}{%
          \pcif \gid \in \HO \lor \gid \in \CO: \pcreturn \bot \\
          (\opk,\osk) \gets \OKeyGen(\parm) \\
          \OK[\gid] \gets ((\opk,\finsp),\osk) \\
          \HO \gets \HO \cup \lbrace \gid \rbrace \\
          \GK[\gid] \gets (\cdot,(\opk,\finsp)) \\
          \pcreturn \opk \\
        }

        \procedure{$\OCORR(\gid)$}{%
          \pcif \gid \in \CO \lor \gid \notin \HO: \pcreturn \bot \\
          \HO \gets \HO \setminus \lbrace \gid \rbrace \\
          \CO \gets \CO \cup \lbrace \gid \rbrace \\
          \pcreturn \osk \\
        }        
        
        \procedure{$\CUGEN(\uid,\upk)$}{%          
          \pcif \uid \in \CU: \pcreturn \bot \\
          \CU \gets \CU \cup \lbrace \uid \rbrace \\          
          \pcif \uid \in \HU: \\
          \pcind \HU \gets \HU \setminus \lbrace \uid \rbrace; \\
          \pcind \pcreturn (\UK[\uid],\CRED[\uid]) \\
          \pcelse: \UK[\uid] = (\upk,\bot) \\          
          \pcreturn \top
        }
        
      \end{minipage}
      
    }

    \caption{Detailed oracles available in our model (1/2). Oracles for
      generating key material for users, issuers, and inspectors.}
    \label{fig:oracles1}
  \end{figure*}
}

{%\setlength\intextsep{\sep}
  \begin{figure*}[htp!]
    \centering
    \scalebox{0.9}{

      \begin{minipage}[t]{0.55\textwidth}

        \procedure{$\ISSUE(\cid,\uid,\gid,\attrs,\ldblbrace\scid\rdblbrace)$}{%
          \pcif \uid \notin \CU: \pcreturn \bot \\          
          \pcif \gid \notin \HI: \pcreturn \bot \\
          \pcif \exists \gid' \in \sgid~\st~\gid' \notin \HI: \pcreturn \bot \\
          \pcif \CRED[\cid] \neq \bot: \pcreturn \bot \\
          \langle \cdot, \utrans \rangle \gets
          \langle \adv, \\
          \hspace*{45pt}
          \Issue(\PRVIK[\gid],\PUBUK[\uid], \attrs,
          \ldblbrace \CRED[\scid] \rdblbrace) \rangle \\
          \trans[\cid] \gets \utrans \\
          \CRED[\cid] \gets (\uid, \cdot, \gid, \attrs, \scid) \\
          \pcreturn \top \\          
        }                

        \procedure{$\OBTAIN(\cid,\uid,\gid,\attrs,\ldblbrace\scid\rdblbrace)$}{%
          \pcif \uid \notin \HU: \pcreturn \bot \\
          \pcif \exists \cid' \in \scid~\st~\CRED[\cid'] \neq \bot: \pcreturn \bot \\
          \langle \cred, \cdot \rangle \gets
          \langle \Obtain(\PRVUK[\uid],\attrs, 
          \ldblbrace \CRED[\scid] \rdblbrace), \\
          \hspace*{50pt} \adv \rangle \\
          \CRED[\cid] \gets (\uid, \cdot, \gid, \attrs, \scid) \\          
          \pcreturn \top \\
        }

        \procedure{$\INSPECT(\gid,\sig,\msg)$}{%
          \textrm{Let}~\uid~\textrm{be s.t.}~(\cid,\sig,\msg,\feval)
          \in \SIG[\uid] \\
          (\y,\iproof) \gets
          \Inspect(\GK[\gid],\PRVOK[\gid],\trans,\sig,\msg,\feval) \\
          \pcif \CSIG[\sig] \neq \bot: \\
          \pcind \textrm{Parse $\CSIG[\sig]$ as $(\sig_{1-b},\msg,\feval)$} \\
          \pcind (\y_{1-b},\iproof_{1-b}) \gets
          \Inspect(\GK[\gid],\PRVOK[\gid],\\
          \hspace*{107pt} \trans,\sig_{1-b},\msg,\feval) \\
          \pcind \pcif \y_{1-b} \neq \y: \pcreturn \bot \\
          \pcreturn (\y,\iproof)
        }
        
      \end{minipage}
    }
    \scalebox{0.9}{
      
      \begin{minipage}[t]{.5\textwidth}

        \procedure{$\OBTISS(\cid,\uid,\gid,\attrs,\ldblbrace\scid\rdblbrace)$}{%
          \pcif \uid \notin \HU: \pcreturn \bot \\
          \pcif \gid \notin \HI: \pcreturn \bot \\
          \pcif \exists \gid' \in \sgid~\st~\gid' \notin \HI: \pcreturn \bot \\
          \pcif \exists \cid' \in \scid~\st~\CRED[\cid'] \neq \bot:
          \pcreturn \bot \\
          \langle \cred, \utrans \rangle \gets
          \langle \Obtain(\PRVUK[\uid],\attrs,
          \ldblbrace \CRED[\scid] \rdblbrace), \\
          \hspace*{60pt} \Issue(\PRVIK[\gid],\PUBUK[\uid],\attrs,
          \ldblbrace \CRED[\scid] \rdblbrace ) \rangle \\
          \trans[\cid] \gets \utrans \\
          \CRED[\cid] \gets (\uid, \cred, \gid, \attrs, \scid) \\
          \pcreturn \top \\
        }

        \procedure{$\SIGN(\uid,\cid,\msg,\feval)$}{%
          \pcif \uid \notin \HU \lor \CRED[\cid] = \bot: \pcreturn \bot \\
          \sig \gets \Sign(\GK[\GRP[\cid]],\PRVUK[\uid],\msg,\CRED[\cid],\feval) \\
          \SIG[\uid] \gets \SIG[\uid] \cup
          \lbrace (\cid,\sig,\msg,\feval) \rbrace \\
          \pcreturn \sig \\
        }                

        \procedure{$\CHALb(\cuid_{0,1},\ccid_{0,1},\msg,\feval)$}{%
          \pcif \cuid_0 \notin \HU \lor \cuid_1 \notin \HU: \pcreturn \bot \\
          \pcif \gid = \GRP[\ccid_0] \neq \GRP[\ccid_1]: \pcreturn \bot \\
          \pcif \gid \in \CO: \pcreturn \bot \\
          \pcif \feval(\PUBUK[\uid_0],\CRED[\scid_0],\msg) \neq \\
          \pcind \feval(\PUBUK[\uid_1],\CRED[\scid_1],\msg):
          \pcreturn \bot \\
          \csig_b \gets \Sign(\GK[\gid],\PRVUK[\cuid_b],\CRED[\ccid_b],
          \msg,\feval) \\
          \csig_{1-b} \gets \Sign(\GK[\gid],\PRVUK[\cuid_{1-b}],\CRED[\ccid_{1-b}],
          \msg,\feval) \\          
          \CSIG[\csig_b] \gets 
          \lbrace (\csig_{1-b},\msg,\feval) \rbrace \\
          \pcreturn \csig_b
        }
        
      \end{minipage}
      
    }

    \caption{Detailed oracles available in our model (2/2). Oracles for
      obtaining credentials, signatures, and processing them.}
    \label{fig:oracles2}
  \end{figure*}
}

\paragraph{Correctness.} %
Correctness of \UAS schemes is formalized through the experiment in
\figref{fig:exp-uas-corr}. It states that a signature over any arbitrary message
and valid function \feval \todo{Should we explicitly check \feval in the game?
  If so, how?},
produced honestly by an honest user \uid with credential \cid, is accepted by
\Verify. Moreover, upon issuance of the credential \cid, it must have met the
conditions set by \fissue. Similarly, the value returnd by \Inspect must be
accepted by \Judge, and must match the output of applying \finsp on \feval, the
credential, user key, and message.

\begin{figure}[htp!]
  \procedure{$\ExpCorrect(1^\secpar)$}{%
    \parm \gets \Setup(1^\secpar) \\
    (\uid,\cid,\msg,\feval)
    \gets \adv^{\IGEN,\OGEN,\HUGEN,\OBTISS}(\parm) \\
    \sig \gets \Sign(\GK[\cid],\PRVUK[\uid],\cid,\msg,\feval) \\
    \pcif \Verify(\GK[\cid],\sig,\msg,\feval) = 0: \pcreturn 1~
    \pccomment{\sig fails to verify} \\
    \pcif \CorrectIssue(\uid,\cid) = 0: \pcreturn 1~
    \pccomment{\cid should not have been issued} \\
    % \pcif \CorrectEval(\uid,\cid,\msg,\feval)
    % = 0: \pcreturn 1~
    % \pccomment{\msg should not have been signed} \\
    \pcif \CorrectEvalInspect(\uid,\cid,\msg,\sig,\feval) = 0: \pcreturn 1~
    \pccomment{The combination of evaluation and inspection is wrong} \\
    \pcreturn 0 \\
  }

  \procedure{$\CorrectIssue(\uid,\cid)$}{
    \gid \gets \GRP[\cid] \\
    \textrm{Parse}~\ATTR[\cid]~\textrm{as}~(\attrs^\cid,\scid^\cid);~
    \textrm{Parse}~\GK[\gid]~\textrm{as}~
    ((\cdot,\fissue^\gid),\cdot) \\        
    \pcif \fissue^\gid(\PUBUK[\uid],\attrs^\cid,\CRED[\scid]^\cid) = 0: 
    \pcreturn 0 \\
    \pcreturn 1 \\   
  }

  % \procedure{$\CorrectEval(\uid,\cid,\msg,\feval)$}{
  %   \pcif \feval(\PUBUK[\uid],\CRED[\cid],\msg) = 0: \pcreturn 0 \\
  %   \pcreturn 1 \\
  % }

  \procedure{$\CorrectEvalInspect(\uid,\cid,\msg,\sig,\feval)$}{
    \textrm{Let}~\gid \gets \GRP[\cid];~
    \textrm{Parse}~\GK[\gid]~\textrm{as}~(\cdot,(\cdot,\finsp^\gid)) \\
    \pccomment{\sig cannot be inspected} \\
    \pcif \Inspect(\GK[\gid],\PRVOK[\gid],\trans,\sig,\msg,\feval) = \bot: \pcreturn 0 \\
    \pccomment{The produced $(\y,\iproof)$ pair is rejected by \Judge
      % \todo{This must be conditioned on \feval = 0!}
    } \\
    \pcif (\y,\iproof) \gets \Inspect(\GK[\gid],\PRVOK[\gid],\trans,\sig,\msg,\feval)
    \land
    \Judge(\GK[\gid],\y,\iproof,\sig,\msg) = 0: \\
    \pcind \pcreturn 0 \\
    \pccomment{\y is the wrong value} \\
    \pcif \y \neq \finsp^\gid(\feval(\PUBUK[\uid],\CRED[\cid],\msg),
    \PUBUK[\uid],\CRED[\cid],\msg)):
    \pcreturn 0 \\
    \pcreturn 1
  }
  
  \caption{Correctness experiment for \UAS schemes.}
  \label{fig:exp-uas-corr}
\end{figure}

\subsection{Security Properties}
\label{ssec:security}

\paragraph{Anonymity.} %
In group signatures, anonymity captures that no adversary must be able to learn,
from any group signature, the identity (e.g., member index) of its signer. In 
anonymous credentials, it requires that no adversary should learn anything about
the holder of a successfully shown credential, beyond that he owns a credential
attesting for the claimed predicate of the attributes it contains. In both GS
and AC, it is also typically required that
multiple signatures/presentations by the users are unlinkable. The approach to
formally state this property is in both cases frequently the same: the adversary
picks two (honest) users (or credentials in the AC case), the game randomly
chooses one of them, and lets the adversary request challenge
signatures/presentations from it. The adversary wins if it succeeds in guessing
which was the chosen user/credential better than guessing at random. In group
signatures, the game must also restrict the adversary from opening challenge
signatures. In anonymous credentials, the game must further constraint the
adversary to output credentials that both meet the same (challenge) predicate
of their attributes.

In our notion of anonymity for \UAS, we need to merge the previous constraints.
Furthermore, a key difference with group signatures is that the game requires
the adversary to output credential identifiers, rather than user identifiers.
Specifically, this means that the adversary may actually output two credentials
that belong to the same user. Therefore, in some sense, the anonymity we get is
more general than that of group signatures. Moreover, in order to prevent
trivial wins by the adversary, we have to restrict that the challenge signatures
belong to a group that has been ``programmed'' with the same evaluation and
inspection functions, which is again a generalization over group signatures,
as discussed in the sequel. Other than this, the overall approach is the same:
the adversary picks two honestly obtained credentials, and one of them (set
by the $b$ value defining the $anon-b$ game) is used to program the \CHALb
oracle. The formal specification of the anonymity game is
given in \figref{fig:exp-uas-anonb}, where $\Oanonc \gets (\lbrace\HU,\CU\rbrace
\GEN,\lbrace\II,\OO\rbrace\GEN,\lbrace\II,\OO\rbrace\CORR,\OBTAIN,\SIGN,
\INSPECT)$ and $\Oanong \gets (\lbrace\HU,\CU\rbrace\GEN,\lbrace\II,\OO\rbrace
\GEN,\lbrace\II,\OO\rbrace\CORR,\OBTAIN,\SIGN,\INSPECT,\CHALb)$

\begin{figure}[htp!]
  \procedure{$\ExpAnonb(1^\secpar)$}{%
     \parm \gets \Setup(1^\secpar) \\
     (\ccid_0,\ccid_1,\status) \gets \adv^{\Oanonc}(\choose,\parm) \\
     b^* \gets \adv^{\Oanong} (\guess,\status) \\
     \pcreturn b^*
  }
  \caption{Anonymity experiment for \UAS schemes.}
  \label{fig:exp-uas-anonb}
\end{figure}

\begin{definition}{(Anonymity of \UAS)}
  We define the advantage \AdvAnon of $\adv$ against \ExpAnonb as
  $\AdvAnon=|\Pr\lbrack\ExpAnono(1^\secpar)=1\rbrack-
  \Pr\lbrack\ExpAnonz(1^\secpar)=1\rbrack|$.
  %
  An \UAS scheme satisfies anonymity if, for any p.p.t. adversary $\adv$,
  \AdvAnon is a negligible function of $1^\secpar$.
\end{definition}

\paragraph{Discussion on the generality of anonymity in \UAS schemes.} %
This notion of anonymity is more general than that of group signatures in the
sense that calls to the \INSPECT oracle reveal an arbitrary function of the
identity of the user -- which can certainly be the member index itself, as it
is frequent in group signatures, or any other function computable from the
user public key, its credentials, and produced signature. Moreover, note that
our notion is even stronger than the conventional ``CCA-like'' anonymity notion
that gives the adversary access to the open oracle, only restricting it when
trying to open challenge signature. Precisely the introduction of generic
inspection functions allows us to \uline{\emph{let the adversary open
    challenge signatures $\csig_b$}} as long as the counterpart $\csig_{1-b}$
makes \Inspect produce the same \y value as output. This is certainly not
possible when using conventional opening, since it directly outputs the identity
of the signer -- which cannot be the same for different challenge users.

\paragraph{Traceability.} %
% Traceability is one of the unforgeability-related properties in group
% signatures. It captures that any signature accepted by \Verify needs to open
% to one of the users that joined the group. While there is no traceability notion
% in anonymous credentials, it is natural to map it to their unforgeability
% property; if only because both require the issuer to be honest. Unforgeability
% in anonymous credentials typically ensures that no adversary can get a verifier
% to accept a credential presentation requiring a set of attributes that is not
% contained in one of the credentials controlled by the adversary.

% Our notion of traceability for \UAS is inspired by both. First, we restrict to
% signatures that are accepted by \Verify. For any such signature, \Inspect has to
% create a valid output (i.e., must not abort). The output of \Inspect has to be
% accepted by \Judge too. Moreover, there must exist one user (either honest or
% corrupt) who used his public key to obtain one or more credentials that allowed
% him to produce a signature which, once inspected, returns \y.
In group signatures, traceability ensures that, in the presence of an honest
issuer, every signature accepted by the verify algorithm must have been created
by a user who joined the group.  With conventional opening, this is essentially
checked by requesting the adversary to produce a signature, opening it, and
checking whether or not it comes from a group member; i.e., this ensures that,
as long as there are verifiable inspections, inspection cannot be forged in the
presence of an honest issuer.
%
The somehow equivalent property in anonymous credentials is unforgeability. It
requires that, again in the presence of an honest issuer, no adversary can
succeed in a credential presentation for attributes (or predicates of them) that
are not contained in a legitimately issued credential it controls. In other
words, that the evaluation of the credential attributes cannot be forged.
%
Both notions have an equivalent in \UAS. That is, we need to ensure that, in the
presence of an honest issuer, no signature accepted by \Verify can result in a
wrong inspection, nor it can have been obtained by a wrong evaluation of some
credential. Note, however, that \UAS offer the adversary yet another way to
break traceability/unforgeability. Namely, an adversary can attempt to
illegitimately obtain a credential that later enables it to produce untraceable
signatures; i.e., signatures that evaluate correctly, or for which \Inspect
returns the appropiate value, yet the adversary should not have been able to
obtain a credential that allowed it to produce such signatures. Our notion of
traceability/unforgeability thus challenges the adversary to produce a signature
that breaks any of those conditions. The formal
definition of the traceability experiment is given in \figref{fig:exp-uas-trace},
where $\Otrace \gets \lbrace\HU,\CU\rbrace\GEN,\IGEN,\OGEN,\OCORR,\OBTISS,
\ISSUE,\SIGN,\INSPECT$.

\begin{figure}[htp!]
    \procedure{$\ExpTrace(1^\secpar)$}{%
      \parm \gets \Setup(1^\secpar) \\
      (\gid,\sig,\msg,\feval) \gets \adv^{\Otrace}(\parm) \\
      \pcif \Verify(\GK[\gid],\sig,\msg,\feval) = 0: \pcreturn 0 \\
      \pcif \EvalInspectForge(\gid,\sig,\msg,\feval) = 1 \\%\land
%      \InspectForge(\gid,\sig,\msg,\feval) = 1: \\
      \pcind \pcreturn 1 \\
      \pcreturn 0 \\
    }
        
    % \procedure{$\EvalForge(\gid,\sig,\msg,\feval)$}{%
    %   \pcif \exists \uid~\st~\Identify(\uid,\sig) = 1~\land \\
    %   \pcind \pccomment{\uid does not own a \cred that satisfies \feval...} \\
    %   \pcind (\nexists \cred \in \CRED[\uid]~\st~
    %   \feval(\PUBUK[\uid],\cred,\msg) \neq 0 ~\lor \\
    %   \hspace*{13pt} \pccomment{... or \uid does, but \cred was itself obtained
    %     fraudulently} \\
    %   \hspace*{13pt} (\exists \cred \in \CRED[\uid]~\st~
    %   \feval(\PUBUK[\uid],\cred,\msg) \neq 0~\land \\
    %   \pcind \pcind \fissue(\PUBUK[\uid],\attrs^\cid,\scred^\cid) = 0, \\
    %   \pcind \pcind \textrm{where $\CRED[\cid]=\cred$ and
    %     $(\attrs^\cid,\scred^\cid) \gets \ATTR[\cid]$})): \\
    %   \pcind \pcreturn 1 \\
    %   \pcelse \pcreturn 0 \\
    % }
    
    \procedure{$\EvalInspectForge(\gid,\sig,\msg,\feval)$}{%
      \pccomment{All \Obtain transcripts fail to inspect \sig} \\
      \pcif \Inspect(\PRVOK[\gid],\trans,\sig,\msg) \neq \bot~\lor \\
      \pcind \pccomment{A valid transcript exists, but ...} \\
      \pcind \exists \uid~\st~\Inspect(\PRVOK[\gid],\trans[\uid],\sig,\msg) =
      (\y,\iproof)~\land (\\
      \pcind \pcind \pccomment{... the proof is rejected by \Judge ...} \\
      \pcind \pcind \Judge(\y,\iproof,\sig,\msg,\GK[\sgid]) = 0~\lor \\
      \pcind \pcind \pccomment{... or \uid does not own a \cred for which
        \finsp outputs \y} \\
      \pcind \pcind \nexists \cred \in \CRED[\uid]~\st~
      \y = \finsp(\feval(\PUBUK[\uid],\cred,\msg),
      \PUBUK[\uid],\cred,\msg)~\lor \\
      \pcind \pcind \pccomment{... or \uid does, but \cred was itself obtained
        fraudulently} \\
      \pcind \pcind (\exists \cred \in \CRED[\uid]~\st~
      y = \finsp(\feval(\PUBUK[\uid],\cred,\msg),
      \PUBUK[\uid],\cred,\msg)~\land \\
      \pcind \pcind \pcind \fissue(\PUBUK[\uid],\attrs^\cid,\scred^\cid) = 0, \\
      \pcind \pcind \pcind \textrm{where $\CRED[\cid]=\cred$ and
        $(\attrs^\cid,\scred^\cid) \gets \ATTR[\cid]$})): \\      
      \pcind \pcreturn 1 \\      
      \pcreturn 0
    }
  \caption{Traceability experiment for \UAS schemes.}
  \label{fig:exp-uas-trace}
\end{figure}

\begin{definition}{(Traceability of \UAS)}
  We define the advantage \AdvTrace of $\adv$ against \ExpTrace as
  $\AdvTrace=\Pr\lbrack\ExpTrace(1^\secpar)=1\rbrack$.
  %
  A \UAS scheme satisfies traceability if, for any p.p.t. adversary $\adv$,
  \AdvTrace is a negligible function of $1^\secpar$.
\end{definition}

\paragraph{Discussion on the generality of traceability in \UAS schemes.} %
The notion of traceability we present for \UAS is strictly more general than
the corresponding one for group signatures. This is again a direct
consequence of the fact that \Inspect, which can return an arbitrary function
of the signer's credential (and signed message), is a generalization of the
conventional \Open -- if we make \Inspect return just the identity of the
signer, then we get something similar to the usual notion of traceability.
Although, even in that case, we need to take into account attributes, and the
fact that the same user may obtain multiple credentials (that is why, even when
having \Inspect return the identity of the signer, our notion is not exactly
the same). And, in this sense, the unforgeability notion that \UAS have is
equivalent to that of anonymous credentials. It would seem, though, that we do
not need the traceability part of group signatures; after all, it is the
protection against wrong claims on attributes what enables meaningful and
flexible authentication. However, the type of protection against misuses of
the inspection functionality that we can get with an honest issuer (as in
traceability) is much higher than without an honest user (as in
non-frameability). Specifically, with an honest issuer we can ensure that
the adversary cannot even alter the value returned by \Inspect on signatures
by corrupt users, nor the output of the signing predicate \feval. Whereas, with
a corrupt issuer, all we can ensure is that
the adversary cannot forge a signature from an honest user for which \Inspect
returns the same value as a signature by that honest user would produce; and,
certainly, a corrupt issuer can arbitrarily issue credentials meeting any
desired predicate \feval .Traceability is, therefore, a core property to ensure
accountability.

Note also that we have implicitly assumed an unforgeability relaxation in the
sense that we do not consider a forgery the fact that an adversary can obtain
credentials that do not meet the \fissue predicate \emph{as long as they are
  not used to produced untraceable signatures}. Indeed, this is in line with
previous work \cite[Section 3.3.3]{ckl+15}, and it does make sense as, in the
real world, being able to fraudulently obtain credentials that cannot be later
used to authenticate, does not pose a risk. However, an adversary breaking
the issue policy defined by \fissue to get a credential and later using it to
create a valid signature (i.e., meeting \feval or \finsp) is considered a
forgery by our definition.

\paragraph{Non-frameability.} %
Non-frameability variants are a core unforgeability-type property in group
signatures. However, no
similar property is modeled for anonymous credentials (\todo{see the discussion
  in \secref{sec:introduction} for further detail}). It is a quite strong
property, as it must be ensured even in the presence of dishonest issuer and
opener. Intuitively, it prevents the adversary from creating a signature that
frames an honest user. Depending on the inspection capabilities of the scheme,
this framing could be done in different ways; i.e., by convincing third parties
that signatures by different (possibly corrupt) users are linked, or directly
by having inspection proofs output the identity of a user who did not create the
signature being inspected.

The notion of non-frameability in \UAS schemes is unavoidably more subtle than
in group signatures, though. To see this, we note that, by allowing any
arbitrary inspection function \finsp to be used, it can be perfectly valid to
have a signature produced by a corrupted user output the same \y value upon
inspection than the one that \finsp outputs when inspecting a signature by an
honest user. As a concrete example, imagine an inspection function that returns
the banking account number (or cryptocurrency address) to be used to request
payment of a fine. In this example, a corrupted user and an honest user could
both have delegated this to some agency\footnote{\todo{Maybe, come up with a
    better example. How about spam filters that apply some sort of classification
    engine? \finsp could be this engine, and emails by many different users could
    be classified just as ``Spam'' or ``Not spam''}}, so it makes perfect sense
that the inspection function returns the same value for both users.
%
Thus, in \UAS schemes, we must be more subtle, by necessity. Note that we cannot
just require that no adversary can produce a signature for which inspection
returns the same value as it would for a signature honestly generated by an
uncorrupted user. This is again the case since inspection may be non-injective,
which means that inspection of a signature by some corrupted user may
legitimately produce the same value as that of an honest user. Thus, we need
to further refine the definition by requiring that (i) no adversary can produce
a signature that is recognized (via \Identify) as originating from an honest
user \uid, (ii) who owns a credential that makes \finsp return a valid \y value
(i.e., generated by \Inspect along with a proof, and accepted by \Judge), (iii)
without having queried the \SIGN oracle before. This non-frameability property
for \UAS schemes is formally defined in \figref{fig:exp-uas-frame}, where
$\Oframe \gets \lbrace\HU,\CU\rbrace\GEN,
\lbrace\II,\OO\rbrace\GEN,\lbrace\II,\OO\rbrace\CORR,\OBTAIN,\SIGN$

\begin{figure}[htp!]
  \procedure{$\ExpNonframe(1^\secpar)$}{%
    \parm \gets \Setup(1^\secpar) \\
     (\gid,\sig,\msg,\feval,\y,\iproof) \gets \adv^{\Oframe}(\parm) \\
     \pcreturn 1~\pcif \Verify(\GK[\gid],\sig,\msg,\feval) = 1 \land
     \Judge(\GK[\gid],\y,\iproof,\sig,\msg) = 1~\land \\
     \pcind \pccomment{\adv~did not query \SIGN to get \sig, yet \sig originates
       from an honest \uid, owning a credential that makes \finsp
       evaluate to \y} \\
     \pcind \exists \uid \in \HU~\st~\Identify(\PRVUK[\uid],\sig) = 1 \land
     (\cdot,\sig,\msg,\cdot) \notin \SIG[\uid]~\land\\
     \pcind \exists \cred \in \CRED[\uid]~\st~
     \finsp(\feval(\PUBUK[\uid],\cred,\msg),\PUBUK[\uid],\cred,\msg) = \y \\
%     \pccomment{\todo{I don't think we can give any assurance about \feval here,
%         given that issuers are corrupt. But still, think about it.}} \\
     \pcreturn 0
  }
  \caption{Non-frameability experiment for \UAS schemes.}
  \label{fig:exp-uas-frame}
\end{figure}

\begin{definition}{(Non-frameability of \GSAC)}
  We define the advantage \AdvNonframe of $\adv$ against \ExpNonframe as
  $\AdvNonframe=\Pr\lbrack\ExpNonframe(1^\secpar)=1\rbrack$.
  %
  A \GSAC scheme satisfies non-frameability if, for any p.p.t. adversary $\adv$,
  \AdvNonframe is a negligible function of $1^\secpar$.
\end{definition}

\paragraph{Discussion on the generality of non-frameability in \UAS schemes.} %
Anonymous credentials do not have non-frameability property and, thus, it is
hard to make a comparison. However, we can draw some connections with AC schemes
that support revocation, as revocation is somehow equivalent to linking, which
is a type of inspection available in group signatures. In this sense, note that
basic revocation (without straight deanonymization) can be trivially achieved
through our generic \Inspect function. For instance, one could set \finsp to
be a pseudorandom number seeded with the user's public key (or credential). In
this sense, \Inspect could be essentially seen as a Verifiable Random Function.
If we compare with group signatures, our notion is again more general than the
conventional one. Indeed, in typical group signatures, \Open returns the
identity of the signer, and thus non-frameability does not allow the same value
to be returned when opening signatures by different users. Otherwise, a
corrupted user controlled by the adversary could be able to create a signature
opening to some honest user (hence, framing him). But this is again possible
with our definition which, in case of making \Inspect equal \Open, becomes
equivalent to conventional non-frameability. However, it also allows more
generic situations in which signatures by different users may return the same
value. 

\subsection{Functionality ``Transformations'' and Special Cases}
\label{ssec:transformations}

\commentwho{Jesus}{This section is aimed at showing the ``universality'' of
  our model. If I'm not mistaken, ideally, it should support the following
  variations (except the transformation to interactive presentations,
  probably).}

\subsubsection{Transformation to Interactive Presentations}
\label{sssec:interactivetransform}

\todo{Is it possible to give it in some generic sense?}

\subsubsection{Combining Multiple Credentials in One Presentation}

\todo{I think this might be possible if we can use \fissue so that any user can
  create arbitrary groups, where he is the issuer, an can thus run
  \Obtain,\Issue protocols to combine credentials from other groups. This is
  probably inefficient (or, at least, more than doing so wihtout having to
  create ad hoc groups), but at least allows the enhanced functionality...}

\subsubsection{Restricting to Conventional GS and AC Schemes}

\todo{It would be nice to prove that a \GSAC scheme to which we remove the
  \Open/\Judge functions becomes an AC scheme. And conversely, a \GSAC scheme
  where all credentials have no attributes, and where we restrict to only
  one credential per user, becomes a conventional GS scheme.}


\subsubsection{Group Signatures with Message Dependent Opening}

\todo{Describe what type of \finsp would be needed to achieve a functionality
  similar to that of GS-MDO. Does this fit our model straight away? Maybe also
  show how other types of GS could be ``mimicked'' (e.g., GS only with linking).
  This would also be good to test if the model is as generic as I think it is}

\subsubsection{Ring Signatures}

\todo{Can we come up with a (\fissue,\feval,\finsp) tuple that allows us to
  somehow mimic ring signatures (i.e., ``a group signature without issuer nor
  opening''? Does the model support this?}
  
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "uas"
%%% End:
