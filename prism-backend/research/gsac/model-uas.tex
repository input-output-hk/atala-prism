\subsection{Model for \UAS Schemes}
\label{ssec:model-uas}

We now define our model for Universal Anonymous Signatures. Property-wise, we
maintain anonymity, non-frameability, and include two extra unforgeability
properties: unforgeability of issuance, which ensures that issuance policies
are not circumvented; and unforgeability of signatures, guaranteeing that
signing policies are respected, as well as soundness of opening.

From a functional perspective, we require that each issuer and opener fix
the issuance predicate \fissue and opener function \finsp when generating
their public keys. On the other hand, signature evaluation functions \feval can
be defined at signing time. This is in line with the usual practice in anonymous
credentials, that let
users prove arbitrary claims on their credentials, as long as they are met by
the contained attributes. In practice, most probably, the signing policy to be
employed in each signature will be defined by the verifier (or jointly between
user and verifier), including the specification of which inspector will be
able to post-process signatures\footnote{See, for instance, the concept of
  presentation exchanges, or requests, in the context of Verifiable Credentials:
  \url{https://identity.foundation/presentation-exchange/} (last access, May
  5th, 2022).}. Beyond these general policies, which already give much
flexibility, the syntax for \UAS supports multiple issuers and openers, and
lets users leverage multiple credentials to request issuance of new ones, and
to produce signatures.

\subsubsection{Syntax.} An \UAS scheme is composed by the following algorithms:

\begin{description}
\item[$\parm \gets \Setup(\secpar)$.] Given a security parameter \secpar,
  returns a global system parameter variable \parm. We assume that \parm are
  available to all the other functions, even if not explicitly listed in their
  input parameters.
\item[$(\ipk,\isk) \gets \IKeyGen(\parm,\fissue)$.] Given global system
  parameters \parm, and the function \fissue to be used to check that credential
  requestors meet the conditions to be issued a credential, an issuer runs
  \IKeyGen to generate its issuing key pair. 
\item[$(\opk,\osk) \gets \OKeyGen(\parm,\finsp)$.] Given global system
  parameters \parm, and function \finsp, an opener runs \OKeyGen to generate
  its opening key pair. The function \finsp defines the type of utility that
  will be extractable from signatures.
\item[$\usk \gets \UKeyGen(\parm)$.] Given global system parameters
  \parm, returns a user's secret key.
\item[$\langle \cred/\bot,\utrans/\bot \rangle \gets
  \langle
  \Obtain(\usk,\lbrace (\cred_i,\ipk_i)\rbrace_{i \in \Issuers},\attrs),
  \Issue(\isk,\lbrace \ipk_i \rbrace_{i \in \Issuers},\attrs))
  \rangle$.] %
  This interactive protocol lets a user with key \usk running the
  \Obtain process, receive a credential \cred from an issuer in the system, on
  attribute set $\attrs$. The user leverages a set of $(\cred_i,\ipk_i)$ pairs,
  where $\cred_i$ is a credential obtained from the issuer with public
  key $\ipk_i$. The user outputs the produced credential \cred, while
  the issuer outputs the protocol transcript \utrans for the produced
  credential. To ease notation, we assume that the issuer public key associated
  to credential is available from the credential itself, and therefore
  omit the $\ipk_i$ values from the syntax, unless necessary to avoid
  ambiguity.
\item[$(\sig,\yeval) \gets \Sign(\usk,\opk,\lbrace (\cred_i,\ipk_i)
  \rbrace_{i \in \Issuers},\msg,\feval)$.] %
  Upon receiving a user secret key \usk, opener public key \opk, a set of
  credential-issuer pairs $(\cred_i,\ipk_i)$, a message \msg and evaluation
  function \feval, returns signature \sig and value \yeval.
\item[$1/0 \gets \Verify(\opk, \lbrace \ipk_i \rbrace_{i \in \Issuers},\sig,
  \yeval,\msg,\feval)$.] Checks whether $(\sig,\yeval)$ is a valid signature
  over message \msg, from a user with credentials issued by issuers with public
  keys $\ipk_i$, for evaluation function \feval and inspector key \opk.
\item[$(\yinsp,\iproof)/\bot \gets \Open(\osk,\lbrace \ipk_i
  \rbrace_{i \in \Issuers},\sig,\yeval,\msg,\feval)$.] %
  Executed by the opener with private key \osk. Receives a signature $(\sig,
  \yeval)$ over message \msg and evaluation function \feval, generated using
  credentials issued by the issuers with public keys $\ipk_i$. If \sig is valid,
  the function outputs a value $\yinsp$.
\item[$1/0 \gets \Judge(\opk,\lbrace ipk_i \rbrace_{i \in \Issuers},\yinsp,
  \iproof,\sig,\yeval,\msg,\feval)$.] %
  Checks if \iproof is a valid opening correctness proof for the value \yinsp,
  obtained by applying \Open to the the signature $(\sig,\yeval)$ over
  message \msg, and for evaluation function \feval. 
\end{description}

\paragraph{Issuance, evaluation, and opening functions.} %
We emphasize that, both in our syntax definition, as well as on the following
modelling, we make use of three different and abstract functions: \fissue,
\feval and \finsp. The three functions are introduced to allow customized
governance of the resulting instantiation of an \UAS scheme. They will be
defined by different parties, but in all cases, they are run by users (maybe,
on user-private data). Also, in all cases, the user has to prove correctness of
their computation. We introduce them next, \todo{and will give concrete examples
  in \secref{sec:uas-instantiation}.}

\begin{description}
\item[$\fissue: (\usk,\lbrace (\cred_i,\ipk_i) \rbrace_{i \in \Issuers},\attrs)
  \rightarrow 0/1$.] Chosen by issuers within a family of functions \famfissue,
  the issuance function defines what customized conditions an issuer requires
  in order to issue credentials, when receiving a request from user with secret
  key \usk, for attributes \attrs. \fissue may run checks on a (possibly empty)
  set of additional credentials $\cred_i$, all bound to \usk, and possibly
  issued by other issuers. \fissue returns $1$ to accept a request, $0$ to
  reject it.
\item[$\feval: (\usk,\lbrace (\cred_i,\ipk_i) \rbrace_{i \in \Issuers},\msg)
  \rightarrow \yeval$.] Signing evaluation functions, from a family of functions
  \famfeval, can be set on a per-signature basis. They receive the user secret
  key \usk, credentials $\cred_i$, and message to be signed \msg, and can be
  used to control the information related to the signer that will be revealed
  alongside a signature, and to modulate the behaviour of \finsp. Its outputs
  \yeval must belong in a well defined set \rngfeval.
\item[$\finsp: (\yeval,\usk,\lbrace (\cred_i,\ipk_i) \rbrace_{i \in \Issuers},
  \msg) \rightarrow \yinsp$.]
  Chosen by openers from a family of functions \famfinsp. The opening
  functions define what utility value, derived from the user's secret key,
  credentials, and signed message, should be extractable by an opener.
  Note that \finsp also receives as input a value in the range of the \feval
  function, \rngfeval. This allows opening logic to depend on the value
  produced by the evaluation function. The output of \finsp is a value
  \yinsp, which must belong in a well defined set \rngfinsp.
\end{description}

We emphasize that, even though \finsp and \feval seem redundant, they are not.
To see this, observe that \finsp is defined by inspectors, and will be fixed in
all signatures that can be opened by the opener who defined it. On the other
hand, \feval can be defined by (e.g.) verifiers on a per-signature basis, even
if the signatures use the same \finsp. Thus, \feval can be programmed to contain
the conditions set by (e.g.) verifiers for signatures they receive; whereas
\finsp can be programmed to extract specific utility values when needed, which
may depend on the checks required by the verifier a signature was intended to.

\paragraph{Helper functions \Identify, \ExtractIssue and \ExtractSign.} In our
modelling, we assume the existence of three functions, \Identify, \ExtractIssue
and \ExtractSign. They are not functions available in the actual scheme, but
rather to the challenger in the experiments we use to formalize security fof
\UAS. Indeed, similar techniques have been used before to prove security in
privacy-preserving schemes with some sort of accountability, but that do not
offer conventional opening as vanilla group signatures. For instance, see
related works on DAA \cite{bfg+11,cdl16} and group signature variants
\cite{dl21,fgl21,gl19,lnpy21}. More concretely, both functions are as follows:

\begin{description}
\item[$\Identify(\usk,\attrs_{\cred},\cred)$.] Returns $1$ if \cred has been
  issued over attributes $\attrs_{\cred}$ and for a user with secret key \usk.
  Otherwise, it returns $0$. In order to be meaningful, this requires that,
  for every $(\attrs_{\cred},\cred)$ pair, there is at most one \usk that makes
  \Identify return $1$.
\item[$\ExtractIssue(\utrans) \rightarrow (\usk,\scred,\attrs_{\scred})$.]
  Receives an $\langle \Obtain, \Issue \rangle$ transcript, and returns the
  credentials (if any), their attributes, and the user secret key used during
  the execution of the $\langle\Obtain,\Issue\rangle$ protocol. It clearly needs
  an honest issuer as, otherwise, the transcripts won't be available.
  Consequently, we only use it to define the properties that require an honest
  issuer.
\item[$\ExtractSign(\oid,\siid,\sig,\yeval,\msg,\feval) \rightarrow (\usk,
  \scred)$.] Receives a signature pair $(\sig,\yeval)$, as well as the opener
  identifier \oid, and the identifiers of all issuers of the credentials used to
  produce the signature over \msg, and for \feval. It outputs the user secret
  key and credentials used to generate the signature.
\end{description}

Note that, for the three functions, in the case of credentials, transcripts,
and signatures by honest users, it is enough to have access to the corresponding
state information (described below) maintained by the challenger in our
experiments. For credentials and join transcripts of corrupt users, or
dishonestly produced signatures, we do need to perform actual extraction. How to
do this will depend on each specific construction. Certainly, the challenger
needs special knowledge/power such as decryption trapdoors, the ability to
rewind the game, or program random oracles. The approach needs thus to depend on
the concrete construction, although. Although, for the case of \ExtractIssue,
online extractability \needcite (or alternative requirements, such as
non-parallel or logarithmic number of joins) is necessary.

\paragraph{Global Variables.} %
The environment manages several global variables in the games posed to the
adversary. Users are referred to with user identifiers, \uid; for credentials,
we use \cid; for issuers, \iid; and for openers, \oid. In all cases, we use bold
font to denote sets: e.g., \scid and \siid denote sets of credential and issuer
identifiers. All tables/sets are initialized as empty tables/sets.

\begin{description}
\item[Tables for parties]:
  \begin{description}
  \item[\HU and \CU.] Keep track of honest (\HU) and corrupted (\CU) users;
    i.e., they are sets of {\uid}s.
  \item[\HI and \CI.] Keep track of honest (\HI) and corrupted (\CI) issuers;
    i.e., they are sets of {\iid}s.
  \item[\HO and \CO.] Keep track of honest (\HO) and corrupted (\CO) openers;
    i.e., they are sets of {\oid}s.
  \end{description}
\item[Tables for keys]:
  \begin{description}
  \item[\UK.] \UK maintains user keys $\usk$. To refer to the key of a specific
    user, we use $\UK[\uid]$. 
  \item[\IK, \PUBIK and \PRVIK.] \IK maintains issuer key pairs, where
    $\IK[\iid]$ refers to the key pair of the issuer with identifier \iid. We
    use \PUBIK to refer to the public component, which also includes the \fissue
    function; and \PRVIK refers to the private component of the key pair.
  \item[\OK, \PUBOK, \PRVOK.] Same as \IK, but for opener key pairs. Instead
    of \fissue, \OK includes the \finsp function.
  \end{description}
\item[Tables for credentials-related data]:
  \begin{description}
  \item[\CRED.] Stores information related to credentials obtained by users in
    the system. Thus, it is indexable by \cid. More specifically, it stores
    tuples of the form $(\uid,\cred,\iid,\attrs,\scid)$, where \uid is the
    identity of the owner of the credential, \cred (when available) is the
    credential itself, \iid is the identifier of the credential issuer, \attrs
    are the attributes included in \cred, and \scid are the identifiers of the
    credentials (if any) that \uid used to request \cred. For notational
    convenience, we may use $\CRED[\scid]$ to refer to $\CRED[\cid]$ for all
    $\cid \in \scid$. Also, when clear from context, we sometimes use
    $\CRED[\cid]$ (resp. $\CRED[\scid]$ to mean \cred (resp. \scred) in
    $\CRED[\cid] = (\cdot,\cred,\cdot,\cdot,\cdot)$ (resp. $\CRED[\scid]$).
  \item[\OWNR.] For notational convenience, when we write $\OWNR[\cid]$ we mean
    ``\uid such that $\CRED[\cid] = (\uid, \cdot, \cdot, \cdot, \cdot)$''.
  \item[\ATTR.] For notational convenience, when we write $\ATTR[\cid]$ we mean
    ``\attrs such that $\CRED[\cid] = (\cdot, \cdot, \cdot, \attrs, \cdot)$''.
  \item[\ISR.] For notational convenience, when we write $\ISR[\cid]$ we mean
    ``\iid such that $\CRED[\cid] = (\cdot, \iid, \cdot, \cdot, \cdot)$''.
  \end{description}
\item[Tables for signatures]:
  \begin{description}
  \item[\SIG.] Maintains signatures generated via the \SIGN oracle, on behalf
    of honest users. Entries of this table are $(\oid,\scid,\sig,\yeval,\msg,
    \feval)$, where \oid is the opener chosen for the signature, \scid is the
    set of credentials used for signing, \feval is the signing evaluation
    function, and \sig and \msg are the produced signature and signed message.
  \item[\CSIG.] Maintains challenge signatures output to the adversary; i.e.,
    the table is indexable by challenge signatures \csig.
    Each entry contains also $\cuid_b$ and $\scid_b$ the challenge user and
    credential identifiers set used to produce \csig; as well as the
    corresponding challenge user and credential set indexed by the complementary
    $1-b$; the signed message \msg and signing evaluation function \feval, the
    result of \feval, \yeval, and the opener identifier \oid.
  \end{description}
\end{description}

\paragraph{Oracles.} %
Oracles are the interface of the adversary with the corresponding games. In
other words: through these oracles, the game environment exposes to the adversary
functionality that could otherwise be executed only by honest parties with
private knowledge -- knowledge that would make the adversary capable of
trivially breaking the security properties formalized in the experiments.
In the game-based definitions of our \UAS model, we leverage the following
oracles, which are formally defined in \figref{fig:oracles1} and
\figref{fig:oracles2}. 

\begin{description}
\item[\IGEN.] Adds a new issuer to the game, generating its keypair and setting
  the associated issuance function.
\item[\OGEN.] Adds a new inspector to the game, generating its key pair and
  setting the associated evaluation and inspection functions.
\item[\ICORR.] Corrupts an existing (and honest) issuer, by giving its secret
  key to the adversary.
\item[\OCORR.] Corrupts an existing (and honest) inspector, by giving its secret
  key to the adversary.  
\item[\HUGEN.] Adds a new honest user to the game, by honestly generating
  the user's key pair.
\item[\CUGEN.] Adds a new corrupt user to the game or, if the specified
  user already exists and is honest, corrupts it.
\item[\RREG.] Reads the given transcript table entry.
\item[\WREG.] Sets a transcript table entry to the given value.
\item[\OBTISS.] Lets the adversary add a new honestly generated credential to
  the game, on behalf of an honest user.
\item[\OBTAIN.] Enables the adversary to play the role of a dishonest issuer
  in games that support it, by letting it interact with honest users who want to
  receive credentials.
\item[\ISSUE.] Allows the adversary to play the role of dishonest users,
  requesting an honest issuer to produce credentials for them.
\item[\SIGN.] Lets the adversary get signatures from credentials belonging
  to honest users.
\item[\OPEN.] Given an honestly produced signature, outputs the result of the
  opening function, along with a correctness proof.
\item[\CHALb.] Upon receiving two challenge users and credential sets, a common
  singing evaluation function and a message, returns a signature produced by one
  of these two user and credential sets, defined by the bit $b$, which is
  established in the anonymity game.
\end{description}

{%\setlength\intextsep{\sep}
  \begin{figure*}[htp!]
    \centering
    \scalebox{0.9}{

      \begin{minipage}[t]{0.55\textwidth}       

        \procedure{$\IGEN(\iid,\fissue)$}{%
          \pcif \iid \in \HI \lor \iid \in \CI: \pcreturn \bot \\
          \pcif \fissue \notin \famfissue: \pcreturn \bot \\
          (\ipk,\isk) \gets \IKeyGen(\parm) \\
          \IK[\iid] \gets ((\ipk,\fissue),\isk) \\
          \HI \gets \HI \cup \lbrace \iid \rbrace \\
          \pcreturn \ipk \\
        }

        \procedure{$\ICORR(\iid)$}{%
          \pcif \iid \in \CI \lor \iid \notin \HI: \pcreturn \bot \\
          \HI \gets \HI \setminus \lbrace \iid \rbrace \\
          \CI \gets \CI \cup \lbrace \gid \rbrace \\
          \pcreturn \isk \\
        }        

        \procedure{$\HUGEN(\uid)$}{%
          \pcif \uid \in \HU \lor \uid \in \CU: \pcreturn \bot \\
          (\upk,\usk) \gets \UKeyGen(\parm) \\
          \UK[\uid] \gets (\upk,\usk);
          \HU \gets \HU \cup \lbrace  \uid \rbrace \\
          \pcreturn \top \\
        }

        \procedure{$\RREG(i)$}{%
          \pcreturn \trans[i]
        }        
        
      \end{minipage}
    }
    \scalebox{0.9}{
      
      \begin{minipage}[t]{.5\textwidth}

        \procedure{$\OGEN(\oid,\finsp)$}{%
          \pcif \oid \in \HO \lor \oid \in \CO: \pcreturn \bot \\
          \pcif \finsp \notin \famfinsp: \pcreturn \bot \\
          (\opk,\osk) \gets \OKeyGen(\parm) \\
          \OK[\oid] \gets ((\opk,\finsp),\osk) \\
          \HO \gets \HO \cup \lbrace \oid \rbrace \\
          \pcreturn \opk \\
        }

        \procedure{$\OCORR(\oid)$}{%
          \pcif \oid \in \CO \lor \oid \notin \HO: \pcreturn \bot \\
          \HO \gets \HO \setminus \lbrace \oid \rbrace \\
          \CO \gets \CO \cup \lbrace \oid \rbrace \\
          \pcreturn \osk \\
        }        
        
        \procedure{$\CUGEN(\uid,\upk)$}{%          
          \pcif \uid \in \CU: \pcreturn \bot \\
          \CU \gets \CU \cup \lbrace \uid \rbrace \\          
          \pcif \uid \in \HU: \\
          \pcind \HU \gets \HU \setminus \lbrace \uid \rbrace; \\
          \pcind \pcreturn (\UK[\uid],\CRED[\uid]) \\
          \pcelse: \UK[\uid] = (\upk,\bot) \\          
          \pcreturn \top \\
        }

        \procedure{$\WREG(i,\rho)$}{%
          \trans[i] \gets \rho
        }        
        
      \end{minipage}
      
    }

    \caption{Detailed oracles available in our model (1/2). Oracles for
      generating key material for users, issuers, and inspectors.}
    \label{fig:oracles1}
  \end{figure*}
}

{%\setlength\intextsep{\sep}
  \begin{figure*}[htp!]
    \centering
    \scalebox{0.9}{

      \begin{minipage}[t]{0.55\textwidth}

        \procedure{$\ISSUE(\cid,\uid,\iid,\attrs,\siid)$}{%
          \pcif \uid \notin \CU: \pcreturn \bot \\          
          \pcif \iid \notin \HI: \pcreturn \bot \\
          \pcif \exists \iid' \in \ISR[\scid] \notin \HI: \pcreturn \bot \\
          \pcif \CRED[\cid] \neq \bot: \pcreturn \bot \\
          \langle \cdot, \utrans \rangle \gets
          \langle \adv, 
          \Issue(\PRVIK[\iid],\siid,\attrs) \rangle \\
          \trans[\cid] \gets \utrans \\
          \CRED[\cid] \gets (\uid, \cdot, \iid, \attrs, \cdot, \siid) \\
          \pcreturn \top \\          
        }                

        \procedure{$\OBTAIN(\cid,\uid,\iid,\attrs,\scid)$}{%
          \pcif \uid \notin \HU: \pcreturn \bot \\
          \pcif \iid \notin \CI: \pcreturn \bot \\
          \pcif \CRED[\cid] \neq \bot: \pcreturn \bot \\
          \pcif \exists \cid' \in \scid~\st~\CRED[\cid'] = \bot: \pcreturn \bot \\
          \langle \cred, \cdot \rangle \gets
          \langle \Obtain(\PRVUK[\uid],\CRED[\scid],\attrs),\adv \rangle \\
          \CRED[\cid] \gets (\uid, \cred, \iid, \attrs, \scid, \siid) \\
          \pcreturn \top \\
        }

        \procedure{$\CHALb(\oid,\cuid_{0,1},\cscid_{0,1},\msg,\feval)$}{%
          \pcif \cuid_0 \notin \HU \lor \cuid_1 \notin \HU: \pcreturn \bot \\
          \pcif \oid \in \CO: \pcreturn \bot \\
          \pcif \yeval = \feval(\PUBUK[\cuid_0],\CRED[\cscid_0],\msg) \neq \\
          \pcind \feval(\PUBUK[\cuid_1],\CRED[\cscid_1],\msg):
          \pcreturn \bot \\
          \pcif \PUBIK[\cscid_0] \neq \PUBIK[\cscid_1]: \pcreturn \bot \\
          (\yeval,\csig_b) \gets \Sign(\PRVUK[\cuid_b],\PUBOK[\oid], \\
          \hspace*{71pt}\CRED[\cscid_b],\msg,\feval) \\
          (\yeval,\csig_{1-b}) \gets \Sign(\PRVUK[\cuid_{1-b}],\PUBOK[\oid], \\
          \hspace*{80pt}\CRED[\cscid_{1-b}],\msg,\feval) \\          
          \CSIG[\csig_b] \gets 
          \lbrace (\oid,\cuid_b,\cscid_b,\msg,\feval,\yeval,\\
          \hspace*{74pt}\cuid_{1-b},\csig_{1-b},\cscid_{1-b})
          \rbrace \\
          \pcreturn (\csig_b,\yeval)
        }        
        
      \end{minipage}
    }
    \scalebox{0.9}{
      
      \begin{minipage}[t]{.5\textwidth}

        \procedure{$\OBTISS(\cid,\uid,\iid,\attrs,\scid)$}{%
          \pcif \uid \notin \HU: \pcreturn \bot \\
          \pcif \iid \notin \HI: \pcreturn \bot \\
          \pcif \CRED[\cid] \neq \bot: \pcreturn \bot \\
          \pcif \exists \iid' \in \ISR[\scid]~\st~\iid' \notin \HI: \pcreturn \bot \\
          \pcif \exists \cid' \in \scid~\st~\CRED[\cid'] = \bot:
          \pcreturn \bot \\
          \langle \cred, \utrans \rangle \gets
          \langle \Obtain(\PRVUK[\uid],\CRED[\scid],\attrs), \\
          \hspace*{60pt} \Issue(\PRVIK[\iid],\ISR[\scid],\attrs)
          \rangle \\
          \trans[\cid] \gets \utrans \\
          \CRED[\cid] \gets (\uid, \cred, \iid, \attrs, \scid, \siid) \\
          \pcreturn \top \\
        }

        \procedure{$\SIGN(\oid,\uid,\scid,\msg,\feval)$}{%
          \pcif \uid \notin \HU: \pcreturn \bot \\
          (\sig,\yeval) \gets \Sign(\PRVUK[\uid],\PUBOK[\oid],\CRED[\scid],\msg,
          \feval) \\
          \SIG[\uid] \gets \SIG[\uid] \cup
          \lbrace (\oid,\scid,\sig,\yeval,\msg,\feval) \rbrace \\
          \pcreturn (\sig,\yeval) \\
        }                

        \procedure{$\OPEN(\oid,\sig,\yeval,\msg)$}{%
          \textrm{Let}~\uid~\textrm{be s.t.}~(\oid,\scid,\sig,\yeval,\msg,\feval)
          \in \SIG[\uid] \\
          (\yinsp,\iproof) \gets
          \Inspect(\PRVOK[\oid],\GK[\scid],\sig,\yeval,\msg,\feval) \\
          \pcif \CSIG[\sig] \neq \bot: \\
          \pcind \textrm{Parse $\CSIG[\sig]$ as $(\oid,\cuid_b,\scid_b,\msg,
            \feval,\yeval$} \\
          \hspace*{83pt}\cuid_{1-b},\csig_{1-b},\scid_{1-b}) \\
          \pcind (\yinsp',\iproof') \gets
          \Inspect(\PRVOK[\oid],\IK[\siid],\\
          \hspace*{107pt} \sig_{1-b},\msg,\feval) \\
          \pcind \pcif \yinsp' \neq \yinsp: \pcreturn \bot \\
          \pcreturn (\yinsp,\iproof)
        }
        
      \end{minipage}
      
    }

    \caption{Detailed oracles available in our model (2/2). Oracles for
      obtaining credentials, signatures, and processing them.}
    \label{fig:oracles2}
  \end{figure*}
}

\paragraph{Correctness.} %
Correctness of \UAS schemes is formalized through the experiment in
\figref{fig:exp-uas-corr}. It states that a signature over any arbitrary message
and valid function \feval produced honestly leveraging credential set \scid,
owned by user \uid, is accepted by \Verify. Moreover, all the credentials in
\scid met the conditions set by the corresponding \fissue defined by the issuer
which issued each credential. Similarly, the output \yeval of \feval matches the
value produced by \Sign alongside with \sig; and the value produced by \Open
is accepted by \Judge, and matches the output of applying \finsp on \yeval, the
credentials, user key, and message.

\begin{definition}{(Correctness of \UAS)}
  \label{def:correctness-uas}
  An \UAS scheme is correct if, for any p.p.t. adversary $\adv$,
  $\ExpCorrect(1^\secpar)$ outputs 1 with negligible probability.
\end{definition}

\begin{figure}[htp!]
  \procedure{$\ExpCorrect(1^\secpar)$}{%
    \parm \gets \Setup(1^\secpar) \\
    (\uid,\oid,\scid,\msg,\feval)
    \gets \adv^{\IGEN,\OGEN,\HUGEN,\OBTISS,\RREG}(\parm) \\
    \pcif \feval \notin \famfeval: \pcreturn 0 \\
    \pcif \OWNR[\scid] \neq \uid: \pcreturn 0 \\
    (\sig,\yeval) \gets \Sign(\PRVUK[\uid],\PUBOK[\oid],\scid,\msg,\feval) \\
    \pcif \Verify(\PUBOK[\oid],\PUBIK[\scid],\sig,\msg,\feval) = 0: \pcreturn 1 \\
    \pcfor \cid \in \scid \pcdo: \\
    \pcind \textrm{Let}~\scred^{\cid}~\textrm{be the credentials used to obtain}
    ~\cid;~\textrm{Parse}~\PUBIK[\ISR[\cid]]~\textrm{as}~((\cdot,\fissue^{\cid}),\cdot)\\
    \pcind \pcif \fissue^{\cid}(\PUBUK[\uid],\scred^{\cid},\ATTR[\cid]) = 0: \pcreturn 1 \\
    \pcif \feval(\UK[\uid],\CRED[\scid],\msg) \neq \yeval: \pcreturn 1 \\
    (\yinsp,\iproof) \gets \Inspect(\PRVOK[\gid],\PUBIK[\scid],\sig,\msg,\feval) \\
    \pcif \Judge(\PUBOK[\oid],\PUBIK[\scid],\y,\iproof,\sig,\yeval,\msg,\feval)
    = 0 \lor \yinsp \neq \finsp^\gid(\yeval,\UK[\uid],\CRED[\scid],\msg)): \\
    \pcind \pcreturn 1 \\
    \pcreturn 0
  }  
  \caption{Correctness experiment for \UAS schemes.}
  \label{fig:exp-uas-corr}
\end{figure}

\subsubsection{Security Properties}
\label{sssec:security}

\paragraph{Anonymity.} %
In group signatures, anonymity captures that no adversary must be able to learn,
from any group signature, the identity (e.g., member index) of its signer. In 
anonymous credentials, it requires that no adversary should learn anything about
the holder of a successfully shown credential, beyond that he owns a credential
attesting for the claimed predicate of the attributes it contains. In both GS
and AC, it is also typically required that
multiple signatures/presentations by the users are unlinkable. The approach to
formally state this property is in both cases frequently the same: the adversary
picks two (honest) users (or credentials in the AC case), the game randomly
chooses one of them, and lets the adversary request challenge
signatures/presentations from it. The adversary wins if it succeeds in guessing
which was the chosen user/credential better than guessing at random. In group
signatures, the game must also restrict the adversary from opening challenge
signatures. In anonymous credentials, the game must further constraint the
adversary to output credentials that both meet the same (challenge) predicate
of their attributes.

In our notion of anonymity for \UAS, we need to merge the previous constraints.
In order to prevent trivial wins by the adversary, we have to restrict that the
signing evaluation function outputs the same value for both user-credentials
pairs. Very interestingly, since our opening functionality does not
(necessarily) output the identity of the signer, \uline{we can even allow the
  adversary to open challenge signatures, as long as they produce the same
  output}. Other than this, the overall approach is similar: as
in group signatures and anonymous credentials, the adversary picks two pairs of
honest users and credential sets. We also require the adversary to pick an
evaluation function and an opener (hence, an opening function). Then, the
user-credential pair defind by the value of $b$ (unknown to the adversary) is
used to program the \CHALb oracle. The formal specification of the anonymity
game is given in \figref{fig:exp-uas-anonb}, where $\Oanonc \gets (\lbrace\HU,
\CU\rbrace\GEN,\lbrace\II,\OO\rbrace\GEN,\lbrace\II,\OO\rbrace\CORR,\OBTAIN,
\WREG,\SIGN,\OPEN)$ and $\Oanong \gets (\lbrace\HU,\CU\rbrace\GEN,\lbrace\II,
\OO\rbrace\GEN,\lbrace\II,\OO\rbrace\CORR,\OBTAIN,\WREG,\SIGN,\OPEN,\CHALb)$

\begin{figure}[htp!]
  \procedure[linenumbering]{$\ExpAnonb(1^\secpar)$}{%
     \parm \gets \Setup(1^\secpar) \\
     (\cuid_0,\cscid_0,\cuid_1,\cscid_1,\feval,\status) \gets \adv^{\Oanonc}
     (\choose,\parm) \\
     \pcif \feval \notin \famfeval: \pcreturn \bot \\
     b^* \gets \adv^{\Oanong} (\guess,\status) \\
     \pcreturn b^*
  }
  \caption{Anonymity experiment for \UAS schemes.}
  \label{fig:exp-uas-anonb}
\end{figure}

\begin{definition}{(Anonymity of \UAS)}
  \label{def:anonymity-uas}  
  We define the advantage \AdvAnon of $\adv$ against \ExpAnonb as
  $\AdvAnon=|\Pr\lbrack\ExpAnono(1^\secpar)=1\rbrack-
  \Pr\lbrack\ExpAnonz(1^\secpar)=1\rbrack|$.
  %
  An \UAS scheme satisfies anonymity if, for any p.p.t. adversary $\adv$,
  \AdvAnon is a negligible function of $1^\secpar$.
\end{definition}

\paragraph{Discussion on the generality of anonymity in \UAS schemes.} %
This notion of anonymity is more general than that of group signatures in the
sense that calls to the \OPEN oracle reveal an arbitrary function of the
identity of the user -- which can certainly be the member index itself, as it
is frequent in group signatures, or any other function computable from the
user key, its credentials, and signed message. Moreover, note that
our notion is even stronger than the conventional ``CCA-like'' anonymity notion
that gives the adversary access to the open oracle, only restricting it when
trying to open challenge signature. Precisely the introduction of generic
opening functions allows us to let the adversary open challenge signatures
$\csig_b$ as long as the counterpart $\csig_{1-b}$
makes \Open produce the same \y value as output. This is certainly not
possible when using conventional opening, since it directly outputs the identity
of the signer -- which cannot be the same for different challenge users.

Note that we could actually remove the requirement that the evaluation function
has to produce the same output on both challenge user-credentials pairs.
However, by doing so, we would force all constructions to maintain private the
output of \feval. We opt not to require that, though, as it directly allows
our model to cover interesting use cases -- such as restricting to selective
disclosure, or privacy-preserving variants of functional signatures \todo{check
  the latter, and perhaps expand}.

\paragraph{Unforgeability.} In anonymous credentials, unforgeability requires
that no adversary can succeed in a credential presentation for attributes that
are not contained in a legitimately issued credential (set) it controls. Note
that, for this, assuming honest issuers is essential as, otherwise, the
adversary can get credentials on any attribute set it wants.
%
The somehow equivalent property in group signatures, inasmuch it also requires
honest issuers, is traceability. It captures the security of the
open-related functionality (e.g., \Open and \Judge) over signatures
that produced by potentially malicious signers, in the presence of an honest
issuer. In a nutshell, it ensures that every signature accepted by
the verification algorithm must have been created by a user who joined the
group, and that the result of \Open (and thus, \Judge) over such a valid
signature is consistent with its signer. With conventional opening, this is
essentially checked by requesting the adversary to produce a signature,
obtaining -- via open -- the ``identifier'' of the user who produced the
signature. Schemes
that do not have conventional opening resort to more subtle techniques, like
matching keys extracted during join transcripts, with keys used for signing
(see, e.g., \cite{dl21}). Thus, even though for more subtle reasons (the need
for reliable bookkeeping during joins) than for anonymous credentials, honest
issuers are required for traceability of group signatures too.

In our \UAS scheme we need to allow users prove claims over the attributes they
own -- attested via obtained credentials -- through the \feval function.
Roughly, we capture this roughly as in unforgeability requirement of anonymous
credentials. Namely, that the \yeval value returned by \Sign along with the
signature, matches the expected one from the specified \feval function.
On the other hand, the opening capabilities of \UAS schemes also call for a
traceability-like property. However, note that, as opposed to group signatures,
$\langle \Obtain,\Issue \rangle$ protocols are over credentials rather than
users -- although, ultimately, credentials must be owned by some user.
Furthermore, since \Open
does not return the actual identity of the signer, but a function \finsp of it
(and other arguments), we need to make sure that the output of \Open
matches the output of \finsp. As in group signatures with non-conventional open,
we resort to extraction-based techniques. All this is captured via \ExpForgeSign
in \figref{fig:exp-uas-unfor-issue}. Therein, the adversary is challenged to
produce a signature $(\sig,\yeval)$ over message \msg and for evaluation
function \feval; as well as the identifiers for the opener (\oid) and
credential issuers (\siid) used to compute the signature. As in traditional
group signatures, the adversary wins if the signature is accepted by \Verify,
yet \Open or \Judge fail. Then, the game extracts the user key and
credentials used to produce the signature. From it, the game checks if the
output of \feval matches the \yeval value produced by the adversary -- this
mimics the behaviour of unforgeability in anonymous credentials. Finally, the
game also checks that the output of \Open (even if accepted by \Judge)
matches the output of \finsp. If there is any mismatch in the last two checks,
or some of the credentials used to produce the signature do not correspond to
the secret key that was allegedly used to request them, the adversary wins the
game.

Our \UAS scheme includes yet another generalisation that requires unforgeability-like
security, though. Concretely, the issuance function \fissue. We need to make
sure that no credential is issued unless its corresponding
request meets the defined issuance policy. From the point of view of group
signatures, this may seem redundant. After all, if all valid signatures produce
consistent evaluation and opening results, given the employed user key,
credentials, and signed message, the notion of traceability seems to be
satisfied. However, from the point of view of anonymous credentials, an attacker
being able to obtain a credential, even when it does not meet the required
conditions to have it issued, is clearly problematic: it would allow to prove
claims over attributes it does not really ``own'' (even if the output of \Sign
and \Open are consistent with the values returned by \feval and \finsp, and
the credential was obtained via an $\langle \Obtain,\Issue \rangle$ run). To
capturethis, we define the \ExpForgeIssue experiment. In the experiment, the
adversary is challenged to produce a credential identifier that must be
associated to an existing $\langle \Obtain,\Issue \rangle$ interaction -- thus,
the corresponding \trans entry must exist (which we can check, as the issuer is
honest). The adversary wins if, either the extraction process fails, or the
extracted user secret key and credentials make the corresponding issuance
function fail.

For both \ExpForgeIssue and \ExpForgeSign, the adversary is given access to the
oracle set $\Oforgeissue = \Oforgesign \gets \lbrace\HU,\CU\rbrace\GEN,\IGEN,
\OGEN,\OCORR,\OBTISS,\ISSUE,\RREG,\SIGN,\OPEN$.

\begin{figure}[htp!]
    \procedure[linenumbering]{$\ExpForgeIssue(1^\secpar)$}{%
      \parm \gets \Setup(1^\secpar) \\
      \cid \gets \adv^{\Oforgeissue}(\parm) \\
      \pcif \trans[\cid] = \bot \lor \CRED[\cid] = \bot: \pcreturn 0 \\
      \textrm{Parse}~\CRED[\cid]~\textrm{as}~(\cdot,\cdot,\iid,\cdot,\cdot);~
      \IK[\iid]~\textrm{as}~((\ipk,\fissue),\cdot) \\
      (\usk,\scred,\attrs_{\scred}) \gets \ExtractIssue(\trans[\cid]) \\
      \pcif \fissue(\usk,\scred,\ATTR[\cid]) = 0 \lor
      \exists \cred \in \scred~\st~\Identify(\usk,\attrs_{\cred},\cred) = 0: \\
      \pcind \pcreturn 1 \\
      \pcreturn 0
    }
  \caption{Experiment for unforgeability of credential issuance in \UAS schemes.}
  \label{fig:exp-uas-unfor-issue}
\end{figure}    

\begin{figure}[htp!]
    \procedure[linenumbering]{$\ExpForgeSign(1^\secpar)$}{%
      \parm \gets \Setup(1^\secpar) \\
      (\oid,\siid,\sig,\yeval,\msg,\feval) \gets \adv^{\Oforgesign}(\parm) \\
      \pcif \exists \uid~\st~(\cdot,\cdot,\sig,\yeval,\msg,\feval) \in
      \SIG[\uid]: \pcreturn 0 \\
      \pcif \Verify(\PUBOK[\oid],\PUBIK[\siid],\sig,\yeval,\msg,\feval) = 0:
      \pcreturn 0 \\
      (\yinsp,\iproof) \gets \Inspect(\PRVOK[\oid],\siid,\sig,\yeval,\msg) \\
      \pcif \Judge(\PUBOK[\oid],\PUBIK[\siid],\yinsp,\iproof,\sig,\yeval,\msg,\feval)
      = 0: \pcreturn 1 \\
      (\usk,\scred,\attrs_{\scred},\yinsp',r) \gets \ExtractSign(\oid,\siid,\sig,
      \yeval,\msg,\feval) \\
      \pcif \feval(\usk,\scred,\msg) \neq \yeval: \pcreturn 1 \\
      \pcif \finsp(\yeval,\usk,\scred,\msg) \neq \yinsp \lor \yinsp \neq \yinsp':
      \pcreturn 1 \\
      \pcif \exists \cred \in \scred~\st~\Identify(\usk,\attrs_{\cred},\cred) = 0:
      \pcreturn 1 \\
      \pcreturn 0
    }
  \caption{Experiment for unforgeability of signatures in \UAS schemes.}
  \label{fig:exp-uas-unfor-sign}
\end{figure}

\begin{definition}{(Unforgeable issuance of \UAS)}
  \label{def:issue-forge-uas}  
  We define the advantage \AdvForgeIssue of $\adv$ against \ExpForgeIssue as
  $\AdvForgeIssue=\Pr\lbrack\ExpForgeIssue(1^\secpar)=1\rbrack$.
  %
  A \UAS scheme has unforgeable issuance if, for any p.p.t. adversary $\adv$,
  \AdvForgeIssue is a negligible function of $1^\secpar$.
\end{definition}

\begin{definition}{(Unforgeable signing of \UAS)}
  \label{def:sign-forge-uas}  
  We define the advantage \AdvForgeSign of $\adv$ against \ExpForgeSign as
  $\AdvForgeSign=\Pr\lbrack\ExpForgeSign(1^\secpar)=1\rbrack$.
  %
  A \UAS scheme has unforgeable signing if, for any p.p.t. adversary $\adv$,
  \AdvForgeSign is a negligible function of $1^\secpar$.
\end{definition}

For short, we say that an \UAS scheme that has both unforgeable issuance and
signing, is an unforgeable \UAS scheme.

\paragraph{Discussion on the generality of unforgeability in \UAS schemes.} %
The notion of signature unforgeability we present for \UAS is strictly more
general than the corresponding one of traceability for group signatures. This is
again a direct consequence of the fact that \Open can return an arbitrary
function of the signer's key and credentials (and signed message), whic is a
strict generalization of the conventional \Open. Although, even in that case, we
need to take into account attributes, and the fact that the same user may obtain
multiple credentials (that is why, even when having \Open return the identity of
the signer, our notion is not exactly the same). In this sense, the sign
unforgeability notion for \UAS is equivalent to that of anonymous
credentials. It would seem, though, that we do not need the traceability part of
group signatures; after all, it is the protection against wrong claims on
attributes what enables meaningful and flexible authentication. However, the
type of protection against misuses of the open functionality that we can
get with an honest issuer (as in traceability) is much higher than without an
honest issuer (as in non-frameability). Specifically, with an honest issuer we
can ensure that the adversary cannot even alter the value returned by \Open on
signatures by corrupt users, nor the output of the signing predicate \feval.
Whereas, with a corrupt issuer, all we can ensure is that
the adversary cannot forge a signature from an honest user for which \Open
returns the same value as a signature by that honest user would produce; and,
certainly, a corrupt issuer can arbitrarily issue credentials meeting any
desired predicate \feval. Signing unforgeability is, therefore, a core property
to ensure accountability.

Similarly, by adding the related notion of issuance unforgeability, we ensure
that no credential can be issued that did not meet the corresponding issuance
policy. This is again something not necessary in group signatures (with
verifiable openings), where \Judge accepting the opening proof implies that
there is a valid join transcript associated to the membership credential used
to produce the signature. However, in \UAS, even though that transcript exists,
we need to make sure that the issuance policy was satisfied -- and this is not
something (easily) extractable from the signature.

\paragraph{Non-frameability.} %
Non-frameability variants are a core unforgeability-type property in group
signatures. However, no similar property is modeled for anonymous credentials
(\todo{see the discussion in \secref{sec:introduction} for further detail. Also,
consider conditional anonymity notions pointed to by Elizabeth}). It is a quite
strong property, as it must be ensured even in the presence of dishonest issuer
and opener. Intuitively, it prevents the adversary from creating a signature
that can be (even in some generic sense) associated to an honest user who did
not produce it. Depending on the opening capabilities of the scheme,
this framing could be done in different ways; i.e., by convincing third parties
that signatures by different (possibly corrupt) users are linked, or directly
by having opening proofs output the identity of a user who did not create the
signature being opened.

The notion of non-frameability in \UAS schemes is unavoidably more subtle than
in group signatures, though. To see this, we note that, by allowing arbitrary
evaluation and open functions to be used, it can be perfectly valid to
have a signature produced by a corrupted user output the same \yeval or \yinsp
values than the ones output when evaluating or opening a signature by an honest
user. As a concrete example, imagine an open function that returns the
nationality of the signer. In any country, there will be many users (corrupt or
not) sharing nationality.
%
More generally, since the issuer is dishonest in non-frameability properties
and, in \UAS, the value produced by \Open may depend on the attributes
included in user credentials, the adversary may even be able to just produce
``legitimate'' openings that output any desired value.

Thus, we again need to resort to extraction techniques. In the non-frameability
definition for \UAS, given in experiment \ExpNonframe in
\figref{fig:exp-uas-frame}, the adversary is challenged to produce a signature
and opening proof that is accepted by \Verify and \Judge, respectively. From
the signature, we then extract the secret key of the signer, and match it
against the secret keys of the honest users. The adversary wins if there is a
match and the signature has not been queried to \SIGN. In the game, the
adversary has access to the oracles in $\Oframe \gets \lbrace\HU,\CU\rbrace\GEN,
\lbrace\II,\OO\rbrace\GEN,\lbrace\II,\OO\rbrace\CORR,\WREG,\OBTAIN,\SIGN$.

\begin{figure}[htp!]
  \procedure[linenumbering]{$\ExpNonframe(1^\secpar)$}{%
    \parm \gets \Setup(1^\secpar) \\
    (\oid,\siid,\sig,\yeval,\msg,\feval,\yinsp,\iproof) \gets
    \adv^{\Oframe}(\parm) \\
    \pcif \exists \uid~\st~(\cdot,\cdot,\sig,\yeval,\msg,\feval) \in \SIG[\uid]:
    \pcreturn 0 \\
    \pcif \Verify(\PUBOK[\oid],\PUBIK[\siid],\sig,\yeval,\msg,\feval) = 0:
    \pcreturn 0 \\
    \pcif \Judge(\PUBOK[\oid],\PUBIK[\siid],\yinsp,\iproof,\sig,\yeval,\msg) = 0:
    \pcreturn 0 \\
    (\usk,\scred,\attrs_{\scred},\yinsp',r) \gets
    \ExtractSign(\oid,\siid,\sig,\yeval,\msg,\feval) \\
    \pcif \exists \uid \in \HU~\st~\PRVUK[\uid] = \usk: \pcreturn 1 \\
    \pcreturn 0
  }
  \caption{Experiment for non-frameability on \UAS schemes.}
  \label{fig:exp-uas-frame}
\end{figure}

\begin{definition}{(Non-frameability of \UAS)}
  \label{def:frame-uas}
  We define the advantage \AdvNonframe of $\adv$ against \ExpNonframe as
  $\AdvNonframe=\Pr\lbrack\ExpNonframe(1^\secpar)=1\rbrack$.
  %
  A \GSAC scheme satisfies non-frameability if, for any p.p.t. adversary $\adv$,
  \AdvNonframe is a negligible function of $1^\secpar$.
\end{definition}

\paragraph{Discussion on the generality of non-frameability in \UAS schemes.} %
Anonymous credentials do not have non-frameability property and, thus, it is
hard to make a comparison. However, we can draw some connections with AC schemes
that support revocation, as revocation is somehow equivalent to linking, which
is a type of inspection available in group signatures. In this sense, note that
basic revocation (without straight deanonymization) can be trivially achieved
through our generic \Open function. For instance, one could set \finsp to
be a pseudorandom number seeded with the user's public key (or credential). In
this sense, \Open could be essentially seen as a Verifiable Random Function.
If we compare with group signatures, our notion is also more general than the
conventional one, again for the same reason as sign unforgeability (i.e., \Open
can return any value, not just the signer's identity). Thus, the need to extract
the signer's data in order to detect if a framing has taken place.
  
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "uas"
%%% End:
