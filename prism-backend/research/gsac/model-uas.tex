\subsection{Model for \UAS Schemes}
\label{ssec:model-uas}

\comment{\textbf{DISCLAIMER}: I've done a major rewriting of most
  properties. For now, please ignore the text until I have been able to sync
  it.}

We now define our model for Universal Anonymous Signatures. At a very high
level, it is a combination of the main models for group signatures and
anonymous credentials -- we try to extract the most useful features from both.
Instead of considering just one group, as in group signatures, we directly and
explicitly include support for multiple issuers as in anonymous credentials.
Moreover, instead of letting each user own a single credential, we allow
multiple credentials per user, even within the same group. This of course
makes us put forward refined notions of anonymity, traceability and
non-frameability. Note that, property-wise, we keep the three main properties
from group signatures, rather than sticking to the two usual properties of
anonymous credentials (anonymity and unforgeability). This is a consequence
of keeping the inspection capability from group signatures, which we consider
crucial in order to ensure some sort of accountability even in very adversarial
contexts where the issuer may be corrupt.
%
But, as stated in the introduction, we go beyond just combining anonymous
credentials and group signatures, and include support for arbitrary policies
during issuance, signing, and inspection. Consequently, our model needs to
capture the flexibility that these policies provide. In short, manipulations of
the issuance policy are only considered forgeries if the adversary manages to
create a valid signature using a credential that was obtained by dishonestly
manipulating the issuance policy (we discuss this further in the traceability
definition). Signing policies are taken into account both in the anonymity
property, where we need to restrict that both credentials used to produce the
challenge signatures always satisfy the policy, and in traceability.
\commentwho{Jesus}{Think a bit more about the following claim, and update if
  needed.}
We cannot give any assurance on the signing policies when the issuers are
corrupt, and thus they are not considered in the non-frameability property.
Inspection policies are considered both in traceability and non-frameability,
where the adversary wins if it manages to somehow alter the correct output of
\Inspect. What is even suprising, is that given the possible non-injectivity of
the inspection function lets us reach an even stronger notion of anonymity.
Namely, \uline{we can allow the adversary to open challenge signatures, as
  long as the inspection function outputs the same value for both}. We give more
details on these aspects in the actual definitions of the security properties.
%
Finally, from a functional perspective, we require that both issuer and
inspector fix the issuance predicate \fissue and inspection function \finsp when
generating their public keys. Indeed, both will be part of the common group key.
This also makes our definitions easier, as supporting multiple issuance
predicate and inspection functions per group would require to consider many
special cases -- and, anyway, that would probably end up being equivalent to
just requiring that a new group needs to be created per each $(\fissue,\finsp)$
pair. On the other hand, signing policies can be defined at signing time (in
practice, most probably by the verifiers). This is in line with the usual
practice in anonymous credentials, that let users prove arbitrary claims on
their credentials, as long as they are met by the contained attributes.

\subsubsection{Syntax}
\label{sssec:syntax}

An \UAS scheme is composed by the following algorithms.

\todo{The notation for multisets is not strictly correct. Still, leaving it as
  is for now.} 

\begin{description}
\item[$\parm \gets \Setup(\secpar)$.] Given a security parameter \secpar,
  returns a global system parameter variable \parm.
\item[$(\ipk,\isk) \gets \IKeyGen(\parm,\fissue)$.] Given global system
  parameters \parm, and the function \fissue to be used to check that credential
  requestors meet the conditions to be issued a credential, an issuer runs
  \IKeyGen to generate its issuing key pair. 
\item[$(\opk,\osk) \gets \OKeyGen(\parm,\finsp)$.] Given global system
  parameters \parm, and function \finsp, an inspector runs \OKeyGen to generate
  its inspecting key pair. The function \finsp defines the type of utility that
  will be extractable from those pairs that do not meet conditions defined
  at signing time (typically, by verifiers).
\item[$\usk \gets \UKeyGen(\parm)$.] Given global system parameters
  \parm, returns a user's secret key.
\item[$\langle \cred/\bot,\utrans/\bot \rangle \gets
  \langle
  \Obtain(\usk,\lbrace (\cred_i,\ipk_i)\rbrace_{i \in \Issuers},\attrs),
  \Issue(\isk,\lbrace \ipk_i \rbrace_{i \in \Issuers},\attrs))
  \rangle$.] %
  This interactive protocol lets a user with key \usk running the
  \Obtain process, receive a credential \cred from an issuer in the system, on
  attribute set $\attrs$. The user leverages a set of $(\cred_i,\ipk_i)$ pairs,
  where $\cred_i$ is a credential obtained from the issuer with public
  key $\ipk_i$. The user outputs the produced credential \cred, while
  the issuer outputs the protocol transcript \utrans for the produced
  credential. To ease notation, we assume that the group to which each
  credential belongs is available from the credential itself, and therefore
  omit the $\ipk_i$ values from the syntax, unless necessary to avoid ambiguity.
\item[$(\sig,\yeval) \gets \Sign(\usk,\opk,\lbrace (\cred_i,\ipk_i)
  \rbrace_{i \in \Issuers},\msg,\feval)$.] %
  Upon receiving a user secret key \usk, inspector public key \opk, a set of
  credential-issuer pairs $(\cred_i,\ipk_i)$, a message \msg and evaluation
  function \feval, returns signature \sig and value \yeval.
\item[$1/0 \gets \Verify(\opk, \lbrace \ipk_i \rbrace_{i \in \Issuers},\sig,
  \yeval,\msg,\feval)$.] Checks whether $(\sig,\yeval)$ is a valid signature
  over message \msg, from a user with credentials issued by issuers with public
  keys $\ipk_i$, for evaluation function \feval and inspector key \opk.
\item[$(\yinsp,\iproof)/\bot \gets \Inspect(\osk,\lbrace \ipk_i
  \rbrace_{i \in \Issuers},\sig,\yeval,\msg,\feval)$.] %
  Executed by the inspector with private key \osk. Receives a signature $(\sig,
  \yeval)$ over message \msg and evaluation function \feval, generated using
  credentials issued by the issuers with public keys $\ipk_i$. If \sig is valid,
  the function outputs a value $\yinsp$ derived from the signer's public key,
  credentials, message, and signature, as well as a proof of correct
  inspection.
\item[$1/0 \gets \Judge(\opk,\lbrace ipk_i \rbrace_{i \in \Issuers},\yinsp,
  \iproof,\sig,\yeval,\msg,\feval)$.] %
  Checks if \iproof is a valid inspection correctness proof for the value \yinsp,
  obtained by applying \Inspect to the the signature $(\sig,\yeval)$ over
  message \msg, and for evaluation function \feval. 
\end{description}

\paragraph{Issuance, evaluation, and inspection functions.} %
We emphasize that, both in our syntax definition, as well as on the following
modelling, we make use of three different and abstract functions: \fissue,
\feval and \finsp. The three functions are introduced to allow customized
governance of the resulting instantiation of an \UAS scheme. They will be
defined by different parties, but in all cases, they are run by users (maybe,
on user-private data). Also, in all cases, the user has to prove correctness of
their computation. We introduce them next, \todo{and will give concrete examples
  in \secref{sec:uac-instantiation}.}

\begin{description}
\item[$\fissue: (\upk,\lbrace (\cred_i,\ipk_i) \rbrace_{i \in \Issuers},\attrs)
  \rightarrow 0/1$.] Chosen by issuers within a family of functions \famfissue,
  the issuance function defines what customized conditions an issuer requires
  in order to issue credentials, when receiving a request from user with public
  key \upk, for attributes \attrs. \fissue may run checks on a (possibly empty)
  set of additional credentials $\cred_i$, all bound to \upk, and possibly
  issued by other issuers. \fissue returns $1$ to accept a request, $0$ to
  reject it.
\item[$\feval: (\upk,\lbrace (\cred_i,\ipk_i) \rbrace_{i \in \Issuers},\msg)
  \rightarrow \yeval$.] Evaluation functions, from a family of functions
  \famfeval, can be set on a per-signature basis. The evaluation function
  defines customized conditions to be met by the owner of a user key \upk and
  credentials $\cred_i$, bound to \upk, in order to sign a concrete message
  \msg. Its outputs \yeval must belong in a well defined set \rngfeval.
\item[$\finsp: (\yeval,\upk,\lbrace (\cred_i,\ipk_i) \rbrace_{i \in \Issuers},
  \msg) \rightarrow \yinsp$.]
  Chosen by inspectors from a family of functions \famfinsp. The inspection
  functions define what utility value, derived from the user's public key,
  credentials, and signed message, should be extractable by an inspector.
  Note that \finsp also receives as input a value in the range of the \feval
  function, \rngfeval. This will allow inspection logic to depend on the value
  produced by the evaluation function. The output of \finsp is a value
  \yinsp, which must belong in a well defined set \rngfinsp.
\end{description}

We emphasize that, even though \finsp and \feval seem redundant, they are not.
To see this, observe that \finsp is defined by inspectors, and will be fixed in
all signatures ``inspectable'' by the inspector that defined it. On the other
hand, \feval can be defined by (e.g.) verifiers and, as such, it can be changed
on a per-signature basis, even if the signatures use the same \finsp. Thus,
\feval can (and is intended to) be programmed to contain the conditions set by
(e.g.) verifiers for signatures they receive; whereas \finsp can (and is intended
to) be programmed to extract specific utility values when needed, which may
depend on the checks required by the verifier a signature was intended to.

\paragraph{Helper functions \ExtractIssue and \ExtractSign.} In our modelling,
we assume the existence of two functions, \ExtractIssue and \ExtractSign. They
are not functions available in the actual scheme, but rather to the challenger,
in the experiments we use to formalize security fof \UAS. Indeed, similar
techniques have been used before to prove security in privacy-preserving schemes
with some sort of accountability, but that do not offer conventional opening as
vanilla group signatures. For instance, see related works on DAA
\cite{bfg+11,cdl16} and group signature variants \cite{dl21,fgl21,gl19,lnpy21}
More concretely, both functions are as follows:

\begin{description}
\item[$\ExtractIssue(\utrans) \rightarrow (\usk,\scred)$.] Receives an
$\langle \Obtain, \Issue \rangle$ transcript, and returns the credentials (if
any) and user secret key used during the execution of the protocol. It clearly
needs an honest issuer as, otherwise, the transcripts won't be available.
Consequently, we only use it to define the properties that require an honest
issuer.
\item[$\ExtractSign(\oid,\siid,\sig,\yeval,\msg,\feval) \rightarrow (\usk,\scred)$.]
Receives a signature pair $(\sig,\yeval)$, as well as the inspector identifier
\oid, and the identifiers of all issuers of the credentials used to produce the
signature over \msg, and for \feval. It outputs the user secret key
and credentials used to generate the signature.
\end{description}

Note that, both for \ExtractIssue and \ExtractSign, in the case of transcripts
and signatures by honest users, it is enough to have access to the corresponding
state information (described below) maintained by the challenger in our
experiments. For join transcripts of corrupt users, or dishonestly produced
signatures, we do need to perform actual extraction. How to do this will depend
on each specific construction. Certainly, the challenger needs special
knowledge/power such as decryption trapdoors, the ability to rewind the game, or
program random oracles; the approach needs thus to depend on the concrete
construction. Although, for the case of \ExtractIssue, online extractability
(or alternative requirements, such as non-parallel or logarithmic number of
joins) is necessary. \todo{\needcite Paper from Camenisch and Shoup on the need
  for online extractability?} \todo{How do we do this in our construction(s)?
  Can we be more specific here? Also, this poses an interesting question: Is
  extraction a requirement for this kind of schemes? Can we find alternative
  definitions?}

\paragraph{Global Variables.} %
The environment manages several global variables in the games posed to the
adversary. Users are referred to with user identifiers, \uid; for credentials,
we use \cid; for groups, \gid. For credentials and groups, we use bold font to
denote sets: i.e., \scid and \sgid denote sets of credential and group
identifiers. All tables/sets are initialized as empty tables/sets, denoted
with $\emptyset$.

\begin{description}
\item[Tables for parties]:
  \begin{description}
  \item[\HU and \CU.] Keep track of honest (\HU) and corrupted (\CU) users;
    i.e., they are sets of {\uid}s.
  \item[\HI and \CI.] Keep track of honest (\HI) and corrupted (\CI) issuers;
    i.e., they are sets of {\iid}s.
  \item[\HO and \CO.] Keep track of honest (\HO) and corrupted (\CO) inspectors;
    i.e., they are sets of {\oid}s.
  \end{description}
\item[Tables for keys]:
  \begin{description}
  \item[\UK.] \UK maintains user keys $\usk$. To refer to the key of a specific
    user, we use $\UK[\uid]$. 
  \item[\IK, \PUBIK and \PRVIK.] \IK maintains issuer key pairs, where
    $\IK[\iid]$ refers to the key pair of the issuer with identifier \iid. We
    use \PUBIK to refer to the public component, which also includes the \fissue
    function; and \PRVIK refers to the private component of the key pair.
  \item[\OK, \PUBOK, \PRVOK.] Same as \IK, but for inspector key pairs. Instead
    of \fissue, \OK includes the \finsp function.
  \end{description}
\item[Tables for credentials-related data]:
  \begin{description}
  \item[\CRED.] Stores information related to credentials obtained by users in
    the system. Thus, it is indexable by \cid. More specifically, it stores
    tuples of the form $(\uid,\cred,\iid,\attrs,\scid)$, where \uid is the
    identity of the owner of the credential, \cred (when available) is the
    credential itself, \iid is the identifier of the credential issuer, \attrs
    are the attributes included in \cred, and \scid are the identifiers of the
    credentials (if any) that \uid used to request \cred. For notational
    convenience, we may use $\CRED[\scid]$ to refer to $\CRED[\cid]$ for all
    $\cid \in \scid$. Also, when clear from context, we sometimes use
    $\CRED[\cid]$ (resp. $\CRED[\scid]$ to mean \cred (resp. \scred) in
    $\CRED[\cid] = (\cdot,\cred,\cdot,\cdot,\cdot)$ (resp. $\CRED[\scid]$).
  \item[\OWNR.] For notational convenience, when we write $\OWNR[\cid]$ we mean
    ``\uid such that $\CRED[\cid] = (\uid, \cdot, \cdot, \cdot, \cdot)$''.
  \item[\ATTR.] For notational convenience, when we write $\ATTR[\cid]$ we mean
    ``\attrs such that $\CRED[\cid] = (\cdot, \cdot, \cdot, \attrs, \cdot)$''.
  \item[\ISR.] For notational convenience, when we write $\ISR[\cid]$ we mean
    ``\iid such that $\CRED[\cid] = (\cdot, \iid, \cdot, \cdot, \cdot)$''.
  \end{description}
\item[Tables for signatures]:
  \begin{description}
  \item[\SIG.] Maintains signatures generated via the \SIGN oracle, on behalf
    of honest users. Entries of this table are $(\oid,\scid,\sig,\yeval,\msg,
    \feval)$, where \oid is the inspector chosen for the signature, \scid is the
    set of credentials used for signing, \feval is the evaluation function, and
    \sig and \msg are the produced signature and signed message.
  \item[\CSIG.] Maintains challenge signatures output to the adversary; i.e.,
    the table is indexable by challenge signatures \csig.
    Each entry contains also $\cuid_b$ and $\scid_b$ the challenge user and
    credential identifiers set used to produce \csig; as well as the
    corresponding challenge user and credential set indexed by the complementary
    $1-b$; the signed message \msg and evaluation function \feval, the result of
    \feval, \yeval, and the inspector identifier \oid.
  \end{description}
\end{description}

\paragraph{Oracles.} %
Oracles are the interface of the adversary with the corresponding games. In
other words: through these oracles, the game environment exposes to the adversary
functionality that could otherwise be executed only by honest parties with
private knowledge -- knowledge that would make the adversary capable of
trivially breaking the security properties formalized in the experiments.
In the game-based definitions of our \UAS model, we leverage the following
oracles, which are formally defined in \figref{fig:oracles1} and
\figref{fig:oracles2}. 

\begin{description}
\item[\IGEN.] Adds a new issuer to the game, generating its keypair and setting
  the associated issuance function.
\item[\OGEN.] Adds a new inspector to the game, generating its key pair and
  setting the associated evaluation and inspection functions.
\item[\ICORR.] Corrupts an existing (and honest) issuer, by giving its secret
  key to the adversary.
\item[\OCORR.] Corrupts an existing (and honest) inspector, by giving its secret
  key to the adversary.  
\item[\HUGEN.] Adds a new honest user to the game, by honestly generating
  the user's key pair.
\item[\CUGEN.] Adds a new corrupt user to the game or, if the specified
  user already exists and is honest, corrupts it.
\item[\RREG.] Reads the given transcript table entry.
\item[\WREG.] Sets a transcript table entry to the given value.
\item[\OBTISS.] Lets the adversary add a new honestly generated credential to
  the game, on behalf of an honest user.
\item[\OBTAIN.] Enables the adversary to play the role of a dishonest issuer
  in games that support it, by letting it interact with honest users who want to
  receive credentials.
\item[\ISSUE.] Allows the adversary to play the role of dishonest users,
  requesting an honest issuer to produce credentials for them.
\item[\SIGN.] Lets the adversary get signatures from credentials belonging
  to honest users.
\item[\OPEN.] Given an honestly produced signature, lets the adversary learn
  which credential was used to produce it.
\item[\CHALb.] Upon receiving two challenge credentials, a common intersecting
  set of attributes, and a message, returns a signature produced by one of these
  two credentials, defined by the bit $b$, which is established in the anonymity
  game.
\end{description}

{%\setlength\intextsep{\sep}
  \begin{figure*}[htp!]
    \centering
    \scalebox{0.9}{

      \begin{minipage}[t]{0.55\textwidth}       

        \procedure{$\IGEN(\iid,\fissue)$}{%
          \pcif \iid \in \HI \lor \iid \in \CI: \pcreturn \bot \\
          \pcif \fissue \notin \famfissue: \pcreturn \bot \\
          (\ipk,\isk) \gets \IKeyGen(\parm) \\
          \IK[\iid] \gets ((\ipk,\fissue),\isk) \\
          \HI \gets \HI \cup \lbrace \iid \rbrace \\
          \pcreturn \ipk \\
        }

        \procedure{$\ICORR(\iid)$}{%
          \pcif \iid \in \CI \lor \iid \notin \HI: \pcreturn \bot \\
          \HI \gets \HI \setminus \lbrace \iid \rbrace \\
          \CI \gets \CI \cup \lbrace \gid \rbrace \\
          \pcreturn \isk \\
        }        

        \procedure{$\HUGEN(\uid)$}{%
          \pcif \uid \in \HU \lor \uid \in \CU: \pcreturn \bot \\
          (\upk,\usk) \gets \UKeyGen(\parm) \\
          \UK[\uid] \gets (\upk,\usk);
          \HU \gets \HU \cup \lbrace  \uid \rbrace \\
          \pcreturn \top \\
        }

        \procedure{$\RREG(i)$}{%
          \pcreturn \trans[i]
        }        
        
      \end{minipage}
    }
    \scalebox{0.9}{
      
      \begin{minipage}[t]{.5\textwidth}

        \procedure{$\OGEN(\oid,\finsp)$}{%
          \pcif \oid \in \HO \lor \oid \in \CO: \pcreturn \bot \\
          \pcif \finsp \notin \famfinsp: \pcreturn \bot \\
          (\opk,\osk) \gets \OKeyGen(\parm) \\
          \OK[\oid] \gets ((\opk,\finsp),\osk) \\
          \HO \gets \HO \cup \lbrace \oid \rbrace \\
          \pcreturn \opk \\
        }

        \procedure{$\OCORR(\oid)$}{%
          \pcif \oid \in \CO \lor \oid \notin \HO: \pcreturn \bot \\
          \HO \gets \HO \setminus \lbrace \oid \rbrace \\
          \CO \gets \CO \cup \lbrace \oid \rbrace \\
          \pcreturn \osk \\
        }        
        
        \procedure{$\CUGEN(\uid,\upk)$}{%          
          \pcif \uid \in \CU: \pcreturn \bot \\
          \CU \gets \CU \cup \lbrace \uid \rbrace \\          
          \pcif \uid \in \HU: \\
          \pcind \HU \gets \HU \setminus \lbrace \uid \rbrace; \\
          \pcind \pcreturn (\UK[\uid],\CRED[\uid]) \\
          \pcelse: \UK[\uid] = (\upk,\bot) \\          
          \pcreturn \top \\
        }

        \procedure{$\WREG(i,\rho)$}{%
          \trans[i] \gets \rho
        }        
        
      \end{minipage}
      
    }

    \caption{Detailed oracles available in our model (1/2). Oracles for
      generating key material for users, issuers, and inspectors.}
    \label{fig:oracles1}
  \end{figure*}
}

{%\setlength\intextsep{\sep}
  \begin{figure*}[htp!]
    \centering
    \scalebox{0.9}{

      \begin{minipage}[t]{0.55\textwidth}

        \procedure{$\ISSUE(\cid,\uid,\iid,\attrs,\siid)$}{%
          \pcif \uid \notin \CU: \pcreturn \bot \\          
          \pcif \iid \notin \HI: \pcreturn \bot \\
          \pcif \exists \iid' \in \ISR[\scid] \notin \HI: \pcreturn \bot \\
          \pcif \CRED[\cid] \neq \bot: \pcreturn \bot \\
          \langle \cdot, \utrans \rangle \gets
          \langle \adv, 
          \Issue(\PRVIK[\iid],\siid,\attrs) \rangle \\
          \trans[\cid] \gets \utrans \\
          \CRED[\cid] \gets (\uid, \cdot, \iid, \attrs, \cdot, \siid) \\
          \pcreturn \top \\          
        }                

        \procedure{$\OBTAIN(\cid,\uid,\iid,\attrs,\scid)$}{%
          \pcif \uid \notin \HU: \pcreturn \bot \\
          \pcif \iid \notin \CI: \pcreturn \bot \\
          \pcif \CRED[\cid] \neq \bot: \pcreturn \bot \\
          \pcif \exists \cid' \in \scid~\st~\CRED[\cid'] = \bot: \pcreturn \bot \\
          \langle \cred, \cdot \rangle \gets
          \langle \Obtain(\PRVUK[\uid],\CRED[\scid],\attrs),\adv \rangle \\
          \CRED[\cid] \gets (\uid, \cred, \iid, \attrs, \scid, \siid) \\
          \pcreturn \top \\
        }

        \procedure{$\CHALb(\oid,\cuid_{0,1},\cscid_{0,1},\msg,\feval)$}{%
          \pcif \cuid_0 \notin \HU \lor \cuid_1 \notin \HU: \pcreturn \bot \\
          \pcif \oid \in \CO: \pcreturn \bot \\
          \pcif \yeval = \feval(\PUBUK[\cuid_0],\CRED[\cscid_0],\msg) \neq \\
          \pcind \feval(\PUBUK[\cuid_1],\CRED[\cscid_1],\msg):
          \pcreturn \bot \\
          (\yeval,\csig_b) \gets \Sign(\PRVUK[\cuid_b],\PUBOK[\oid], \\
          \hspace*{71pt}\CRED[\cscid_b],\msg,\feval) \\
          (\yeval,\csig_{1-b}) \gets \Sign(\PRVUK[\cuid_{1-b}],\PUBOK[\oid], \\
          \hspace*{80pt}\CRED[\cscid_{1-b}],\msg,\feval) \\          
          \CSIG[\csig_b] \gets 
          \lbrace (\oid,\cuid_b,\cscid_b,\msg,\feval,\yeval,\\
          \hspace*{74pt}\cuid_{1-b},\csig_{1-b},\cscid_{1-b})
          \rbrace \\
          \pcreturn \csig_b
        }        
        
      \end{minipage}
    }
    \scalebox{0.9}{
      
      \begin{minipage}[t]{.5\textwidth}

        \procedure{$\OBTISS(\cid,\uid,\iid,\attrs,\scid)$}{%
          \pcif \uid \notin \HU: \pcreturn \bot \\
          \pcif \iid \notin \HI: \pcreturn \bot \\
          \pcif \CRED[\cid] \neq \bot: \pcreturn \bot \\
          \pcif \exists \iid' \in \ISR[\scid]~\st~\iid' \notin \HI: \pcreturn \bot \\
          \pcif \exists \cid' \in \scid~\st~\CRED[\cid'] = \bot:
          \pcreturn \bot \\
          \langle \cred, \utrans \rangle \gets
          \langle \Obtain(\PRVUK[\uid],\CRED[\scid],\attrs), \\
          \hspace*{60pt} \Issue(\PRVIK[\iid],\ISR[\scid],\attrs)
          \rangle \\
          \trans[\cid] \gets \utrans \\
          \CRED[\cid] \gets (\uid, \cred, \iid, \attrs, \scid, \siid) \\
          \pcreturn \top \\
        }

        \procedure{$\SIGN(\oid,\uid,\scid,\msg,\feval)$}{%
          \pcif \uid \notin \HU: \pcreturn \bot \\
          (\sig,\yeval) \gets \Sign(\PRVUK[\uid],\PUBOK[\oid],\CRED[\scid],\msg,
          \feval) \\
          \SIG[\uid] \gets \SIG[\uid] \cup
          \lbrace (\oid,\scid,\sig,\yeval,\msg,\feval) \rbrace \\
          \pcreturn \sig \\
        }                

        \procedure{$\INSPECT(\oid,\sig,\yeval,\msg)$}{%
          \textrm{Let}~\uid~\textrm{be s.t.}~(\oid,\scid,\sig,\yeval,\msg,\feval)
          \in \SIG[\uid] \\
          (\yinsp,\iproof) \gets
          \Inspect(\PRVOK[\oid],\GK[\scid],\sig,\yeval,\msg,\feval) \\
          \pcif \CSIG[\sig] \neq \bot: \\
          \pcind \textrm{Parse $\CSIG[\sig]$ as $(\oid,\cuid_b,\scid_b,\msg,
            \feval,\yeval$} \\
          \hspace*{83pt}\cuid_{1-b},\csig_{1-b},\scid_{1-b}) \\
          \pcind (\yinsp',\iproof') \gets
          \Inspect(\PRVOK[\oid],\IK[\siid],\\
          \hspace*{107pt} \sig_{1-b},\msg,\feval) \\
          \pcind \pcif \yinsp' \neq \yinsp: \pcreturn \bot \\
          \pcreturn (\yinsp,\iproof)
        }
        
      \end{minipage}
      
    }

    \caption{Detailed oracles available in our model (2/2). Oracles for
      obtaining credentials, signatures, and processing them.}
    \label{fig:oracles2}
  \end{figure*}
}

\paragraph{Correctness.} %
Correctness of \UAS schemes is formalized through the experiment in
\figref{fig:exp-uas-corr}. It states that a signature over any arbitrary message
and valid function \feval produced honestly leveraging credential set \scid,
owned by user \uid, is accepted by \Verify. Moreover, all the credentials in
\scid met the conditions set by the corresponding \fissue defined by the issuer
which issued each credential. Similarly, the output \yeval of \feval matches the
value produced by \Sign alognside with \sig; and the value produced by \Inspect
is accepted by \Judge, and matches the output of applying \finsp on \yeval, the
credentials, user key, and message.

\begin{definition}{(Correctness of \UAS)}
  \label{def:correctness-uas}
  An \UAS scheme is correct if, for any p.p.t. adversary $\adv$, \ExpCorrect
   outputs 1 with negligible probability.
\end{definition}

\begin{figure}[htp!]
  \procedure{$\ExpCorrect(1^\secpar)$}{%
    \parm \gets \Setup(1^\secpar) \\
    (\uid,\oid,\scid,\msg,\feval)
    \gets \adv^{\IGEN,\OGEN,\HUGEN,\OBTISS,\RREG}(\parm) \\
    \pcif \feval \notin \famfeval: \pcreturn 0 \\
    \pcif \OWNR[\scid] \neq \uid: \pcreturn 0 \\
    (\sig,\yeval) \gets \Sign(\PRVUK[\uid],\PUBOK[\oid],\scid,\msg,\feval) \\
    \pcif \Verify(\PUBOK[\oid],\PUBIK[\scid],\sig,\msg,\feval) = 0: \pcreturn 1 \\
    \pcfor \cid \in \scid \pcdo: \\
    \pcind \textrm{Let}~\scred^{\cid}~\textrm{be the credentials used to obtain}
    ~\cid;~\textrm{Parse}~\PUBIK[\ISR[\cid]]~\textrm{as}~((\cdot,\fissue^{\cid}),\cdot)\\
    \pcind \pcif \fissue^{\cid}(\PUBUK[\uid],\scred^{\cid},\ATTR[\cid]) = 0: \pcreturn 1 \\
    \pcif \feval(\UK[\uid],\CRED[\scid],\msg) \neq \yeval: \pcreturn 1 \\
    (\yinsp,\iproof) \gets \Inspect(\PRVOK[\gid],\PUBIK[\scid],\sig,\msg,\feval) \\
    \pcif \Judge(\PUBOK[\oid],\PUBIK[\scid],\y,\iproof,\sig,\yeval,\msg,\feval)
    = 0 \lor \yinsp \neq \finsp^\gid(\yeval,\UK[\uid],\CRED[\scid],\msg)): \\
    \pcind \pcreturn 1 \\
    \pcreturn 0
  }
  
  \caption{Correctness experiment for \UAS schemes.}
  \label{fig:exp-uas-corr}
\end{figure}

\subsubsection{Security Properties}
\label{sssec:security}

% \paragraph{Extractability.} %
% \commentwho{Jesus}{I have a doubt here. On one hand, modelling the
%   extractability-related properties here as in \cite{lnpy21} would lead to
%   redundancy with the current unforgeability properties. I do like the
%   precission in the definition of \cite{lnpy21}; but I do not like that,
%   within the extractability property, they include ``domain-specific''
%   concepts (e.g., open, etc.) On the other hand, we could model extractability
%   as (an extension of) the Identify approach in e.g. \cite{gl19,dl21}. What
%   I like about that is that it would not be redundant (we just assume the
%   existance of a function extracting some secret values). What I do not like,
%   is that the definition is not as precise as in \cite{lnpy12}. Namely, at the
%   design stage, one just has to informally describe what Identify-Extract does;
%   then, what it *really* does, has to be defined in the security proofs. That
%   is, its definition is somehow deferred, which makes the presentation a bit
%   harder to follow, IMO.}

% Before getting into the ``actual'' security properties, we introduce an
% auxiliary yet crucial property, extractability, that will allow us to formally
% define unforgeability-related properties in a meaningful way. More concretely,
% we require issuance extractability, and signing extractability. Informally, with
% issuance extractability we require that given an additional trapdoor generated
% at setup time, it is possible to extract the witnesses (user secret key and
% credentials) used to request issuance of a new credential, from its $\langle
% \Obtain,\Issue \rangle$ transcript. With signing extractability, we refer to the
% requirement to be able to extract, given an additional trapdoor, the user secret
% key and credentials used to produce any (possibly maliciously generated)
% signature. The need to differentiate both comes from the fact that, for issuance
% extractability, we need to assume honest issuers -- as otherwise, the $\langle
% \Obtain,\Issue\rangle$ transcripts may
% just not exist. Other than that, both properties are essentially the same: given
% some proof an instance of an NP relation, they allow extracting the
% corresponding witnesses. The need to resort to this extraction technique comes
% from the fact of not including a conventional opening functionality. Indeed,
% this has been used (at times, somehow implicitly) in related works on DAA
% \cite{bfg+11,cdl16} and group signature variants \cite{dl21,fgl21,gl19,lnpy21}.

% In more detail, we require the existence of three additional algorithms,
% \ExtractSetup, \ExtractIssue, and \ExtractSign, as follows:

% \begin{description}
% \item[$\ExtractSetup(1^\secpar) \rightarrow (\parm,\extracttrap)$.] \todo{Describe,
%     and mention that it must be indistinguishable from \Setup.}
% \item[$\ExtractIssue(\extracttrap,\utrans) \rightarrow (\usk,\scred)$.] \todo{Describe.}
% \item[$\ExtractSign(\extracttrap,\oid,\siid,\sig,\yeval,\msg,\feval) \rightarrow (\usk,\scred)$.]
%   \todo{Describe.}
% \end{description}

% With these algorithms, we formally define the issuance extractability and
% signing extractability properties as shown in \figref{fig:exp-uas-extract}.

% \begin{figure}[htp!]
%   \procedure{$\ExpExtractIssue(\utrans)$}{%
%     \pcreturn (\usk,\scred) \\    
%   }

%   \procedure{$\ExpExtractSign(\oid,\siid,\sig,\yeval,\msg,\feval)$}{%
%     \pcreturn (\usk,\scred)
%   }
  
%   \caption{Issuance and signing extractability experiments for \UAS schemes.}
%   \label{fig:exp-uas-extract}
% \end{figure}

% \begin{definition}{(Extractable issuance of \UAS)}
%   We define the advantage \AdvExtractIssue of $\adv$ against \ExpExtractIssue as
%   $\AdvExtractIssue=\Pr\lbrack\ExpExtractIssue(1^\secpar)=1\rbrack$.
%   %
%   A \UAS scheme has extractable issuance if, for any p.p.t. adversary $\adv$,
%   \AdvExtractIssue is a negligible function of $1^\secpar$.
% \end{definition}

% \begin{definition}{(Extractable signing of \UAS)}
%   We define the advantage \AdvExtractSign of $\adv$ against \ExpExtractSign as
%   $\AdvExtractSign=\Pr\lbrack\ExpExtractSign(1^\secpar)=1\rbrack$.
%   %
%   A \UAS scheme has extractable signing if, for any p.p.t. adversary $\adv$,
%   \AdvExtractSign is a negligible function of $1^\secpar$.
% \end{definition}

% For short, we say that an \UAS scheme that has both extractable issuance and
% signing, is an extractable \UAS scheme.

\paragraph{Anonymity.} %
In group signatures, anonymity captures that no adversary must be able to learn,
from any group signature, the identity (e.g., member index) of its signer. In 
anonymous credentials, it requires that no adversary should learn anything about
the holder of a successfully shown credential, beyond that he owns a credential
attesting for the claimed predicate of the attributes it contains. In both GS
and AC, it is also typically required that
multiple signatures/presentations by the users are unlinkable. The approach to
formally state this property is in both cases frequently the same: the adversary
picks two (honest) users (or credentials in the AC case), the game randomly
chooses one of them, and lets the adversary request challenge
signatures/presentations from it. The adversary wins if it succeeds in guessing
which was the chosen user/credential better than guessing at random. In group
signatures, the game must also restrict the adversary from opening challenge
signatures. In anonymous credentials, the game must further constraint the
adversary to output credentials that both meet the same (challenge) predicate
of their attributes.

In our notion of anonymity for \UAS, we need to merge the previous constraints.
In order to prevent trivial wins by the adversary, we have to restrict that the
evaluation function outputs the same value for both user-credentials pairs. Very
interestingly, since our inspection functionality does not (necessarily) output
the identity of the signer, \uline{we can even allow the adversary to
  inspect challenge signatures, as long as they produce the same output upon
  inspection}. Other than this, the overall approach is similar: as in group
signatures and anonymous credentials, the adversary picks two pairs of honest
users and credential sets. We also require the adversary to pick an evaluation
function and an inspector (hence, an inspection function). Then, the
user-credential pair defind by the value of $b$ (unknown to the adversary) is
used to program the \CHALb oracle. The formal specification of the anonymity
game is given in \figref{fig:exp-uas-anonb}, where $\Oanonc \gets (\lbrace\HU,
\CU\rbrace\GEN,\lbrace\II,\OO\rbrace\GEN,\lbrace\II,\OO\rbrace\CORR,\OBTAIN,
\WREG,\SIGN,\INSPECT)$ and $\Oanong \gets (\lbrace\HU,\CU\rbrace\GEN,\lbrace\II,
\OO\rbrace\GEN,\lbrace\II,\OO\rbrace\CORR,\OBTAIN,\WREG,\SIGN,\INSPECT,\CHALb)$

\begin{figure}[htp!]
  \procedure{$\ExpAnonb(1^\secpar)$}{%
     \parm \gets \Setup(1^\secpar) \\
     (\cuid_0,\cscid_0,\cuid_1,\cscid_1,\feval,\status) \gets \adv^{\Oanonc}
     (\choose,\parm) \\
     \pcif \feval \notin \famfeval: \pcreturn \bot \\
     b^* \gets \adv^{\Oanong} (\guess,\status) \\
     \pcreturn b^*
  }
  \caption{Anonymity experiment for \UAS schemes.}
  \label{fig:exp-uas-anonb}
\end{figure}

\begin{definition}{(Anonymity of \UAS)}
  \label{def:anonymity-uas}  
  We define the advantage \AdvAnon of $\adv$ against \ExpAnonb as
  $\AdvAnon=|\Pr\lbrack\ExpAnono(1^\secpar)=1\rbrack-
  \Pr\lbrack\ExpAnonz(1^\secpar)=1\rbrack|$.
  %
  An \UAS scheme satisfies anonymity if, for any p.p.t. adversary $\adv$,
  \AdvAnon is a negligible function of $1^\secpar$.
\end{definition}

\paragraph{Discussion on the generality of anonymity in \UAS schemes.} %
This notion of anonymity is more general than that of group signatures in the
sense that calls to the \INSPECT oracle reveal an arbitrary function of the
identity of the user -- which can certainly be the member index itself, as it
is frequent in group signatures, or any other function computable from the
user public key, its credentials, and produced signature. Moreover, note that
our notion is even stronger than the conventional ``CCA-like'' anonymity notion
that gives the adversary access to the open oracle, only restricting it when
trying to open challenge signature. Precisely the introduction of generic
inspection functions allows us to \uline{\emph{let the adversary open
    challenge signatures $\csig_b$}} as long as the counterpart $\csig_{1-b}$
makes \Inspect produce the same \y value as output. This is certainly not
possible when using conventional opening, since it directly outputs the identity
of the signer -- which cannot be the same for different challenge users.

Note that we could actually remove the requirement that the evaluation function
has to produce the same output on both challenge user-credentials pairs.
However, by doing so, we would force all constructions to maintain private the
output of \feval. We opt not to require that, though, as it directly allows
our model to cover interesting use cases -- such as restricting to selective
disclosure, or privacy-preserving variants of functional signatures \todo{check
  the latter, and perhaps expand}.

\paragraph{Unforgeability.} In anonymous credentials, unforgeability requires
that no adversary can succeed in a credential presentation for attributes that
are not contained in a legitimately issued credential (set) it controls. Note
that, for this, assuming honest issuers is essential as, otherwise, the
adversary can get credentials on any attribute set it wants.
%
The somehow equivalent property in group signatures, inasmuch it also requires
honest issuers, is traceability. It captures the security of the
inspection-related functionality (e.g., \Inspect and \Judge) over signatures
that produced by potentially malicious signers, in the presence of an honest
issuer. In a nutshell, it ensures that every signature accepted by
the verification algorithm must have been created by a user who joined the
group, and that the result of \Inspect (and thus, \Judge) over such a valid
signature is consistent with its signer. With conventional opening, this is
essentially checked by requesting the adversary to produce a signature,
obtaining -- via open -- the ``identifier'' of the user who produced the
signature. Schemes
that do not have conventional opening resort to more subtle techniques, like
matching keys extracted during join transcripts, with keys used for signing
(see, e.g., \cite{dl21}). Thus, even though for more subtle reasons (the need
for reliable bookkeeping during joins) than for anonymous credentials, honest
issuers are required for traceability of group signatures too.

In \UAS schemes, users can prove claims over the attributes they own
-- attested via obtained credentials -- through the \feval function. Thus, we
need to capture the same unforgeability requirement as in anonymous credentials.
Namely, that the \yeval value returned by \Sign along with the signature,
matches the expected one from the specified \feval function.
On the other hand, the inspection capabilities of \UAS schemes also call for a
traceability-like property. However, note that, as opposed to group signatures,
$\langle \Obtain,\Issue \rangle$ protocols are over credentials rather than
users -- although, ultimately, credentials must be owned by some user.
However, we need to ensure that all signatures have been produced by credentials
that have been obtained from an (honest) issuer. Furthermore, since \Inspect
does not return the actual identity of the signer, but a function \finsp of it
(and other arguments), we need to make sure that the output of \Inspect
matches the output of \finsp. As in group signatures with non-conventional open,
we resort to extraction-based techniques. All this is captured via \ExpForgeSign
in \figref{fig:exp-uas-unfor-issue}. Therein, the adversary is challenged to
produce a signature $(\sig,\yeval)$ over message \msg and for evaluation
function \feval; as well as the identifiers for the inspector (\oid) and
credential issuers (\siid) used to compute the signature. As in traditional
group signatures, the adversary wins if the signature is accepted by \Verify,
yet \Inspect or \Judge fail. Then, the game extracts the user key and
credentials used to produce the signature. From it, the game checks if the
output of \feval matches the \yeval value produced by the adversry -- this
mimics the behaviour of unforgeability in anonymous credentials. Finally, the
game also checks that the output of \Inspect (even if accepted by \Judge)
matches the output of \finsp. If there is any mismatch in the last two checks,
the adversary wins the game.

\UAS schemes include yet another generalisation that requires unforgeability-like
security, though. Concretely, the issuance function \fissue. Thus, an \UAS
scheme needs to make sure that no credential is issued unless its corresponding
request meets the defined issuance policy. From the point of view of group
signatures, this may seem redundant. After all, if all valid signatures produce
consistent evaluation and inspection results, given the employed user key,
credentials, and signed message, the notion of traceability seems to be
satisfied. However, from the point of view of anonymous credentials, an attacker
being able to obtain a credential, even though it does not meet the required
conditions to have it issued, is clearly problematic: it would allow to prove
claims over attributes it does not really ``own'' (even if the output of \Sign
and \Inspect are consistent with the values returned by \feval and \finsp, and
the credential was obtained via an $\langle \Obtain,\Issue \rangle$). To capture
this, we define the \ExpForgeIssue experiment. In the experiment, the adversary
is challenged to produce a credential identifier that must be associated to an
existing $\langle \Obtain,\Issue \rangle$ interaction -- thus, the corresponding
\trans entry must exist (which we can check, as the issuer is honest).
The adversary wins if, either the extraction process fails, or the extracted
user secret key and credentials make the corresponding issuance function fail.

For both \ExpForgeIssue and \ExpForgeSign, the adversary is given access to the
oracle set $\Oforgeissue = \Oforgesign \gets \lbrace\HU,\CU\rbrace\GEN,\IGEN,
\OGEN,\OCORR,\OBTISS,\ISSUE,\RREG,\SIGN,\INSPECT$.

\begin{figure}[htp!]
    \procedure{$\ExpForgeIssue(1^\secpar)$}{%
      \parm \gets \Setup(1^\secpar) \\
      \cid \gets \adv^{\Oforgeissue}(\parm) \\
      \pcif \trans[\cid] = \bot \lor \CRED[\cid] = \bot: \pcreturn 0 \\
      \textrm{Parse}~\CRED[\cid]~\textrm{as}~(\cdot,\cdot,\iid,\cdot,\cdot);~
      \IK[\iid]~\textrm{as}~((\ipk,\fissue),\cdot) \\
      w \gets \ExtractIssue(\trans[\cid]) \\
      \pcif w = \bot: \pcreturn 1 \\
      \textrm{Parse}~w~\textrm{as}~(\usk,\lbrace (\cred_i,\ipk_i)
      \rbrace_{i \in \Issuers})  \\      
      \pcif \fissue(\usk,\lbrace (\cred_i,\ipk_i) \rbrace_{i \in \Issuers},
      \ATTR[\cid]) = 0: \pcreturn 1 \\
      \pcreturn 0
    }
  \caption{Experiment for unforgeability of credential issuance in \UAS schemes.}
  \label{fig:exp-uas-unfor-issue}
\end{figure}    

\begin{figure}[htp!]
    \procedure{$\ExpForgeSign(1^\secpar)$}{%
      \parm \gets \Setup(1^\secpar) \\
      (\oid,\siid,\sig,\yeval,\msg,\feval) \gets \adv^{\Oforgesign}(\parm) \\
      \pcif \exists \uid~\st~(\cdot,\cdot,\sig,\yeval,\msg,\feval) \in
      \SIG[\uid]: \pcreturn 0 \\
      \pcif \Verify(\PUBOK[\oid],\PUBIK[\siid],\sig,\yeval,\msg,\feval) = 0:
      \pcreturn 0 \\
      (\yinsp,\iproof) \gets \Inspect(\PRVOK[\oid],\siid,\sig,\yeval,\msg) \\
      \pcif \yinsp = \bot \lor \iproof = \bot \lor       
      \Judge(\PUBOK[\oid],\PUBIK[\siid],\yinsp,\iproof,\sig,\yeval,\msg,\feval)
      = 0: \pcreturn 0 \\
      (\usk,\scred) \gets \ExtractSign(\oid,\siid,\sig,\yeval,\msg,\feval) \\
      \pcif \feval(\usk,\scred,\msg) \neq \yeval: \pcreturn 1 \\
      \pcif \finsp(\yeval,\usk,\scred,\msg) \neq \yinsp: \pcreturn 1 \\
      \pcreturn 0
    }
  \caption{Experiment for unforgeability of signatures in \UAS schemes.}
  \label{fig:exp-uas-unfor-sign}
\end{figure}

\begin{definition}{(Unforgeable issuance of \UAS)}
  \label{def:issue-forge-uas}  
  We define the advantage \AdvForgeIssue of $\adv$ against \ExpForgeIssue as
  $\AdvForgeIssue=\Pr\lbrack\ExpForgeIssue(1^\secpar)=1\rbrack$.
  %
  A \UAS scheme has unforgeable issuance if, for any p.p.t. adversary $\adv$,
  \AdvForgeIssue is a negligible function of $1^\secpar$.
\end{definition}

\begin{definition}{(Unforgeable signing of \UAS)}
  \label{def:sign-forge-uas}  
  We define the advantage \AdvForgeSign of $\adv$ against \ExpForgeSign as
  $\AdvForgeSign=\Pr\lbrack\ExpForgeSign(1^\secpar)=1\rbrack$.
  %
  A \UAS scheme has unforgeable signing if, for any p.p.t. adversary $\adv$,
  \AdvForgeSign is a negligible function of $1^\secpar$.
\end{definition}

For short, we say that an \UAS scheme that has both unforgeable issuance and
signing, is an unforgeable \UAS scheme.

\paragraph{Discussion on the generality of unforgeability in \UAS schemes.} %
\todo{Re-check and re-write as needed}.
The notion of traceability we present for \UAS is strictly more general than
the corresponding one for group signatures. This is again a direct
consequence of the fact that \Inspect, which can return an arbitrary function
of the signer's credential (and signed message), is a generalization of the
conventional \Open -- if we make \Inspect return just the identity of the
signer, then we get something similar to the usual notion of traceability.
Although, even in that case, we need to take into account attributes, and the
fact that the same user may obtain multiple credentials (that is why, even when
having \Inspect return the identity of the signer, our notion is not exactly
the same). And, in this sense, the unforgeability notion that \UAS have is
equivalent to that of anonymous credentials. It would seem, though, that we do
not need the traceability part of group signatures; after all, it is the
protection against wrong claims on attributes what enables meaningful and
flexible authentication. However, the type of protection against misuses of
the inspection functionality that we can get with an honest issuer (as in
traceability) is much higher than without an honest user (as in
non-frameability). Specifically, with an honest issuer we can ensure that
the adversary cannot even alter the value returned by \Inspect on signatures
by corrupt users, nor the output of the signing predicate \feval. Whereas, with
a corrupt issuer, all we can ensure is that
the adversary cannot forge a signature from an honest user for which \Inspect
returns the same value as a signature by that honest user would produce; and,
certainly, a corrupt issuer can arbitrarily issue credentials meeting any
desired predicate \feval .Traceability is, therefore, a core property to ensure
accountability.

Note also that we have implicitly assumed an unforgeability relaxation in the
sense that we do not consider a forgery the fact that an adversary can obtain
credentials that do not meet the \fissue predicate \emph{as long as they are
  not used to produced untraceable signatures}. Indeed, this is in line with
previous work \cite[Section 3.3.3]{ckl+15}, and it does make sense as, in the
real world, being able to fraudulently obtain credentials that cannot be later
used to authenticate, does not pose a risk. However, an adversary breaking
the issue policy defined by \fissue to get a credential and later using it to
create a valid signature (i.e., meeting \feval or \finsp) is considered a
forgery by our definition.

\paragraph{Non-frameability.} %
Non-frameability variants are a core unforgeability-type property in group
signatures. However, no similar property is modeled for anonymous credentials
(\todo{see the discussion in \secref{sec:introduction} for further detail. Also,
consider conditional anonymity notions pointed to by Elizabeth}). It is a quite
strong property, as it must be ensured even in the presence of dishonest issuer
and opener. Intuitively, it prevents the adversary from creating a signature
that can be (even in some generic sense) associated to an honest user who did
not produce it. Depending on the inspection capabilities of the scheme,
this framing could be done in different ways; i.e., by convincing third parties
that signatures by different (possibly corrupt) users are linked, or directly
by having inspection proofs output the identity of a user who did not create the
signature being inspected.

The notion of non-frameability in \UAS schemes is unavoidably more subtle than
in group signatures, though. To see this, we note that, by allowing arbitrary
evaluation and inspection functions to be used, it can be perfectly valid to
have a signature produced by a corrupted user output the same \yeval or \yinsp
values than the one that \feval or \finsp output when evaluating or inspecting
a signature by an honest user. As a concrete example, imagine an inspection
function that returns the banking account number (or cryptocurrency address) to
be used to request payment of a fine. In this example, a corrupted user and an
honest user could both have delegated this to some agency\footnote{\todo{Maybe,
    come up with a better example. How about spam filters that apply some sort
    of classification engine? \finsp could be this engine, and emails by many
    different users could be classified just as ``Spam'' or ``Not spam''}}, so
it makes perfect sense that the inspection function returns the same value for
both users.
%
More generally, since the issuer is dishonest in non-frameability properties
and, in \UAS, the value produced by \Inspect may depend on the attributes
included in user credentials, the adversary may even be able to just produce
``legitimate'' inspections that output any desired value.

Thus, we again need to resort to extraction techniques. In the non-frameability
definition for \UAS, given in experiment \ExpNonframe in
\figref{fig:exp-uas-frame}, the adversary is challenged to produce a signature
and inspection proof that accepted by \Verify and \Judge, respectively. From
the signature, we then extract the secret key of the signer, and match it
against the secret keys of the honest users. The adversary wins if there is a
match (and the signature, of course, has not been queried to \SIGN). In the
game, the adversary has access to the oracles in 
$\Oframe \gets \lbrace\HU,\CU\rbrace\GEN,
\lbrace\II,\OO\rbrace\GEN,\lbrace\II,\OO\rbrace\CORR,\WREG,\OBTAIN,\SIGN$

\begin{figure}[htp!]
  \procedure{$\ExpNonframe(1^\secpar)$}{%
    \parm \gets \Setup(1^\secpar) \\
    (\oid,\siid,\sig,\yeval,\msg,\feval,\yinsp,\iproof) \gets
    \adv^{\Oframe}(\parm) \\
    \pcif \exists \uid~\st~(\cdot,\cdot,\sig,\yeval,\msg,\feval) \in \SIG[\uid]:
    \pcreturn 0 \\
    \pcif \Verify(\PUBOK[\oid],\PUBIK[\siid],\sig,\yeval,\msg,\feval) = 0:
    \pcreturn 0 \\
    \pcif \Judge(\PUBOK[\oid],\PUBIK[\siid],\yinsp,\iproof,\sig,\yeval,\msg) = 0:
    \pcreturn 0 \\
    (\usk,\scred) \gets \ExtractSign(\oid,\siid,\sig,\yeval,\msg,\feval) \\
    \pcif \exists \uid \in \HU~\st~\PRVUK[\uid] = \usk: \pcreturn 1 \\
    \pcreturn 0
  }
  \caption{Experiment for non-frameability on \UAS schemes.}
  \label{fig:exp-uas-frame}
\end{figure}

\begin{definition}{(Non-frameability of \UAS)}
  \label{def:frame-uas}
  We define the advantage \AdvNonframe of $\adv$ against \ExpNonframe as
  $\AdvNonframe=\Pr\lbrack\ExpNonframe(1^\secpar)=1\rbrack$.
  %
  A \GSAC scheme satisfies non-frameability if, for any p.p.t. adversary $\adv$,
  \AdvNonframe is a negligible function of $1^\secpar$.
\end{definition}

\paragraph{Discussion on the generality of non-frameability in \UAS schemes.} %
\todo{Re-check and re-write as needed}.
Anonymous credentials do not have non-frameability property and, thus, it is
hard to make a comparison. However, we can draw some connections with AC schemes
that support revocation, as revocation is somehow equivalent to linking, which
is a type of inspection available in group signatures. In this sense, note that
basic revocation (without straight deanonymization) can be trivially achieved
through our generic \Inspect function. For instance, one could set \finsp to
be a pseudorandom number seeded with the user's public key (or credential). In
this sense, \Inspect could be essentially seen as a Verifiable Random Function.
If we compare with group signatures, our notion is again more general than the
conventional one. Indeed, in typical group signatures, \Open returns the
identity of the signer, and thus non-frameability does not allow the same value
to be returned when opening signatures by different users. Otherwise, a
corrupted user controlled by the adversary could be able to create a signature
opening to some honest user (hence, framing him). But this is again possible
with our definition which, in case of making \Inspect equal \Open, becomes
equivalent to conventional non-frameability. However, it also allows more
generic situations in which signatures by different users may return the same
value. 
  
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "uas"
%%% End:
