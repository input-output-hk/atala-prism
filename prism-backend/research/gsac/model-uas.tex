\subsection{Model for \UAS Schemes}
\label{ssec:model-uas}

We now define our model for Universal Anonymous Signatures. Property-wise, we
maintain anonymity, non-frameability, and include two extra unforgeability
properties: unforgeability of issuance, which ensures that issuance policies
are not circumvented; and unforgeability of signatures, guaranteeing that
signature evaluation policies are respected, as well as soundness of opening.

From a functional perspective, we require that each issuer and opener fix
the issuance predicate \fissue and opener function \finsp when generating
their public keys. On the other hand, signature evaluation functions \feval can
be defined at signing time. This is in line with the usual practice in anonymous
credentials, that let
users prove arbitrary claims on their credentials, as long as they are met by
the contained attributes. In practice, most probably, the signature evaluation
policy to be
employed in each signature will be defined by the verifier (or jointly between
user and verifier), including the specification of which opener will be
able to post-process signatures\footnote{See, for instance, the concept of
  presentation exchanges, or requests, in the context of Verifiable Credentials:
  \url{https://identity.foundation/presentation-exchange/} (last access, May
  5th, 2022).}. Beyond these general policies, which already give much
flexibility, the syntax for \UAS supports multiple issuers and openers, and
lets users leverage multiple credentials to request issuance of new ones, and
to produce signatures.

\subsubsection{Syntax.} An \UAS scheme is composed by the following algorithms,
where for readability we assume that issuer public keys (\ipk) are extractable
from credentials:

\begin{description}
\item[$\Setup(\secpar) \rightarrow \parm$.] Given a security parameter \secpar,
  returns a global system parameter variable \parm. We assume that \parm are
  available to all the other functions, even if not explicitly listed in their
  input parameters.
\item[$\IKeyGen(\parm,\fissue) \rightarrow (\ipk,\isk)$.] Given global system
  parameters \parm, and the function \fissue to be used to check that credential
  requestors meet the conditions to be issued a credential, an issuer runs
  \IKeyGen to generate its issuing key pair. 
\item[$\OKeyGen(\parm,\finsp) \rightarrow (\opk,\osk)$.] Given global system
  parameters \parm, and function \finsp, an opener runs \OKeyGen to generate
  its opening key pair. The function \finsp defines the type of utility that
  will be extractable from signatures.
\item[$\UKeyGen(\parm) \rightarrow \usk$.] Given global system parameters
  \parm, returns a user's secret key.
\item[$\langle
  \Obtain(\usk,\ipk,\scred,\attrs),
  \Issue(\isk,\sipk,\attrs))
  \rangle \rightarrow \langle \cred/\bot,\utrans/\bot \rangle$.] %
  This interactive protocol lets a user with key \usk running the
  \Obtain process, receive a credential \cred from an issuer in the system, on
  attribute set $\attrs$. The user leverages a set of credentials \scred,
  each with a matching issuer key in \sipk.
  The user outputs the produced credential \cred, while
  the issuer outputs the protocol transcript \utrans for the produced
  credential.
\item[$\Sign(\usk,\opk,\scred,\msg,\feval) \rightarrow (\sig,\yeval)$.] %
  Upon receiving a user secret key \usk, opener public key \opk, a set of
  credentials \scred, a message \msg and evaluation
  function \feval, returns signature \sig, and a plaintext value \yeval. For
  readability, we use \Sig to denote the tuple $(\sig,\yeval)$.
\item[$\Verify(\opk, \sipk,\Sig,\msg,\feval) \rightarrow 1/0$.]
  Checks whether $\Sig = (\sig,\yeval)$ is a valid signature
  over message \msg, from a user with credentials issued by issuers with public
  keys in \sipk, for evaluation function \feval and opener key \opk.
\item[$\Open(\osk,\sipk,\Sig,\msg,\feval) \rightarrow
  (\yinsp,\iproof)/\bot$.]
  Executed by the opener with private key \osk. Receives a signature $\Sig=
  (\sig,\yeval)$ over message \msg and evaluation function \feval,
  generated using credentials issued by the issuers with public keys in \sipk.
  If \Sig is valid, the function outputs a value $\yinsp$.
\item[$\Judge(\opk,\sipk,\yinsp,\iproof,\Sig,\msg,\feval) \rightarrow 1/0$.] %
  Checks if \iproof is a valid opening correctness proof for the value \yinsp,
  obtained by applying \Open to the the signature $\Sig = (\sig,\yeval)$
  over message \msg, and for evaluation function \feval. 
\end{description}

\paragraph{Issuance, evaluation, and opening functions.} %
We emphasize that, both in our syntax definition, as well as on the following
modelling, we make use of three different and abstract functions: \fissue,
\feval and \finsp. The three functions are introduced to allow customized
governance of the resulting instantiation of an \UAS scheme. They will be
defined by different parties, but in all cases, they are run by users (maybe,
on user-private data). Also, in all cases, the user has to prove correctness of
their computation. We introduce them next, and give concrete examples for
building specific well-known restrictions of \UAS in
\secref{sec:transformations}.

\begin{description}
\item[$\fissue: (\usk,\scred,\attrs)
  \rightarrow 0/1$.] Chosen by issuers within a family of functions \famfissue,
  the issuance function defines what customized conditions an issuer requires
  in order to issue credentials, when receiving a request from user with secret
  key \usk, for attributes \attrs. \fissue may run checks on a (possibly empty)
  set of additional credentials \scred, all bound to \usk, and possibly
  issued by other issuers. \fissue returns $1$ to accept a request, $0$ to
  reject it.
\item[$\feval: (\usk,\scred,\msg)
  \rightarrow (\yeval^0,\yeval^1)$.] Signing evaluation functions, from a
  family of functions \famfeval, can be set on a per-signature basis. They
  receive the user secret key \usk, credentials \scred, and message to be signed
  \msg. \feval can be used to control the information related to the signer that
  will be revealed alongside a signature, and to modulate the behaviour of
  \finsp. Its outputs two values, $\yeval^0$ and $\yeval^1$, where the former
  is revealed in plaintext along with the signature, and $\yeval^1$ is encrypted
  and used to modulate the behaviour of \finsp. Both values must belong in a
  well defined set \rngfeval. For readability, we write
  $\Yeval = (\yeval^0,\yeval^1)$.
\item[$\finsp: (\Yeval,\usk,\scred,\msg) \rightarrow \yinsp$.]
  Chosen by openers from a family of functions \famfinsp. The opening
  functions define what utility value, derived from the user's secret key,
  credentials, and signed message, should be extractable by an opener.
  Note that \finsp also receives as input a value in the range of the \feval
  function, $\rngfeval^2$. This allows opening logic to depend on the values
  produced by the evaluation function. The output of \finsp is a value
  \yinsp, which must belong in a well defined set \rngfinsp.
\end{description}

We emphasize that, even though \finsp and \feval seem redundant, they are not.
To see this, observe that \finsp is defined by openers, and will be fixed in
all signatures that can be opened by the opener who defined it. On the other
hand, \feval can be defined by (e.g.) verifiers on a per-signature basis, even
if the signatures use the same \finsp. Thus, \feval can be programmed to contain
the conditions set by (e.g.) verifiers for signatures they receive; whereas
\finsp can be programmed to extract specific utility values when needed, which
may depend on the checks required by the verifier a signature was intended to.

\paragraph{Helper functions \ExtractIssue, \ExtractSign, \IdentifyCred, and
  \IdentifyUK.} In our modelling, we assume the existence of fhese four
functions. They are not
functions available in the actual scheme, but rather to the challenger in the
experiments we use to formalize security of \UAS schemes. Similar techniques
have been used before to prove security in privacy-preserving schemes with some
sort of accountability, but that do not offer conventional opening as vanilla
group signatures. For instance, see related works on DAA \cite{bfg+11,cdl16} and
group signature variants \cite{dl21,fgl21,gl19,lnpy21}. More concretely, these
functions are as follows:

\begin{description}
\item[$\ExtractIssue(\utrans) \rightarrow (\usk,\attrs_{\scred},\scred)$.]
  Receives an $\langle \Obtain, \Issue \rangle$ transcript, and returns the
  credentials (if any) and their attributes that were involved
  in the request. It clearly needs an honest issuer as, otherwise, the
  transcripts won't be available. Consequently, we only use it to define the
  properties that require an honest issuer.
\item[$\ExtractSign(\oid,\siid,\Sig,\msg,\feval) \rightarrow (\usk,
  \scred,\attrs_{\scred},\yeval^1,\yinsp)$.] Receives a signature \Sig,
  as well as the opener identifier \oid, and the identifiers of all issuers of
  the credentials used to produce the signature over \msg, and for \feval. It
  outputs the user secret key and credentials (with their attributes) used to
  generate the signature, and the value returned by the opening fuction.
\item[$\IdentifyCred(\usk,\attrs_{\cred},\cred)$.] Returns $1$ if \cred has been
  issued over attributes $\attrs_{\cred}$ and for a user with secret key \usk.
  Otherwise, it returns $0$. In order to be meaningful, this requires that,
  for every $(\attrs_{\cred},\cred)$ pair, there is at most one \usk that makes
  \IdentifyCred return $1$.
\item[$\IdentifyUK(\uid,\usk)$.] Returns $1$ is \usk is {\uid}'s secret key.
  This is trivial for honest users, for which there must be a one-to-one
  relationship between {\uid}s and {\usk}s. For corrupt users, \IdentifyUK has
  to iterate through the $\langle\Obtain,\Issue\rangle$ transcripts associated
  to \uid, extract the used secret key, and check if there is a match. Note that
  this does not guarantee that there will be only one \usk per corrupt \uid,
  though. Also, when used for corrupt users, this can only be used when the
  issuer is honest, as transcripts are needed. 
\end{description}

Note that, for all the helper functions, in the case of credentials, transcripts,
and signatures by honest users, it is enough to have access to the corresponding
state information (described below) maintained by the challenger in our
experiments. For credentials and join transcripts of corrupt users, or
dishonestly produced signatures, we do need to perform actual extraction.
Certainly, the challenger
needs special knowledge/power such as decryption trapdoors, the ability to
rewind the game, or program random oracles. The approach needs thus to depend on
the concrete construction. \jdv{Although, for the case of \ExtractIssue and
  \IdentifyUK, online extractability (or alternative requirements, such as
  non-parallel or logarithmic number of joins) is necessary.}

\paragraph{Global Variables.} %
The environment manages several global variables in the games posed to the
adversary. Users are referred to with user identifiers, \uid; for credentials,
we use \cid; for issuers, \iid; and for openers, \oid. In all cases, we use bold
font to denote sets: e.g., \scid and \siid denote sets of credential and issuer
identifiers. All tables/sets are initialized as empty tables/sets.

\begin{description}
\item[Sets for parties]:
  \begin{description}
  \item[\HU and \CU.] Keep track of honest (\HU) and corrupted (\CU) users;
    i.e., they are sets of {\uid}s.
  \item[\HI and \CI.] Keep track of honest (\HI) and corrupted (\CI) issuers;
    i.e., they are sets of {\iid}s.
  \item[\HO and \CO.] Keep track of honest (\HO) and corrupted (\CO) openers;
    i.e., they are sets of {\oid}s.
  \end{description}
\item[Tables for keys]:
  \begin{description}
  \item[\UK.] \UK maintains user keys $\usk$. To refer to the key of a specific
    user, we use $\UK[\uid]$. 
  \item[\IK, \PUBIK and \PRVIK.] \IK maintains issuer key pairs, where
    $\IK[\iid]$ refers to the key pair of the issuer with identifier \iid. We
    use \PUBIK to refer to the public component, which also includes the \fissue
    function; and \PRVIK refers to the private component of the key pair.
  \item[\OK, \PUBOK, \PRVOK.] Same as \IK, but for opener key pairs. Instead
    of \fissue, \OK includes the \finsp function.
  \end{description}
\item[Tables for credentials-related data]:
  \begin{description}
  \item[\CRED.] Stores information related to credentials obtained by users in
    the system. Thus, it is indexable by \cid. More specifically, it stores
    tuples of the form $(\uid,\cred,\iid,\attrs,\scid)$, where \uid is the
    identity of the owner of the credential, \cred (when available) is the
    credential itself, \iid is the identifier of the credential issuer, \attrs
    are the attributes included in \cred, and \scid are the identifiers of the
    credentials (if any) that \uid used to request \cred. For notational
    convenience, we may use $\CRED[\scid]$ to refer to $\CRED[\cid]$ for all
    $\cid \in \scid$. Also, when clear from context, we sometimes use
    $\CRED[\cid]$ (resp. $\CRED[\scid]$ to mean \cred (resp. \scred) in
    $\CRED[\cid] = (\cdot,\cred,\cdot,\cdot,\cdot)$ (resp. $\CRED[\scid]$).
  \item[\OWNR.] For notational convenience, when we write $\OWNR[\cid]$ we mean
    ``\uid such that $\CRED[\cid] = (\uid, \cdot, \cdot, \cdot, \cdot)$''.
  \item[\ATTR.] For notational convenience, when we write $\ATTR[\cid]$ we mean
    ``\attrs such that $\CRED[\cid] = (\cdot, \cdot, \cdot, \attrs, \cdot)$''.
  \item[\ISR.] For notational convenience, when we write $\ISR[\cid]$ we mean
    ``\iid such that $\CRED[\cid] = (\cdot, \iid, \cdot, \cdot, \cdot)$''.
  \end{description}
\item[Tables for signatures]:
  \begin{description}
  \item[\SIG.] Maintains signatures generated via the \SIGN oracle, on behalf
    of honest users. Entries of this table are $(\oid,\scid,\sig,\Yeval,\msg,
    \feval)$, where \oid is the opener chosen for the signature, \scid is the
    set of credentials used for signing, \feval is the signing evaluation
    function, and \sig and \msg are the produced signature and signed message.
  \item[\CSIG.] Maintains challenge signatures output to the adversary; i.e.,
    the table is indexable by challenge signatures \csig.
    Each entry contains also $\cuid_b$ and $\scid_b$ the challenge user and
    credential identifiers set used to produce \csig; as well as the
    corresponding challenge user and credential set indexed by the complementary
    $1-b$; the signed message \msg and signing evaluation function \feval, the
    result of \feval, \yeval, and the opener identifier \oid.
  \end{description}
\end{description}

\paragraph{Oracles.} %
In the game-based definitions of our \UAS model, we leverage the following
oracles, which are formally defined in \figref{fig:oracles1} and
\figref{fig:oracles2}. 

\begin{description}
\item[\IGEN.] Adds a new issuer to the game, generating its keypair and setting
  the associated issuance function.
\item[\OGEN.] Adds a new opener to the game, generating its key pair and
  setting the associated evaluation and inspection functions.
\item[\ICORR.] Corrupts an existing (and honest) issuer, by giving its secret
  key to the adversary.
\item[\OCORR.] Corrupts an existing (and honest) opener, by giving its secret
  key to the adversary.  
\item[\HUGEN.] Adds a new honest user to the game, by honestly generating
  the user's key pair.
\item[\CUGEN.] Adds a new corrupt user to the game or, if the specified
  user already exists and is honest, corrupts it, leaking its key and
  credentials.
\item[\RREG.] Reads the given transcript table entry.
\item[\WREG.] Sets a transcript table entry to the given value.
\item[\OBTISS.] Lets the adversary add a new honestly generated credential to
  the game, on behalf of an honest user.
\item[\OBTAIN.] Enables the adversary to play the role of a dishonest issuer
  in games that support it, by letting it interact with honest users who want to
  receive credentials.
\item[\ISSUE.] Allows the adversary to play the role of dishonest users,
  requesting an honest issuer to produce credentials for them.
\item[\SIGN.] Lets the adversary get signatures from credentials belonging
  to honest users.
\item[\OPEN.] Given an honestly produced signature, outputs the result of the
  opening function, along with a correctness proof.
\item[\CHALb.] Upon receiving two challenge users and credential sets, a common
  singing evaluation function and a message, returns a signature produced by one
  of these two user and credential sets, defined by the bit $b$, which is
  established in the anonymity game.
\end{description}

{%\setlength\intextsep{\sep}
  \begin{figure*}[htp!]
    \centering
    \scalebox{0.9}{

      \begin{minipage}[t]{0.55\textwidth}

        \procedure{$\IGEN(\iid,\fissue)$}{%
          \pcif \iid \in \HI \lor \iid \in \CI: \pcreturn \bot \\
          \pcif \fissue \notin \famfissue: \pcreturn \bot \\
          (\ipk,\isk) \gets \IKeyGen(\parm) \\
          \IK[\iid] \gets ((\ipk,\fissue),\isk) \\
          \HI \gets \HI \cup \lbrace \iid \rbrace \\
          \pcreturn \ipk \\
        }

        \procedure{$\ICORR(\iid)$}{%
          \pcif \iid \in \CI \lor \iid \notin \HI: \pcreturn \bot \\
          \HI \gets \HI \setminus \lbrace \iid \rbrace \\
          \CI \gets \CI \cup \lbrace \iid \rbrace \\
          \pcreturn \isk \\
        }        

        \procedure{$\HUGEN(\uid)$}{%
          \pcif \uid \in \HU \lor \uid \in \CU: \pcreturn \bot \\
          \usk \gets \UKeyGen(\parm) \\
          \UK[\uid] \gets \usk;
          \HU \gets \HU \cup \lbrace  \uid \rbrace \\
          \pcreturn \top \\
        }

        \procedure{$\RREG(i)$}{%
          \pcreturn \trans[i]
        }        
        
      \end{minipage}
    }
    \scalebox{0.9}{
      
      \begin{minipage}[t]{.5\textwidth}

        \procedure{$\OGEN(\oid,\finsp)$}{%
          \pcif \oid \in \HO \lor \oid \in \CO: \pcreturn \bot \\
          \pcif \finsp \notin \famfinsp: \pcreturn \bot \\
          (\opk,\osk) \gets \OKeyGen(\parm) \\
          \OK[\oid] \gets ((\opk,\finsp),\osk) \\
          \HO \gets \HO \cup \lbrace \oid \rbrace \\
          \pcreturn \opk \\
        }

        \procedure{$\OCORR(\oid)$}{%
          \pcif \oid \in \CO \lor \oid \notin \HO: \pcreturn \bot \\
          \pcif \exists (\oid,\cdot,\cdot,\cdot,\cdot,
          \cdot,\cdot,\cdot,\cdot) \in \CSIG: \pcreturn \bot \\
          \HO \gets \HO \setminus \lbrace \oid \rbrace \\
          \CO \gets \CO \cup \lbrace \oid \rbrace \\
          \pcreturn \osk \\
        }        
        
        \procedure{$\CUGEN(\uid)$}{%          
          \pcif \uid \in \CU: \pcreturn \bot \\
          \CU \gets \CU \cup \lbrace \uid \rbrace \\          
          \pcif \uid \in \HU: \\
          \pcind \HU \gets \HU \setminus \lbrace \uid \rbrace; \\
          \pcind \pcreturn (\UK[\uid],\CRED[\uid]) \\
          \pcelse: \UK[\uid] = \bot \\          
          \pcreturn \top \\
        }

        \procedure{$\WREG(i,\rho)$}{%
          \trans[i] \gets \rho
        }        
        
      \end{minipage}
      
    }

    \caption{Detailed oracles available in our model (1/2). Oracles for
      generating key material for users, issuers, and openers.}
    \label{fig:oracles1}
  \end{figure*}
}

{%\setlength\intextsep{\sep}
  \begin{figure*}[htp!]
    \centering
    \scalebox{0.9}{

      \begin{minipage}[t]{0.55\textwidth}

        \procedure{$\OBTISS(\cid,\uid,\iid,\attrs,\scid)$}{%
          \pcif \uid \notin \HU: \pcreturn \bot \\
          \pcif \iid \notin \HI: \pcreturn \bot \\
          \pcif \CRED[\cid] \neq \bot \lor \CCRED[\cid] \neq \bot: \pcreturn \bot \\
          %\pcif \exists \iid' \in \ISR[\scid]~\st~\iid' \notin \HI: \pcreturn \bot \\
          %\pcif \exists \cid' \in \scid~\st~\CRED[\cid'] = \bot:
          \langle \cred, \utrans \rangle \gets
          \langle \Obtain(\UK[\uid],\CRED[\scid],\attrs), \\
          \hspace*{60pt} \Issue(\PRVIK[\iid],\ISR[\scid],\attrs)
          \rangle \\
          \trans[\cid] \gets \utrans \\
          \CRED[\cid] \gets (\uid, \cred, \iid, \attrs, \scid, \siid) \\
          \pcreturn \top \\
        }

        \procedure{$\ISSUE(\cid,\uid,\iid,\attrs,\siid)$}{%
          \pcif \uid \notin \CU: \pcreturn \bot \\          
          \pcif \iid \notin \HI: \pcreturn \bot \\
          %\pcif \exists \iid' \in \ISR[\scid] \notin \HI: \pcreturn \bot \\
          \pcif \CRED[\cid] \neq \bot \lor \CCRED[\cid] \neq \bot: \pcreturn \bot \\
          \langle \cdot, \utrans \rangle \gets
          \langle \adv, 
          \Issue(\PRVIK[\iid],\siid,\attrs) \rangle \\
          \trans[\cid] \gets \utrans \\
          \CRED[\cid] \gets (\uid, \cdot, \iid, \attrs, \cdot, \siid) \\
          \pcreturn \top \\          
        }

        \procedure{$\SIGN(\oid,\uid,\scid,\msg,\feval)$}{%
          \pcif \uid \notin \HU: \pcreturn \bot \\
          \pcif \feval \notin \famfeval: \pcreturn \bot \\
          \pcif \exists \cid \in \scid~\suchthat~\cid \in \CRED~\land \\
          \pcind \exists \cid' \in \scid~\suchthat~\cid' \in \CCRED: \pcreturn \bot \\
          \Sig \gets \Sign(\UK[\uid],\PUBOK[\oid],\CRED[\scid],\msg,\feval) \\
          \Yeval=(\yeval^0,\yeval^1) \gets \feval(\UK[\uid],\CRED[\cscid],\msg) \\
          \SIG[\uid] \gets \SIG[\uid] \cup
          \lbrace (\oid,\scid,\Sig,\Yeval,\msg,\feval) \rbrace \\
          \pcreturn \Sig \\
        }        

        \procedure{$\OPEN(\oid,\Sig,\msg)$}{%
          \textrm{Let}~\uid~\textrm{be s.t.}~(\oid,\scid,\Sig,\Yeval,\msg,\feval)
          \in \SIG[\uid] \\
%          \textrm{Parse}~\Sig~\textrm{as}~(\sig,\yeval,\ceval) \\
          (\yinsp,\iproof) \gets
          \Open(\PRVOK[\oid],\PUBIK[\scid],\Sig,\msg,\feval) \\
          \pcif \CSIG[\Sig] \neq \bot: \\
          \pcind \textrm{Parse $\CSIG[\Sig]$ as $(\oid,\cuid_b,\scid_b,
            \Yeval,\msg,\feval$} \\          
          \hspace*{83pt}\cuid_{1-b},\cSig_{1-b},\scid_{1-b},
          \TYeval) \\
          %\pcind \pcif \yeval^1 \neq \tyeval^1: \pcreturn \bot \\          
          \pcind (\tyinsp,\tiproof) \gets
          \Open(\PRVOK[\oid],\IK[\siid],\\
          \hspace*{107pt} \cSig_{1-b},\msg,\feval) \\
          \pcind \pcif \tyinsp \neq \yinsp: \pcreturn \bot \\
          \pcreturn (\yinsp,\iproof)
        }
        
      \end{minipage}
    }
    \scalebox{0.9}{
      
      \begin{minipage}[t]{.5\textwidth}

        \procedure{$\OBTAIN(\cid,\uid,\iid,\attrs,\scid)$}{%
          \pcif \uid \notin \HU: \pcreturn \bot \\
          \pcif \iid \notin \CI: \pcreturn \bot \\
          \pcif \exists \cid' \in \scid~\suchthat~\cid' \in \CRED~\land \\
          \pcind \exists \cid'' \in \scid~\suchthat~\cid'' \in \CCRED: \pcreturn \bot \\
          \pcif \CRED[\cid] \neq \bot \lor \CCRED[\cid] \neq \bot: \pcreturn \bot \\
          %\pcif \exists \cid' \in \scid~\st~\CRED[\cid'] = \bot: \pcreturn \bot \\
          \langle \cred, \cdot \rangle \gets
          \langle \Obtain(\UK[\uid],\PUBIK[\iid],\CRED[\scid],\attrs),\adv \rangle \\
          \CRED[\cid] \gets (\uid, \cred, \iid, \attrs, \scid, \siid) \\
          \pcreturn \top \\
        }

        \procedure{$\OBTCHALb(\cid,\iid,\cuid_{0,1},\cscid_{0,1},\attrs)$}{%
          \pcif \cuid_0 \notin \HU \lor \cuid_1 \notin \HU: \pcreturn \bot \\
          \pcif \iid \notin \CI: \pcreturn \bot \\
          \pcif \CRED[\cid] \neq \bot: \pcreturn \bot \\
          \pcif \pcfor d \in \bin,~ \exists \cid' \in \cscid_d~\suchthat~\cid'
          \in \CRED~\land \\
          \pcind \exists \cid'' \in \cscid_d~\suchthat~\cid'' \in \CCRED:
          \pcreturn \bot \\
          \textrm{Parse}~\PUBIK[\iid]~\textrm{as}~((\cdot,\fissue),\cdot) \\
          \pcif \fissue(\UK[\cuid_0],\cscid_0,\attrs) \neq
          \fissue(\UK[\cuid_1],\cscid_1,\attrs) \\
          \langle \cred, \cdot \rangle \gets
          \langle \Obtain(\UK[\cuid_b],\PUBIK[\iid],\CRED[\scid_b],\attrs),\adv \rangle \\
          \CCRED[\cid] \gets (\cuid_b, \cred, \iid, \attrs, \scid_b, \siid) \\
          \pcreturn \top \\
        }

        \procedure{$\CHALb(\oid,\cuid_{0,1},\cscid_{0,1},\msg,\feval)$}{%
          \pcif \cuid_0 \notin \HU \lor \cuid_1 \notin \HU: \pcreturn \bot \\
          \pcif \oid \in \CO: \pcreturn \bot \\
          \pcif \feval \notin \famfeval: \pcreturn \bot \\          
          \Yeval = (\yeval^0,\yeval^1) \gets \feval(\UK[\cuid_0],\CRED[\cscid_0],
          \msg) \\
          \TYeval = (\tyeval^0,\tyeval^1) \gets
          \feval(\UK[\cuid_1],\CRED[\cscid_1],\msg) \\
          \pcif \yeval^0 \neq \tyeval^0: \pcreturn \bot \\
          \pcif \PUBIK[\cscid_0] \neq \PUBIK[\cscid_1]: \pcreturn \bot \\
          \cSig_b \gets \Sign(\UK[\cuid_b],\PUBOK[\oid], \\
          \hspace*{71pt}\CRED[\cscid_b],\msg,\feval) \\
          \cSig_{1-b} \gets \Sign(\UK[\cuid_{1-b}],\PUBOK[\oid], \\
          \hspace*{80pt}\CRED[\cscid_{1-b}],\msg,\feval) \\          
          \CSIG[\cSig_b] \gets 
          \lbrace (\oid,\cuid_b,\cscid_b,\Yeval,\msg,\feval,\\
          \hspace*{74pt}\cuid_{1-b},\cSig_{1-b},\cscid_{1-b},\TYeval)\rbrace \\
          \pcreturn \cSig_b
        }
        
      \end{minipage}
      
    }

    \caption{Detailed oracles available in our model (2/2). Oracles for
      obtaining credentials, signatures, and processing them.}
    \label{fig:oracles2}
  \end{figure*}
}

\paragraph{Correctness.} %
Correctness of \UAS schemes is formalized through the experiment in
\figref{fig:exp-uas-corr}. It states that a signature over any arbitrary message
and valid function \feval, produced honestly leveraging credential set \scid,
owned by user \uid, is accepted by \Verify. Moreover, all the credentials in
\scid meet the conditions set by the corresponding \fissue defined by the issuer
which issued each credential. Similarly, the output \yeval of \feval matches the
value produced by \Sign alongside with \sig; and the value produced by \Open
is accepted by \Judge, and matches the output of applying \finsp on \yeval, the
credentials, user key, and message.

\begin{definition}{(Correctness of \UAS)}
  \label{def:correctness-uas}
  An \UAS scheme is correct if, for any p.p.t. adversary $\adv$,
  $\ExpCorrect(1^\secpar)$ outputs 1 with negligible probability.
\end{definition}

\begin{figure}[htp!]
  \procedure[linenumbering]{$\ExpCorrect(1^\secpar)$}{%
    \parm \gets \Setup(1^\secpar) \\
    (\uid,\oid,\scid,\msg,\feval)
    \gets \adv^{\IGEN,\OGEN,\HUGEN,\OBTISS,\RREG}(\parm) \\
    \pcif \feval \notin \famfeval: \pcreturn 0 \\
    \pcif \OWNR[\scid] \neq \uid: \pcreturn 0 \\
    (\Sig = (\sig,\yeval)) \gets \Sign(\UK[\uid],\PUBOK[\oid],\scid,\msg,
    \feval) \\
    \pcif \Verify(\PUBOK[\oid],\PUBIK[\scid],\Sig,\msg,\feval) = 0: \pcreturn 1 \\
    \pcfor \cid \in \scid \pcdo: \\
    \pcind \textrm{Let}~\scred^{\cid}~\textrm{be the credentials used to obtain}
    ~\cid;~\textrm{Parse}~\PUBIK[\ISR[\cid]]~\textrm{as}~((\cdot,\fissue^{\cid}),\cdot)\\
    \pcind \pcif \fissue^{\cid}(\UK[\uid],\scred^{\cid},\ATTR[\cid]) = 0: \pcreturn 1 \\
    (\yeval^0,\yeval^1) \gets \feval(\UK[\uid],\CRED[\scid],\msg) \\
    \pcif \yeval^0 \neq \yeval: \pcreturn 1 \\
    (\yinsp,\iproof) \gets \Open(\PRVOK[\gid],\PUBIK[\scid],\Sig,\msg,\feval) \\
    \pcif \Judge(\PUBOK[\oid],\PUBIK[\scid],\yinsp,\iproof,\Sig,\msg,\feval)
    = 0~\lor \\
    \pcind \yinsp \neq \finsp^\gid((\yeval,\yeval^1),\UK[\uid],\CRED[\scid],\msg)): \\
    \pcind \pcreturn 1 \\
    \pcreturn 0
  }  
  \caption{Correctness experiment for \UAS schemes.}
  \label{fig:exp-uas-corr}
\end{figure}

\subsubsection{Security Properties}
\label{sssec:security}

\paragraph{Anonymity.} %
\iffalse
Informally, anonymity must capture two requirements: (1) interactive credential
issuance protocols do not leak any information about the user requesting them;
and (2) signatures do not leak any information about the signer. In both cases,
any leakage must be limited to whatever the user decides to reveal, for
instance, through arbitrary predicates on the attributes of the credentials used
for issuance and signing. We follow a simulation-based approach to capture this.
Basically, the adversary is challenged to distinguish between real and ideal
executions. In both worlds, the adversary can generate and corrupt honest users,
issuers, and openers. Then, in the real world, the adversary has access to
oracles that allow requesting credentials on behalf of honest users, create
signatures by honest users, and open signatures by honest users. In the ideal
world, these three oracles are replaced by simulated counterparts, which produce
outputs independent of the users' secrets. This formulation is given in
\figref{fig:exp-uas-simanon}, where $\Osimanon = (\lbrace\HU,\CU\rbrace\GEN,
\lbrace\II,\OO\rbrace\GEN,\lbrace\II,\OO\rbrace\CORR,\WREG)$.

\begin{figure}[htp!]

  \centering
  \procedure[linenumbering]{$\ExpSimAnonb(1^\secpar)$}{%
    \pcif b = 0: \\
    \pcind \parm \gets \Setup(1^\secpar) \\    
    \pcind b^* \gets \adv^{\Osimanon,\OBTAIN,\SIGN,\OPEN}(\parm) \\
    \pcelse: \\
    \pcind (\parm,\NIZKtrap) \gets \SIMSETUP(1^\secpar) \\
    \pcind b^* \gets \adv^{\Osimanon,\SIMOBTAIN,\SIMSIGN,\SIMOPEN}(\parm) \\    
    \pcreturn b^*
  }
  
  \caption{Simulation-based anonymity experiment for \UAS schemes.}
  \label{fig:exp-uas-anonb}
\end{figure}

\begin{definition}{(Anonymity of \UAS)}
  \label{def:sign-anonymity-uas}  
  We define the advantage \AdvSimAnon of $\adv$ against \ExpSimAnonb as
  $\AdvSimAnon=|\Pr\lbrack\ExpSimAnono(1^\secpar)=1\rbrack-
  \Pr\lbrack\ExpSimAnonz(1^\secpar)=1\rbrack|$.
  %
  An \UAS scheme satisfies simulatable anonymity if there exists simulators
  \SIMSETUP, \SIMOBTAIN, \SIMSIGN and \SIMOPEN such that, for any p.p.t.
  adversary $\adv$, \AdvSimAnon is a negligible function of $1^\secpar$.
\end{definition}
\fi

In addition to the considerations made for \GSAC (see \secref{ssec:model-gsac}),
in our notion of anonymity for \UAS,
in order to prevent trivial wins by the adversary, we have to restrict that the
signing evaluation function outputs the same value for both user-credentials
pairs. Very interestingly, since our opening functionality does not
(necessarily) output the identity of the signer, \uline{we can even allow the
  adversary to open challenge signatures, as long as they produce the same
  output}. Other than this, the overall approach is similar: as
in group signatures and anonymous credentials, the adversary asks for challenge
signatures from either one of two honest users and credential sets -- bit $b$,
unkown to the adversary, defining which one is used. Note that the adversary
also has to pick a signature valuation function \feval, as well as an opener
(passed as arguments to the \SIGN and \CHALb oracles). The formal specification
of the anonymity game is given in \figref{fig:exp-uas-anonb}, where
$\OIssAnon \gets (\lbrace\HU,\CU\rbrace\GEN,\lbrace\II,\OO\rbrace\GEN,\lbrace\II,
\OO\rbrace\CORR,\OBTAIN,\WREG,\SIGN,\OPEN,\OBTCHALb)$, and $\OSigAnon
\gets (\lbrace\HU,\CU\rbrace\GEN,\lbrace\II,\OO\rbrace\GEN,\lbrace\II,\OO\rbrace
\CORR,\OBTAIN,\WREG,\SIGN,\OPEN,\CHALb)$.

\begin{figure*}[htp!]
  \centering
  \scalebox{0.9}{
    \begin{minipage}[t]{0.5\textwidth}
      \procedure[linenumbering]{$\ExpIssAnonb(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        b^* \gets \adv^{\OIssAnon} (\status,\parm) \\
        \pcreturn b^*
      }
    \end{minipage}
    
    \begin{minipage}[t]{0.5\textwidth}
      \procedure[linenumbering]{$\ExpSigAnonb(1^\secpar)$}{%
        \parm \gets \Setup(1^\secpar) \\
        b^* \gets \adv^{\OSigAnon} (\status,\parm) \\
        \pcreturn b^*
      }
    \end{minipage}
  }
  \caption{Issuance and signature anonymity experiments for \UAS schemes.}
  \label{fig:exp-uas-anonb}
\end{figure*}

\begin{definition}{(Issuance anonymity in \UAS)}
  \label{def:issue-anonymity-uas}  
  We define the advantage \AdvIssAnon of $\adv$ against \ExpIssAnonb as
  $\AdvIssAnon=|\Pr\lbrack\ExpIssAnono(1^\secpar)=1\rbrack-
  \Pr\lbrack\ExpIssAnonz(1^\secpar)=1\rbrack|$.
  %
  An \UAS scheme satisfies issuance anonymity if, for any p.p.t. adversary
  $\adv$, \AdvIssAnon is a negligible function of $1^\secpar$.
\end{definition}

\begin{definition}{(Signature anonymity in \UAS)}
  \label{def:sign-anonymity-uas}  
  We define the advantage \AdvSigAnon of $\adv$ against \ExpSigAnonb as
  $\AdvSigAnon=|\Pr\lbrack\ExpSigAnono(1^\secpar)=1\rbrack-
  \Pr\lbrack\ExpSigAnonz(1^\secpar)=1\rbrack|$.
  %
  An \UAS scheme satisfies signature anonymity if, for any p.p.t. adversary
  $\adv$, \AdvSigAnon is a negligible function of $1^\secpar$.
\end{definition}

\paragraph{Discussion on the generality of anonymity in \UAS schemes.} %
This notion of anonymity is more general than that of group signatures in the
sense that calls to the \OPEN oracle reveal an arbitrary function of the
identity of the user -- which can certainly be the member index itself, as it
is frequent in group signatures, or any other function computable from the
user key, its credentials, and signed message. Moreover, note that
our notion is even stronger than the conventional ``CCA-like'' anonymity notion
that gives the adversary access to the open oracle, only restricting it when
trying to open challenge signature. Precisely the introduction of generic
opening functions allows us to let the adversary open challenge signatures
$\csig_b$ as long as the counterpart $\csig_{1-b}$
makes \Open produce the same \y value as output. This is certainly not
possible when using conventional opening, since it directly outputs the identity
of the signer -- which cannot be the same for different challenge users.

Note that we could actually remove the requirement that the evaluation function
has to produce the same output on both challenge user-credentials pairs.
However, by doing so, we would force all constructions to maintain private the
output of \feval. We opt not to require that, though, as it directly allows
our model to cover interesting use cases -- such as restricting to selective
disclosure, or privacy-preserving variants of functional signatures \jdv{check
  the latter}, although we show how to do that in \secref{sec:transformations}.

\paragraph{Unforgeability.} In anonymous credentials, unforgeability requires
that no adversary can succeed in a credential presentation for attributes that
are not contained in a legitimately issued credential (set) it controls. Note
that, for this, assuming honest issuers is essential as, otherwise, the
adversary can get credentials on any attribute set it wants.
%
The somehow equivalent property in group signatures, inasmuch it also requires
honest issuers, is traceability. It captures the security of the
open-related functionality (e.g., \Open and \Judge) over signatures
that produced by potentially malicious signers, in the presence of an honest
issuer. In a nutshell, it ensures that every signature accepted by
the verification algorithm must have been created by a user who joined the
group, and that the result of \Open (and thus, \Judge) over such a valid
signature is consistent with its signer. With conventional opening, this is
essentially checked by requesting the adversary to produce a signature,
obtaining -- via open -- the ``identifier'' of the user who produced the
signature. Schemes
that do not have conventional opening resort to more subtle techniques, like
matching keys extracted during join transcripts, with keys used for signing
(see, e.g., \cite{dl21}). Thus, even though for more subtle reasons (the need
for reliable bookkeeping during joins) than for anonymous credentials, honest
issuers are required for traceability of group signatures too.

In our \UAS scheme we allow users prove claims over the attributes they
own -- attested via obtained credentials -- through the \feval function.
Roughly, we capture this as in unforgeability requirement of anonymous
credentials. Namely, we check that the \yeval value returned by \Sign along with
the signature, matches the expected one from the specified \feval function.
On the other hand, the opening capabilities of \UAS schemes also call for a
traceability-like property. However, note that, as opposed to group signatures,
$\langle \Obtain,\Issue \rangle$ protocols are over credentials rather than
users -- although, ultimately, credentials must be owned by some user.
Furthermore, since \Open
does not return the actual identity of the signer, but a function \finsp of it
(and other arguments), we need to make sure that the output of \Open
matches the output of \finsp. As in group signatures with non-conventional open,
we resort to extraction-based techniques. All this is captured via \ExpForgeSign
in \figref{fig:exp-uas-unfor-issue}. Therein, the adversary is challenged to
produce a signature $(\sig,\yeval)$ over message \msg and for evaluation
function \feval; as well as the identifiers for the opener (\oid) and
credential issuers (\siid) used to compute the signature. As in traditional
group signatures, the adversary wins if the signature is accepted by \Verify,
yet \Open or \Judge fail. Then, the game extracts the user key and
credentials used to produce the signature. From it, the game checks if the
output of \feval matches the \yeval value produced by the adversary -- this
mimics the behaviour of unforgeability in anonymous credentials. Finally, the
game also checks that the output of \Open (even if accepted by \Judge)
matches the output of \finsp. If there is any mismatch in the last two checks,
or some of the credentials used to produce the signature do not correspond to
the secret key that was allegedly used to request them, the adversary wins the
game.

Our \UAS scheme includes yet another generalisation that requires unforgeability-like
security, though. Concretely, the issuance function \fissue. We need to make
sure that no credential is issued unless its corresponding
request meets the defined issuance policy. From the point of view of group
signatures, this may seem redundant. After all, if all valid signatures produce
consistent evaluation and opening results, given the employed user key,
credentials, and signed message, the notion of traceability seems to be
satisfied. However, from the point of view of anonymous credentials, an attacker
being able to obtain a credential, even when it does not meet the required
conditions to have it issued, is clearly problematic: it would allow to prove
claims over attributes it does not really ``own'' (even if the output of \Sign
and \Open are consistent with the values returned by \feval and \finsp, and
the credential was obtained via an $\langle \Obtain,\Issue \rangle$ run). To
capture this, we define the \ExpForgeIssue experiment. In the experiment, the
adversary is challenged to produce a credential identifier that must be
associated to an existing $\langle \Obtain,\Issue \rangle$ interaction -- thus,
the corresponding \trans entry must exist (which we can check, as the issuer is
honest). The adversary wins if, either the extraction process fails, or the
extracted user secret key and credentials make the corresponding issuance
function fail.

For both \ExpForgeIssue and \ExpForgeSign, the adversary is given access to the
oracle set $\Oforgeissue = \Oforgesign \gets \lbrace\HU,\CU\rbrace\GEN,\IGEN,
\OGEN,\OCORR,\OBTISS,\ISSUE,\RREG,\SIGN,\OPEN$.

\begin{figure}[htp!]
    \procedure[linenumbering]{$\ExpForgeIssue(1^\secpar)$}{%
      \parm \gets \Setup(1^\secpar) \\
      \cid \gets \adv^{\Oforgeissue}(\parm) \\
      \pcif \trans[\cid] = \bot \lor \CRED[\cid] = \bot: \pcreturn 0 \\
      \textrm{Parse}~\CRED[\cid]~\textrm{as}~(\cdot,\cdot,\iid,\cdot,\cdot);~
      \IK[\iid]~\textrm{as}~((\ipk,\fissue),\cdot) \\
      (\usk,\scred,\attrs_{\scred}) \gets \ExtractIssue(\trans[\cid]) \\
      \pcif \fissue(\usk,\scred,\ATTR[\cid]) = 0 \lor
      \exists \cred \in \scred~\st~\IdentifyCred(\usk,\attrs_{\cred},\cred) = 0: \\
      \pcind \pcreturn 1 \\
%      \pcif \nexists \uid~\st~\IdentifyUK(\uid,\usk) = 1: \pcreturn 1 \\
      \pcreturn 0
    }
  \caption{Experiment for unforgeability of credential issuance in \UAS schemes.}
  \label{fig:exp-uas-unfor-issue}
\end{figure}    

\begin{figure}[htp!]
    \procedure[linenumbering]{$\ExpForgeSign(1^\secpar)$}{%
      \parm \gets \Setup(1^\secpar) \\
      (\oid,\siid,\Sig=(\sig,\yeval),\msg,\feval) \gets \adv^{\Oforgesign}(\parm) \\
      \pcif \exists \uid~\st~(\cdot,\cdot,\Sig,\cdot,\msg,\feval) \in
      \SIG[\uid]: \pcreturn 0 \\
      \pcif \Verify(\PUBOK[\oid],\PUBIK[\siid],\Sig,\msg,\feval) = 0:
      \pcreturn 0 \\
      (\yinsp,\iproof) \gets \Open(\PRVOK[\oid],\siid,\Sig,\msg) \\
      \pcif \Judge(\PUBOK[\oid],\PUBIK[\siid],\yinsp,\iproof,\Sig,\msg,\feval)
      = 0: \pcreturn 1 \\
      (\usk,\scred,\attrs_{\scred},\tyeval^1,\yinsp',r) \gets \ExtractSign(\oid,\siid,\Sig,
      \msg,\feval) \\
      (\yeval^0,\yeval^1) \gets \feval(\usk,\scred,\msg) \\
      \pcif \yeval \neq \yeval^0 \lor \yeval^1 \neq \tyeval^1:
      \pcreturn 1 \\
      \pcif \finsp((\yeval^0,\yeval^1),\usk,\scred,\msg) \neq \yinsp'
      \lor \yinsp \neq \yinsp':
      \pcreturn 1 \\
      \pcif \exists \cred \in \scred~\st~\IdentifyCred(\usk,\attrs_{\cred},\cred) = 0:
      \pcreturn 1 \\
      \pcif \nexists \uid~\st~\IdentifyUK(\uid,\usk) = 1: \pcreturn 1 \\
      \pcreturn 0
    }
  \caption{Experiment for unforgeability of signatures in \UAS schemes.}
  \label{fig:exp-uas-unfor-sign}
\end{figure}

\begin{definition}{(Unforgeable issuance of \UAS)}
  \label{def:issue-forge-uas}  
  We define the advantage \AdvForgeIssue of $\adv$ against \ExpForgeIssue as
  $\AdvForgeIssue=\Pr\lbrack\ExpForgeIssue(1^\secpar)=1\rbrack$.
  %
  A \UAS scheme has unforgeable issuance if, for any p.p.t. adversary $\adv$,
  \AdvForgeIssue is a negligible function of $1^\secpar$.
\end{definition}

\begin{definition}{(Unforgeable signing of \UAS)}
  \label{def:sign-forge-uas}  
  We define the advantage \AdvForgeSign of $\adv$ against \ExpForgeSign as
  $\AdvForgeSign=\Pr\lbrack\ExpForgeSign(1^\secpar)=1\rbrack$.
  %
  A \UAS scheme has unforgeable signing if, for any p.p.t. adversary $\adv$,
  \AdvForgeSign is a negligible function of $1^\secpar$.
\end{definition}

For short, we say that an \UAS scheme that has both unforgeable issuance and
signing, is an unforgeable \UAS scheme.

\paragraph{Discussion on the generality of unforgeability in \UAS schemes.} %
The notion of signature unforgeability we present for \UAS is strictly more
general than the corresponding one of traceability for group signatures. This is
again a direct consequence of the fact that \Open can return an arbitrary
function of the signer's key and credentials (and signed message), which is a
strict generalization of the conventional \Open. Although, even in that case, we
need to take into account attributes, and the fact that the same user may obtain
multiple credentials (that is why, even when having \Open return the identity of
the signer, our notion is not exactly the same). In this sense, the sign
unforgeability notion for \UAS is equivalent to that of anonymous
credentials. It would seem, though, that we do not need the traceability part of
group signatures; after all, it is the protection against wrong claims on
attributes what enables meaningful and flexible authentication. However, the
type of protection against misuses of the open functionality that we can
get with an honest issuer (as in traceability) is much higher than without an
honest issuer (as in non-frameability). Specifically, with an honest issuer we
can ensure that the adversary cannot even alter the value returned by \Open on
signatures by corrupt users, nor the output of the signing predicate \feval.
Whereas, with a corrupt issuer, all we can ensure is that
the adversary cannot forge a signature from an honest user for which \Open
returns the same value as a signature by that honest user would produce; and,
certainly, a corrupt issuer can arbitrarily issue credentials meeting any
desired predicate \feval. Signing unforgeability is, therefore, a core property
to ensure accountability.

Similarly, by adding the related notion of issuance unforgeability, we ensure
that no credential can be issued that did not meet the corresponding issuance
policy. This is again something not necessary in group signatures (with
verifiable openings), where \Judge accepting the opening proof implies that
there is a valid join transcript associated to the membership credential used
to produce the signature. However, in \UAS, given that the credentials contain
attributes, even though that transcript exists, we need to make sure that the
issuance policy over these attributes was satisfied -- and this is not something
(easily) extractable from the signature.

\paragraph{Non-frameability.} %
The notion of non-frameability in \UAS schemes is unavoidably more subtle than
in group signatures. To see this, we note that, by allowing arbitrary
evaluation and open functions to be used, it can be perfectly valid to
have a signature produced by a corrupted user output the same \yeval or \yinsp
values than the ones output when evaluating or opening a signature by an honest
user. As a concrete example, imagine an open function that returns the
nationality of the signer. In any country, there will be many users (corrupt or
not) sharing nationality.
%
More generally, since the issuer is dishonest in non-frameability properties
and, in \UAS, the value produced by \Open may depend on the attributes
included in user credentials, the adversary may even be able to just produce
``legitimate'' openings that output any desired value.

Thus, we again need to resort to extraction techniques. In the non-frameability
definition for \UAS, given in experiment \ExpNonframe in
\figref{fig:exp-uas-frame}, the adversary is challenged to produce a signature
and opening proof that is accepted by \Verify and \Judge, respectively. From
the signature, we then extract the secret key of the signer, and match it
against the secret keys of the honest users. The adversary wins if there is a
match and the signature has not been queried to \SIGN, or if the value \yinsp
output by the adversary is accepted by \Judge, yet it is different from the
extracted $\yinsp'$ value. In the game, the
adversary has access to the oracles in $\Oframe \gets \lbrace\HU,\CU\rbrace\GEN,
\lbrace\II,\OO\rbrace\GEN,\lbrace\II,\OO\rbrace\CORR,\WREG,\OBTAIN,\SIGN$.

\begin{figure}[htp!]
  \procedure[linenumbering]{$\ExpNonframe(1^\secpar)$ \todo{Updated win conditions here. Update proof.}}{%
    \parm \gets \Setup(1^\secpar) \\
    (\oid,\siid,\Sig=(\sig,\yeval),\msg,\feval,\yinsp,\iproof) \gets
    \adv^{\Oframe}(\parm) \\
%    \pcif \exists \uid~\st~(\cdot,\cdot,\sig,\yeval,\msg,\feval) \in \SIG[\uid]:
%    \pcreturn 0 \\
    \pcif \Verify(\PUBOK[\oid],\PUBIK[\siid],\Sig,\msg,\feval) = 0:
    \pcreturn 0 \\
    \pcif \Judge(\PUBOK[\oid],\PUBIK[\siid],\yinsp,\iproof,\Sig,\msg) = 0:
    \pcreturn 0 \\
    (\usk,\scred,\attrs_{\scred},\tyeval^1,\yinsp',r) \gets
    \ExtractSign(\oid,\siid,\Sig,\msg,\feval) \\
%    (\yeval^0,\yeval^1) \gets \feval(\usk,\scred,\msg)~\pccomment{\todo{New}} \\
    \pcif \nexists \uid \in \HU~\st~\UK[\uid] = \usk: \pcreturn 0 \\
    \pcif \nexists (\cdot,\cdot,\Sig,(\yeval^0,\yeval^1),\msg,\feval)
    \in \SIG[\uid]: \pcreturn 1 \\
    \pcif \finsp((\yeval^0,\yeval^1),\usk,\scred,\msg) \neq \yinsp \lor
    \tyeval^1 \neq \yeval^1 \lor \yinsp \neq \yinsp': \pcreturn 1~\pccomment{\todo{1st or part is new}} \\
    \pcif \yeval \neq \yeval^0: \pcreturn 1~\pccomment{\todo{New}} \\
    \pcreturn 0
  }
  \caption{Experiment for non-frameability on \UAS schemes.}
  \label{fig:exp-uas-frame}
\end{figure}

\begin{definition}{(Non-frameability of \UAS)}
  \label{def:frame-uas}
  We define the advantage \AdvNonframe of $\adv$ against \ExpNonframe as
  $\AdvNonframe=\Pr\lbrack\ExpNonframe(1^\secpar)=1\rbrack$.
  %
  A \GSAC scheme satisfies non-frameability if, for any p.p.t. adversary $\adv$,
  \AdvNonframe is a negligible function of $1^\secpar$.
\end{definition}

\paragraph{Discussion on the generality of non-frameability in \UAS schemes.} %
Anonymous credentials do not have non-frameability property and, thus, it is
hard to make a comparison. However, we can draw some connections with AC schemes
that support revocation, as revocation is somehow equivalent to linking, which
is a type of inspection available in group signatures. In this sense, note that
basic revocation (without straight deanonymization) can be trivially achieved
through our generic \Open function. For instance, one could set \finsp to
be a pseudorandom number seeded with the user's public key (or credential). In
this sense, \Open could be essentially seen as a Verifiable Random Function.
If we compare with group signatures, our notion is also more general than the
conventional one, again for the same reason as sign unforgeability (i.e., \Open
can return any value, not just the signer's identity). Thus, the need to extract
the signer's data in order to detect if a framing has taken place.
  
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "uas"
%%% End:
