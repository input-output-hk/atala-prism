\documentclass[10pt,a4paper]{article}
\usepackage[margin=1in]{geometry}

\title{PRISM protocol v0.3} 

\author{Atala PRISM team - IOG} 

\date{} 

\begin{document}


\maketitle 

\begin{abstract} 
This document describes the current state of the protocol that supports PRISM. PRISM is a framework for the management of decentralized identifiers and verifiable credentials. 
\end{abstract}

\setcounter{tocdepth}{3} 

\tableofcontents 
\newpage 

%----------------------------------------------------------------------------------------
%	INTRODUCTION
%----------------------------------------------------------------------------------------

\section{Introduction and protocol description}

In this section we will informally describe a protocol to create and manage DIDs (\textbf{D}ecentralized textbf{Id}entifiers), that also allows to manage the creation, revocation and presentation of verifiable credentials.

\subsection{DIDs management}

For simplicity, we will define a DID as a string identifier of the form 

\begin{center}
	\emph{did:prism:$\langle$identifier$\rangle$}
\end{center}

Each DID is associated to a list of public keys. The list can be updated over time by adding and revoking keys. Each key has an assigned role during its lifetime. The three possible roles we describe are:

\begin{description}
\item[issuing keys] used to issue credentials on behalf of the DID.
\item[revocation keys] used to revoke credentials on behalf of the DID.
\item[master keys] used to add or revoke other keys associated to the DID.
\end{description}

Our construction for DID management relies on an underlying blockchain. The blockchain allows us to publish transactions with sufficiently large metadata. We use the blockchain for both; data distribution along parties, and for consensus related to the order of relevant events in our protocol. All the parties participating in our protocol are running a full node that reads the metadata of the blockchain transactions. When they find a protocol event, they process it to construct their view of the system.

In the following sub-sections we describe the events in our protocol related to DID management.

\subsubsection{DID creation}

In order to create a DID, a user will follow the steps below:

\begin{itemize}
\item The user generates a desired list of public keys. He will associate each key to a key identifier and a role.
      There must be at least one key with the master role in this initial list.
\item The resulting list is encoded and hashed producing an encoded \emph{initial\_state} and a \emph{hash}.
\item The \emph{hash} is encoded in hexadecimal form producing an \emph{encoded\_hash}.
\item The user DID is constructed as \emph{did:prism:encoded\_hash}.
\item The user will send in the metadata of a blockchain transaction a signed \emph{CreateDID} event. 
      The event contains the list of public keys with their identifiers and roles.
      The signature will be performed using the private key associated to any of the master keys in the initial list of keys.
\end{itemize}

Once the transaction is added to the blockchain with a sufficient number of confirmations $d$ (i.e. the block containing the transaction has $d$ blocks appended after it on the underlying chain), all the participants following our protocol will validate the signature of the CreateDID event. After verification, they will register the DID as \emph{published} along with all the keys posted in the initial list. The keys will be considered valid since the time associated to the event carrier transaction. This is a timestamp generated by the blockchain.

Optionally, while waiting for blockchain confirmation, the user can also use the associated DID 

\begin{center}
\emph{did:prism:encoded\_hash:initial\_state}
\end{center}
	
This DID, called \emph{long form} or \emph{unpublished} DID will not be recognised as \emph{published} by other parties in the protocol. However, other users would be able to verify that the list of keys encoded in \emph{initial\_state} corresponds to the DID \emph{did:prism:encoded\_hash}. The recipient of an unpublished DID needs to query the state of the \emph{short form} of the DID (the prefix before "\emph{:initial\_state}") to check for changes in the list of keys. 

\subsubsection{DID update}

Updating a DID means that the user controlling a master key associated to it, will add new or revoke existing keys to the list associated to the DID. In order to update the list of keys, the user will:
\begin{itemize}
\item Create the list of key identifiers that the user wants to revoke from the current state of his DID.
\item Create a list of keys he wants to add to the list of keys associated to his identifier. 
      This keys must be associated to a role and a fresh key identifier.
\item Create an \emph{UpdateDID} event that contains the two previously generated lists.
\item Sign the even with one of the \emph{currently associated} master keys of the DID, and publish the event inside the metadata of a transaction.
\end{itemize}

When the event added to the blockchain with enough confirmations, all parties will process the event. This is, they will validate the signature, and update their internal knowledge of the updated DID. The newly added keys and the revoked keys will be timestamped using the time of the carrier transaction.

With these two events we have shown how to create and update DIDs. 

\subsubsection{Obtain the list of keys associated to a DID}

Now, we can define the process that a protocol participant must follow to obtain the keys associated to a list. 
We mentioned that a DID can be presented in long form (or as an unpublished DID), or in its short form. Hence, we will describe the process in the two cases.

In order to obtain the keys associated to a DID in short form, we simply read the state we have constructed so far by processing the CreateDID and UpdateDID events we read from the blockchain. The list of DIDs associated to the DID is the list of keys we see in our internal state. If we do not find the DID as a published one in our state, we return a \emph{DID unknown} response.

Now, if the DID we receive is in long form, we first verify that $hash(initial\_state) = initial\_hash$. If that check fails we reply with an \emph{Invalid DID} response. If the check passes, we extract the short form of this DID (the prefix that ends right before the last \emph{":"}), and we check the list of keys as described in the previous paragraph. If the result of this process is a \emph{DID unknown} response, then we decode the list from the \emph{initial\_state} suffix and return this list as a result.

With this process we complete the events and operations related to DIDs. 
Lets now move into the events related to issue and revoke credentials.

\subsection{Verifiable credentials}

Now that we have DIDs, we can proceed to the creation and revocation of credentials. A \emph{credential} to us is a set of \emph{claims}. Each claim is represented by a property-value pair, e.g. $(name, John)$. Credentials are created by \emph{issuers} to \emph{subjects}. Both issuers and subjects are represented with their corresponding DIDs. 

For practical reasons, we assume that issuers want to issue credentials in batches. This is, an issuer would like to create multiple credentials at once. Below we describe the steps to issue a batch of credentials.

\subsubsection{Credentials batch issuance}

Lets us define first what a credential is in the context of this document

\begin{description}
\item[Credential] a credential is a JSON document that contains three key-value maps.
 \begin{itemize}
 \item the "issuer" key represents the issuer DID.
 \item the "keyId" key represents the key identifier associated to the issuer DID that was used to sign the credential.
 \item the "claims" key represents claims that the issuer makes about the subject. The claims are grouped in a JSON object.
       There is a key for each claim asserted by the issuer. One particular claim is the subject DID, that represents a DID
       controlled by the subject of the credential.
 \end{itemize}
\end{description}

In the following steps, we assume the issuer and subjects have already established a secure communication channel.
In order to issue a batch of an arbitrary number $N$ of credentials, the issuer will:
\begin{itemize}
\item Ask to each subject the DID they would like to use for the credential they will receive.
\item The issuer creates the credentials for each subject. It uses his DID and the key id of an \emph{issuing key} to populate
      the credential corresponding fields. On each credential, it adds the corresponding subject DID as one of the claims.
\item The issuer encodes each individual credential using a base64URL encoding.
\item The issuer signs each individual encoded credential with an \emph{issuing key} associated to his publicly known DID. 
      The signing key corresponds to the key id in the credentials' claims.
\item The issuer encodes each signature, and concatenate them to their corresponding credentials using a dot (".") as separator.
      This produces strings of the form $\langle{}encoded\_credentials\rangle{}.\langle{}encoded\_signature\rangle{}$. We call these strings as \emph{signed credentials}.
\item Now, the issuer takes all the signed credentials, and computes a merkle root from them.
\item The issuer creates an \emph{IssueBatch} event that contains the merkle root, and signs the event with an \emph{issuing key} associated to his publicly known DID. 
\textbf{Note}: Today we use the same issuing key for the event signature and the individual credentials signature, but those could be different keys.
\item The issuer attaches the signed event to the metadata of a transaction and sends it to the blockchain.
\item The issuer gives to each user their corresponding signed credential along with their associated merkle inclusion proof.
\end{itemize}

Likewise previous protocol events, all parties will process the transaction once confirmed, validate the event signature and timestamp the merkle root with the time associated to the carrier transaction.

Note that, to issue credential batches, the issuer DID \emph{must be published} already. However, users' DIDs can remain unpublished.

\subsubsection{Credentials revocation}

In order to revoke a credentials, issuers have two alternatives:
\begin{enumerate}
\item They revoke all the credentials in a batch.
      This is done by signing a \emph{RevokeBath} event with a \emph{revocation} key associated to the issuer DID.
      The signed event contains the merkle root to revoke.
\item They revoke specific credentials associated to a batch.
      This is done by signing a \emph{RevokeCredentials} event with a \emph{revocation} key associated to the issuer DID. 
      The signed event contains both the merkle root associated to the credentials to revoke, and the hashes of the specific credentials to revoke.
\end{enumerate}

In both variants, the event is published on-chain and processed by all the participants. The participants will timestamp the new information with the carrier transaction time.

\subsection{Credential presentation and verification}

Once they receive credentials from issuers, subjects will present them to interested parties, called \emph{verifiers}. For example, a student may receive a verifiable credential from a university, and would like to present his credential to a potential employer. In our setting, the verifier will be a party following our protocol events from the blockchain. The steps to present and verify a credential are the following:
\begin{itemize}
\item We assume a safe communication channel between the subject and verifier.
      We also assume that the channel can be identified by an identifier $ch$.
\item The subject shares his credential and merkle inclusion proof to the verifier.
\item The verifier then: 
	\begin{itemize}
	\item computes the merkle root from the inclusion proof and the credential hash;
	\item extracts the issuer DID and signing key id from the credential claims,
	\item retrieves from the state he computed from the blockchain, the timestamps associated to the merkle root and the issuing key, 
	\item checks if the merkle root or credential hash has been revoked
	\item validates the issuer signature on the credential, and determines if it was signed at a time when the issuer key was valid.
	\end{itemize}
  \textbf{Note:} The signature of the IssueBatch event has already been verified by the protocol participants at the time of batch publication. 
\item At this point, the verifier knows that the credential was properly signed. Now, he shares a nonce to the subject and asks him to sign it with a key associated to his DID.
\item The subject signs the hash of $nonce || ch$ and returns the signature to the verifier.
\item The verifier now checks the signature and concludes that the credential subject is indeed the person presenting it.
\end{itemize}

%----------------------------------------------------------------------------------------
%	PROPERTIES
%----------------------------------------------------------------------------------------

\section{Properties we believe we have}

\paragraph{Unforgeability.} A user cannot forge issuer-generated credentials.
\paragraph{Privacy against issuers.} An issuer does not learn whether a user (who acquired a credential from the issuer) has interacted with a given verifier (assuming no cooperation between issuer and verifiers).
\paragraph{Revocability.} An issuer can revoke a previously-issued credential without users’ cooperation.
\paragraph{Protection against credential reuse.} A verifier can ensure no credential is used by different DIDs. 
\paragraph{Deferred and offline verification checks.} A verifier can verify the revocation status of a credential asynchronously without users’ participation. A verifier can also verify a credential without contacting the internet, in which case the verification result is with respect to the last time the verifier synchronized with blockchain events.
\paragraph{Resistance to key rotation.} If an issuer's issuing key is revoked, credentials already issued by that key remain valid. This means that the issuer does not need to re-issue the credentials signed by a compromised issuing key. This is possible due to the fact that key revocation and credential issuances are timestamped. Hence, if an issuing key is revoked, credentials already issued remain valid unless they are explicitly revoked.
\paragraph{Independence of issuers and verifiers.} Verifiers only need to know which issuer DIDs they trust. They do not need to contact issuers to query issuance nor revocation lists.
\paragraph{Past preservation.} Any party that verifies a credential has non-reputable information of when the credential was valid even if it has been revoked.

\section{Properties we are not offering}

\paragraph{Unlinkability.} A coalition of verifiers cannot link activities of users across verifiers.
\paragraph{Minimal disclosure.} A user only reveals what is necessary to establish a relationship with a verifier.

%----------------------------------------------------------------------------------------
%	PROPOSED IDEAS
%----------------------------------------------------------------------------------------

% \section{Ideas to add missing properties}


\end{document}
