\section{Preliminaries}
\label{sec:preliminaries}

\subsection{Cryptographic Building Blocks}
\label{ssec:bbs}

% \todo{Briefly describe algorithms they use.}

% \paragraph{Append-Only Bulletin Boards.} %
% %\todo{For now, simplified notion as in \cite{acc+20}.}

% \paragraph{Digital Signatures.} %
% %Maybe build on \IdealFSig from \cite{canetti03}.

% \paragraph{Merkle Trees.}

% \paragraph{Public Key Infrastructures.} %
% % Maybe build on \IdealFCA from \cite{canetti03}.

% \subsection{Base Functionalities}
% \label{ssec:did-funcs}

\todo{Mention public delayed outputs.}
\todo{If the functionalities try to fetch some entry from a list, and the entry
  does not exist, then it aborts (assumed for updates).}

\paragraph{Hashes.} %
We model hashes as a global subroutine. No participant needs extra power (such
as programmability or observability), so we use a conventional random oracle --
called strict random oracle in \cite{cdg+18}. For self-containment, we reproduce
here the formulation.

\begin{figure}[ht]
  \begin{framed}
    \begin{minipage}[t]{\textwidth}
      \textrm{Upon receiving a call $\IdealGRO(\cmd,\sid,\arg)$ from some party
        $P$ to run command \cmd, in session \sid, with arguments \arg,
        \IdealGRO operates as follows.} \\
      \textrm{\IdealGRO keeps a list \hashlist of known hashed messages, and
        outputs hashes of length $l \gets l(n)$, for some fixed security
        parameter $n$.}
    \end{minipage}
    \vspace*{0.5em}
    
    \centering
    \procedure{$\pcif \cmd = \uccmd{HashQuery} \land \arg = \msg$}{%
      \pcif (\msg,h) \notin \hashlist:
      h \getr \bin^{l}; \hashlist \gets \hashlist \cup \lbrace (\msg,h) \rbrace \\
      \ucio{Output}~(\uccmd{HashConfirm},h)
    }
  \end{framed}
\end{figure}

\paragraph{Global clock.} %
Our ideal (global) functionality for a ledger relies on a global clock to model
delays in appending information. We rely on the ideal global clock functionality
given in \cite{kkk21}. In a nutshell, the functionality keeps track of the
parties in the system, and allows them to signal their intention to advance the
clock's time. When all parties agree on it, the clock's time is incremented. See
\figref{fig:gclock}.

\begin{figure}[ht]
  \begin{framed}
    \begin{minipage}[t]{\textwidth}
      \textrm{Upon receiving a call $\IdealGclock(\cmd,\arg)$ from
        some party $P$ to run command \cmd, with arguments \arg,
        \IdealGclock operates as follows.} \\
      \textrm{\IdealGclock maintains a variable $t$ with the current itme,
        a variable $T$ with the list of parties keeping track of the time,
        and a map $A$ which keeps the parties' (dis)agreements to advance the
        clock.}
    \end{minipage}
    \vspace*{0.5em}

    \begin{minipage}[t]{0.40\textwidth}
      \procedure{$\pcif \cmd = \uccmd{Register} \land \arg = \emptyset$}{
        T \gets T \cup \set{P} \\
        \ucio{Output}~(\uccmd{Registered})~\text{to}~P \\
      }
      \procedure{$\pcif \cmd = \uccmd{Update} \land \arg = \emptyset$}{
        A(P) \gets \top \\
        \pcif \forall P \in T, A(P) = \top: \\
        \pcind t \gets t + 1; \forall P \in T, A(P) = \bot \\
        \pcind \ucio{Send}~(\uccmd{Updated})~\text{to}~P        
      }
    \end{minipage}
    \hspace*{1.25em}
    \begin{minipage}[t]{0.60\textwidth}
      \procedure{$\pcif \cmd = \uccmd{Deregister} \land \arg = \emptyset$}{
        T \gets T \setminus \set{P} \\
        \text{Output}~(\uccmd{DeregisteredOk})~\text{to}~P \\
      }
      \procedure{$\pcif \cmd = \uccmd{Read} \land \arg = \emptyset$}{
        \text{Output}~(\uccmd{ReadOk},t)~\text{to}~P
      }
    \end{minipage}
  \end{framed}
  \caption{Ideal subroutine for a global clock, from \cite{kkk21}.}
  \label{fig:gclock}
\end{figure}

\paragraph{$\delta$-delay Ledger.} %
We adopt a ledger notion given in \cite{kkk21}. This is global functionality
that defines an ideal version of a ledger as a shared subroutine, which models
the append-only property of ledgers, and the fact that changes take some delay
until they are applied to the ledger.
%
This functionality accepts sending individual transactions to be added to the
ledger state, fetching (reading) the state of the ledger, and extending the
ledger by appending (blocks of) transactions to it. Interestingly, it gives the
adversary control over when to advance the status of each party, as long as
these advancements ensure the common prefix rule -- where $\ldgState' \prec
\ldgState$ means that $\ldgState'$ is a prefix of \ldgState. It also relies
on yet another global functionality, the global clock, to timestamp incoming
transactions. If a transaction is not appended to an honest party's view before
the given $\delta$ delay, then the functionality aborts.
%
For the sake of readability, we reproduce the functionality in
\figref{fig:gledger}.

\begin{figure}[ht]
  \begin{framed}
    \begin{minipage}[t]{\textwidth}
      \textrm{Upon receiving a call $\IdealGdledger(\cmd,\arg)$ from
        some party $P$ to run command \cmd, with arguments \arg,
        \IdealGdledger operates as follows.} \\
      \textrm{\IdealGdledger maintains a mapping \ldgMap which associates
        parties with their view of the ledger.
        \ldgUtxo is a multiset of unconfirmed transactions.
        \ldgState is the authoritative ledger state
        All mappings and (multi-)sets are initialised to empty values.
      }
    \end{minipage}
    \vspace*{0.5em}

    \begin{minipage}[t]{0.40\textwidth}
      \procedure{$\pcif \cmd = \uccmd{Submit} \land \arg = \ldgTx$}{
        \ucio{Send}~(\uccmd{Read})~\text{to}~\IdealGclock \\
        \ucio{Recv}~(\uccmd{ReadOk},t)~\text{from}~\IdealGclock \\
        \ldgUtxo \gets \ldgUtxo \cup \set{(\ldgTx,t)} \\ 
        \ucio{Output}~(\uccmd{Transaction},\ldgTx,t)~\text{to}~\adv \\
      }
      \procedure{$\pcif \cmd = \uccmd{Extend} \land \arg = \ldgState'$}{
        \pcif P = \adv \land \ldgState' \subseteq \ldgUtxo: \\
        \pcind \ldgUtxo \gets \ldgUtxo \setminus \ldgState' \\
        \pcind \ldgState \gets \ldgState || \ldgState'
      }
    \end{minipage}
    \hspace*{1.25em}
    \begin{minipage}[t]{0.60\textwidth}
      \procedure{$\pcif \cmd = \uccmd{Read} \land \arg =
        \emptyset$}{
        % \pcif P = \adv: data \gets \ldgState \\
        % \pcelse: data \gets \ldgMap(P) \\
        \ucio{Send}~(\uccmd{Read})~\text{to}~\IdealGclock \\
        \ucio{Recv}~(\uccmd{ReadOk},t)~\text{from}~\IdealGclock \\
        \pcif \exists (\ldgTx,t') \in \ldgUtxo~\suchthat~|t-t'| > \delta:
        \pcreturn \bot \\
        \pcelse \pcif \exists (\ldgTx,t') \in \ldgState~\suchthat~ |t-t'|
        > \delta~\land \\
        \pcind \exists P' \in \ldgHonest~\suchthat~(\ldgTx,t') \notin \ldgMap(P'):
        \pcreturn \bot \\        
        \text{Output}~(\uccmd{ReadOk}, \ldgHead(\ldgMap(P)))~\text{to}~P \\
      }
      \procedure{$\pcif \cmd = \uccmd{Advance} \land \arg = (P',\ldgState')$}{
        \pcif P = \adv \land \ldgMap(P') \prec \ldgState' \prec \ldgState:
        \ldgMap(P') \gets \ldgState'
      }
    \end{minipage}
  \end{framed}
  \caption{Ideal subroutine for a global $\delta$-delay ledger, from
    \cite{kkk21}.}
  \label{fig:gledger}
\end{figure}

\paragraph{Digital Signatures.} %

\begin{figure}
  \begin{framed}
    \begin{minipage}[t]{\textwidth}
      \textrm{Upon receiving a call $\IdealFSig(\cmd,\sid,\arg)$ from some party
        $P$ to run command \cmd, in session \sid, with arguments \arg,
        \IdealFSig operates as follows.} \\
      \textrm{\IdealFSig keeps a list \SIG of known signed messages.}      
    \end{minipage}
    \vspace*{0.5em}

    \begin{minipage}[t]{0.5\textwidth}
      \procedure{$\pcif \cmd = \uccmd{KeyGen} \land \arg =
        \emptyset$}{
        \pccomment{\fbox{Key Generation}} \\
        \pcif \sid = (P,\ssid): \\
        \pcind \ucsend~(\uccmd{KeyGen},\sid)~\text{to}~\adv \\
        \pcind \ucrecv~(\uccmd{VerKey},\sid,v)~\text{from}~\adv \\
        \pcind \ucio{Output}~(\uccmd{VerKey},\sid,v)~\text{to}~P \\
        \pcind \text{Store}~(P,v)
      }
      \vspace*{0.25em}
      \procedure{$\pcif \cmd = \uccmd{Verif} \land
        \arg = (\sig,\msg,v')$}{
        \pccomment{\fbox{Verify a message}} \\
        \ucsend~(\uccmd{Verif},\sid,\msg,\sig,v)~\text{to}~\adv \\
        \ucrecv~(\uccmd{Verifd},\sid,\msg,\phi)~\text{from}~\adv \\
        \pcif v' = v \land (\msg,\sig,v,1) \in \SIG: f \gets 1 \\
        \pcelse \pcif v' = v \land P~\text{is not corrupt}~\land \\
        \pcind (\msg,\sig',v,1) \notin \SIG: \\
        \pcind \SIG \gets \SIG \cup \lbrace (\msg,\sig,v,0) \rbrace;
        f \gets 0 \\
        \pcelse \pcif (\msg,\sig,v',f') \in \SIG: f \gets f' \\
        \pcelse: \\
        \pcind \SIG \gets \SIG \cup \lbrace (\msg,\sig,v',\phi) \rbrace;~
        f \gets \phi \\
        \ucio{Output}~(\uccmd{Verifd},\sid,\msg,f)
      }
    \end{minipage}
    \begin{minipage}[t]{0.5\textwidth}
      \procedure{$\pcif \cmd = \uccmd{Sign} \land \arg = \msg$}{
        \pccomment{\fbox{Sign a message}} \\
        \pcif \sid = (P,\ssid) \\
        \pcind \ucsend~(\uccmd{Sign},\sid,\msg)~\text{to}~\adv \\
        \pcind \ucrecv~(\uccmd{Signed},\sid,\msg,\sig)~\text{from}~
        \adv \\
        \pcind \pcif (\msg,\sig,v,0) \in \SIG: \\
        \pcind \pcind \ucio{Output}~(\uccmd{Error}) \\
        \pcind \pcelse: \\
        \pcind \pcind \SIG \gets \SIG \cup (\msg,\sig,v,1) \\
        \pcind \pcind \ucio{Output}~(\uccmd{Signed},\sid,\msg,\sig)
      }
    \end{minipage}
  \end{framed}
  \caption{Ideal signature functionality, \IdealFSig, from \cite{canetti03}.}
  \label{fig:fsig}
\end{figure}

\iffalse
We take the basic approach to see DID documents as simple dictionaries
(i.e., lists of labels with corresponding types and values), associated to a
common label, the DID. Based on this, we define the operations that compose an
ideal basic functionality for DIDs, as follows:

\begin{description}
\item[Create interface.] To create a new DID, the functionality exposes a
  \uccmd{Create} interface that receives a tuple of label and key type values.
  Then, it asks the adversary to provide a value to each of the specified
  labels, and the DID value. If the DID value does not exist in the records of
  the functionality, a new entry (including the dictionary) is created. In order
  to meet the authentication requirement, the ideal functionality takes note of
  the party creating the DID, so that subsequent changes in the DID can only be
  done by this party. We note that more advanced predicates could be defined, by
  this bare minimum seems to be enough for most (current) DID methods.
  \todo{Give evidence of the latter?}
\item[Read interface.] The contents of existing DIDs can be fetched via the
  \uccmd{Read} interface. It receives a DID value and, if it exists in the
  functionality's records, returns the associated contents. Note that, if such
  entry exists, then it is authentic by definition, and thus trivially meets
  the authentication requirements.
\item[Update interface.] The contents of existing DIDs can be modified via the
  \uccmd{Update} interface. It requires to specify the actual DID and two lists:
  $\sval_d$ with the labels to remove, and $\sval_a$ with the lables of new keys
  to add (along with their types). The DID must exist in the records of the
  functionality, and the call must originate from the same party that created
  it. Note that this covers variants such as using update only to add new keys
  (e.g. by specifying an empty $\sval_d$), or modifications of existing labels
  (e.g., by adding an existing label in $\sval_d$, and also in $\sval_a$).
\item[Deactivate interface.] Deactivating a DID is actually a simplification of
  the update operation, without specifying new keys to add. This is possible
  via the \uccmd{Deact} interface. Note that it is not strictly necessary to
  specify this interface, as it is a special case of \uccmd{Update}. However, we
  explicitly add it for proximity to the actual DID specification. \todo{Just
    remove it?}
\end{description}

Our expectation is that this simple approach allows to capture a large
subset of all possible DID method implementations. Note that the functional
restrictions we impose seem to be unavoidable. Namely, we do not specify how
the actual identifiers are computed; instead, we allow the adversary to pick
them. To update a DID, we only require such DID to exist and that the caller
is the party that created it, but otherwise the DID's contents can be set to
something completely new. Finally, deactivating labels within an existing DID
requires that these labels exist -- and, again, that the caller is the same
party who created the DID. Concretely, note that any further structure beyond
the label-type-value dictionary approach, is left as an implementation detail.
However, enforcing additional structure seems unavoidable in practice (e.g.,
requiring that all DIDs include keys of certain type). Since this definitely
has an impact on the behaviour of the ideal functionality, we parameterize it
with a policy \P, which can be used as a black box: the functionality invokes
\P with a set of labels and key types, and receives either $1$ to denote
acceptance, or $0$ to denote rejection. However, it is not realistic to assume
that, even corrupted parties will enforce such policies. Thus, our approach is
to defer policy checking in the ideal functionality until after having
interacted with the simulator \Sim. Intuitively then, if the output of the
ideal functionality along with \Sim is indistinguishable to that of the real
protocol with any real world adversary, then the policy is correctly enforced
by the real protocol. Looking ahead, the real protocol in turn ``delegates''
this policy-checking to an ideal append-only bulletin board. \todo{This captures
  the idea, but refine and re-structure.}

Note that we also allow the adversary to pick the values associated to the
labels in new and updated DIDs. This is a strong requirement that follows the
argumentation in \cite{canetti03} for ideal digital signatures: namely, this
means that there is absolutely any requirement on the way in which this values
are computed (they might not even be conventional public keys). Indeed, this
seems to match the permissive philosophy of defining DIDs in the W3C DID
specification.

We capture the resulting notion in \figref{fig:fpkidid}.

\begin{figure}
  \begin{framed}
    \scalebox{0.9}{
      \begin{minipage}[t]{\textwidth}
        \textrm{Upon receiving a call $\IdealFPKIDID^{\P}(\cmd,\sid,\arg)$
          from some party $P$ to run command \cmd, in session \sid, with arguments
          \arg, $\IdealFPKIDID^{\P}$ operates as follows.}
        \textrm{If the received \cmd and \arg pair does not meet any of
          the following options, the request is ignored.}
        \textrm{\P is a boolean predicate defining concrete conditions for
          acceptable DID creations, updates and deactivations.
        }
        \textrm{\todo{We assume that the functionality keeps track of the
            received requests.}}
      \end{minipage}
    }
    \vspace*{0.5em}

    \scalebox{0.9}{
      \begin{minipage}[t]{0.55\textwidth}
        \procedure[linenumbering]{$\pcif \cmd = \uccmd{Create} \land \arg =
          \lbrace (\lbl_i,\typ_i) \rbrace_{i\in[n]}$}{
          \pcif \P(\lbrace (\lbl_i, \typ_i) \rbrace_{i\in[n]}) = 0:
          \text{abort} \\                    
          \ucsend~(\uccmd{Create}, \sid, \arg)~\text{to}~\Sim \\
          \ucrecv~(\uccmd{CreateOk}, \sid, \did,
          \sval=\lbrace \val_i \rbrace_{i\in[n]}) \\
          \hspace*{2.8em}\text{from}~\Sim \\
          \pcif (\cdot,\did,\cdot) \notin \DID: \\
          \pcind \DID \gets \DID \cup \lbrace (P,\did,\lbrace
          (\lbl_i,\typ_i,\val_i) \rbrace_{i\in[n]}) \rbrace \\
          \ucio{Output}~(\uccmd{Created},\sid,\did,\sval)
        }
      \end{minipage}
    }
    \scalebox{0.9}{
      \begin{minipage}[t]{0.5\textwidth}
        \procedure[linenumbering]{$\pcif \cmd = \uccmd{Read} \land
          \arg = did$}{
          \ucsend~(\uccmd{Read},\sid,\arg)~\text{to}~\Sim \\
          \ucrecv~(\uccmd{ReadOk},\sid)~\text{from}~\Sim \\          
          \pcif (\cdot,did,\sval) \notin \DID: abort \\
          \pcif \P(\sval) = 0: abort \\
          \ucio{Output}~(\uccmd{Read},\sid,(did,\sval))~\text{to}~P
        }    
      \end{minipage}
    }
    \vspace*{0.25em} \\
    \scalebox{0.9}{
      \begin{minipage}[t]{0.55\textwidth}
        % \arg = (did, \sval= \lbrace (\lbl_i,\typ_i) \rbrace_{i\in[n]})\$}{
        \procedure[linenumbering]{$\pcif \cmd = \uccmd{Update} \land
          \arg = (did, \sval_d,\sval_a)$}{          
          % \sval_{del} \gets \sval_0 \setminus \sval;
          % \sval_{add} \gets \sval \setminus \sval_{del} \\          
          % n'' \gets |\sval_{add}| \\
          \pcif (P,\did,\sval_0) \notin \DID: \text{abort} \\
          \pcif \P((\sval \setminus \sval_d) \cup \sval_a) = 0: \text{abort} \\
          \ucsend~(\uccmd{Update}, \sid,\did,\sval_d,\sval_a)~\text{to}~\Sim \\
          \ucrecv~(\uccmd{UpdtOk},\sid,\did,\lbrace \val^a_i \rbrace_{i\in[n^a]})~
          \text{from}~\Sim \\
          \lbrace (\lbl_i^a,\typ_i^a) \rbrace_{i\in[n^a]} \gets \sval_a;~
          \lbrace \lbl_i^d \rbrace_{i\in[n^d]} \gets \sval_d \\          
          \sval_1 \gets (\sval_0 \setminus \sval_d) \cup
          \lbrace (\lbl^a_i,\typ^a_i,\val^a_i) \rbrace_{i\in[n^a]} \\          
          \DID \gets \DID \setminus \lbrace (P,\did,\sval_0) \rbrace \cup
          \lbrace (P, \did, \sval_1) \rbrace \\
          \ucio{Output}~(\uccmd{Updated},\sid, (\did,\lbrace \val_a \rbrace_{i\in[n^a]}))
        }
      \end{minipage}
    }
    \scalebox{0.9}{
      \begin{minipage}[t]{0.5\textwidth}
        \procedure[linenumbering]{$\pcif \cmd = \uccmd{Deact} \land \arg =
          (did, \lbrace \lbl_i \rbrace_{i\in[n]})$}{          
          \pcif (P,did,\sval_0) \notin \DID: abort \\
          \sval_1 \gets \sval_0 \setminus \lbrace \lbl_i \rbrace_{i\in[n]} \\
          \pcif \P(\sval_1) = 0: abort \\
          \ucsend~(\uccmd{Deact}, \sid, \arg)~\text{to}~\Sim \\
          \ucrecv~(\uccmd{DeactOk},\sid)~\text{from}~\Sim \\          
          \pcind \DID \gets \DID \setminus \lbrace(P,did,\sval_0)\rbrace~\cup \\
          \hspace*{7em}\lbrace (P,did,\sval_1) \rbrace \\
          \ucio{Output}~(\uccmd{Deacted},\sid,\did)
        }
      \end{minipage}
    }
  \end{framed}
  \caption{Ideal PKI functionality, \IdealFPKI. We abuse set
    notation, and write $\lbrace (a_i,\dots) \rbrace_{i\in[n]} \setminus
    \lbrace (b_j,\dots) \rbrace_{j\in[m]}$ to mean subtracting from the first
    set the elements present in the second set, whenever $a_i = b_j$ for some
    $i,j$, even if the size of the $(a_i,\dots)$ and $(b_j,\dots)$ tuples do not
    match.}
  \label{fig:fpki}
\end{figure}
\fi

\subsection{Self-Sovereign Identities}
\label{ssec:ssi}

\paragraph{Decentralised Identifiers (DIDs).} %
Much of the SSI community is built on top of DIDs, which is a W3C Recommendation
since 2022\footnote{\url{https://www.w3.org/TR/did-core}. Last access, 3rd
  November, 2022.}. Strictly speaking, a DID is a string that uniquely
identifies information referring to some entity, whereas such information is
the DID document. The DID controller is yet another entity who is allowed to
apply changes to a DID document. In the sequel, for simplicity we assume that
the controller is also the entity that the information in the DID document
refers to, but this is not necessarily the case in general.

Essentially, the DID specification defines how to associate
public keys and additional metadata to unique identifiers, leveraging verifiable
data registries (VDR). Whereas there is no concrete requirement on these VDRs,
the typical choice are blockchains, which leads to the ``Decentralised''
adjective for DIDs. The DID specification describes the syntax that identifiers
must follow, as well as the CRUD (Create, Read, Update, Deactivate) operations
that any DID-compatible mechanism must implement. Concretely:

\begin{description}
\item[Create.] Must specify how controllers create new DIDs.
\item[Read.] Must specify how the contents of a DID can be fetched and
  authenticated.
\item[Update.] Must specify what updates can controllers apply (if any)
  to existing DIDs.
\item[Deactivate.] Must specify if (parts of) existing DIDs can be signaled
  as no longer valid, and how.
\end{description}

That is, a mechanism following the DID specification must enable any user to be
able to register a unique identifier, associate public key material to it, and
manange it. Thus, as we do here, it is natural to see such a mechanism as an
specific type of Public Key Infrastructures (PKIs), where different
approaches to implement the CRUD methods required by the DID specification, or
based on different VDRs -- can be seen as a different type of DID-based PKI.

A final requirement put by the W3C DID specification concerns authorisation.
Namely, it states (in Section 8.2) that candidate DID methods ``must define how
authorisation is performed''. This concretely means that DID methods have to
define the way in which controllers prove to be entitled to perform create,
update, or deactivate operations.

\paragraph{Verifiable Credentials (VCs).} %
\todo{Describe: Introduction to VCs. Relating to DIDs.}

\subsection{Overview of Atala PRISM}
\label{ssec:overview-prism}

In a nutshell, Atala PRISM builds VCs and DIDs on top of the Cardano blockchain.
More concretely, any entity can create (and manage) a DID, and issuers can issue
VCs associated to a previously existing DID, where Cardano is the chosen VDR.
Users can later leverage VCs to authenticate against any potential verifier, in
a manner that all the information that the verifier needs to (cryptographically)
authenticate the user is contained in the Cardano blockchain.

\todo{Ellaborate more.}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "prism-protocol"
%%% End:
