\section{DIDs in Atala PRISM}
\label{sec:did-atala}

In this section we first give an ideal functionality for Public-Key
Infrastructures built atop of DIDs \IdealGPKIDID, and subsequently describe
Atala PRISM DID method \RealPKIDIDAtala, which is a protocol realizing
\IdealGPKIDID.
%
Before doing so, we introduce some base ideal functionalities upon which we
rely for \RealPKIDIDAtala. Namely, a simplified notion of append-only bulletin
boards, and digital signatures.

\subsection{Base Functionalities}
\label{ssec:did-funcs}

\todo{Mention public delayed outputs.}
\todo{If the functionalities try to fetch some entry from a list, and the entry
  does not exist, then it aborts (assumed for updates).}

\paragraph{Hashes.} %
We model hashes as a global subroutine. No participant needs extra power (such
as programmability or observability), so we use a conventional random oracle --
called strict random oracle in \cite{cdg+18}. For self-containment, we reproduce
here the formulation.

\begin{figure}[ht]
  \begin{framed}
    \begin{minipage}[t]{\textwidth}
      \textrm{Upon receiving a call $\IdealGRO(\cmd,\sid,\arg)$ from some party
        $P$ to run command \cmd, in session \sid, with arguments \arg,
        \IdealGRO operates as follows.} \\
      \textrm{\IdealGRO keeps a list \hashlist of known hashed messages, and
        outputs hashes of length $l \gets l(n)$, for some fixed security
        parameter $n$.}
    \end{minipage}
    \vspace*{0.5em}
    
    \centering
    \procedure{$\pcif \cmd = \uccmd{HashQuery} \land \arg = \msg$}{%
      \pcif (\msg,h) \notin \hashlist:
      h \getr \bin^{l}; \hashlist \gets \hashlist \cup \lbrace (\msg,h) \rbrace \\
      \ucio{Output}~(\uccmd{HashConfirm},h)
    }
  \end{framed}
\end{figure}

\paragraph{Global clock.} %
Our ideal (global) functionality for a ledger relies on a global clock to model
delays in appending information. We rely on the ideal global clock functionality
given in \cite{kkk21}. In a nutshell, the functionality keeps track of the
parties in the system, and allows them to signal their intention to advance the
clock's time. When all parties agree on it, the clock's time is incremented. See
\figref{fig:gclock}.

\begin{figure}[ht]
  \begin{framed}
    \begin{minipage}[t]{\textwidth}
      \textrm{Upon receiving a call $\IdealGclock(\cmd,\arg)$ from
        some party $P$ to run command \cmd, with arguments \arg,
        \IdealGclock operates as follows.} \\
      \textrm{\IdealGclock maintains a variable $t$ with the current itme,
        a variable $T$ with the list of parties keeping track of the time,
        and a map $A$ which keeps the parties' (dis)agreements to advance the
        clock.}
    \end{minipage}
    \vspace*{0.5em}

    \begin{minipage}[t]{0.40\textwidth}
      \procedure{$\pcif \cmd = \uccmd{Register} \land \arg = \emptyset$}{
        T \gets T \cup \set{P} \\
        \ucio{Output}~(\uccmd{Registered})~\text{to}~P \\
      }
      \procedure{$\pcif \cmd = \uccmd{Update} \land \arg = \emptyset$}{
        A(P) \gets \top \\
        \pcif \forall P \in T, A(P) = \top: \\
        \pcind t \gets t + 1; \forall P \in T, A(P) = \bot \\
        \pcind \ucio{Send}~(\uccmd{Updated})~\text{to}~P        
      }
    \end{minipage}
    \hspace*{1.25em}
    \begin{minipage}[t]{0.60\textwidth}
      \procedure{$\pcif \cmd = \uccmd{Deregister} \land \arg = \emptyset$}{
        T \gets T \setminus \set{P} \\
        \text{Output}~(\uccmd{DeregisteredOk})~\text{to}~P \\
      }
      \procedure{$\pcif \cmd = \uccmd{Read} \land \arg = \emptyset$}{
        \text{Output}~(\uccmd{ReadOk},t)~\text{to}~P
      }
    \end{minipage}
  \end{framed}
  \caption{Ideal subroutine for a global clock, from \cite{kkk21}.}
  \label{fig:gclock}
\end{figure}

\paragraph{$\delta$-delay Ledger.} %
We adopt a ledger notion given in \cite{kkk21}. This is global functionality
that defines an ideal version of a ledger as a shared subroutine, which models
the append-only property of ledgers, and the fact that changes take some delay
until they are applied to the ledger.
%
This functionality accepts sending individual transactions to be added to the
ledger state, fetching (reading) the state of the ledger, and extending the
ledger by appending (blocks of) transactions to it. Interestingly, it gives the
adversary control over when to advance the status of each party, as long as
these advancements ensure the common prefix rule -- where $\ldgState' \prec
\ldgState$ means that $\ldgState'$ is a prefix of \ldgState. It also relies
on yet another global functionality, the global clock, to timestamp incoming
transactions. If a transaction is not appended to an honest party's view before
the given $\delta$ delay, then the functionality aborts.
%
For the sake of readability, we reproduce the functionality in
\figref{fig:gledger}.

\begin{figure}[ht]
  \begin{framed}
    \begin{minipage}[t]{\textwidth}
      \textrm{Upon receiving a call $\IdealGdledger(\cmd,\arg)$ from
        some party $P$ to run command \cmd, with arguments \arg,
        \IdealGdledger operates as follows.} \\
      \textrm{\IdealGdledger maintains a mapping \ldgMap which associates
        parties with their view of the ledger.
        \ldgUtxo is a multiset of unconfirmed transactions.
        \ldgState is the authoritative ledger state
        All mappings and (multi-)sets are initialised to empty values.
      }
    \end{minipage}
    \vspace*{0.5em}

    \begin{minipage}[t]{0.40\textwidth}
      \procedure{$\pcif \cmd = \uccmd{Submit} \land \arg = \ldgTx$}{
        \ucio{Send}~(\uccmd{Read})~\text{to}~\IdealGclock \\
        \ucio{Recv}~(\uccmd{ReadOk},t)~\text{from}~\IdealGclock \\
        \ldgUtxo \gets \ldgUtxo \cup \set{(\ldgTx,t)} \\ 
        \ucio{Output}~(\uccmd{Transaction},\ldgTx,t)~\text{to}~\adv \\
      }
      \procedure{$\pcif \cmd = \uccmd{Extend} \land \arg = \ldgState'$}{
        \pcif P = \adv \land \ldgState' \subseteq \ldgUtxo: \\
        \pcind \ldgUtxo \gets \ldgUtxo \setminus \ldgState' \\
        \pcind \ldgState \gets \ldgState || \ldgState'
      }
    \end{minipage}
    \hspace*{1.25em}
    \begin{minipage}[t]{0.60\textwidth}
      \procedure{$\pcif \cmd = \uccmd{Read} \land \arg =
        \emptyset$}{
        % \pcif P = \adv: data \gets \ldgState \\
        % \pcelse: data \gets \ldgMap(P) \\
        \ucio{Send}~(\uccmd{Read})~\text{to}~\IdealGclock \\
        \ucio{Recv}~(\uccmd{ReadOk},t)~\text{from}~\IdealGclock \\
        \pcif \exists (\ldgTx,t') \in \ldgUtxo~\suchthat~|t-t'| > \delta:
        \pcreturn \bot \\
        \pcelse \pcif \exists (\ldgTx,t') \in \ldgState~\suchthat~ |t-t'|
        > \delta~\land \\
        \pcind \exists P' \in \ldgHonest~\suchthat~(\ldgTx,t') \notin \ldgMap(P'):
        \pcreturn \bot \\        
        \text{Output}~(\uccmd{ReadOk}, \ldgHead(\ldgMap(P)))~\text{to}~P \\
      }
      \procedure{$\pcif \cmd = \uccmd{Advance} \land \arg = (P',\ldgState')$}{
        \pcif P = \adv \land \ldgMap(P') \prec \ldgState' \prec \ldgState:
        \ldgMap(P') \gets \ldgState'
      }
    \end{minipage}
  \end{framed}
  \caption{Ideal subroutine for a global $\delta$-delay ledger, from
    \cite{kkk21}.}
  \label{fig:gledger}
\end{figure}

\paragraph{Digital Signatures.} %

\begin{figure}
  \begin{framed}
    \begin{minipage}[t]{\textwidth}
      \textrm{Upon receiving a call $\IdealFSig(\cmd,\sid,\arg)$ from some party
        $P$ to run command \cmd, in session \sid, with arguments \arg,
        \IdealFSig operates as follows.} \\
      \textrm{\IdealFSig keeps a list \SIG of known signed messages.}      
    \end{minipage}
    \vspace*{0.5em}

    \begin{minipage}[t]{0.5\textwidth}
      \procedure{$\pcif \cmd = \uccmd{KeyGen} \land \arg =
        \emptyset$}{
        \pccomment{\fbox{Key Generation}} \\
        \pcif \sid = (P,\ssid): \\
        \pcind \ucsend~(\uccmd{KeyGen},\sid)~\text{to}~\adv \\
        \pcind \ucrecv~(\uccmd{VerKey},\sid,v)~\text{from}~\adv \\
        \pcind \ucio{Output}~(\uccmd{VerKey},\sid,v)~\text{to}~P \\
        \pcind \text{Store}~(P,v)
      }
      \vspace*{0.25em}
      \procedure{$\pcif \cmd = \uccmd{Verif} \land
        \arg = (\sig,\msg,v')$}{
        \pccomment{\fbox{Verify a message}} \\
        \ucsend~(\uccmd{Verif},\sid,\msg,\sig,v)~\text{to}~\adv \\
        \ucrecv~(\uccmd{Verifd},\sid,\msg,\phi)~\text{from}~\adv \\
        \pcif v' = v \land (\msg,\sig,v,1) \in \SIG: f \gets 1 \\
        \pcelse \pcif v' = v \land P~\text{is not corrupt}~\land \\
        \pcind (\msg,\sig',v,1) \notin \SIG: \\
        \pcind \SIG \gets \SIG \cup \lbrace (\msg,\sig,v,0) \rbrace;
        f \gets 0 \\
        \pcelse \pcif (\msg,\sig,v',f') \in \SIG: f \gets f' \\
        \pcelse: \\
        \pcind \SIG \gets \SIG \cup \lbrace (\msg,\sig,v',\phi) \rbrace;~
        f \gets \phi \\
        \ucio{Output}~(\uccmd{Verifd},\sid,\msg,f)
      }
    \end{minipage}
    \begin{minipage}[t]{0.5\textwidth}
      \procedure{$\pcif \cmd = \uccmd{Sign} \land \arg = \msg$}{
        \pccomment{\fbox{Sign a message}} \\
        \pcif \sid = (P,\ssid) \\
        \pcind \ucsend~(\uccmd{Sign},\sid,\msg)~\text{to}~\adv \\
        \pcind \ucrecv~(\uccmd{Signed},\sid,\msg,\sig)~\text{from}~
        \adv \\
        \pcind \pcif (\msg,\sig,v,0) \in \SIG: \\
        \pcind \pcind \ucio{Output}~(\uccmd{Error}) \\
        \pcind \pcelse: \\
        \pcind \pcind \SIG \gets \SIG \cup (\msg,\sig,v,1) \\
        \pcind \pcind \ucio{Output}~(\uccmd{Signed},\sid,\msg,\sig)
      }
    \end{minipage}
  \end{framed}
  \caption{Ideal signature functionality, \IdealFSig, from \cite{canetti03}.}
  \label{fig:fsig}
\end{figure}

\subsection{Global Functionality \IdealGPKIDID}

Giving an ideal functionality for a DID-based PKI does not seem to be direct.
The difficulty stems from the fact that the W3C specification (see footnote
\todo{X}) is very permissive in regards to what can be seen as a valid DID
method definition. Namely, it simply states the following conditions for any
candidate method, in Section 8.2 of the specification:

\begin{description}
\item[Authentication.] It must define how authorisation is performed.  
\item[Create.] It must specify how controllers create new DIDs.
\item[Read.] It must specify how the contents of a DID can be fetched and
  authenticated.
\item[Update.] It must specify what updates can controllers apply (if any)
  to existing DIDs.
\item[Deactivate.] It must specify if DIDs can be deactivated, and how.
\end{description}

Where the authentication aspect specifically covers the way in which controllers
prove to be entitled to perform create, update, or deactivate operations.

However, since no functional requirements are given as to, e.g., what an update
may be, or what a deactivation implies, it seems hard to define a functionality
that would cover all possible options (or a significant subset).

\paragraph{Ideal functionality specification.} %
We take the basic approach to see DID documents as simple dictionaries
(i.e., lists of labels with corresponding types and values), associated to a
common label, the DID. Based on this, we define the operations that compose an
ideal basic functionality for DIDs, as follows:

\begin{description}
\item[Create interface.] To create a new DID, the functionality exposes a
  \uccmd{Create} interface that receives a tuple of label and key type values.
  Then, it asks the adversary to provide a value to each of the specified
  labels, and the DID value. If the DID value does not exist in the records of
  the functionality, a new entry (including the dictionary) is created. In order
  to meet the authentication requirement, the ideal functionality takes note of
  the party creating the DID, so that subsequent changes in the DID can only be
  done by this party. We note that more advanced predicates could be defined, by
  this bare minimum seems to be enough for most (current) DID methods.
  \todo{Give evidence of the latter?}
\item[Read interface.] The contents of existing DIDs can be fetched via the
  \uccmd{Read} interface. It receives a DID value and, if it exists in the
  functionality's records, returns the associated contents. Note that, if such
  entry exists, then it is authentic by definition, and thus trivially meets
  the authentication requirements.
\item[Update interface.] The contents of existing DIDs can be modified via the
  \uccmd{Update} interface. It requires to specify the actual DID and two lists:
  $\sval_d$ with the labels to remove, and $\sval_a$ with the lables of new keys
  to add (along with their types). The DID must exist in the records of the
  functionality, and the call must originate from the same party that created
  it. Note that this covers variants such as using update only to add new keys
  (e.g. by specifying an empty $\sval_d$), or modifications of existing labels
  (e.g., by adding an existing label in $\sval_d$, and also in $\sval_a$).
\item[Deactivate interface.] Deactivating a DID is actually a simplification of
  the update operation, without specifying new keys to add. This is possible
  via the \uccmd{Deact} interface. Note that it is not strictly necessary to
  specify this interface, as it is a special case of \uccmd{Update}. However, we
  explicitly add it for proximity to the actual DID specification. \todo{Just
    remove it?}
\end{description}

Our expectation is that this simple approach allows to capture a large
subset of all possible DID method implementations. Note that the functional
restrictions we impose seem to be unavoidable. Namely, we do not specify how
the actual identifiers are computed; instead, we allow the adversary to pick
them. To update a DID, we only require such DID to exist and that the caller
is the party that created it, but otherwise the DID's contents can be set to
something completely new. Finally, deactivating labels within an existing DID
requires that these labels exist -- and, again, that the caller is the same
party who created the DID. Concretely, note that any further structure beyond
the label-type-value dictionary approach, is left as an implementation detail.
However, enforcing additional structure seems unavoidable in practice (e.g.,
requiring that all DIDs include keys of certain type). Since this definitely
has an impact on the behaviour of the ideal functionality, we parameterize it
with a policy \P, which can be used as a black box: the functionality invokes
\P with a set of labels and key types, and receives either $1$ to denote
acceptance, or $0$ to denote rejection. However, it is not realistic to assume
that, even corrupted parties will enforce such policies. Thus, our approach is
to defer policy checking in the ideal functionality until after having
interacted with the simulator \Sim. Intuitively then, if the output of the
ideal functionality along with \Sim is indistinguishable to that of the real
protocol with any real world adversary, then the policy is correctly enforced
by the real protocol. Looking ahead, the real protocol in turn ``delegates''
this policy-checking to an ideal append-only bulletin board. \todo{This captures
  the idea, but refine and re-structure.}

Note that we also allow the adversary to pick the values associated to the
labels in new and updated DIDs. This is a strong requirement that follows the
argumentation in \cite{canetti03} for ideal digital signatures: namely, this
means that there is absolutely any requirement on the way in which this values
are computed (they might not even be conventional public keys). Indeed, this
seems to match the permissive philosophy of defining DIDs in the W3C DID
specification.

We capture the resulting notion in \figref{fig:fpkidid}.

\begin{figure}
  \begin{framed}
    \scalebox{0.9}{
      \begin{minipage}[t]{\textwidth}
        \textrm{Upon receiving a call $\IdealGPKIDID^{\P}(\cmd,\sid,\arg)$
          from some party $P$ to run command \cmd, in session \sid, with arguments
          \arg, $\IdealGPKIDID^{\P}$ operates as follows.}
        \textrm{If the received \cmd and \arg pair does not meet any of
          the following options, the request is ignored.}
        \textrm{\P is a boolean predicate defining concrete conditions for
          acceptable DID creations, updates and deactivations.}
        \textrm{\didOP is a list of submitted (yet, possibly unconfirmed) DID
          operations, and \DID is the authoritative state of published DIDs.}
        \todo{Think about what happens if two conflicting ops (esp. create)
          are submitted with diff $t < \delta$.}
        \todo{Idea: func keeps track of DID ownership, associated to parties.
          Also, replace \didOP with an UTXO, that gets updated like the delay
          ledger (i.e., upon applying a new op, remove it from the set.)}
      \end{minipage}
    }
    \vspace*{0.5em}

    \scalebox{0.9}{
      \begin{minipage}[t]{0.55\textwidth}
        \procedure[linenumbering]{$\pcif \cmd = \uccmd{Create} \land \arg =
          \setind{(\lbl_i,\typ_i)}{i\in[n]}$}{ 
          %\DID \gets \DIDReadLdg \\          
          \ucsend~(\uccmd{Create}, \sid, \arg)~\text{to}~\Sim \\
          \ucrecv~(\uccmd{CreateOk}, \sid, \did,
          \sval=\setind{\val_i}{i\in[n]}) \\
          \hspace*{2.7em}\text{from}~\Sim \\
          % \pcif (\did,\cdot) \in \DID \lor
          % \P(\setind{(\lbl_i,\typ_i)}{i\in[n]}) = 0: \\
          % \pcind \pcreturn \bot \\
          \ucsend~(\uccmd{Read})~\text{to}~\IdealGclock \\
          \ucrecv~(\uccmd{ReadOk},\tau)~\text{from}~\IdealGclock \\
          \didOp \gets (\did,\setind{(\lbl_i,\typ_i,\val_i)}{i\in[n]}) \\
          \didOP \gets \didOP \cup \set{(P,\tau,\didOp)} \\
          \ucsend~(\uccmd{Submit}, \didOp)~\text{to}~\IdealGdledger \\
          \ucio{Output}~(\uccmd{ProcessedC},\sid,\did,\sval)
          % \pcind \DID \gets \DID \cup \lbrace (P,\did,\lbrace
          % (\lbl_i,\typ_i,\val_i) \rbrace_{i\in[n]}) \rbrace \\
          % \ucio{Output}~(\uccmd{Created},\sid,\did,\sval,t)
        }
        \vspace*{0.25em} \\

        \procedure[linenumbering]{$\pcif \cmd = \uccmd{Update} \land
          \arg = (did, \sval_d,\sval_a)$}{
          \DID \gets \DIDReadLdg \\
          \pcif (P,\did) \notin \didOWN: \pcreturn \bot \\
          \pcif (\did,\sval_0) \notin \DID: \pcreturn \bot \\ %\lor (P,\cdot,(\did,\cdot))
          % \notin \didOP: \\
          % \pcind \pcreturn \bot \\
          % \pcif \P((\sval_0 \setminus \sval_d) \cup \sval_a) = 0:
          % \pcreturn \bot \\
          \ucsend~(\uccmd{Update}, \sid,\did,\sval_d,\sval_a)~\text{to}~\Sim \\
          \ucrecv~(\uccmd{UpdOk},\sid,\did,\setind{\val^a_i}{i\in[n^a]})~
          \text{from}~\Sim \\
          \ucsend~(\uccmd{Read})~\text{to}~\IdealGclock \\
          \ucrecv~(\uccmd{ReadOk},\tau)~\text{from}~\IdealGclock \\
          \lbrace (\lbl_i^a,\typ_i^a) \rbrace_{i\in[n^a]} \gets \sval_a \\
          % \lbrace \lbl_i^d \rbrace_{i\in[n^d]} \gets \sval_d \\          
          \sval_1 \gets (\sval_0 \setminus \sval_d) \cup
          \setind{(\lbl^a_i,\typ^a_i,\val^a_i)}{i\in[n^a]} \\
          \didOp \gets (\did,\sval_1);~
          \didOP \gets \didOP \cup \set{(P,\tau,\didOp)} \\
          \ucsend~(\uccmd{Submit}, \didOp)~\text{to}~\IdealGdledger \\
          \ucio{Output}~(\uccmd{ProcessedU},\sid,\did,\didOp)
        }        
      \end{minipage}
    }
    \scalebox{0.9}{
      \begin{minipage}[t]{0.5\textwidth}
        \procedure[linenumbering]{$\pcif \cmd = \uccmd{Read} \land
          \arg = \did$}{
          \DID \gets \DIDReadLdg \\
          \pcif (\did,\sval) \notin \DID: \pcreturn \bot \\ % \lor \P(\sval) = 0: \\
          %\pcind \pcreturn \bot \\
          \ucio{Output}~(\uccmd{ReadOk},\sid,\did,\sval)~\text{to}~P
        }
        \vspace*{0.25em} \\

        \procedure[linenumbering]{$\pcif \cmd = \uccmd{Deact} \land \arg =
          (did, \lbrace \lbl_i \rbrace_{i\in[n]})$}{
          \DID \gets \DIDReadLdg \\
          \pcif (P,\did) \notin \didOWN: \pcreturn \bot \\                    
          \pcif (P,did,\sval_0) \notin \DID: \pcreturn \bot \\ % \lor (P,\cdot,(\did,\cdot))
          % \notin \didOP: \\
          % \pcind \pcreturn \bot \\
          \sval_1 \gets \sval_0 \setminus \lbrace \lbl_i \rbrace_{i\in[n]} \\
          % \pcif \P(\sval_1) = 0: \pcreturn \bot \\
          \ucsend~(\uccmd{Deact}, \sid, \arg)~\text{to}~\Sim \\
          \ucrecv~(\uccmd{DeactOk},\sid)~\text{from}~\Sim \\
          \ucsend~(\uccmd{Read})~\text{to}~\IdealGclock \\
          \ucrecv~(\uccmd{ReadOk},\tau)~\text{from}~\IdealGclock \\          
          \didOp \gets (\did,\sval_1);
          \didOP \gets \didOP \cup \set{(P,\tau,\didOp)} \\
          \ucsend~(\uccmd{Submit},\didOp)~\text{to}~\IdealGdledger \\          
          \ucio{Output}~(\uccmd{ProcessedD},\sid,\did,\didOp)
        }
%        \vspace*{0.05em} \\

        \procedure[linenumbering]{$\pcif \cmd = \uccmd{Extend} \land \arg =
          \didOP'$}{
          \pcif P \neq \Sim \lor \didOP' \subseteq \didOP: \pcreturn \bot \\
          \DID \gets \DIDReadLdg \\          
          %\lor~\\
          %\pcind \exists \didOp \in \didOP'~\suchthat~\P(\didOp) = 0: \\
          %\pcind \pcreturn \bot \\
          \pcfor \didOp = (P,\cdot,(\did,\cdot)) \in \didOP': \\
          \pcind \pcif \P(\didOp,\DID) = 0: \pcreturn \bot \\
          \pcind \didOWN \gets (P,\did) \\
          \didOP \gets \didOP \setminus \didOP' \\
          \ucsend~(\uccmd{Extend},\didOP')~\text{to}~\IdealGledger
        }
      \end{minipage}
    }
    \vspace*{0.25em} \\
    
    \scalebox{0.9}{
      \begin{minipage}[t]{\textwidth}
        \centering
        \procedure[linenumbering]{$\DIDReadLdg$}{
          \ucsend~(\uccmd{Read})~\text{to}~\IdealGdledger~\text{and recv}~
          (\uccmd{ReadOk},\DID)~\text{back} \\
          \ucsend~(\uccmd{Read})~\text{to}~\IdealGclock ~\text{and recv}~
          (\uccmd{ReadOk},\tau)~\text{back} \\
          \pcif \exists (\cdot,\tau',\didOp) \in \didOP~\suchthat~
          |\tau - \tau'| > \delta \land \P(\didOp) = 1 \land \didOp \notin \DID:
          \pcreturn \bot \\
          \pcreturn \DID
        }
      \end{minipage}
    }
  \end{framed}
  \caption{Ideal DID-based PKI functionality, \IdealGPKIDID. We abuse set
    notation, and write $\lbrace (a_i,\dots) \rbrace_{i\in[n]} \setminus
    \lbrace (b_j,\dots) \rbrace_{j\in[m]}$ to mean subtracting from the first
    set the elements present in the second set, whenever $a_i = b_j$ for some
    $i,j$, even if the size of the $(a_i,\dots)$ and $(b_j,\dots)$ tuples do not
    match.}
  \label{fig:fpkidid}
\end{figure}

\subsection{The \RealPKIDIDAtala Construction}

We next define the Atala PRISM DID method, following the interfaces defined for
\IdealGPKIDID. We begin by describing the types of keys supported in Atala
PRISM, and then specify how sets of such keys can be managed through DIDs in
Atala.

\paragraph{Key Types.} %
All operations in Atala PRISM are authenticated, meaning that a cryptographic
key needs to be involved in proving that the operation comes from the intended
party. Atala specifies four key types, that are thus supported in Atala's DID
method. Namely: master keys (\MasterKey), for operating on DIDs; issuing keys,
for issuing VCs (\IssueKey); communication keys (\CommKey), for key-exchange
protocols; and authentication keys, to associate to VCs (\AuthKey).

\paragraph{Custom Notation.} %
Keys in Atala are identified by labels. In the following description of the
\RealPKIDIDAtala construction, given a set of keys, we frequently refer to the
``master key with lowest label'' (using any order relation, like lexicographic
order).  For brevity, given a set \st, we use $\LMKL(\st)$ to denote such label.

\paragraph{$\P_{Atala}$ policy.} %
Before proceeding with the specififying the DID operations in Atala, we define
its policy on the keys' labels and types.

\begin{figure}[ht]
  \centering
  \procedure{$\P_{Atala}(\lbrace (\lbl_i,\typ_i) \rbrace_{i\in[n]})$}{    
    \pcif \exists i\in[n]~\suchthat~\typ_i \notin [\MasterKey,\IssueKey,
    \CommKey,\AuthKey]: \pcreturn 0~\pccomment{All types must be known} \\   
    \pcif \not\exists i\in[n]~\suchthat~\typ_i = \MasterKey: \pcreturn 0~
    \pccomment{There must be at least one master key} \\
    \pcif \exists i, j \in[n], i \neq j~\suchthat~\lbl_i = \lbl_j: \pcreturn 0~
    \pccomment{No duplicate labels} \\
    \pcreturn 1
  }
  \caption{Policy $\P_{Atala}$ that all DID documents must meet in Atala.}
\end{figure}

\paragraph{DID Operations.} %
\todo{For now, this ignores \emph{unpublished} DIDs.}
\figref{fig:atalapkidid1} and \figref{fig:atalapkidid2} contain the
specification of Atala PRISM's DID method,
which we describe next. Looking at the \texttt{Create} and \texttt{Update}
operations, it is clear that $\P(\lbrace (i, \lbl_i) \rbrace_{i\in[n]})$ in
Atala requires that all key labels are of a known type (\MasterKey, \IssueKey,
\CommKey, or \AuthKey) and that at least one of the keys in the DID Document
is of type \MasterKey.

\begin{description}
\item{\uccmd{Create}.} %
  To create a DID, the user has to specify the key pairs to create, along with
  fresh identifiers (labels) and their type. For ease of exposition, we assume
  that the used identifiers just follow a sequence. The predicate \P in Atala
  simply requires that at least one key pair of \MasterKey type is created. The
  \uccmd{Create} algorithm creates as many keys of each type as requested,
  and keeps a list with the identifier, type and public key of each key pair.
  This list is then hashed into a value \texttt{h}, and the created DID is
  ``\texttt{\did:prism:h}''. A transaction containing the created list, the
  DID, and the \texttt{CreateDID} instruction is sent to the blockchain,
  signed by one of the master keys -- w.l.o.g., we simply use the first one
  in the list. The DID owner stores locally the list, along with the
  corresponding private keys.
\item[\uccmd{Read}.] %
  Getting the contents of a DID simply requires processing the associated
  transactions in the blockchain. Namely, transactions $(\tx,\sig)$ where $\tx$
  is either $(\texttt{CreateDID},\did,\cdot)$ or $(\texttt{UpdateDID},\did,
  \cdot)$. The associated DID Document is the result of applying in an ordered
  manner (from oldest to newest) all such validly signed transactions.
\item[\uccmd{Update}.] %
  To update a DID, we first assume for ease of exposition that the calling party
  $P$ has an updated version of the associated DID Document (which included
  a list of $n$ keys) -- if this is not the case, it suffices to make first a
  call to \uccmd{Read} for the given DID. \todo{This seems relevant enough to
    be highlighted in some more visible place, no?}
  Then, updating a DID requires to (optionally) specify a list of previously
  existing key identifiers to remove, and (optionally) specify a list of new key
  identifiers, and their types, to add. To simplify notation, we just adopt the
  (equivalent) convention that the caller indicates a list of $\lbrace (i,
  \lbl_i) \rbrace_{i\in\tilde{N}\subseteq[\tilde{n}]}$ pairs, where $\tilde{n}$
  may be smaller or larger than $n$, depending on the desired update. This
  list is then interpreted as follows. If $i$ is an already existing
  identifier, the label is ignored and the corresponding key is not removed. If
  $i$ is a new identifier, then a new key pair of the given type is created.
  Omitting an existing identifier is then interpreted as the desire to remove
  the corresponding key pair. Otherwise, the same policy as for \uccmd{Create}
  applies here. Key pairs for the new keys are generated, and a transaction is
  sent to the blockchain, signed with one of the master keys in the DID
  \emph{before applying the update}. This transaction contains a list of the
  identifiers of the keys to remove, and a list of the identifiers and types
  of the keys to add.
\item[\uccmd{Deactivate}.] %
  A deactivate operation is simply an update operation with no new key
  identifiers, and that only specifies the existing identifiers that will
  \emph{not} be deactivated.
\end{description}

\begin{figure}[ht!]
  \begin{framed}

    \scalebox{0.9}{
      \begin{minipage}[t]{\textwidth}
        \textrm{Party $P$ running operation \cmd with arguments \arg, in
          session \sid.}
      \end{minipage}
    }
    \vspace*{0.5em}
    
    \scalebox{0.9}{
      \begin{minipage}[t]{0.55\textwidth}
        \procedure[linenumbering=on]{$\pcif \cmd = \uccmd{Create} \land \arg =
          \lbrace (\lbl_i,\typ_i) \rbrace_{i\in[n]}$}{
          \pcif \P_{Atala}(\lbrace (\lbl_i,\typ_i) \rbrace_{i\in[n]}) = 0: abort \\
          \st \gets \emptyset \\
          \pcfor i \in [n]: \\
          \pcind \sid' \gets ((P,\lbl_i),\sid) \\
          \pcind \ucsend~(\uccmd{KeyGen},\sid')~\text{to}~\IdealFSig \\
          \pcind \ucrecv~(\uccmd{VerKey},\sid',\pk_i)~\text{from}~
          \IdealFSig \\
          \pcind \st \gets \st \cup \lbrace (\lbl_i,\typ_i,\pk_i) \rbrace \\
          \ucsend~(\uccmd{Hash},\st)~\text{to}~\IdealGRO \\
          \ucrecv~(\uccmd{Hashed},\st,h)~\text{from}~\IdealGRO \\
          \did \gets ``did:prism:''||~h \\
          \tx \gets (\texttt{CreateDID}, \did, \st) \\
          \lbl \gets \LMKL(\st); \sid' \gets ((P,\lbl),\sid) \\
          \ucsend~(\uccmd{Sign},\sid',\tx)~\text{to}~\IdealFSig \\
          \ucrecv~(\uccmd{Signed},\sid',\tx,\sig)~\text{from}~\IdealFSig \\
          \ucsend~(\uccmd{Append},(\tx,\sig))~\text{to}~\IdealGdledger \\
          \text{Locally store}~
          (\did, \lbrace (\lbl_i,\typ_i,\pk_i) \rbrace_{i\in[n]}) \\
          \ucio{Output}~(\uccmd{Created},\sid,\did,\lbrace \pk_i
          \rbrace_{i\in[n]})
        }
      \end{minipage}
    }
    \scalebox{0.9}{
      \begin{minipage}[t]{0.5\textwidth}
        \procedure[linenumbering=on]{$\pcif \cmd = \uccmd{Read} \land
          \arg = did$}{
          \ucsend~(\uccmd{Retrieve})~\texttt{to}~\IdealGdledger \\
          \ucrecv~(\uccmd{Retrieve},L)~\texttt{from}~\IdealGdledger \\
          \st \gets \emptyset \\
          L_{\did} \gets (\ast,\did,\ast) \subseteq \DID \\
          \pcfor (\tx=(\texttt{op},\did,\cdot),\sig) \in L_{\did}: \\
          \pcind \pk \gets \emptyset \\
          \pcind \pcif \texttt{op} = \texttt{CreateDID}~\land \\
          \pcind \pcind \text{no \texttt{CreateDID} appeared before}: \\
          \pcind \pcind (\cdot,\cdot,\lbrace (\lbl_i,\typ_i,\pk_i)
          \rbrace_{i\in[n]}) \gets \tx \\
          \pcind \pcind \st \gets \lbrace (\lbl_i,\typ_i,\pk_i) \rbrace_{i \in [n]} \\
          \pcind \pcif \texttt{op} = \texttt{UpdateDID}: \\
          \pcind \pcind (\cdot,\cdot,(\st_d,\st_a)) \gets \tx \\
          \pcind \pcind \lbrace \lbl^d_i \rbrace_{i\in[n^d]} \gets \st_d \\ 
          \pcind \pcind \lbrace (\lbl^a_i,\typ^a_i,\pk^a_i)
          \rbrace_{i\in[n^a]} \gets \st_a \\
          \pcind \pcind \st \gets (\st \setminus \st_d) \cup \st_a \\
          \pcind \lbl \gets \LMKL(\st) \\
          \pcind \pcif \lbl = \emptyset \lor \P_{Atala}(\st) = 0: \text{skip} \\
          \pcind \pcelse \sid' \gets ((P,\lbl),\sid) \\
          \pcind \ucsend~(\uccmd{Verif},\sid',\tx,\sig,\pk)~\text{to}~\IdealFSig \\
          \pcind \ucrecv~(\uccmd{Verifd},\sid',\tx,b)~\text{from}~\IdealFSig \\
          \pcind \pcif b = 0: \text{skip} \\
          \ucio{Output}~(\uccmd{Read},\sid,(\did,\st))
        }    
      \end{minipage}
    }
  \end{framed}
  \caption{\texttt{Create} and \texttt{Read} operations in Atala
    PRISM DID-based PKI protocol, \RealPKIDIDAtala, realising \IdealGPKIDID
    in the $(\IdealGRO,\IdealFSig,\IdealGdledger)$-hybrid model.}
  \label{fig:atalapkidid1}
\end{figure}

\begin{figure}[ht!]
  \begin{framed}
    \scalebox{0.9}{
      \begin{minipage}[t]{\textwidth}
        \textrm{Party $P$ running operation \cmd with arguments \arg, in
          session \sid.} \\
      \end{minipage}
    }
    \vspace*{0.5em}
    
    \scalebox{0.90}{          
      \begin{minipage}[t]{0.6\textwidth}
        \procedure[linenumbering=on]{$\pcif \cmd = \uccmd{Update} \land
          \arg = (did, \sval_d, \sval_a)$}{
          % \pcif \exists i~\suchthat~\typ_i \notin [\MasterKey,\AuthKey,
          % \CommKey,\IssueKey]~\lor \\
          % \pcind \nexists i~\suchthat~\typ_i = \MasterKey
          % \lor \exists i,j~\suchthat~\lbl_i = \lbl_j: abort \\
          % \pcif \exists i~\suchthat~\lbl_i \notin [\MasterKey,\AuthKey,
          % \CommKey,\IssueKey] \lor
          % \nexists i~\suchthat~\lbl_i = \MasterKey: \\
          % \pcind abort \\
          % \text{Run $(\uccmd{Read},\sid,\did)$ to fetch $(\did,\sval)$} \\
          % \pcif \sval = \bot: abort \\
          \text{Fetch}~
          (\did, \sval=\lbrace (\lbl_i,\typ_i,\pk_i) \rbrace_{i\in[n]})
          ~\text{from storage} \\
          \st_a \gets \emptyset;~
          \lbrace (\lbl_i,\typ_i,\pk_i) \rbrace_{i\in[n]} \gets \sval \\
          \lbrace \lbl^d_i \rbrace_{i\in[n_d]} \gets \sval_d;~
          \lbrace (\lbl^a_i,\typ^a_i) \rbrace_{i\in[n_a]} \gets \sval_a \\
          \sval' \gets (\sval \setminus \sval_d) \cup \sval_a
          \pccomment{\todo{Syntax refinement needed here.}} \\
          \pcif \P_{Atala}(\sval') = 0: abort \\          
          \pcfor i \in [n_a] \\
          \pcind \ucsend~(\uccmd{KeyGen},((P,\lbl_i),\sid))~\text{to}~\IdealFSig \\
          \pcind \ucrecv~(\uccmd{VerKey},((P,\lbl_i),\sid),\pk^a_i)~\text{from}~
          \IdealFSig \\
          \pcind \st_a \gets \st_a \cup \lbrace (\lbl^a_i,\typ^a_i,\pk^a_i) \rbrace \\
          % \text{Locally store}~(\did,\lbrace (i,\lbl_i,\pk_i) \rbrace_{i\in[\tilde{n}]} \\
          \tx \gets (\texttt{UpdateDID}, \did, \sval_d, \st_a) \\
          \lbl \gets \LMKL(\sval) \\
          \ucsend~(\uccmd{Sign},((P,\lbl),\sid),\tx)~\text{to}~\IdealFSig \\
          \ucrecv~(\uccmd{Signed},((P,\lbl),\sid),\tx,\sig)~\text{from}~\IdealFSig \\
          \ucsend~(\uccmd{Append},(\tx,\sig))~\text{to}~\IdealGdledger \\
          \text{Locally store}~(\did,\sval) \\
          \ucio{Output}~(\uccmd{Updated},\sid,(\did,\lbrace \pk^a_i \rbrace_{i\in[n^a]}))
        }
      \end{minipage}
    }
    \scalebox{0.9}{
      \begin{minipage}[t]{0.45\textwidth}
        \procedure[linenumbering=on]{$\pcif \cmd = \uccmd{Deact} \land \arg =
          (did, \sval)$}{       
          \text{Run as a \texttt{Update} operation} \\
          \text{with $\sval_d \gets \sval$ and $\sval_a \gets \emptyset$}
        }
      \end{minipage}
    }
  \end{framed}
  \caption{\texttt{Update} and \texttt{Deactivate} operations in Atala
    PRISM DID-based PKI protocol, \RealPKIDIDAtala, realising \IdealGPKIDID
    in the $(\IdealGRO,\IdealFSig,\IdealGdledger)$-hybrid model.}
  \label{fig:atalapkidid2}
\end{figure}

\subsubsection{Notes for Implementations.} %

We acknowledge that, in the pseudocode given in \figref{fig:atalapkidid1} and
\figref{fig:atalapkidid2}, we have favoured notational simplicity over
implementation efficiency or
convenience. For instance, it is not really needed that the master key signing a
transaction is the one with the lowest index -- any such key can actually do it.
However, it makes notation much easier. Similarly, in practice it may be easier
to use different ``function arguments'' to denote the set of keys to remove and
a set of keys to add from/to an existing DID. However, notationally it is
simpler to follow the chosen (equivalent) approach. Finally, key indexes don't
need to follow a sequential order.

Somehow related, it is of course not needed to fetch the contents of the whole
blockchain whenever we want to get an up to date DID Document. Instead, the
party running the operation can keep a local copy, and just fetch the new
operations since it last synced. However, again the given simplified notion of
a blockchain (via \IdealGdledger) eases notation -- and seems good enough for a
first modelling effort.

\subsection{Security of \RealPKIDIDAtala}
\label{ssec:sec-didatala}

Before going into the proofs, observe that the \uccmd{Create} (in lines 1-2) and
\uccmd{Update} (in lines 6-7) operations in \RealPKIDIDAtala include a policy on
the received key labels and types. Concretely, this policy requires that all
labels are unique, all types are of a known key type, and that at least one of
them is of type \MasterKey. In the sequel, we use $\P_{Atala}$ to refer to this
policy.

\todo{Do we mention somewhere that {\sid}s have structure $(P,\sid')$? This is
  used for \Sim to know which party is generating which keys.}

\begin{theorem}[UC-security of \RealPKIDIDAtala]
  \label{thm:sec-didatala}
  \RealPKIDIDAtala UC-realizes $\IdealGPKIDID^{\P_{Atala}}$ in the $(\IdealGRO,
  \IdealFSig, \IdealGdledger)$-hybrid model.
\end{theorem}

\begin{proof}
  We show that \RealPKIDIDAtala UC-realizes \IdealGPKIDID, when configured
  with policy $\P_{Atala}$. For this, we give a simulator \Sim such that, for
  any environment \Env, $\Exec_{\RealPKIDIDAtala\adv,\Env} \approx
  \Exec_{\phiDID,\Sim,\Env}$,
  where \phiDID is a protocol composed with the same parties as
  \RealPKIDIDAtala but where each party is simply a dummy party that forwards
  every message from \Env to the ideal functionality \IdealGPKIDID, and every
  response from \IdealGPKIDID back to \Env. The simulator \Sim runs internally a
  copy of the real-world adversary \adv, as well as the ideal functionalities
  \IdealGRO, \IdealFSig and \IdealGdledger, and any involved party.

  \begin{description}
  \item[Simulating DID Create.] %
    % 
    % Keys generation
    If \Sim receives a message $(\uccmd{Create},\sid,\lbrace (\lbl_i,\typ_i)
    \rbrace_{i\in[n]})$ from \IdealGPKIDID, with $\sid=(P,\sid')$, it simulates
    the key generation process of $n$ signing key pairs run in the real
    protocol, by sending $n$ queries $(\uccmd{KeyGen},((P,\lbl_i),\sid))$ to
    \adv~on behalf of \IdealFSig, and receiving the $n$ corresponding
    $(\uccmd{VerKey},((P,\lbl_i),\sid),\pk_i)$ responses.
    %
    % Hash computation
    \Sim then concatenates all $(\lbl_i,\typ_i,\pk_i)$ tuples into \st, and
    simulates a query to \IdealGRO, to set \did as ``$did:prism: h$'' as DID
    value.
    %
    % Tx sim
    With the DID value, \Sim simulates for \adv~the preparation of transaction
    \tx. That is, \Sim uses the master key with lowest label, $\lbl \gets
    \LMKL(\st)$, and simulates a query $(\uccmd{Sign},((P,\lbl),\sid),\tx)$ to
    \IdealFSig, obtaining from \adv~$(\uccmd{Signed},((P,\lbl),\sid),\tx,\sig)$.
    %
    % BB append
    \Sim also simulates appending the $(\tx,\sig)$ tuple to the bulletin board,
    by sending $(\uccmd{Append},(\tx,\sig))$ to \adv~on behalf of \IdealGdledger.
    %
    % Output
    Finally, \Sim sends the $(\uccmd{CreateOk},\sid,\did,\lbrace \pk_i
    \rbrace_{i\in[n]})$ to \IdealGPKIDID, and stores the tuple $(P,\did,\lbrace
    (\lbl_i,\typ_i,\pk_i)\rbrace_{i\in[n]})$.
    %
    % Additional considerations
    \todo{The following should probably go to the argumentation part.}
    Note that \did is generated by an ideal random oracle (thus, uniformly at
    random), just as in the real protocol \RealPKIDIDAtala. Hence, the
    probability that \IdealGPKIDID halts because $\did \in \DID$ is negligible,
    and \IdealGPKIDID outputs $(\uccmd{Created},\sid,\did,\lbrace \val_i=\pk_i
    \rbrace_{i\in[n]})$ to \IdealGPKIDID.
  \item[Simulating DID Read.]
    To simulate read operations, when \Sim receives $(\uccmd{Read},\sid,\did)$
    from \IdealGPKIDID, it first simulates for \adv~the call to \IdealGdledger, to
    get the current status $L$ of the bulletin board. Then, \Sim reproduces the
    processing a normal party would do: from older to newer entry in $L$ related
    to \did, applies the updates in a sequential order -- ignoring any
    \uccmd{UpdateDID} operation before a \uccmd{CreateDID}, and only applying
    the first \uccmd{CreateDID}. If, after applying an update, $\P_{Atala}$ is
    not met by the resulting set of keys and labels, \Sim skips the update.
    Otherwise, \Sim simulates for \adv~a verification query to \IdealFSig for
    the transaction corresponding to the update, and skips the update if the
    signature fails.
    %
    Finally, if after processing all transactions related to \did, the resulting
    contents differ from those stored by \Sim in its record $(P,\did,\sval)$,
    \Sim aborts \todo{Do we need this?}. Otherwise, \Sim returns the processed
    contents.    
  \item[Simulating DID Update.]
    % Load DID
    Upon receiving a request from dummy party $P$, \IdealGPKIDID fetches
    $(P,\did,\sval)$ from its records, and checks if $(\sval \setminus \sval_d)
    \cup \sval_a$ meets $\P_{Atala}$. If either step fails, \IdealGPKIDID
    aborts. Else, it sends $(\uccmd{Update},\sid,\did,\sval_d,\sval_a)$ to \Sim.
    \Sim then retrieves $(P,\did,\sval)$ from its records \todo{this is kept at
      some point, no?)} and simulates for \adv~the calls to \IdealFSig for the
    keys in the received $\sval_a$. \Sim gets the key with the lowest label from
    \sval, with label $\lbl$, bundles the transaction \tx, and simulates a call
    to \IdealFSig to get a signature over \tx. Finally, \Sim simulates the call
    to \IdealGdledger, and returns $(\uccmd{Updated},\sid,(\did,\lbrace \val_i
    \rbrace_{i\in[n_a]}))$ to \IdealGPKIDID, where the $\val_i$'s are the values
    output by \adv~when creating the new keys via simulated calls to \IdealFSig.
  \item[Simulating DID Deactivate.] Directly follows from DID Update.      
  \end{description}
  \todo{This to take into account when arguing indistinguishability}:
  \begin{itemize}
  \item The records of \Sim are always consistent with \IdealGdledger.
  \end{itemize}

  % General comments
  Now, observe that, in all ideal operations, the policy $\P_{Atala}$ is checked
  on the resulting data structure. If the policy is not satisfied, the
  functionality aborts. This is also the case for the real world.

  % Create comments
  Regarding create operations, note that, both in the simulation and in the real
  world, the resulting \did value is produced in a consistent way -- via a call
  to \IdealGRO, using the contents of the DID document to create.
  % Key generation and signature comments
  Similarly, the (verification) keys used and signatures are defined by \adv~
  both the real and ideal world -- in the latter, as part of \Sim's simulation
  of \IdealFSig.
  
\end{proof}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "prism-protocol"
%%% End:
