\section{DIDs in Atala PRISM}
\label{sec:did-atala}

In this section we first give an ideal functionality for Public-Key
Infrastructures built atop of DIDs \IdealFPKIDID, and subsequently describe
Atala PRISM DID method \RealPKIDIDAtala, which is a protocol realizing
\IdealFPKIDID.
%
Before doing so, we introduce some base ideal functionalities upon which we
rely for \RealPKIDIDAtala. Namely, a simplified notion of append-only bulletin
boards, and digital signatures.

\subsection{Base Functionalities}
\label{ssec:did-funcs}

\paragraph{Append-Only Bulletin Boards.} %
We adopt a simplified notion of append-only bulletin boards, given in
\cite{acc+20}. This is a local functionality, that defines an (probably too)
idealized version of a bulletin board, where no delays in the operations
occur \todo{We probably want to improve this to use a UC version that
  supports global functionalities}. For the sake of readability, we reproduce
the functionality in \figref{fig:faobb}.

\begin{figure}
  \begin{framed}
    \begin{minipage}[t]{\textwidth}
      \textrm{Upon receiving a call $\IdealFaobb(\cmd,\arg)$ from
        some party $P$ to run command \cmd, with arguments \arg,
        \IdealFaobb operates as follows.}
      \textrm{\IdealFaobb maintains a list \aobbl of bit strings.}      
    \end{minipage}
    \vspace*{0.5em}

    \begin{minipage}[t]{0.55\textwidth}
      \procedure[linenumbering]{$\pcif \cmd = \uccmd{Append} \land \arg = x$}{
        \pccomment{\fbox{Append data to \aobbl}} \\
        \aobbl \gets \aobbl || x \\
        \pcif P~\text{is corrupt}:~\ucsend~(\uccmd{Appended},x,P)~\text{to}
        ~\adv
      }
    \end{minipage}
    \hspace*{1.25em}
    \begin{minipage}[t]{0.45\textwidth}
      \procedure[linenumbering]{$\pcif \cmd = \uccmd{Retrieve} \land \arg =
        \emptyset$}{
        \pccomment{\fbox{Retrieve the contents of \aobbl}} \\
        \text{Output}~(\uccmd{Retrieved},\aobbl)~\text{to}~P
      }
    \end{minipage}
  \end{framed}
  \caption{Ideal append-only bulletin board functionality, \IdealFaobb, from
    \cite{acc+20}.}
  \label{fig:faobb}
\end{figure}

\paragraph{Hashes.} %
\todo{\IdealFRO.}

\paragraph{Digital Signatures.} %

\begin{figure}
  \begin{framed}
    \begin{minipage}[t]{\textwidth}
      \textrm{Upon receiving a call $\IdealFSig(\cmd,\sid,\arg)$ from some party
        $P$ to run command \cmd, in session \sid, with arguments \arg,
        \IdealFSig operates as follows.} \\
      \textrm{\IdealFSig keeps a list \SIG of known signed messages.}      
    \end{minipage}
    \vspace*{0.5em}

    \begin{minipage}[t]{0.5\textwidth}
      \procedure[linenumbering]{$\pcif \cmd = \uccmd{KeyGen} \land \arg =
        \emptyset$}{
        \pccomment{\fbox{Key Generation}} \\
        \pcif \sid = (P,\ssid): \\
        \pcind \ucsend~(\uccmd{KeyGen},\sid)~\text{to}~\adv \\
        \pcind \ucrecv~(\uccmd{VerKey},\sid,v)~\text{from}~\adv \\
        \pcind \ucio{Output}~(\uccmd{VerKey},\sid,v)~\text{to}~P \\
        \pcind \text{Store}~(P,v)
      }
      \vspace*{0.25em}
      \procedure[linenumbering]{$\pcif \cmd = \uccmd{Verif} \land
        \arg = (\sig,\msg,v')$}{
        \pccomment{\fbox{Verify a message}} \\
        \ucsend~(\uccmd{Verif},\sid,\msg,\sig,v)~\text{to}~\adv \\
        \ucrecv~(\uccmd{Verifd},\sid,\msg,\phi)~\text{from}~\adv \\
        \pcif v' = v \land (\msg,\sig,v,1) \in \SIG: f \gets 1 \\
        \pcelse \pcif v' = v \land P~\text{is not corrupt}~\land \\
        \pcind (\msg,\sig',v,1) \notin \SIG: \\
        \pcind \SIG \gets \SIG \cup \lbrace (\msg,\sig,v,0) \rbrace;
        f \gets 0 \\
        \pcelse \pcif (\msg,\sig,v',f') \in \SIG: f \gets f' \\
        \pcelse: \\
        \pcind \SIG \gets \SIG \cup \lbrace (\msg,\sig,v',\phi) \rbrace;~
        f \gets \phi \\
        \ucio{Output}~(\uccmd{Verifd},\sid,\msg,f)
      }
    \end{minipage}
    \begin{minipage}[t]{0.5\textwidth}
      \procedure[linenumbering]{$\pcif \cmd = \uccmd{Sign} \land \arg = \msg$}{
        \pccomment{\fbox{Sign a message}} \\
        \pcif \sid = (P,\ssid) \\
        \pcind \ucsend~(\uccmd{Sign},\sid,\msg)~\text{to}~\adv \\
        \pcind \ucrecv~(\uccmd{Signed},\sid,\msg,\sig)~\text{from}~
        \adv \\
        \pcind \pcif (\msg,\sig,v,0) \in \SIG: \\
        \pcind \pcind \ucio{Output}~(\uccmd{Error}) \\
        \pcind \pcelse: \\
        \pcind \pcind \SIG \gets \SIG \cup (\msg,\sig,v,1) \\
        \pcind \pcind \ucio{Output}~(\uccmd{Signed},\sid,\msg,\sig)
      }
    \end{minipage}
  \end{framed}
  \caption{Ideal signature functionality, \IdealFSig, from \cite{canetti03}.}
  \label{fig:faobb}
\end{figure}

\subsection{Functionality \IdealFPKIDID}

\todo{Syntax using counter indexes doesn't seem a good idea (the simplification
  does not seem to work for proving security). Maybe change to arbitrary labels
  (and change current key label name to key type).}
\todo{Mention public delayed outputs.}
\todo{If the functionality tries to fetch some entry from a list, and the entry
  does not exist, then it aborts (assumed for updates).}

Giving an ideal functionality for a DID-based PKI does not seem to be easy. The
difficulty stems from the fact that the W3C specification (see footnote
\todo{X}) is very permissive in regards to what can be seen as a valid DID
method definition. Namely, it simply states the following conditions for any
candidate method, in Section 8.2 of the specification:

\begin{description}
\item[Authentication.] It must define how authorisation is performed.  
\item[Create.] It must specify how controllers create new DIDs.
\item[Read.] It must specify how the contents of a DID can be fetched and
  authenticated.
\item[Update.] It must specify what updates can controllers apply (if any)
  to existing DIDs.
\item[Deactivate.] It must specify if DIDs can be deactivated, and how.
\end{description}

Where the authentication aspect specifically covers the way in which controllers
prove to be entitled to perform create, update, or deactivate operations.

However, since no functional requirements are given as to, e.g., what an update
may be, or what a deactivation implies, it seems hard to define a functionality
that would cover all possible options.
%
We thus take the basic approach to see DID documents as simple dictionaries
(i.e., lists of labels with corresponding values), associated to a common label,
the DID. From this, creating a DID is simply defining a set (of at least size 1)
of initial label-value pairs and get an identifier associated to them. Updating
a DID is essentially a creation, but over an existing identifier - the
functionality just replaces the old contents with the new ones, where of course
both sets don't need to be disjoint. And deactivating a DID means removing some
of its labels and associated values, where removing all of them equates to
deactivating the whole DID. Reading a DID just outputs the latest contents of
the associated dictionary.
%
Our expectation is that this permissive approach allows to capture a large
subset of all possible DID method implementations. Note that the functional
restrictions we impose seem to be unavoidable. Namely, we do not specify how
the actual identifiers are computed; instead, we allow the adversary to pick
them. To update a DID, we only require such DID to exist, but otherwise its
contents can be set to something completely new, as long as the caller is the
same party who created it. Finally, deactivating labels within an existing DID
requires that these labels exist -- and, again, that the caller is the same
party who created the DID. Concretely, note that any further structure beyond
the label-value dictionary approach, is left as an implementation detail.
%
Note that we also allow the adversary to pick the values associated to the
labels in new and updated DIDs. This is a strong requirement that follows the
argumentation in \cite{canetti03} for ideal digital signatures: namely, this
means that there is absolutely any requirement on the way in which this values
are computed (they might not even be conventional public keys). Indeed, this
seems to match the permissive philosophy of defining DIDs in the W3C DID
specification.
%
\todo{Introduce \P, and re-write this in a more structured manner.}
%
We capture the resulting notion in \figref{fig:fpkidid}.

\begin{figure}
  \begin{framed}
    \scalebox{0.9}{
      \begin{minipage}[t]{\textwidth}
        \textrm{Upon receiving a call $\IdealFPKIDID^{\P}(\cmd,\sid,\arg)$
          from some party $P$ to run command \cmd, in session \sid, with arguments
          \arg, $\IdealFPKIDID^{\P}$ operates as follows.}
        \textrm{If the received \cmd and \arg pair does not meet any of
          the following options, the request is ignored.}
        \textrm{\P is a boolean predicate defining concrete conditions for
          acceptable DID creations, updates and deactivations.
        }
        \textrm{\todo{We assume that the functionality keeps track of the
            received requests.}}
      \end{minipage}
    }
    \vspace*{0.5em}

    \scalebox{0.9}{
      \begin{minipage}[t]{0.55\textwidth}
        \procedure[linenumbering]{$\pcif \cmd = \uccmd{Create} \land \arg =
          \lbrace (\lbl_i,\typ_i) \rbrace_{i\in[n]}$}{
          \pccomment{\fbox{DID Create operation}} \\
          \pcif \P(\lbrace (\lbl_i, \typ_i) \rbrace_{i\in[n]}) = 0:
          \text{abort} \\
          \ucsend~(\uccmd{Create}, \sid, \arg)~\text{to}~\adv \\
          \ucrecv~(\uccmd{CreateOk}, \sid, did,
          \lbrace (\lbl_i, \val_i) \rbrace_{i\in[n]}) \\
          \pcind \text{from}~\adv \\
          \pcif (\cdot,\did,\cdot) \notin \DID: \\
          \pcind \DID \gets \DID \cup \lbrace (P,did,\lbrace
          (\lbl_i,\typ_i,\val_i) \rbrace_{i\in[n]}) \rbrace \\
          \ucio{Output}~(\uccmd{Created},\sid,\did,
          \lbrace (\lbl_i,\typ_i,\val_i) \rbrace_{i\in[n]})
        }
      \end{minipage}
    }
    \scalebox{0.9}{
      \begin{minipage}[t]{0.5\textwidth}
        \procedure[linenumbering]{$\pcif \cmd = \uccmd{Read} \land
          \arg = did$}{
          \pccomment{\fbox{DID Read operation}} \\
          \ucsend~(\uccmd{Read},\sid,\arg)~\text{to}~\adv \\
          \ucrecv~(\uccmd{ReadOk},\sid)~\text{from}~\adv \\
          \pcif (\cdot,did,\sval) \in \DID: \\
          \pcind \ucio{Output}~(\uccmd{Read},\sid,(did,\sval))~\text{to}~P \\
          \pcelse: \\
          \pcind \ucio{Output}~(\uccmd{Read},\sid,\bot)~\text{to}~P    
        }    
      \end{minipage}
    }
    \vspace*{0.25em} \\
    \scalebox{0.9}{
      \begin{minipage}[t]{0.55\textwidth}
        \procedure[linenumbering]{$\pcif \cmd = \uccmd{Update} \land
          \arg = (did, \lbrace (\lbl_i,\typ_i) \rbrace_{i\in[\tilde{n}]})$}{
          \pccomment{\fbox{DID Update operation}} \\
          % \pcif \P(\lbrace (i, \lbl_i) \rbrace_{i\in[n]}) = 0:
          % \text{abort} \\
          \pcif (P,\did,\sval) \in DID: \\
          \pcind \sval_{del} \gets \sval \setminus
          \lbrace (\lbl_i,\cdot) \rbrace_{i\in[\tilde{n}]} \\ 
          \pcind \sval_{add} \gets \lbrace (\lbl_i,\typ_i)
          \rbrace_{i\in[\tilde{n}]} \setminus \sval_{del} \\
          \pccomment{\todo{Continue here!! XXXX}} \\
          \ucsend~(\uccmd{Update}, \sid, \arg)~\text{to}~\adv \\
          \ucrecv~(\uccmd{UpdateOk},\sid,
          \lbrace (i,\val_i) \rbrace_{i\in[n]}) \\
          \pcind \text{from}~\adv \\
          \pcif (P,did,\sval) \in \DID:  \\
          \pcind \DID \gets \DID \setminus \lbrace (P,did,\sval) \rbrace~\cup \\
          \hspace*{7em} \lbrace (P, did,
          \lbrace (i,\lbl_i,\val_i) \rbrace_{i\in[n]}) \rbrace \\
          \ucio{Output}~(\uccmd{Updated},\sid,
          (\did,\lbrace (i,\val_i) \rbrace_{i\in[n]}))
        }
      \end{minipage}
    }
    \scalebox{0.9}{
      \begin{minipage}[t]{0.5\textwidth}
        \procedure[linenumbering]{$\pcif \cmd = \uccmd{Deact} \land \arg =
          (did, \lbrace (i,\lbl_i) \rbrace_{i\in[n]})$}{
          \pccomment{\fbox{DID Deactivate operation}} \\
          \ucsend~(\uccmd{Deact}, \sid, \arg)~\text{to}~\adv \\
          \ucrecv~(\uccmd{DeactOk},\sid)~\text{from}~\adv \\
          \pcif (P,did,\sval) \in \DID~\land \\
          \pcind \lbrace (i,\lbl_i) \rbrace_{i\in[n]} \subseteq \LBL(\sval): \\
          \pcind \sval' \gets \sval \setminus \lbrace (i,\lbl_i,\cdot)
          \rbrace_{i\in[n]} \\
          \pcind \pcif \P(\sval') = 1: \\
          \pcind \pcind \DID \gets \DID \setminus \lbrace (P,did,\sval) \rbrace~\cup \\
          \hspace*{8em}\lbrace (P,did,\sval') \rbrace \\
          \ucio{Output}~(\uccmd{Deacted},\sid,(\did,\sval'))
        }
      \end{minipage}
    }
  \end{framed}
  \caption{Ideal DID-based PKI functionality, \IdealFPKIDID.}
  \label{fig:fpkidid}
\end{figure}

\subsection{The \RealPKIDIDAtala Construction}

We next define the Atala PRISM DID method, following the interfaces defined for
\IdealFPKIDID. We begin by describing the types of keys supported in Atala
PRISM, and then specify how sets of such keys can be managed through DIDs in
Atala.

\paragraph{Key Types.} %
All operations in Atala PRISM are authenticated, meaning that a cryptographic
key needs to be involved in proving that the operation comes from the intended
party. Atala specifies four key types, that are thus supported in Atala's DID
method. Namely: master keys (\MasterKey), for operating on DIDs; issuing keys,
for issuing VCs (\IssueKey); communication keys (\CommKey), for key-exchange
protocols; and authentication keys, to associate to VCs (\AuthKey).

\paragraph{Custom Notation.} %
Keys in Atala are identified by indexes. In the following description of the
\RealPKIDIDAtala construction, given a set of keys, we frequently refer to the
``master key with lowest index''.  For brevity, given a set \st, we use
$\LMKI(\st)$ to denote such index.

\paragraph{DID Operations.} %
\todo{For now, this ignores \emph{unpublished} DIDs.}
\figref{fig:atalapkidid1} and \figref{fig:atalapkidid2} contain the
specification of Atala PRISM's DID method,
which we describe next. Looking at the \texttt{Create} and \texttt{Update}
operations, it is clear that $\P(\lbrace (i, \lbl_i) \rbrace_{i\in[n]})$ in
Atala requires that all key labels are of a known type (\MasterKey, \IssueKey,
\CommKey, or \AuthKey) and that at least one of the keys in the DID Document
is of type \MasterKey.

\begin{description}
\item{\uccmd{Create}.} %
  To create a DID, the user has to specify the key pairs to create, along with
  fresh identifiers and their type. For ease of exposition, we assume that the
  used identifiers just follow a sequence. The predicate \P in Atala simply
  requires that at least one key pair of \MasterKey type is created. The
  \uccmd{Create} algorithm creates as many keys of each type as requested,
  and keeps a list with the identifier, type and public key of each key pair.
  This list is then hashed into a value \texttt{h}, and the created DID is
  ``\texttt{\did:prism:h}''. A transaction containing the created list, the
  DID, and the \texttt{CreateDID} instruction is sent to the blockchain,
  signed by one of the master keys -- w.l.o.g., we simply use the first one
  in the list. The DID owner stores locally the list, along with the
  corresponding private keys.
\item[\uccmd{Read}.] %
  Getting the contents of a DID simply requires processing the associated
  transactions in the blockchain. Namely, transactions $(\tx,\sig)$ where $\tx$
  is either $(\texttt{CreateDID},\did,\cdot)$ or $(\texttt{UpdateDID},\did,
  \cdot)$. The associated DID Document is the result of applying in an ordered
  manner (from oldest to newest) all such validly signed transactions.
\item[\uccmd{Update}.] %
  To update a DID, we first assume for ease of exposition that the calling party
  $P$ has an updated version of the associated DID Document (which included
  a list of $n$ keys) -- if this is not the case, it suffices to make first a
  call to \uccmd{Read} for the given DID. \todo{This seems relevant enough to
    be highlighted in some more visible place, no?}
  Then, updating a DID requires to (optionally) specify a list of previously
  existing key identifiers to remove, and (optionally) specify a list of new key
  identifiers, and their types, to add. To simplify notation, we just adopt the
  (equivalent) convention that the caller indicates a list of $\lbrace (i,
  \lbl_i) \rbrace_{i\in\tilde{N}\subseteq[\tilde{n}]}$ pairs, where $\tilde{n}$
  may be smaller or larger than $n$, depending on the desired update. This
  list is then interpreted as follows. If $i$ is an already existing
  identifier, the label is ignored and the corresponding key is not removed. If
  $i$ is a new identifier, then a new key pair of the given type is created.
  Omitting an existing identifier is then interpreted as the desire to remove
  the corresponding key pair. Otherwise, the same policy as for \uccmd{Create}
  applies here. Key pairs for the new keys are generated, and a transaction is
  sent to the blockchain, signed with one of the master keys in the DID
  \emph{before applying the update}. This transaction contains a list of the
  identifiers of the keys to remove, and a list of the identifiers and types
  of the keys to add.
\item[\uccmd{Deactivate}.] %
  A deactivate operation is simply an update operation with no new key
  identifiers, and that only specifies the existing identifiers that will
  \emph{not} be deactivated.
\end{description}

\begin{figure}[ht!]
  \begin{framed}

    \scalebox{0.9}{
      \begin{minipage}[t]{\textwidth}
        \textrm{Party $P$ running operation \cmd with arguments \arg, in
          session \sid.}
      \end{minipage}
    }
    \vspace*{0.5em}
    
    \scalebox{0.9}{
      \begin{minipage}[t]{0.55\textwidth}
        \procedure[linenumbering=on]{$\pcif \cmd = \uccmd{Create} \land \arg =
          \lbrace (i,\lbl_i) \rbrace_{i\in[n]}$}{
          \pcif \exists i~\suchthat~\lbl_i \notin [\MasterKey,\AuthKey,
          \CommKey,\IssueKey] \lor
          \nexists i~\suchthat~\lbl_i = \MasterKey: \\
          \pcind \texttt{abort} \\
          \st \gets \emptyset \\
          \pcfor i \in [n]: \\
          \pcind \sid' \gets ((P,i),\sid) \\
          \pcind \ucsend~(\uccmd{KeyGen},\sid')~\text{to}~\IdealFSig \\
          \pcind \ucrecv~(\uccmd{VerKey},\sid',\pk_i)~\text{from}~
          \IdealFSig \\
          \pcind \st \gets \st \cup \lbrace (i,\lbl_i,\pk_i) \rbrace \\
          \ucsend~(\uccmd{Hash},\st)~\text{to}~\IdealFRO \\
          \ucrecv~(\uccmd{Hashed},\st,h)~\text{from}~\IdealFRO \\
          \did \gets ``did:prism:''||~h \\
          \tx \gets (\texttt{CreateDID}, \did, \st) \\
          j \gets \LMKI(\st); \sid' \gets ((P,j),\sid) \\
          \ucsend~(\uccmd{Sign},\sid',\tx)~\text{to}~\IdealFSig \\
          \ucrecv~(\uccmd{Signed},\sid',\tx,\sig)~\text{from}~\IdealFSig \\
          \ucsend~(\uccmd{Append},(\msg,\sig))~\text{to}~\IdealFaobb \\
          \ucio{Output}~(\uccmd{Created},\sid,\did,\lbrace (i,\pk_i)
          \rbrace_{i\in[n]})
        }
      \end{minipage}
    }
    \scalebox{0.9}{
      \begin{minipage}[t]{0.5\textwidth}
        \procedure[linenumbering=on]{$\pcif \cmd = \uccmd{Read} \land
          \arg = did$}{
          \ucsend~(\uccmd{Retrieve})~\texttt{to}~\IdealFaobb \\
          \ucrecv~(\uccmd{Retrieve},L)~\texttt{from}~\IdealFaobb \\
          \st \gets \emptyset \\
          L_{\did} \gets (\ast,\did,\ast) \subseteq \DID \\
          \pcfor (\tx=(\texttt{op},\did,\cdot),\sig) \in L_{\did}: \\
          \pcind \pk \gets \emptyset \\
          \pcind \pcif \texttt{op} = \texttt{CreateDID}~\land \\
          \pcind \pcind \text{no \texttt{CreateDID} appeared before}: \\
          \pcind \pcind (\cdot,\cdot,\lbrace (i,\lbl_i,\pk_i)
          \rbrace_{i\in[n]}) \gets \tx \\
          \pcind \pcind \st \gets \lbrace (i,\lbl_i,\pk_i) \rbrace_{i \in [n]} \\
          \pcind \pcind j \gets \LMKI(\st); \pk \gets \pk_j \\
          \pcind \pcif \texttt{op} = \texttt{UpdateDID}: \\
          \pcind \pcind (\cdot,\cdot,(\st_{del},\st_{add})) \gets \tx \\
          \pcind \pcind \lbrace i \rbrace_{i\in[n]} \gets \st_{del} \\ 
          \pcind \pcind \lbrace (i,\lbl_i,\pk_i) \rbrace_{i\in[\tilde{n}]} \gets \st_{add} \\
          \pcind \pcind j \gets \LMKI(\st); \pk \gets \pk_j \\
          \pcind \pcind \st \gets \st \setminus \st_{del} \cup \st_{add} \\
          \pcind \pcif \pk = \emptyset: \text{abort}; \pcelse \sid' \gets (P, \sid) \\
          \pcind \ucsend~(\uccmd{Verif},\sid',\tx,\sig,\pk)~\text{to}~\IdealFSig \\
          \pcind \ucrecv~(\uccmd{Verifd},\sid',\tx,b)~\text{from}~\IdealFSig \\
          \pcind \pcif b = 0: \text{abort} \\
          \ucio{Output}~(\uccmd{Read},\sid,(\did,\st))
        }    
      \end{minipage}
    }
  \end{framed}
  \caption{\texttt{Create} and \texttt{Read} operations in Atala
    PRISM DID-based PKI protocol, \RealPKIDIDAtala, realising \IdealFPKIDID
    in the $(\IdealFRO,\IdealFSig,\IdealFaobb)$-hybrid model.}
  \label{fig:atalapkidid1}
\end{figure}

\begin{figure}[ht!]
  \begin{framed}
    \scalebox{0.9}{
      \begin{minipage}[t]{\textwidth}
        \textrm{Party $P$ running operation \cmd with arguments \arg, in
          session \sid.} \\
        \textrm{We assume that the party running
          \texttt{Update} and \texttt{Deactivate} operations has an up to date
          copy $(\did,\lbrace (i,\lbl_i,\pk_i) \rbrace_{i\in[n]})$ of the DID to
          modify. Otherwise, a \texttt{Read} operation needs to be run before.
          If no such \did exists, the execution is aborted.}
      \end{minipage}
    }
    \vspace*{0.5em}
    
    \scalebox{0.90}{          
      \begin{minipage}[t]{0.55\textwidth}
        \procedure[linenumbering=on]{$\pcif \cmd = \uccmd{Update} \land
          \arg = (did, \lbrace (i,\lbl_i) \rbrace_{i\in\tilde{N}\subseteq [\tilde{n}]})$}{
          \pcif \exists i~\suchthat~\lbl_i \notin [\MasterKey,\AuthKey,
          \CommKey,\IssueKey] \lor
          \nexists i~\suchthat~\lbl_i = \MasterKey: \\
          \pcind \texttt{abort} \\
          \st_{add} \gets \emptyset \\
          \pcfor i \in \tilde{N}~\suchthat~ i > n : \pccomment{$n$ is determined
            by the local $(\did, \lbrace (i,\lbl_i,\pk_i) \rbrace_{i\in[n]})$
            copy}\\
          \pcind \ucsend~(\uccmd{KeyGen},((P,i),\sid))~\text{to}~\IdealFSig \\
          \pcind \ucrecv~(\uccmd{VerKey},((P,i),\sid),\pk_i)~\text{from}~
          \IdealFSig \\
          \pcind \st_{add} \gets \st_{add} \cup \lbrace (i,\lbl_i,\pk_i) \rbrace \\
          \st_{del} \gets [n] \setminus \tilde{N} \\
          % \text{Locally store}~(\did,\lbrace (i,\lbl_i,\pk_i) \rbrace_{i\in[\tilde{n}]} \\
          \tx \gets (\texttt{UpdateDID}, \did, (\st_{del}, \st_{add})) \\
          j \gets \LMKI(\lbrace \lbl_i \rbrace_{i\in\tilde{N}}) \\
          \ucsend~(\uccmd{Sign},((P,j),\sid),\tx)~\text{to}~\IdealFSig \\
          \ucrecv~(\uccmd{Signed},((P,j),\sid),\tx,\sig)~\text{from}~\IdealFSig \\
          \ucsend~(\uccmd{Append},(\msg,\sig))~\text{to}~\IdealFaobb \\
          \ucio{Output}~(\uccmd{Updated},\sid,\did,\lbrace \pk_i \rbrace_{i\in[\tilde{N}]})
        }
      \end{minipage}
    }
    \scalebox{0.9}{
      \begin{minipage}[t]{0.45\textwidth}
        \procedure[linenumbering=on]{$\pcif \cmd = \uccmd{Deact} \land \arg =
          (did, \lbrace (i,\lbl_i) \rbrace_{i\in N \subseteq[n]})$}{       
          \text{Run as a \texttt{Update} operation}
        }
      \end{minipage}
    }
  \end{framed}
  \caption{\texttt{Update} and \texttt{Deactivate} operations in Atala
    PRISM DID-based PKI protocol, \RealPKIDIDAtala, realising \IdealFPKIDID
    in the $(\IdealFRO,\IdealFSig,\IdealFaobb)$-hybrid model.}
  \label{fig:atalapkidid2}
\end{figure}

\subsubsection{Notes for Implementations.} %

We acknowledge that, in the pseudocode given in \figref{fig:atalapkidid1} and
\figref{fig:atalapkidid2}, we have favoured notational simplicity over
implementation efficiency or
convenience. For instance, it is not really needed that the master key signing a
transaction is the one with the lowest index -- any such key can actually do it.
However, it makes notation much easier. Similarly, in practice it may be easier
to use different ``function arguments'' to denote the set of keys to remove and
a set of keys to add from/to an existing DID. However, notationally it is
simpler to follow the chosen (equivalent) approach. Finally, key indexes don't
need to follow a sequential order.

Somehow related, it is of course not needed to fetch the contents of the whole
blockchain whenever we want to get an up to date DID Document. Instead, the
party running the operation can keep a local copy, and just fetch the new
operations since it last synced. However, again the given simplified notion of
a blockchain (via \IdealFaobb) eases notation -- and seems good enough for a
first modelling effort.

\subsection{Security of \RealPKIDIDAtala}
\label{ssec:sec-didatala}

Before going into the proofs, observe that the \uccmd{Create} and \uccmd{Update}
operations in \RealPKIDIDAtala include (in lines 1-2) a policy on the received
indexes and labels. Concretely, this policy requires that all labels are of a
known key type, and that at least one of them is of type \MasterKey. In the
sequel, we use $\P_{Atala}$ to refer to this policy.

\begin{theorem}[UC-security of \RealPKIDIDAtala]
  \label{thm:sec-didatala}
  \RealPKIDIDAtala UC-realizes $\IdealFPKIDID^{\P_{Atala}}$ in the $(\IdealFRO,
  \IdealFSig, \IdealFaobb)$-hybrid model.
\end{theorem}

\begin{proof}
  We show that \RealPKIDIDAtala UC-realizes \IdealFPKIDID, when configured
  with policy $\P_{Atala}$. For this, we give a simulator \Sim such that, for
  any environment \Env, $\Exec_{\RealPKIDIDAtala\adv,\Env} \approx
  \Exec_{\phiDIDAtala,\Sim,\Env}$,
  where \phiDIDAtala is a protocol composed with the same parties as
  \RealPKIDIDAtala but where each party is simply a dummy party that forwards
  every message from \Env to the ideal functionality \IdealFPKIDID, and every
  response from \IdealFPKIDID back to \Env. The simulator \Sim runs internally a
  copy of the real-world adversary \adv, as well as the ideal functionalities
  \IdealFRO, \IdealFSig and \IdealFaobb, and any involved party.

  \begin{description}
  \item[Simulating DID Create.] %
    % 
    % Policy check
    First, note that \IdealFPKIDID is parameterised with $\P_{Atala}$. Thus,
    if the input labels don't match the policy, the functionality rejects the
    request, just as in the real protocol \RealPKIDIDAtala.
    %
    % Keys generation
    Next, when \Sim receives a message $(\uccmd{Create},\sid,\lbrace (i,\lbl_i)
    \rbrace_{i\in[n]})$ from (dummy) party $P$, it simulates for \adv~the key
    generation process of $n$ signing key pairs, by sending $n$
    $(\uccmd{KeyGen},((P,i),\sid))$ queries to \adv~on
    behalf of \IdealFSig, and receiving the $n$ corresponding $(\uccmd{VerKey}, 
    ((P,i), \sid), \pk_i)$ responses.
    %
    % Hash computation
    \Sim then concatenates all $(i,\lbl_i,\pk_i)$ tuples into \st, and simulates
    a query to \IdealFRO \todo{do we need programmability or something?}, to set
    \did as ``$did:prism: h$'' as DID value.
    %
    % Tx sim
    With the DID value, \Sim simulates for \adv~the preparation of transaction
    \tx. That is, \Sim uses the master key with lower index, $j \gets
    \LMKI(\st)$, and simulates a query $(\uccmd{Sign},((P,j),\sid),\tx)$ to
    \IdealFSig, obtaining from \adv~$(\uccmd{Signed},((P,j),\sid),\tx,\sig)$.
    %
    % BB append
    \Sim also simulates appending the $(\tx,\sig)$ tuple to the bulletin board,
    by sending $(\uccmd{Append},(\tx,\sig))$ to \adv~on behalf of \IdealFaobb.
    %
    % Output
    Finally, \Sim sends the $(\uccmd{CreateOk},\sid,\did,\lbrace (i,\pk_i)
    \rbrace_{i\in[n]})$ to \IdealFPKIDID, and stores the tuple $(\did,\lbrace
    (i,\lbl_i,\pk_i)\rbrace_{i\in[n]})$.
    Note that \did is generated by an ideal random oracle (thus, uniformly at
    random), just as in the real protocol \RealPKIDIDAtala. Thus, the
    probability that \IdealFPKIDID halts because $\did \in \DID$ is negligible,
    and \IdealFPKIDID outputs $(\uccmd{Created},\sid,\did,\lbrace (i,\val_i)
    \rbrace_{i\in[n]})$.
  \item[Simulating DID Read.]
    %
    % Ack
    Upon receiving $(\uccmd{Read},\sid,\did)$ from dummy party P, \Sim simply
    forwards the message to \adv and waits until receiving the response, which
    is forwareded back to P.
    %
    % Consistent and indistinguishable results
    Now, we show that the value returned by \IdealFPKIDID is indistinguishable
    to that of \RealPKIDIDAtala. \todo{Do after Update.}
  \item[Simulating DID Update.]
    % 
    % Policy check
    First, note that \IdealFPKIDID is parameterised with $\P_{Atala}$. Thus,
    if the input labels don't match the policy, the functionality rejects the
    request, just as in the real protocol \RealPKIDIDAtala.
    % 
    % Read if needed
    First, \Sim finds in its records the entry $(\did,\lbrace (i,\lbl_i,\pk_i)
    \rbrace_{i\in[n]})$. If no such \did exists, aborts.
    %
    % Simulate generation of new keys
    Then, \Sim parses the $\lbrace(i,\lbl_i)\rbrace_{i\in\tilde{N}\subseteq
      [\tilde{n}]}$ for new indexes, and simulates for \adv~one call to the
    $\uccmd{KeyGen}$ interface of \IdealFSig for each new key, and composes the
    variable $\st_{add}$ as in the real protocol. Similarly, \Sim initializes
    variable $\st_{del}$ by looking for indexes in $[n]$ no longer present in
    $\tilde{N}$.
    %
    % Simulate transaction
    Finally, \Sim prepares the transaction \tx as in the real protocol using
    variables $\st_{add}$ and $\st_{del}$. For this, a \uccmd{Sign} request is
    sent to \IdealFSign, and an \uccmd{Append} request is sent to \IdealFaobb.
    \Sim sends the resulting $(\uccmd{UpdateOK},\sid,\lbrace (i,\pk_i)
    \rbrace_{i\in[\tilde{N}]})$ back to \IdealFPKIDID.
    %
    % Indistinguishability
    Note that, if \Sim does not abort, then a valid $(P,\did,\sval)$ entry must
    exist in the \DID state variable of \IdealFPKIDID. Thus, \IdealFPKIDID does
    not abort in line 6. Then, \IdealFPKIDID
  \item[Simulating DID Deactivate.] Directly follows from DID Update.      
  \end{description}
\end{proof}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "prism-protocol"
%%% End:
