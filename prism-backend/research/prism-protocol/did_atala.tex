\section{Atala PRISM's \RealPKIDIDAtala: A DID-based PKI}
\label{sec:did-atala}

In this section we first describe Atala PRISM DID method \RealPKIDIDAtala, and
prove that it realizes \IdealGPKIDID.
%
We begin by describing the types of keys supported in Atala PRISM, and the
policy \PAtala that all CRUD operations need to meet.

\paragraph{Custom Notation.} %
Keys in Atala are identified by labels. In the following description of the
\RealPKIDIDAtala construction, given a set of keys, we frequently refer to the
``master key with lowest label'' (using any order relation, like lexicographic
order).  For brevity, given a set \st, we use $\LMKL(\st)$ to denote such label.

\paragraph{Key Types.} %
All operations in Atala PRISM are authenticated, meaning that a cryptographic
key needs to be involved in proving that the operation comes from the intended
party. Atala specifies four key types, that are thus supported in Atala's DID
method. Namely: master keys (\MasterKey), for operating on DIDs; issuing keys,
for issuing VCs (\IssueKey); communication keys (\CommKey), for key-exchange
protocols; and authentication keys, to associate to VCs (\AuthKey).

\paragraph{\PAtala policy.} %
Before proceeding with the specififying the DID operations in Atala, we define
its policy on the keys' labels and types.
\todo{This needs to take into account the caller, and the previous state of the
  PKI list.}

\begin{figure}[ht]
  \centering
  \procedure{$\PAtala(\lbrace (\lbl_i,\typ_i) \rbrace_{i\in[n]})$}{    
    \pcif \exists i\in[n]~\suchthat~\typ_i \notin [\MasterKey,\IssueKey,
    \CommKey,\AuthKey]: \pcreturn 0~\pccomment{All types must be known} \\   
    \pcif \not\exists i\in[n]~\suchthat~\typ_i = \MasterKey: \pcreturn 0~
    \pccomment{There must be at least one master key} \\
    \pcif \exists i, j \in[n], i \neq j~\suchthat~\lbl_i = \lbl_j: \pcreturn 0~
    \pccomment{No duplicate labels} \\
    \pcreturn 1
  }
  \caption{Policy \PAtala that all DID documents must meet in Atala.}
\end{figure}

\paragraph{DID Operations.} %
\todo{For now, this ignores \emph{unpublished} DIDs.}
\figref{fig:atalapkidid1} and \figref{fig:atalapkidid2} contain the
specification of Atala PRISM's DID method,
which we describe next. Looking at the \texttt{Create} and \texttt{Update}
operations, it is clear that $\P(\lbrace (i, \lbl_i) \rbrace_{i\in[n]})$ in
Atala requires that all key labels are of a known type (\MasterKey, \IssueKey,
\CommKey, or \AuthKey) and that at least one of the keys in the DID Document
is of type \MasterKey.

\begin{description}
\item{\uccmd{Create}.} %
  To create a DID, the user has to specify the fresh identifiers (labels) and
  types of the key pairs to include in the DID. The \uccmd{Create} algorithm
  creates as many keys of each type as requested, by leveraging the ideal
  functionality \IdealFSig, and keeps a list with the identifier, type and
  public key of each key pair. This list is then hashed into a value \texttt{h}
  via \IdealGRO, and the created DID is ``\texttt{\did:prism:h}''. A transaction
  containing the created list, the DID, and the \texttt{CreateDID} instruction
  is sent to the blockchain via a call to \IdealGdledger, signed by one of the
  master keys -- w.l.o.g., we 
  simply use the first one in the list. The DID owner stores locally the list.
\item[\uccmd{Read}.] %
  Getting the contents of a DID simply requires processing the associated
  transactions in the blockchain. Namely, the interface first fetches all the
  contents from the \IdealGdledger functionality. Then, transactions the
  relevant transactions are those with $(\tx,\sig)$ where $\tx$
  is either $(\texttt{CreateDID},\did,\cdot)$ or $(\texttt{UpdateDID},\did,
  \cdot)$. The associated DID Document is the result of applying in an ordered
  manner (from oldest to newest) all such validly signed transactions.
\item[\uccmd{Update}.] %
  To update a DID, we first assume for ease of exposition that the calling party
  $P$ has an updated version of the associated DID Document (which included
  a list of $n$ keys) -- if this is not the case, it suffices to make first a
  call to \uccmd{Read} for the given DID.
  %
  Then, updating a DID requires to (optionally) specify a list of previously
  existing key labels to remove $\sval_d$, and (optionally) specify a list
  $\sval_a$ of new key labels and their types to add. The result of removing
  the labels in $\sval_d$ and adding the new keys in $\sval_a$ must satisfy
  \PAtala. Key pairs for the new keys are generated via \IdealFSig, and a
  transaction is sent to the blockchain via \IdealGdledger, signed (again, via
  \IdealFSig) with one of the master keys in the DID \emph{before applying the
    update}. This transaction contains a list of the identifiers of the keys to
  remove, and a list of the identifiers and types of the keys to add.
  %
  Note that the DID remains the same, even though the original contents of
  the associated DID document may change.
\item[\uccmd{Deactivate}.] %
  A deactivate operation is simply an update operation with no new key
  identifiers, and that only specifies the existing identifiers that will
  \emph{not} be deactivated.
\end{description}

\begin{figure}[ht!]
  \begin{framed}

    \scalebox{0.9}{
      \begin{minipage}[t]{\textwidth}
        \textrm{Party $P$ running operation \cmd with arguments \arg, in
          session \sid.}
      \end{minipage}
    }
    \vspace*{0.5em}
    
    \scalebox{0.9}{
      \begin{minipage}[t]{0.55\textwidth}
        \procedure[linenumbering=on]{$\pcif \cmd = \uccmd{Create} \land \arg =
          \lbrace (\lbl_i,\typ_i) \rbrace_{i\in[n]}$}{
          \pcif \PAtala(\lbrace (\lbl_i,\typ_i) \rbrace_{i\in[n]}) = 0: abort \\
          \st \gets \emptyset \\
          \pcfor i \in [n]: \\
          \pcind \sid' \gets ((P,\lbl_i),\sid) \\
          \pcind \ucsend~(\uccmd{KeyGen},\sid')~\text{to}~\IdealFSig \\
          \pcind \ucrecv~(\uccmd{VerKey},\sid',\pk_i)~\text{from}~
          \IdealFSig \\
          \pcind \st \gets \st \cup \lbrace (\lbl_i,\typ_i,\pk_i) \rbrace \\
          \ucsend~(\uccmd{Hash},\st)~\text{to}~\IdealGRO \\
          \ucrecv~(\uccmd{Hashed},\st,h)~\text{from}~\IdealGRO \\
          \did \gets ``did:prism:''||~h \\
          \tx \gets (\texttt{CreateDID}, \did, \st) \\
          \lbl \gets \LMKL(\st); \sid' \gets ((P,\lbl),\sid) \\
          \ucsend~(\uccmd{Sign},\sid',\tx)~\text{to}~\IdealFSig \\
          \ucrecv~(\uccmd{Signed},\sid',\tx,\sig)~\text{from}~\IdealFSig \\
          \ucsend~(\uccmd{Submit},(\tx,\sig))~\text{to}~\IdealGdledger \\
          \text{Locally store}~
          (\did, \lbrace (\lbl_i,\typ_i,\pk_i) \rbrace_{i\in[n]}) \\
          \ucio{Output}~(\uccmd{ProcessedC},\sid,\did,\lbrace \pk_i
          \rbrace_{i\in[n]})
        }
      \end{minipage}
    }
    \scalebox{0.9}{
      \begin{minipage}[t]{0.5\textwidth}
        \procedure[linenumbering=on]{$\pcif \cmd = \uccmd{Read} \land
          \arg = did$}{
          \ucsend~(\uccmd{Retrieve})~\texttt{to}~\IdealGdledger \\
          \ucrecv~(\uccmd{Retrieve},L)~\texttt{from}~\IdealGdledger \\
          \st \gets \emptyset \\
          L_{\did} \gets (\ast,\did,\ast) \subseteq \DID \\
          \pcfor (\tx=(\texttt{op},\did,\cdot),\sig) \in L_{\did}: \\
          \pcind \pk \gets \emptyset \\
          \pcind \pcif \texttt{op} = \texttt{CreateDID}~\land \\
          \pcind \pcind \text{no \texttt{CreateDID} appeared before}: \\
          \pcind \pcind (\cdot,\cdot,\lbrace (\lbl_i,\typ_i,\pk_i)
          \rbrace_{i\in[n]}) \gets \tx \\
          \pcind \pcind \st \gets \lbrace (\lbl_i,\typ_i,\pk_i) \rbrace_{i \in [n]} \\
          \pcind \pcif \texttt{op} = \texttt{UpdateDID}: \\
          \pcind \pcind (\cdot,\cdot,(\st_d,\st_a)) \gets \tx \\
          \pcind \pcind \lbrace \lbl^d_i \rbrace_{i\in[n^d]} \gets \st_d \\ 
          \pcind \pcind \lbrace (\lbl^a_i,\typ^a_i,\pk^a_i)
          \rbrace_{i\in[n^a]} \gets \st_a \\
          \pcind \pcind \st \gets (\st \setminus \st_d) \cup \st_a \\
          \pcind \lbl \gets \LMKL(\st) \\
          \pcind \pcif \lbl = \emptyset \lor \PAtala(\st) = 0: \text{skip} \\
          \pcind \pcelse \sid' \gets ((P,\lbl),\sid) \\
          \pcind \ucsend~(\uccmd{Verif},\sid',\tx,\sig,\pk)~\text{to}~\IdealFSig \\
          \pcind \ucrecv~(\uccmd{Verifd},\sid',\tx,b)~\text{from}~\IdealFSig \\
          \pcind \pcif b = 0: \text{skip} \\
          \ucio{Output}~(\uccmd{ReadOk},\sid,\did,\st)
        }    
      \end{minipage}
    }
  \end{framed}
  \caption{\texttt{Create} and \texttt{Read} operations in Atala
    PRISM DID-based PKI protocol, \RealPKIDIDAtala, realising \IdealGPKIDID
    in the $(\IdealGRO,\IdealFSig,\IdealGdledger)$-hybrid model.}
  \label{fig:atalapkidid1}
\end{figure}

\begin{figure}[ht!]
  \begin{framed}
    \scalebox{0.9}{
      \begin{minipage}[t]{\textwidth}
        \textrm{Party $P$ running operation \cmd with arguments \arg, in
          session \sid.} \\
      \end{minipage}
    }
    \vspace*{0.5em}
    
    \scalebox{0.90}{          
      \begin{minipage}[t]{0.6\textwidth}
        \procedure[linenumbering=on]{$\pcif \cmd = \uccmd{Update} \land
          \arg = (did, \sval_d, \sval_a)$}{
          \text{Fetch}~
          (\did, \sval=\lbrace (\lbl_i,\typ_i,\pk_i) \rbrace_{i\in[n]})
          ~\text{from storage} \\
          \st_a \gets \emptyset;~
          \lbrace (\lbl_i,\typ_i,\pk_i) \rbrace_{i\in[n]} \gets \sval \\
          \lbrace \lbl^d_i \rbrace_{i\in[n_d]} \gets \sval_d;~
          \lbrace (\lbl^a_i,\typ^a_i) \rbrace_{i\in[n_a]} \gets \sval_a \\
          \sval' \gets (\sval \setminus \sval_d) \cup \sval_a
          \pccomment{\todo{Syntax refinement needed here.}} \\
          \pcif \PAtala(\sval') = 0: abort \\          
          \pcfor i \in [n_a] \\
          \pcind \ucsend~(\uccmd{KeyGen},((P,\lbl_i),\sid))~\text{to}~\IdealFSig \\
          \pcind \ucrecv~(\uccmd{VerKey},((P,\lbl_i),\sid),\pk^a_i)~\text{from}~
          \IdealFSig \\
          \pcind \st_a \gets \st_a \cup \lbrace (\lbl^a_i,\typ^a_i,\pk^a_i) \rbrace \\
          \tx \gets (\texttt{UpdateDID}, \did, \sval_d, \st_a) \\
          \lbl \gets \LMKL(\sval) \\
          \ucsend~(\uccmd{Sign},((P,\lbl),\sid),\tx)~\text{to}~\IdealFSig \\
          \ucrecv~(\uccmd{Signed},((P,\lbl),\sid),\tx,\sig)~\text{from}~\IdealFSig \\
          \ucsend~(\uccmd{Submit},(\tx,\sig))~\text{to}~\IdealGdledger \\
          \text{Locally store}~(\did,\sval) \\
          \ucio{Output}~(\uccmd{ProcessedU},\sid,\did,\lbrace \pk^a_i \rbrace_{i\in[n^a]}) \\
          \text{\todo{The previous must return all the final pks, not only
              $pk^a$, to be compatible with deact.}}
        }
      \end{minipage}
    }
    \scalebox{0.9}{
      \begin{minipage}[t]{0.45\textwidth}
        \procedure[linenumbering=on]{$\pcif \cmd = \uccmd{Deact} \land \arg =
          (did, \sval)$}{       
          \text{Run as an \texttt{Update} operation with} \\
          \text{ $\sval_d \gets \sval$ and $\sval_a \gets \emptyset$,
            and output} \\
          \text{\uccmd{ProcessedD} instead of \uccmd{ProcessedU}}
        }
      \end{minipage}
    }
  \end{framed}
  \caption{\texttt{Update} and \texttt{Deactivate} operations in Atala
    PRISM DID-based PKI protocol, \RealPKIDIDAtala, realising \IdealGPKIDID
    in the $(\IdealGRO,\IdealFSig,\IdealGdledger)$-hybrid model.}
  \label{fig:atalapkidid2}
\end{figure}

\subsubsection{Notes for Implementations.} %
\todo{This needs updating. However, keeping it here until I confirm.}
We acknowledge that, in the pseudocode given in \figref{fig:atalapkidid1} and
\figref{fig:atalapkidid2}, we have favoured notational simplicity over
implementation efficiency or
convenience. For instance, it is not really needed that the master key signing a
transaction is the one with the lowest index -- any such key can actually do it.
However, it makes notation much easier. Similarly, in practice it may be easier
to use different ``function arguments'' to denote the set of keys to remove and
a set of keys to add from/to an existing DID. However, notationally it is
simpler to follow the chosen (equivalent) approach. Finally, key indexes don't
need to follow a sequential order.

Somehow related, it is of course not needed to fetch the contents of the whole
blockchain whenever we want to get an up to date DID Document. Instead, the
party running the operation can keep a local copy, and just fetch the new
operations since it last synced. However, again the given simplified notion of
a blockchain (via \IdealGdledger) eases notation -- and seems good enough for a
first modelling effort.

\subsection{Security of \RealPKIDIDAtala}
\label{ssec:sec-didatala}

We now prove that \RealPKIDIDAtala $\xi$-UC-emulates \IdealGPKIDID, in the
presence of global subroutines \IdealGclock, \IdealGRO, and \IdealGdledger.
Given that (multiple) global subroutines are involved, the proving process
requires several steps, which we summarise first, and then specify in detail. In
this process, we rely on recent results in \cite{bch+20,bhz21} as well as,
naturally, on the UC framework \cite{canetti00}. In a nutshell, the steps we
take are as follows (here, we are intentionally imprecise on occasions, in
favour of giving a high-level idea of the overall approach):

\todo{Some diagram would probably help much here.}
\begin{enumerate}
\item \emph{(Merging global subroutines into \gAtala)} Following the strategy
  in \cite{bhz21}, we combine all the global subroutines needed in our protocols
  into a single (equivalent) one. While merely ``bureaucratic'', this
  facilitates the analysis in subsequent steps. We refer to this combined
  global shared subroutine as \gAtala.
\item \emph{(\gAtala is subroutine respecting)} We show that only main ITIs
  in \gAtala accept input from ITIs not in \gAtala, no ITI within \gAtala passes
  input to ITIs not in \gAtala, no ITI in \gAtala expects subroutine output from
  other ITIs outside of \gAtala, and all subroutine outputs produced within
  \gAtala are sent to the outside world via \gAtala's main ITIs.
\item \emph{(\RealPKIDIDAtala is \gAtala-subroutine respecting)} We show that
  \RealPKIDIDAtala is also subroutine respecting, as just described for \gAtala,
  except actually for calls to \gAtala. This means that ITIs within
  \RealPKIDIDAtala may communicate directly with machines in \gAtala without
  needing to ``pass through'' the main ITIs of \RealPKIDIDAtala, and can
  communicate with them even if they are not part of \RealPKIDIDAtala's session.
\item \emph{(\IdealGPKIDID is \gAtala-subroutine respecting)} Same as before,
  but with \IdealGPKIDID.
\item \emph{(\gAtala is \RealPKIDIDAtala-regular)} We show that ITIs in \gAtala
  do not invoke new ITIs of \RealPKIDIDAtala as subroutines, nor call or expect
  subroutine output from machines of \RealPKIDIDAtala.
\item \emph{(\gAtala is \IdealGPKIDID-regular)} Same as before, but with
  \IdealGPKIDID.
\item \emph{(Executions of $\UCM[\RealPKIDIDAtala,\gAtala]$ are indistinguishable
    from execution of \RealPKIDIDAtala in the presence of \gAtala)} Given the
  previous preconditions, \cite[Proposition 3.4]{bch+20} ensures that we can
  safely apply a transformation $\UCM[\cdot,\cdot]$ to \RealPKIDIDAtala, which
  allows to leverage the techniques from the plain UC framework.
\item \emph{(Executions of $\UCM[\IdealGPKIDID,\gAtala]$ are indistinguishable
    from execution of \IdealGPKIDID in the presence of \gAtala)} Same as before,
  but with \IdealGPKIDID.
\item \emph{(\RealPKIDIDAtala $\xi$-UC-emulates \IdealGPKIDID in the presence
    of \gAtala)} By \cite[Definition 3.1]{bch+20}, if $\UCM[\RealPKIDIDAtala,
  \gAtala]$ $\xi$-UC-emulates $\UCM[\IdealGPKIDID,\gAtala]$, then
  \RealPKIDIDAtala $\xi$-UC-emulates \IdealGPKIDID, in the presence
  of \gAtala.
\end{enumerate}

We now proceed to specify in more detail the previous steps.

\paragraph{1. Merging global subroutines into \gAtala.} This transformation
is straightforward, and can be done as in \cite[Definition 4.1]{bhz21}. Namely,
let $\gamma_1 \gets \IdealGledger$, $\gamma_2 \gets \IdealGRO$, and $\gamma_3
\gets \IdealGclock$. Then, we define \gAtala to be a functionality that simply
accepts inputs of type $(\uccmd{query},\sid,i,x)$, and makes a query to
$\gamma_i$, with input $x$ on session \sid -- e.g., a query $(\uccmd{query},
\sid,2,(\uccmd{HasQuery},m))$ results in a query $(\uccmd{HashQuery},\sid,m)$ to
\IdealGRO.
%
This allows us to directly apply the results in \cite{bch+20}. \todo{Later, we
  will get back to arguing that the usual candidates for UC-realising the
  individual $\gamma_i$'s meet certain properties that make them suitable for
  UC-realising the ``merged'' functionality \gAtala. Thus, our main results
  apply when considering real instantiations of the global subroutines, rather
  than their idealised counterparts.}

\paragraph{2. \gAtala is subroutine respecting.} 

\commentwho{Jesus}{Not removing what follows for now,  because it will be
  useful. But keep on the proof process stated in the previous enumeration.}

We prove security of \RealPKIDIDAtala by showing that it UC-emulates
\IdealGPKIDID. For this, we leverage concretely the results in \cite{bch+20} and
\cite{bhz21}. In a nutshell, the former extends the notions of UC emulation and
composition so that they are compatible, in the plain UC model, with global
subroutines (such as a global clock, a ledger, or a random oracle).
\cite{bhz21} builds on these results to make them suitable for systems that rely
simultaneously on multiple global functionalities.
%
To make the previous a bit more precise, we replicate here the relevant theorem
from \cite{bhz21} (in \cite{bch+20}, the same statement appears with only one
global subroutine).

\begin{theorem}[UC emulation with multiple global setups \cite{bhz21}]
  \label{thm:uc-bhz21}
  Let $\pi$, $\phi$ and $\gamma_1,\dots,\gamma_n$ be protocols. We say that
  $\pi$ $\xi$-UC-emulates $\phi$ in the presence of global subroutines
  $\gamma_1,\dots,\gamma_n$ if protocols $\pi$ and $\phi$ are formulated with
  respect to a global subroutine $\hat{\gamma}_{\gamma_1,\dots,\gamma_n}$ and
  $\UCM[\pi,\hat{\gamma}_{\gamma_1,\dots,\gamma_n}]$ $\xi$-emulates protocol
  $\UCM[\phi,\hat{\gamma}_{\gamma_1,\dots,\gamma_n}]$.
\end{theorem}

At a high level, to apply the results in \cite{bch+20,bhz21}, we merge the
global subroutines used in \IdealGPKIDID and \RealPKIDIDAtala into a single
``meta'' global subroutine $\gAtala = \hat{\gamma}_{\gamma_1,\dots,\gamma_n}$
required by \thmref{thm:uc-bhz21}.
%
Then, to prove UC emulation, we follow the approach in \cite{bch+20} and
describe a management protocol \UCM

which furthermore meets the conditions to be
subsequently suitable for UC-emulation. In addition, we later argue that this is
usually the case for the known realisations of each respective global
subroutine. (This suggests that our approach is natural, and indeed
UC-realisable in practice.)
%
We then describe how the management protocol \UCM works in conjunction with
our \IdealGPKIDID and the ``meta'' global subroutines in the ideal world (i.e.,
$\UCM[\IdealGPKIDID,\hat{\gamma}_{\gamma_1,\dots,\gamma_n}]$), and
with \RealPKIDIDAtala and the ``meta'' global subroutine in the real world
(i.e., $\UCM[\RealPKIDIDAtala,\hat{\gamma}_{\gamma_1,\dots,\gamma_n}]$).
%
Finally, we show that the latter emulates the former. This concludes the proof
for \thmref{thm:uc-bhz21}.
%
We emphasise that this is merely an application of the results in
\cite{bch+20,bhz21} to our setting. The previously sketched process is detailed
next, directly referencing the relevant theorems of the corresponding works when
appropriate.

\paragraph{The meta-global subroutine \gAtala.} %
\todo{The idea is here, but the wording is clumsy. Re-write.}
We next show that the global subroutines used in \RealPKIDIDAtala are leveraged
in a way that is compatible with \cite[Theorem 4.3]{bhz21}. This is not a full
proof for a concrete application of the theorem, as that would require proving
that concrete protocols UC-emulate each global functionality. However, we
initially leave it ``incomplete'' to show that any combination of instantiations
of our global subroutines can be used to build a secure variant of the Atala
DID protocol (later, we show the concrete instantiations that Atala currently
uses). For concreteness, we refer to this ``partial'' property as mergability
of the global subroutines of Atala into \gAtala.

\begin{lemma}[Mergeability of \gAtala \todo{``Mergeability'' may not be the
    best term}]
  \label{lma:gAtala}

  % Let $\gamma_1 \gets \IdealGPKIDID$, $\gamma_2 \gets \IdealGdledger$,
  % $\gamma_3 \gets \IdealGRO$, $\gamma_4 \gets \IdealGclock$. Then:

  Let $\gamma_1 \gets \IdealGdledger$, $\gamma_2 \gets \IdealGRO$, $\gamma_3
  \gets \IdealGclock$. Then:  
  
  \begin{enumerate}
  \item For $i < 3$, $\gamma_i$ is subroutine respecting except for calls to
    $\gamma_{i+1,\dots,3}$, and $\gamma_3$ is subroutine respecing. All
    $\gamma_i$'s are subroutine exposing.
  \item For $i>1$, $\gamma_i$ is $\gamma_j$-regular, for all $j \in \set{1,
      \dots,i-1}$.
  \end{enumerate}
  
\end{lemma}

\begin{proof}
  We start with the first item, for which we briefly recall the notion of
  subroutine respecting protocols. Intuitively, a protocol $\pi$ is subroutine
  respecting if, for any session \sid of $\pi$, the main parties of \sid are the
  only ones that communicate with the outside world; this also means that
  subparties only accept input and subroutine output from parties in \sid. A
  more precise definition is available in the 2020 version of \cite{canetti00}.

  Now, the protocol $\IdealP_\IdealF$ associated to an ideal functionality
  \IdealF is composed of dummy parties that simply relay information back and
  forth between the environment \Env and \IdealF (and no one else). The dummy
  parties are the main parties of $\IdealP_\IdealF$, whereas \IdealF is a
  sub-party.

  In the case of \IdealGclock ($\gamma_3$) and \IdealGRO ($\gamma_2$), their
  corresponding protocols, $\IdealP_{\IdealGclock}$ and $\IdealP_{\IdealGRO}$
  are trivially subroutine respecting. Namely, for each session \sid of
  $\IdealP_{\IdealGclock}$ (resp. $\IdealP_{\IdealGRO}$):

  \begin{itemize}
  \item \IdealGclock (resp. \IdealGRO) is the only sub-party in the protocol
    session \sid, and it only accepts input from the main (dummy) parties in
    $\IdealP_{\IdealGclock}$ (resp. $\IdealP_{\IdealGRO}$) in \sid.
  \item The main (dummy) parties of session \sid in $\IdealP_{\IdealGclock}$
    (resp. $\IdealP_{\IdealGRO}$) ignore subroutine outputs from parties other
    than \IdealGclock (resp. \IdealGRO)'s on session \sid. Similarly,
    \IdealGclock (resp. \IdealGRO) ignores subroutine outputs.
  \item \IdealGclock (resp. \IdealGRO) in \sid only passes subroutine output to
    the main (dummy) parties in \sid.
  \item Main (dummy) parties in session \sid of $\IdealP_{\IdealGclock}$ (resp.
    $\IdealGRO$), and \IdealGclock (resp. \IdealGRO)  don't pass input to
    parties not in \sid. 
  \end{itemize}

  Next, observe that \IdealGdledger ($\gamma_1$) is also subroutine respecting
  except for calls to \IdealGclock ($\gamma_3$). Concretely, for each session
  of the ideal protocol $\IdealP_{\IdealGdledger}$ of \IdealGdledger:

  \begin{itemize}
  \item Excluding calls to \IdealGclock, \IdealGdledger is the only sub-party in
    the protocol session \sid, and it only accepts input from the main (dummy)
    parties in $\IdealP_{\IdealGdledger}$ in \sid.
  \item The main (dummy) parties of session \sid in $\IdealP_{\IdealGdledger}$
    ignore subroutine outputs from parties other than \IdealGdledger's on
    session \sid. Also, \IdealGdledger ignores subroutine outputs from any
    party, with the exception from parties in \IdealGclock.
  \item \IdealGdledger in \sid only passes subroutine output to the main (dummy)
    parties of $\IdealP_{\IdealGdledger}$, and to the parties in \IdealGclock,
    in \sid.
  \item Main (dummy) parties in session \sid of $\IdealP_{\IdealGdledger}$ and
    \IdealGdledger don't pass input to parties not in \sid, with the exception
    of parties in $\IdealP_{\IdealGclock}$.
  \end{itemize}

  % The same argument as for \IdealGdledger applies for \IdealGPKIDID, since it
  % also leverages \IdealGclock ($\gamma_4$) in its definition.

  In summary, $\gamma_3 = \IdealGclock$ and $\gamma_2 = \IdealGRO$ are
  subroutine respecting (and, obviously, $\gamma_2$ is also subroutine
  respecting except for calls to $\gamma_3$). Also, $\gamma_1 = \IdealGdledger$
  is subroutine respecting except for calls to $\gamma_3$ -- and, since
  $\gamma_1$ does not use $\gamma_2$, it is trivially also subroutine respecting
  except for calls to $\gamma_2$.

  Thus, condition 1 of \lmaref{lma:gAtala} is met, except for the subroutine
  exposing part. However, even though it is not explicitly stated in their
  corresponding definitions, it is possible to transform the \IdealGclock,
  \IdealGRO and \IdealGdledger (by adding a directory ITI and an extra shell
  taking care of the proper redirections) so that they are actually subroutine
  exposing - cf \cite[Definition 2.7]{bch+20}. Now, we move to condition 2.
  Concretely:

  \begin{itemize}
  \item $\gamma_2$ is $\gamma_1$-regular: The main (dummy) parties in
    $\gamma_2$ ($\IdealP_{\IdealGRO}$) do not invoke new ITIs of $\gamma_1$
    ($\IdealP_{\IdealGdledger}$) via messages to the subroutine output tape.
    Also, the main (dummy) parties of $\IdealP_{\IdealGRO}$ do not have an ITI
    with code $\IdealP_{\IdealGdledger}$ as subsidiary.
  \item $\gamma_3$ is $\gamma_2$-regular: The main (dummy) parties in
    $\gamma_3$ ($\IdealP_{\IdealGclock}$) do not invoke new ITIs of $\gamma_2$
    ($\IdealP_{\IdealGRO}$) via messages to the subroutine output tape. Also,
    the main (dummy) parties of $\IdealP_{\IdealGclock}$ do not have an ITI with
    code $\IdealP_{\IdealGRO}$ as subsidiary.
  \item $\gamma_3$ is $\gamma_1$-regular: The main (dummy) parties in
    $\gamma_3$ ($\IdealP_{\IdealGclock}$) do not invoke new ITIs of $\gamma_1$
    ($\IdealP_{\IdealGdledger}$) via messages to the subroutine output tape --
    dummy parties in $\gamma_3$ pass subroutine output to parties in $\gamma_1$,
    but already existing ones. Also, the main (dummy) parties of
    $\IdealP_{\IdealGclock}$ do not have an ITI with code
    $\IdealP_{\IdealGdledger}$ as subsidiary.
  \end{itemize}
  %
  \qed
\end{proof}

\paragraph{The management protocol $\UCM[\IdealGPKIDID,\gAtala]$.}

\paragraph{The management protocol $\UCM[\RealPKIDIDAtala,\gAtala]$.}

\paragraph{$\UCM[\IdealGPKIDID,\gAtala]$ $\xi$-UC emulates
  $\UCM[\RealPKIDIDAtala,\gAtala]$.}

% Before going into the proofs, observe that the \uccmd{Create} (in lines 1-2) and
% \uccmd{Update} (in lines 6-7) operations in \RealPKIDIDAtala include a policy on
% the received key labels and types. Concretely, this policy requires that all
% labels are unique, all types are of a known key type, and that at least one of
% them is of type \MasterKey. In the sequel, we use \PAtala to refer to this
% policy.

% \todo{Do we mention somewhere that {\sid}s have structure $(P,\sid')$? This is
%   used for \Sim to know which party is generating which keys.}

% \begin{theorem}[UC-security of \RealPKIDIDAtala]
%   \label{thm:sec-didatala}
%   \RealPKIDIDAtala UC-realizes $\IdealGPKIDID$ in the $(\IdealGRO,
%   \IdealFSig, \IdealGdledger)$-hybrid model.
% \end{theorem}

% \begin{proof}
%   We show that \RealPKIDIDAtala UC-realizes \IdealGPKIDID, when configured
%   with policy \PAtala. For this, we give a simulator \Sim such that, for
%   any environment \Env, $\Exec_{\RealPKIDIDAtala\adv,\Env} \approx
%   \Exec_{\phiDID,\Sim,\Env}$,
%   where \phiDID is a protocol composed with the same parties as
%   \RealPKIDIDAtala but where each party is simply a dummy party that forwards
%   every message from \Env to the ideal functionality \IdealGPKIDID, and every
%   response from \IdealGPKIDID back to \Env. The simulator \Sim runs internally a
%   copy of the real-world adversary \adv, as well as the ideal functionalities
%   \IdealGRO, \IdealFSig and \IdealGdledger, and any involved party.

%   \begin{description}
%   \item[Simulating DID Create.] %
%     % 
%     % Keys generation
%     If \Sim receives a message $(\uccmd{Create},\sid,\lbrace (\lbl_i,\typ_i)
%     \rbrace_{i\in[n]})$ from \IdealGPKIDID, with $\sid=(P,\sid')$, it simulates
%     the key generation process of $n$ signing key pairs run in the real
%     protocol, by sending $n$ queries $(\uccmd{KeyGen},((P,\lbl_i),\sid))$ to
%     \adv~on behalf of \IdealFSig, and receiving the $n$ corresponding
%     $(\uccmd{VerKey},((P,\lbl_i),\sid),\pk_i)$ responses.
%     %
%     % Hash computation
%     \Sim then concatenates all $(\lbl_i,\typ_i,\pk_i)$ tuples into \st, and
%     simulates a query to \IdealGRO, to set \did as ``$did:prism: h$'' as DID
%     value.
%     %
%     % Tx sim
%     With the DID value, \Sim simulates for \adv~the preparation of transaction
%     \tx. That is, \Sim uses the master key with lowest label, $\lbl \gets
%     \LMKL(\st)$, and simulates a query $(\uccmd{Sign},((P,\lbl),\sid),\tx)$ to
%     \IdealFSig, obtaining from \adv~$(\uccmd{Signed},((P,\lbl),\sid),\tx,\sig)$.
%     %
%     % BB append
%     \Sim also simulates appending the $(\tx,\sig)$ tuple to the bulletin board,
%     by sending $(\uccmd{Submit},(\tx,\sig))$ to \adv~on behalf of \IdealGdledger.
%     %
%     % Output
%     Finally, \Sim sends the $(\uccmd{CreateOk},\sid,\did,\lbrace \pk_i
%     \rbrace_{i\in[n]})$ to \IdealGPKIDID, and stores the tuple $(P,\did,\lbrace
%     (\lbl_i,\typ_i,\pk_i)\rbrace_{i\in[n]})$.
%     %
%     % Additional considerations
%     \todo{The following should probably go to the argumentation part.}
%     Note that \did is generated by an ideal random oracle (thus, uniformly at
%     random), just as in the real protocol \RealPKIDIDAtala. Hence, the
%     probability that \IdealGPKIDID halts because $\did \in \DID$ is negligible,
%     and \IdealGPKIDID outputs $(\uccmd{Created},\sid,\did,\lbrace \val_i=\pk_i
%     \rbrace_{i\in[n]})$ to \IdealGPKIDID.
%   \item[Simulating DID Read.]
%     To simulate read operations, when \Sim receives $(\uccmd{Read},\sid,\did)$
%     from \IdealGPKIDID, it first simulates for \adv~the call to \IdealGdledger, to
%     get the current status $L$ of the bulletin board. Then, \Sim reproduces the
%     processing a normal party would do: from older to newer entry in $L$ related
%     to \did, applies the updates in a sequential order -- ignoring any
%     \uccmd{UpdateDID} operation before a \uccmd{CreateDID}, and only applying
%     the first \uccmd{CreateDID}. If, after applying an update, \PAtala is
%     not met by the resulting set of keys and labels, \Sim skips the update.
%     Otherwise, \Sim simulates for \adv~a verification query to \IdealFSig for
%     the transaction corresponding to the update, and skips the update if the
%     signature fails.
%     %
%     Finally, if after processing all transactions related to \did, the resulting
%     contents differ from those stored by \Sim in its record $(P,\did,\sval)$,
%     \Sim aborts \todo{Do we need this?}. Otherwise, \Sim returns the processed
%     contents.    
%   \item[Simulating DID Update.]
%     % Load DID
%     Upon receiving a request from dummy party $P$, \IdealGPKIDID fetches
%     $(P,\did,\sval)$ from its records, and checks if $(\sval \setminus \sval_d)
%     \cup \sval_a$ meets \PAtala. If either step fails, \IdealGPKIDID
%     aborts. Else, it sends $(\uccmd{Update},\sid,\did,\sval_d,\sval_a)$ to \Sim.
%     \Sim then retrieves $(P,\did,\sval)$ from its records \todo{this is kept at
%       some point, no?)} and simulates for \adv~the calls to \IdealFSig for the
%     keys in the received $\sval_a$. \Sim gets the key with the lowest label from
%     \sval, with label $\lbl$, bundles the transaction \tx, and simulates a call
%     to \IdealFSig to get a signature over \tx. Finally, \Sim simulates the call
%     to \IdealGdledger, and returns $(\uccmd{Updated},\sid,(\did,\lbrace \val_i
%     \rbrace_{i\in[n_a]}))$ to \IdealGPKIDID, where the $\val_i$'s are the values
%     output by \adv~when creating the new keys via simulated calls to \IdealFSig.
%   \item[Simulating DID Deactivate.] Directly follows from DID Update.      
%   \end{description}
%   \todo{This to take into account when arguing indistinguishability}:
%   \begin{itemize}
%   \item The records of \Sim are always consistent with \IdealGdledger.
%   \end{itemize}

%   % General comments
%   Now, observe that, in all ideal operations, the policy \PAtala is checked
%   on the resulting data structure. If the policy is not satisfied, the
%   functionality aborts. This is also the case for the real world.

%   % Create comments
%   Regarding create operations, note that, both in the simulation and in the real
%   world, the resulting \did value is produced in a consistent way -- via a call
%   to \IdealGRO, using the contents of the DID document to create.
%   % Key generation and signature comments
%   Similarly, the (verification) keys used and signatures are defined by \adv~
%   both the real and ideal world -- in the latter, as part of \Sim's simulation
%   of \IdealFSig.
  
% \end{proof}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "prism-protocol"
%%% End:
