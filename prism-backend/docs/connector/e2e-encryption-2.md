### Problems that protocol need to address

- Participants need to exchange an encryption key in a way that connecter can not intercept this process, in case the connector is already compromised at the stage of key exchange.
    - An issuer will present an AES key in the form of QR code, the same way it happens with connection token, the holder will scan the key and obtain it in that way.
- The key used for encrypting and decrypting messages should be derivable the same way other keys (Master, issuer, communication, authentication) are derived from the mnemonic seed
    - We can derive EC extended keys and use the private one as AES key, since EC private key is a big integer 256 bits long, and AES key does not have any requirements other then being 256 bits long that should have enough entropy for security reasons, EC private key can be used for AES encryption. AES also needs IV, which also needs to be deterministically derivable, we can use public key of the derived extended key, which is 256 bits long, IV needs to be 128 bits long so it is possible to get 128 bits out of public key. this key will not be "public" in a sense it will not be exposed to the outside world.
- In case the holder is connected to many issuers, he should be able to associate every key to a particular issuer to know which one to use for message encryption.
    - the holder already stores a list of contacts in the wallet, those contacts are the connected institutions, the holder can store keys in association with this contacts.
- An issue will likely be connected to many holders, an issuer should know which key to derive in order to decrypt a particular received message
    - We can have a special type of message called "encryptedMessage" that has encryptedData, and derivation path, When issuer generates the key, alongside with it, he will also share a derivation path with a holder. holder, when sending an encryptedMessage, alongside with the message content should also send a derivation path, so that an issuer know which key to derive in order to decrypt this message. The holder will need to store the derivation path alongside with the key, but it is not a secret information. loosing a derivation path for a holder would mean that he is unable to communicate with an issuer anymore.
- Since an issuer has to derive different key for every holder it is connected to, we need some mechanism for an issuer to generate new key every time a new connection is established, this information should also be derivable from the mnemonic seed, because in case the issuer needs to restore the wallet data, similar to dids and other types of keys (master, issuing, etc...) he should be able to know which indexes has been already used to derive the keys, in order to share same keys to new holders upon new connection
    - One way of doing it would be to store some kind of a counter in the did, similar to other keys, for example when restoring an account from the seed, we generate a DID based on the mnemonic seed, we resolve it and inside the did there are all the keys, master-0, master-1...etc, so since we have a convention to derive key indexes sequentially, we know that SK for master-1, in it is the n'th did, can be derived from index m/0`/0`/n-1.  so essentially we use the **amount** of keys the only to know the derivation path. we can the same way store the amount of e2e encryption keys already issued by the holder of this did (in this case, an issuer) such that every knew key will be derived by counter+1 index and then updateDID operation will increase the counter.
- An issuer should know that message he is receiving from the holder is actually sent from the holder
    - We assume that holder has not lost their key, if the message is encrypted by the key an issuer has given to a holder, then it is sent from that holder