# Key derivation and unpublished DIDs

This document summarizes 3 related conversations around the topic of key types, unpublished DIDs and key 
derivation/recovery.

## Unpublished DIDs and recovery process

In our first [key derivation document](./key-derivation.md), we proposed a procedure to deterministically create and
recover DIDs. Later, in we introduced [unpublished DIDs](./unpublished-dids.md) to our system, which consist of DIDs
that can be used without the need of publishing them on-chain.

This new type of DIDs created a conflict with the derivation and recovery algorithm. Initially, the algorithm intended
to: 
- derive a DID
- attempt to resolve it
  - if found, derive all the keys present in the DID document, and repeat the process with the next DID
  - if not found, stop the recovery process

This means that unpublished DIDs cannot be recovered with that process because there is no on-chain history of their 
existence. Furthermore, the development of multiple products is also creating a segregated space for where these DIDs
are used. We do not have a proposal to recover unpublished DIDs automatically.

### Proposal - generate a recovery file standard structure

We propose for the above problem to define an standard way to represent the list of derived DIDs (or their paths)
that are generated by the user. The standardized structure will allow to import the file and use it during the 
recovery process. The file will be complementary to the seed phrase and could be encrypted by a key derived from 
the same seed.

## Key types

A potential problem with our current use of unpublished DIDs is that they have only one key, which is a master key. If 
we want to use unpublished DIDs for multiple uses, it could be more secure to have more keys for specific purposes. 
Having separate keys for communication, authentication, and/or other actions could allow to keep the master key in cold 
storage while other keys are used with higher frequency.  

The [DID spec](https://www.w3.org/TR/did-core/#verification-relationships) mentions some optional key types commonly 
accepted by implementers:

- Authentication
    > The authentication verification relationship is used to specify how the DID subject is expected to be authenticated, 
    > for purposes such as logging into a website or engaging in any sort of challenge-response protocol.
- Assertion
    > The assertionMethod verification relationship is used to specify how the DID subject is expected to express claims,
    > such as for the purposes of issuing a Verifiable Credential.
- Key Agreement
    > The keyAgreement verification relationship is used to specify how an entity can generate encryption material in 
    > order to transmit confidential information intended for the DID subject, such as for the purposes of establishing
    > a secure communication channel with the recipient.
- Capability Invocation
    > The capabilityInvocation verification relationship is used to specify a verification method that might be used by
    > the DID subject to invoke a cryptographic capability, such as the authorization to update the DID Document.
- Capability Delegation
    > The capabilityDelegation verification relationship is used to specify a mechanism that might be used by the DID 
    > subject to delegate a cryptographic capability to another party, such as delegating the authority to access a
    > specific HTTP API to a subordinate.
  
We can also see an example DID method that resembles our unpublished DIDs, name [DID key](https://w3c-ccg.github.io/did-method-key/)
These DIDs are not updatable and also have a single key for all purposes.

Currently, we define the following keys:
- MASTER_KEY: Used to update the associated DID doument
- ISSUING_KEY: Used for credentials issuance and revocation.
- COMMUNICATION_KEY: Used for encrypting messages sent to the DID subject
- AUTHENTICATION_KEY: This key-type is used to authenticate requests or logging into services.

A proposal under discussion is whether we want to add more keys to the initial state of a DID document (i.e. to our 
unpublished DIDs). This would affect our deterministic DID derivation algorithm. 

### Proposal

We want to change the `COMMUNICATION_KEY` type to `KEY_AGREEMENT` in order to align with current specs.
We also want to incorporate the types `ASSERTION_KEY` and `REVOCATION_KEY` (see next section).

With respect to the initial state of our DIDs, we would like them to contain one master key, one 
authentication key, one assertion key, and one key agreement key. However, we should consider if
it is better to have a different key for each type of key than to share a single key in multiple 
roles. For example, we could have a master key, and then we could have a single separate key for 
the other roles.

We will not add an issuing key nor revocation key to the initial state of our DIDs, the use of 
those keys requires operations to be posted on-chain. Therefore, the user will be able to post
a DID update with the first issuance/revocation operation.

## Revocation keys

We have also noticed the improvement of adding a new key type to our protocol, namely, revocation keys. The idea is to
split the function of `issuing` keys into two parts. The existing issuing keys will still be used to sign 
`IssueBatchOperation`s. However, in order to revoke batches or credentials, the `RevokeCredentialsOperation`s will be
now signed by this new `revocation` keys.

The advantage is that we could have a more granular key management. For example, we could have a DID document where one
entity controls a key and has the responsibility of issuing credentials, and let separate entities the right to audit 
and revoke credentials without also granting them the power to issue batches.

### Proposal - incorporate the above key type

We see the value in splitting the role of issuing keys. Therefore, we propose to update the protocol specification, 
key derivation documentation, and incorporate this new key type.
