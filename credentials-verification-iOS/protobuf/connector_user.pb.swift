// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: protobuf/connector_user.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Credential type; FIXME: is it a part of protocol?
enum Connector_CredentialType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// random stuff
  case unknown // = 0

  /// school, university, library
  case education // = 1

  /// national id, goverment id, driver license
  case institutional // = 2

  /// banks
  case financial // = 3

  /// jobs
  case business // = 4

  /// permit to play music in parks (?)
  case entertainment // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .education
    case 2: self = .institutional
    case 3: self = .financial
    case 4: self = .business
    case 5: self = .entertainment
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .education: return 1
    case .institutional: return 2
    case .financial: return 3
    case .business: return 4
    case .entertainment: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Connector_CredentialType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Connector_CredentialType] = [
    .unknown,
    .education,
    .institutional,
    .financial,
    .business,
    .entertainment,
  ]
}

#endif  // swift(>=4.2)

/// Enumeration representing billing plan of Issuer. Possible values are hardcoded as new billing options would require implementation changes anyway.
enum Connector_BillingPlan: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// participant not able to generate connection tokens
  case noPlan // = 0

  /// connections are created for free
  case freePlan // = 1

  /// side generating the token pays for the connection
  case senderPays // = 2

  /// side receiving the token and using it to instantiate connection pays for it
  case receiverPays // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .noPlan
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noPlan
    case 1: self = .freePlan
    case 2: self = .senderPays
    case 3: self = .receiverPays
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .noPlan: return 0
    case .freePlan: return 1
    case .senderPays: return 2
    case .receiverPays: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Connector_BillingPlan: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Connector_BillingPlan] = [
    .noPlan,
    .freePlan,
    .senderPays,
    .receiverPays,
  ]
}

#endif  // swift(>=4.2)

/// Credential information; FIXME: is it a part of protocol?
struct Connector_Credential {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var issuerInfo: Connector_IssuerInfo {
    get {return _storage._issuerInfo ?? Connector_IssuerInfo()}
    set {_uniqueStorage()._issuerInfo = newValue}
  }
  /// Returns true if `issuerInfo` has been explicitly set.
  var hasIssuerInfo: Bool {return _storage._issuerInfo != nil}
  /// Clears the value of `issuerInfo`. Subsequent reads from it will return its default value.
  mutating func clearIssuerInfo() {_uniqueStorage()._issuerInfo = nil}

  var subject: String {
    get {return _storage._subject}
    set {_uniqueStorage()._subject = newValue}
  }

  var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  var type: Connector_CredentialType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var credentialData: Data {
    get {return _storage._credentialData}
    set {_uniqueStorage()._credentialData = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Information on an Issuer
struct Connector_IssuerInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var did: String = String()

  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Information on a Holder
struct Connector_HolderInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var did: String = String()

  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Type representing generic participant in the system, alternative of IssuerInfo, HolderInfo, or VerifierInfo.
struct Connector_ParticipantInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var participant: OneOf_Participant? {
    get {return _storage._participant}
    set {_uniqueStorage()._participant = newValue}
  }

  var issuer: Connector_IssuerInfo {
    get {
      if case .issuer(let v)? = _storage._participant {return v}
      return Connector_IssuerInfo()
    }
    set {_uniqueStorage()._participant = .issuer(newValue)}
  }

  var holder: Connector_HolderInfo {
    get {
      if case .holder(let v)? = _storage._participant {return v}
      return Connector_HolderInfo()
    }
    set {_uniqueStorage()._participant = .holder(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Participant: Equatable {
    case issuer(Connector_IssuerInfo)
    case holder(Connector_HolderInfo)

  #if !swift(>=4.1)
    static func ==(lhs: Connector_ParticipantInfo.OneOf_Participant, rhs: Connector_ParticipantInfo.OneOf_Participant) -> Bool {
      switch (lhs, rhs) {
      case (.issuer(let l), .issuer(let r)): return l == r
      case (.holder(let l), .holder(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Information on the connection; both sides see the same connectionId and creation time, but each sees different participantInfo
struct Connector_ConnectionInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var connectionID: String {
    get {return _storage._connectionID}
    set {_uniqueStorage()._connectionID = newValue}
  }

  /// moment of instantiation as milliseconds since the Unix Epoch
  var created: Int64 {
    get {return _storage._created}
    set {_uniqueStorage()._created = newValue}
  }

  /// information about the participant at the other end
  var participantInfo: Connector_ParticipantInfo {
    get {return _storage._participantInfo ?? Connector_ParticipantInfo()}
    set {_uniqueStorage()._participantInfo = newValue}
  }
  /// Returns true if `participantInfo` has been explicitly set.
  var hasParticipantInfo: Bool {return _storage._participantInfo != nil}
  /// Clears the value of `participantInfo`. Subsequent reads from it will return its default value.
  mutating func clearParticipantInfo() {_uniqueStorage()._participantInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Request connections instantiated by us / with us possibly after a known connection
struct Connector_GetConnectionsPaginatedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// returned credentials will have been created after the last seen connection (optional field)
  var lastSeenConnectionID: String = String()

  /// maximum number of credentials to return; must be > 0
  var limit: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Result with connections instantiated
struct Connector_GetConnectionsPaginatedResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// connections sorted in ascending order by instantiation time
  var connections: [Connector_ConnectionInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request to obtain information of connection token
struct Connector_GetConnectionTokenInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// token value to get information for
  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Result with information on connection token
struct Connector_GetConnectionTokenInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// participant who generated the code
  var creator: Connector_ParticipantInfo {
    get {return _storage._creator ?? Connector_ParticipantInfo()}
    set {_uniqueStorage()._creator = newValue}
  }
  /// Returns true if `creator` has been explicitly set.
  var hasCreator: Bool {return _storage._creator != nil}
  /// Clears the value of `creator`. Subsequent reads from it will return its default value.
  mutating func clearCreator() {_uniqueStorage()._creator = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Request to instantiate a connection using token
struct Connector_AddConnectionFromTokenRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// token to instantiate connection
  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Confirmation of connection instantiation
struct Connector_AddConnectionFromTokenResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// instantiated connection info
  var connection: Connector_ConnectionInfo {
    get {return _storage._connection ?? Connector_ConnectionInfo()}
    set {_uniqueStorage()._connection = newValue}
  }
  /// Returns true if `connection` has been explicitly set.
  var hasConnection: Bool {return _storage._connection != nil}
  /// Clears the value of `connection`. Subsequent reads from it will return its default value.
  mutating func clearConnection() {_uniqueStorage()._connection = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Request to delete a connection
struct Connector_DeleteConnectionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id of connection to delete
  var connectionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Confirmation of connection deletion
struct Connector_DeleteConnectionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request to generate a connection token
struct Connector_GenerateConnectionTokenRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Result with generated token
struct Connector_GenerateConnectionTokenResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// generated token
  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Message received via a connection
struct Connector_ReceivedMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  /// time when Connector received the message as milliseconds since the Unix Epoch
  var received: Int64 = 0

  /// connection where the message has been received
  var connectionID: String = String()

  /// raw message
  var message: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request to return messages for us after the given known message (if any)
struct Connector_GetMessagesPaginatedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// returned credentials will have been received after the given message (if any)
  var lastSeenMessageID: String = String()

  /// maximum number of credentials to return, must be > 0
  var limit: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response with messages
struct Connector_GetMessagesPaginatedResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// messages sorted in ascending order by receiving time
  var messages: [Connector_ReceivedMessage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request to send message
struct Connector_SendMessageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id of the connection
  var connectionID: String = String()

  /// raw message
  var message: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Confirmation of message sending
struct Connector_SendMessageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request to register DID
struct Connector_RegisterDIDRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var did: String = String()

  var diddocument: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Confirmation of DID registration
struct Connector_RegisterDIDResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request to change the billing plan
struct Connector_ChangeBillingPlanRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// new billing plan
  var billingPlan: Connector_BillingPlan = .noPlan

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Confirmation of billing plan change
struct Connector_ChangeBillingPlanResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "connector"

extension Connector_CredentialType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "EDUCATION"),
    2: .same(proto: "INSTITUTIONAL"),
    3: .same(proto: "FINANCIAL"),
    4: .same(proto: "BUSINESS"),
    5: .same(proto: "ENTERTAINMENT"),
  ]
}

extension Connector_BillingPlan: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_PLAN"),
    1: .same(proto: "FREE_PLAN"),
    2: .same(proto: "SENDER_PAYS"),
    3: .same(proto: "RECEIVER_PAYS"),
  ]
}

extension Connector_Credential: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Credential"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "issuerInfo"),
    2: .same(proto: "subject"),
    3: .same(proto: "title"),
    4: .same(proto: "type"),
    5: .same(proto: "credentialData"),
  ]

  fileprivate class _StorageClass {
    var _issuerInfo: Connector_IssuerInfo? = nil
    var _subject: String = String()
    var _title: String = String()
    var _type: Connector_CredentialType = .unknown
    var _credentialData: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _issuerInfo = source._issuerInfo
      _subject = source._subject
      _title = source._title
      _type = source._type
      _credentialData = source._credentialData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._issuerInfo)
        case 2: try decoder.decodeSingularStringField(value: &_storage._subject)
        case 3: try decoder.decodeSingularStringField(value: &_storage._title)
        case 4: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 5: try decoder.decodeSingularBytesField(value: &_storage._credentialData)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._issuerInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._subject.isEmpty {
        try visitor.visitSingularStringField(value: _storage._subject, fieldNumber: 2)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 3)
      }
      if _storage._type != .unknown {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 4)
      }
      if !_storage._credentialData.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._credentialData, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connector_Credential, rhs: Connector_Credential) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._issuerInfo != rhs_storage._issuerInfo {return false}
        if _storage._subject != rhs_storage._subject {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._credentialData != rhs_storage._credentialData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connector_IssuerInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IssuerInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "DID"),
    2: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.did)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.did.isEmpty {
      try visitor.visitSingularStringField(value: self.did, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connector_IssuerInfo, rhs: Connector_IssuerInfo) -> Bool {
    if lhs.did != rhs.did {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connector_HolderInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HolderInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "DID"),
    2: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.did)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.did.isEmpty {
      try visitor.visitSingularStringField(value: self.did, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connector_HolderInfo, rhs: Connector_HolderInfo) -> Bool {
    if lhs.did != rhs.did {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connector_ParticipantInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ParticipantInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "issuer"),
    2: .same(proto: "holder"),
  ]

  fileprivate class _StorageClass {
    var _participant: Connector_ParticipantInfo.OneOf_Participant?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _participant = source._participant
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Connector_IssuerInfo?
          if let current = _storage._participant {
            try decoder.handleConflictingOneOf()
            if case .issuer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._participant = .issuer(v)}
        case 2:
          var v: Connector_HolderInfo?
          if let current = _storage._participant {
            try decoder.handleConflictingOneOf()
            if case .holder(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._participant = .holder(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._participant {
      case .issuer(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .holder(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connector_ParticipantInfo, rhs: Connector_ParticipantInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._participant != rhs_storage._participant {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connector_ConnectionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectionInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "connectionId"),
    2: .same(proto: "created"),
    3: .same(proto: "participantInfo"),
  ]

  fileprivate class _StorageClass {
    var _connectionID: String = String()
    var _created: Int64 = 0
    var _participantInfo: Connector_ParticipantInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _connectionID = source._connectionID
      _created = source._created
      _participantInfo = source._participantInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._connectionID)
        case 2: try decoder.decodeSingularInt64Field(value: &_storage._created)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._participantInfo)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._connectionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._connectionID, fieldNumber: 1)
      }
      if _storage._created != 0 {
        try visitor.visitSingularInt64Field(value: _storage._created, fieldNumber: 2)
      }
      if let v = _storage._participantInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connector_ConnectionInfo, rhs: Connector_ConnectionInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._connectionID != rhs_storage._connectionID {return false}
        if _storage._created != rhs_storage._created {return false}
        if _storage._participantInfo != rhs_storage._participantInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connector_GetConnectionsPaginatedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetConnectionsPaginatedRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lastSeenConnectionId"),
    2: .same(proto: "limit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.lastSeenConnectionID)
      case 2: try decoder.decodeSingularInt32Field(value: &self.limit)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lastSeenConnectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.lastSeenConnectionID, fieldNumber: 1)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connector_GetConnectionsPaginatedRequest, rhs: Connector_GetConnectionsPaginatedRequest) -> Bool {
    if lhs.lastSeenConnectionID != rhs.lastSeenConnectionID {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connector_GetConnectionsPaginatedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetConnectionsPaginatedResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "connections"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.connections)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.connections.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.connections, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connector_GetConnectionsPaginatedResponse, rhs: Connector_GetConnectionsPaginatedResponse) -> Bool {
    if lhs.connections != rhs.connections {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connector_GetConnectionTokenInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetConnectionTokenInfoRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.token)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connector_GetConnectionTokenInfoRequest, rhs: Connector_GetConnectionTokenInfoRequest) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connector_GetConnectionTokenInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetConnectionTokenInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
  ]

  fileprivate class _StorageClass {
    var _creator: Connector_ParticipantInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _creator = source._creator
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._creator)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._creator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connector_GetConnectionTokenInfoResponse, rhs: Connector_GetConnectionTokenInfoResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._creator != rhs_storage._creator {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connector_AddConnectionFromTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddConnectionFromTokenRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.token)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connector_AddConnectionFromTokenRequest, rhs: Connector_AddConnectionFromTokenRequest) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connector_AddConnectionFromTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddConnectionFromTokenResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "connection"),
  ]

  fileprivate class _StorageClass {
    var _connection: Connector_ConnectionInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _connection = source._connection
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._connection)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._connection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connector_AddConnectionFromTokenResponse, rhs: Connector_AddConnectionFromTokenResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._connection != rhs_storage._connection {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connector_DeleteConnectionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteConnectionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "connectionId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.connectionID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.connectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.connectionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connector_DeleteConnectionRequest, rhs: Connector_DeleteConnectionRequest) -> Bool {
    if lhs.connectionID != rhs.connectionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connector_DeleteConnectionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteConnectionResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connector_DeleteConnectionResponse, rhs: Connector_DeleteConnectionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connector_GenerateConnectionTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenerateConnectionTokenRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connector_GenerateConnectionTokenRequest, rhs: Connector_GenerateConnectionTokenRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connector_GenerateConnectionTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenerateConnectionTokenResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.token)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connector_GenerateConnectionTokenResponse, rhs: Connector_GenerateConnectionTokenResponse) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connector_ReceivedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReceivedMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "received"),
    3: .same(proto: "connectionId"),
    4: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularInt64Field(value: &self.received)
      case 3: try decoder.decodeSingularStringField(value: &self.connectionID)
      case 4: try decoder.decodeSingularBytesField(value: &self.message)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.received != 0 {
      try visitor.visitSingularInt64Field(value: self.received, fieldNumber: 2)
    }
    if !self.connectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.connectionID, fieldNumber: 3)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularBytesField(value: self.message, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connector_ReceivedMessage, rhs: Connector_ReceivedMessage) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.received != rhs.received {return false}
    if lhs.connectionID != rhs.connectionID {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connector_GetMessagesPaginatedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMessagesPaginatedRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lastSeenMessageId"),
    2: .same(proto: "limit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.lastSeenMessageID)
      case 2: try decoder.decodeSingularInt32Field(value: &self.limit)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lastSeenMessageID.isEmpty {
      try visitor.visitSingularStringField(value: self.lastSeenMessageID, fieldNumber: 1)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connector_GetMessagesPaginatedRequest, rhs: Connector_GetMessagesPaginatedRequest) -> Bool {
    if lhs.lastSeenMessageID != rhs.lastSeenMessageID {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connector_GetMessagesPaginatedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMessagesPaginatedResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.messages)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connector_GetMessagesPaginatedResponse, rhs: Connector_GetMessagesPaginatedResponse) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connector_SendMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendMessageRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "connectionId"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.connectionID)
      case 2: try decoder.decodeSingularBytesField(value: &self.message)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.connectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.connectionID, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularBytesField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connector_SendMessageRequest, rhs: Connector_SendMessageRequest) -> Bool {
    if lhs.connectionID != rhs.connectionID {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connector_SendMessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendMessageResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connector_SendMessageResponse, rhs: Connector_SendMessageResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connector_RegisterDIDRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterDIDRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "DID"),
    2: .same(proto: "DIDDocument"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.did)
      case 2: try decoder.decodeSingularStringField(value: &self.diddocument)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.did.isEmpty {
      try visitor.visitSingularStringField(value: self.did, fieldNumber: 1)
    }
    if !self.diddocument.isEmpty {
      try visitor.visitSingularStringField(value: self.diddocument, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connector_RegisterDIDRequest, rhs: Connector_RegisterDIDRequest) -> Bool {
    if lhs.did != rhs.did {return false}
    if lhs.diddocument != rhs.diddocument {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connector_RegisterDIDResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterDIDResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connector_RegisterDIDResponse, rhs: Connector_RegisterDIDResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connector_ChangeBillingPlanRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChangeBillingPlanRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "billingPlan"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.billingPlan)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.billingPlan != .noPlan {
      try visitor.visitSingularEnumField(value: self.billingPlan, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connector_ChangeBillingPlanRequest, rhs: Connector_ChangeBillingPlanRequest) -> Bool {
    if lhs.billingPlan != rhs.billingPlan {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Connector_ChangeBillingPlanResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChangeBillingPlanResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Connector_ChangeBillingPlanResponse, rhs: Connector_ChangeBillingPlanResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
