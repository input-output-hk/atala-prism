// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: protobuf/connector_models.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Enumeration representing billing plan of Issuer. Possible values are hardcoded as new billing options would require implementation changes anyway.
enum Io_Iohk_Prism_Protos_BillingPlan: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// participant not able to generate connection tokens
  case noPlan // = 0

  /// connections are created for free
  case freePlan // = 1

  /// side generating the token pays for the connection
  case senderPays // = 2

  /// side receiving the token and using it to instantiate connection pays for it
  case receiverPays // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .noPlan
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noPlan
    case 1: self = .freePlan
    case 2: self = .senderPays
    case 3: self = .receiverPays
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .noPlan: return 0
    case .freePlan: return 1
    case .senderPays: return 2
    case .receiverPays: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Io_Iohk_Prism_Protos_BillingPlan: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Io_Iohk_Prism_Protos_BillingPlan] = [
    .noPlan,
    .freePlan,
    .senderPays,
    .receiverPays,
  ]
}

#endif  // swift(>=4.2)

/// just an EC public key represented with big integers as strings
/// TODO: merge with the node PublicKey
struct Io_Iohk_Prism_Protos_ConnectorPublicKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: String = String()

  var y: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Public key ECPoint uncompressed encoded
struct Io_Iohk_Prism_Protos_EncodedPublicKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publicKey: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Information on an Issuer
struct Io_Iohk_Prism_Protos_IssuerInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var did: String = String()

  var name: String = String()

  var logo: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Information on a Verifier
struct Io_Iohk_Prism_Protos_VerifierInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var did: String = String()

  var name: String = String()

  var logo: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Information on a Holder
struct Io_Iohk_Prism_Protos_HolderInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var did: String = String()

  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Type representing generic participant in the system, alternative of IssuerInfo, HolderInfo, or VerifierInfo.
struct Io_Iohk_Prism_Protos_ParticipantInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var participant: OneOf_Participant? {
    get {return _storage._participant}
    set {_uniqueStorage()._participant = newValue}
  }

  var issuer: Io_Iohk_Prism_Protos_IssuerInfo {
    get {
      if case .issuer(let v)? = _storage._participant {return v}
      return Io_Iohk_Prism_Protos_IssuerInfo()
    }
    set {_uniqueStorage()._participant = .issuer(newValue)}
  }

  var holder: Io_Iohk_Prism_Protos_HolderInfo {
    get {
      if case .holder(let v)? = _storage._participant {return v}
      return Io_Iohk_Prism_Protos_HolderInfo()
    }
    set {_uniqueStorage()._participant = .holder(newValue)}
  }

  var verifier: Io_Iohk_Prism_Protos_VerifierInfo {
    get {
      if case .verifier(let v)? = _storage._participant {return v}
      return Io_Iohk_Prism_Protos_VerifierInfo()
    }
    set {_uniqueStorage()._participant = .verifier(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Participant: Equatable {
    case issuer(Io_Iohk_Prism_Protos_IssuerInfo)
    case holder(Io_Iohk_Prism_Protos_HolderInfo)
    case verifier(Io_Iohk_Prism_Protos_VerifierInfo)

  #if !swift(>=4.1)
    static func ==(lhs: Io_Iohk_Prism_Protos_ParticipantInfo.OneOf_Participant, rhs: Io_Iohk_Prism_Protos_ParticipantInfo.OneOf_Participant) -> Bool {
      switch (lhs, rhs) {
      case (.issuer(let l), .issuer(let r)): return l == r
      case (.holder(let l), .holder(let r)): return l == r
      case (.verifier(let l), .verifier(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A connection between two parties authorizing
/// the use of the connector as a messaging channel.
struct Io_Iohk_Prism_Protos_Connection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the connection token used to initialize the connection with the wallet
  var connectionToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Information on the connection; both sides see the same connectionId and creation time, but each sees different participantInfo
struct Io_Iohk_Prism_Protos_ConnectionInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var connectionID: String {
    get {return _storage._connectionID}
    set {_uniqueStorage()._connectionID = newValue}
  }

  /// moment of instantiation as milliseconds since the Unix Epoch
  var created: Int64 {
    get {return _storage._created}
    set {_uniqueStorage()._created = newValue}
  }

  /// information about the participant at the other end
  var participantInfo: Io_Iohk_Prism_Protos_ParticipantInfo {
    get {return _storage._participantInfo ?? Io_Iohk_Prism_Protos_ParticipantInfo()}
    set {_uniqueStorage()._participantInfo = newValue}
  }
  /// Returns true if `participantInfo` has been explicitly set.
  var hasParticipantInfo: Bool {return _storage._participantInfo != nil}
  /// Clears the value of `participantInfo`. Subsequent reads from it will return its default value.
  mutating func clearParticipantInfo() {_uniqueStorage()._participantInfo = nil}

  /// the token used to generate the connection
  var token: String {
    get {return _storage._token}
    set {_uniqueStorage()._token = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Message received via a connection
struct Io_Iohk_Prism_Protos_ReceivedMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  /// time when Connector received the message as milliseconds since the Unix Epoch
  var received: Int64 = 0

  /// connection where the message has been received
  var connectionID: String = String()

  /// raw message
  var message: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Prism_Protos_Payment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var amount: String = String()

  var createdOn: Int64 = 0

  var status: String = String()

  var failureReason: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "io.iohk.prism.protos"

extension Io_Iohk_Prism_Protos_BillingPlan: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_PLAN"),
    1: .same(proto: "FREE_PLAN"),
    2: .same(proto: "SENDER_PAYS"),
    3: .same(proto: "RECEIVER_PAYS"),
  ]
}

extension Io_Iohk_Prism_Protos_ConnectorPublicKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectorPublicKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.x)
      case 2: try decoder.decodeSingularStringField(value: &self.y)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.x.isEmpty {
      try visitor.visitSingularStringField(value: self.x, fieldNumber: 1)
    }
    if !self.y.isEmpty {
      try visitor.visitSingularStringField(value: self.y, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Prism_Protos_ConnectorPublicKey, rhs: Io_Iohk_Prism_Protos_ConnectorPublicKey) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Prism_Protos_EncodedPublicKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EncodedPublicKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.publicKey)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Prism_Protos_EncodedPublicKey, rhs: Io_Iohk_Prism_Protos_EncodedPublicKey) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Prism_Protos_IssuerInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IssuerInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "DID"),
    2: .same(proto: "name"),
    3: .same(proto: "logo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.did)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularBytesField(value: &self.logo)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.did.isEmpty {
      try visitor.visitSingularStringField(value: self.did, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.logo.isEmpty {
      try visitor.visitSingularBytesField(value: self.logo, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Prism_Protos_IssuerInfo, rhs: Io_Iohk_Prism_Protos_IssuerInfo) -> Bool {
    if lhs.did != rhs.did {return false}
    if lhs.name != rhs.name {return false}
    if lhs.logo != rhs.logo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Prism_Protos_VerifierInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerifierInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "DID"),
    2: .same(proto: "name"),
    3: .same(proto: "logo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.did)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularBytesField(value: &self.logo)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.did.isEmpty {
      try visitor.visitSingularStringField(value: self.did, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.logo.isEmpty {
      try visitor.visitSingularBytesField(value: self.logo, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Prism_Protos_VerifierInfo, rhs: Io_Iohk_Prism_Protos_VerifierInfo) -> Bool {
    if lhs.did != rhs.did {return false}
    if lhs.name != rhs.name {return false}
    if lhs.logo != rhs.logo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Prism_Protos_HolderInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HolderInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "DID"),
    2: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.did)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.did.isEmpty {
      try visitor.visitSingularStringField(value: self.did, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Prism_Protos_HolderInfo, rhs: Io_Iohk_Prism_Protos_HolderInfo) -> Bool {
    if lhs.did != rhs.did {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Prism_Protos_ParticipantInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ParticipantInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "issuer"),
    2: .same(proto: "holder"),
    3: .same(proto: "verifier"),
  ]

  fileprivate class _StorageClass {
    var _participant: Io_Iohk_Prism_Protos_ParticipantInfo.OneOf_Participant?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _participant = source._participant
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Io_Iohk_Prism_Protos_IssuerInfo?
          if let current = _storage._participant {
            try decoder.handleConflictingOneOf()
            if case .issuer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._participant = .issuer(v)}
        case 2:
          var v: Io_Iohk_Prism_Protos_HolderInfo?
          if let current = _storage._participant {
            try decoder.handleConflictingOneOf()
            if case .holder(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._participant = .holder(v)}
        case 3:
          var v: Io_Iohk_Prism_Protos_VerifierInfo?
          if let current = _storage._participant {
            try decoder.handleConflictingOneOf()
            if case .verifier(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._participant = .verifier(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._participant {
      case .issuer(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .holder(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .verifier(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Prism_Protos_ParticipantInfo, rhs: Io_Iohk_Prism_Protos_ParticipantInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._participant != rhs_storage._participant {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Prism_Protos_Connection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Connection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "connectionToken"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.connectionToken)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.connectionToken.isEmpty {
      try visitor.visitSingularStringField(value: self.connectionToken, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Prism_Protos_Connection, rhs: Io_Iohk_Prism_Protos_Connection) -> Bool {
    if lhs.connectionToken != rhs.connectionToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Prism_Protos_ConnectionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectionInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "connectionId"),
    2: .same(proto: "created"),
    3: .same(proto: "participantInfo"),
    4: .same(proto: "token"),
  ]

  fileprivate class _StorageClass {
    var _connectionID: String = String()
    var _created: Int64 = 0
    var _participantInfo: Io_Iohk_Prism_Protos_ParticipantInfo? = nil
    var _token: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _connectionID = source._connectionID
      _created = source._created
      _participantInfo = source._participantInfo
      _token = source._token
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._connectionID)
        case 2: try decoder.decodeSingularInt64Field(value: &_storage._created)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._participantInfo)
        case 4: try decoder.decodeSingularStringField(value: &_storage._token)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._connectionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._connectionID, fieldNumber: 1)
      }
      if _storage._created != 0 {
        try visitor.visitSingularInt64Field(value: _storage._created, fieldNumber: 2)
      }
      if let v = _storage._participantInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._token.isEmpty {
        try visitor.visitSingularStringField(value: _storage._token, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Prism_Protos_ConnectionInfo, rhs: Io_Iohk_Prism_Protos_ConnectionInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._connectionID != rhs_storage._connectionID {return false}
        if _storage._created != rhs_storage._created {return false}
        if _storage._participantInfo != rhs_storage._participantInfo {return false}
        if _storage._token != rhs_storage._token {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Prism_Protos_ReceivedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReceivedMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "received"),
    3: .same(proto: "connectionId"),
    4: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularInt64Field(value: &self.received)
      case 3: try decoder.decodeSingularStringField(value: &self.connectionID)
      case 4: try decoder.decodeSingularBytesField(value: &self.message)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.received != 0 {
      try visitor.visitSingularInt64Field(value: self.received, fieldNumber: 2)
    }
    if !self.connectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.connectionID, fieldNumber: 3)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularBytesField(value: self.message, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Prism_Protos_ReceivedMessage, rhs: Io_Iohk_Prism_Protos_ReceivedMessage) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.received != rhs.received {return false}
    if lhs.connectionID != rhs.connectionID {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Prism_Protos_Payment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Payment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "amount"),
    3: .same(proto: "createdOn"),
    4: .same(proto: "status"),
    5: .same(proto: "failureReason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.amount)
      case 3: try decoder.decodeSingularInt64Field(value: &self.createdOn)
      case 4: try decoder.decodeSingularStringField(value: &self.status)
      case 5: try decoder.decodeSingularStringField(value: &self.failureReason)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 2)
    }
    if self.createdOn != 0 {
      try visitor.visitSingularInt64Field(value: self.createdOn, fieldNumber: 3)
    }
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 4)
    }
    if !self.failureReason.isEmpty {
      try visitor.visitSingularStringField(value: self.failureReason, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Prism_Protos_Payment, rhs: Io_Iohk_Prism_Protos_Payment) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.createdOn != rhs.createdOn {return false}
    if lhs.status != rhs.status {return false}
    if lhs.failureReason != rhs.failureReason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
