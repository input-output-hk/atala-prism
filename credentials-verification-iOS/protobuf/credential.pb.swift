// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: protobuf/credential.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// For now Universites and schools.
enum Io_Iohk_Cvp_Credential_IssuerType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case university // = 0
  case school // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .university
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .university
    case 1: self = .school
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .university: return 0
    case .school: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Io_Iohk_Cvp_Credential_IssuerType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Io_Iohk_Cvp_Credential_IssuerType] = [
    .university,
    .school,
  ]
}

#endif  // swift(>=4.2)

enum Io_Iohk_Cvp_Credential_IdDocumentType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case nationalIDCard // = 0
  case passport // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .nationalIDCard
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .nationalIDCard
    case 1: self = .passport
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .nationalIDCard: return 0
    case .passport: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Io_Iohk_Cvp_Credential_IdDocumentType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Io_Iohk_Cvp_Credential_IdDocumentType] = [
    .nationalIDCard,
    .passport,
  ]
}

#endif  // swift(>=4.2)

struct Io_Iohk_Cvp_Credential_AlphaCredential {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Data associated to the issuer organization. Currently University or School
  var issuerType: Io_Iohk_Cvp_Credential_IssuerData {
    get {return _storage._issuerType ?? Io_Iohk_Cvp_Credential_IssuerData()}
    set {_uniqueStorage()._issuerType = newValue}
  }
  /// Returns true if `issuerType` has been explicitly set.
  var hasIssuerType: Bool {return _storage._issuerType != nil}
  /// Clears the value of `issuerType`. Subsequent reads from it will return its default value.
  mutating func clearIssuerType() {_uniqueStorage()._issuerType = nil}

  /// Personal data associated to the holder (student)
  var subjectData: Io_Iohk_Cvp_Credential_SubjectData {
    get {return _storage._subjectData ?? Io_Iohk_Cvp_Credential_SubjectData()}
    set {_uniqueStorage()._subjectData = newValue}
  }
  /// Returns true if `subjectData` has been explicitly set.
  var hasSubjectData: Bool {return _storage._subjectData != nil}
  /// Clears the value of `subjectData`. Subsequent reads from it will return its default value.
  mutating func clearSubjectData() {_uniqueStorage()._subjectData = nil}

  /// e.g. [subject] was awarded Degree of Master Business Administration in Management
  var grantingDecision: String {
    get {return _storage._grantingDecision}
    set {_uniqueStorage()._grantingDecision = newValue}
  }

  /// head and other members of the institution that will sign the diploma
  var signingAuthorities: [Io_Iohk_Cvp_Credential_Signer] {
    get {return _storage._signingAuthorities}
    set {_uniqueStorage()._signingAuthorities = newValue}
  }

  /// Degree name
  var degreeAwarded: String {
    get {return _storage._degreeAwarded}
    set {_uniqueStorage()._degreeAwarded = newValue}
  }

  /// Optional additional speciality
  var additionalSpeciality: String {
    get {return _storage._additionalSpeciality}
    set {_uniqueStorage()._additionalSpeciality = newValue}
  }

  /// Date of issuance
  var issuedOn: Io_Iohk_Cvp_Credential_Date {
    get {return _storage._issuedOn ?? Io_Iohk_Cvp_Credential_Date()}
    set {_uniqueStorage()._issuedOn = newValue}
  }
  /// Returns true if `issuedOn` has been explicitly set.
  var hasIssuedOn: Bool {return _storage._issuedOn != nil}
  /// Clears the value of `issuedOn`. Subsequent reads from it will return its default value.
  mutating func clearIssuedOn() {_uniqueStorage()._issuedOn = nil}

  /// Fields that are unclear. They may be updated or even deleted
  var issueNumber: String {
    get {return _storage._issueNumber}
    set {_uniqueStorage()._issueNumber = newValue}
  }

  /// NEED CLARIFICATION Registration number. This appears in the example diploma but it is unclear how this may relate to "Issue number"
  var registrationNumber: String {
    get {return _storage._registrationNumber}
    set {_uniqueStorage()._registrationNumber = newValue}
  }

  ///NEED CLARIFICATION Decision number. This appears in the example diploma but it is unclear how this may relate to "Issue number"
  var decisionNumber: String {
    get {return _storage._decisionNumber}
    set {_uniqueStorage()._decisionNumber = newValue}
  }

  /// WE NEED CLARIFICATIONS ON THIS FIELD. It is related to school diplomas
  var yearCompletedByStudent: String {
    get {return _storage._yearCompletedByStudent}
    set {_uniqueStorage()._yearCompletedByStudent = newValue}
  }

  /// Fields inspired from OpenCerts standard. See: https://github.com/OpenCerts/open-certificate/blob/master/schema/2.0/schema.json
  var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  var expiresOn: Io_Iohk_Cvp_Credential_Date {
    get {return _storage._expiresOn ?? Io_Iohk_Cvp_Credential_Date()}
    set {_uniqueStorage()._expiresOn = newValue}
  }
  /// Returns true if `expiresOn` has been explicitly set.
  var hasExpiresOn: Bool {return _storage._expiresOn != nil}
  /// Clears the value of `expiresOn`. Subsequent reads from it will return its default value.
  mutating func clearExpiresOn() {_uniqueStorage()._expiresOn = nil}

  /// unclear meaning
  var admissionDate: Io_Iohk_Cvp_Credential_Date {
    get {return _storage._admissionDate ?? Io_Iohk_Cvp_Credential_Date()}
    set {_uniqueStorage()._admissionDate = newValue}
  }
  /// Returns true if `admissionDate` has been explicitly set.
  var hasAdmissionDate: Bool {return _storage._admissionDate != nil}
  /// Clears the value of `admissionDate`. Subsequent reads from it will return its default value.
  mutating func clearAdmissionDate() {_uniqueStorage()._admissionDate = nil}

  /// (OpenCerts description) The date that this student graduated from the course
  var graduationDate: Io_Iohk_Cvp_Credential_Date {
    get {return _storage._graduationDate ?? Io_Iohk_Cvp_Credential_Date()}
    set {_uniqueStorage()._graduationDate = newValue}
  }
  /// Returns true if `graduationDate` has been explicitly set.
  var hasGraduationDate: Bool {return _storage._graduationDate != nil}
  /// Clears the value of `graduationDate`. Subsequent reads from it will return its default value.
  mutating func clearGraduationDate() {_uniqueStorage()._graduationDate = nil}

  /// (OpenCerts description) The date that this qualification was awarded to the recipient
  var attainmentDate: Io_Iohk_Cvp_Credential_Date {
    get {return _storage._attainmentDate ?? Io_Iohk_Cvp_Credential_Date()}
    set {_uniqueStorage()._attainmentDate = newValue}
  }
  /// Returns true if `attainmentDate` has been explicitly set.
  var hasAttainmentDate: Bool {return _storage._attainmentDate != nil}
  /// Clears the value of `attainmentDate`. Subsequent reads from it will return its default value.
  mutating func clearAttainmentDate() {_uniqueStorage()._attainmentDate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Io_Iohk_Cvp_Credential_IssuerData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Issuer legal name. E.g. "LLC BUSINESS AND TECHNOLOGY UNIVERSITY"
  var issuerLegalName: String = String()

  /// In university case, this could be the faculty name.
  var academicAuthority: String = String()

  /// E.g. Faculty of Business and Technology
  var issuerType: Io_Iohk_Cvp_Credential_IssuerType = .university

  /// public DID associated to the institution
  var did: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Cvp_Credential_Signer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Names of the signer
  var names: [String] = []

  /// Surnames of the signer
  var surnames: [String] = []

  /// Rector, Dean, etc.
  var role: String = String()

  /// public DID associated to the signer
  var did: String = String()

  /// Tittle to address the person. e.g. Mr, Dr, Prof, etc.
  var title: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Cvp_Credential_SubjectData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Names of the subject.
  var names: [String] {
    get {return _storage._names}
    set {_uniqueStorage()._names = newValue}
  }

  /// surnames of the subject.
  var surnames: [String] {
    get {return _storage._surnames}
    set {_uniqueStorage()._surnames = newValue}
  }

  /// date of birth of the holder
  var dateOfBirth: Io_Iohk_Cvp_Credential_Date {
    get {return _storage._dateOfBirth ?? Io_Iohk_Cvp_Credential_Date()}
    set {_uniqueStorage()._dateOfBirth = newValue}
  }
  /// Returns true if `dateOfBirth` has been explicitly set.
  var hasDateOfBirth: Bool {return _storage._dateOfBirth != nil}
  /// Clears the value of `dateOfBirth`. Subsequent reads from it will return its default value.
  mutating func clearDateOfBirth() {_uniqueStorage()._dateOfBirth = nil}

  /// optional identification number of the holder
  var idDocument: Io_Iohk_Cvp_Credential_PersonalId {
    get {return _storage._idDocument ?? Io_Iohk_Cvp_Credential_PersonalId()}
    set {_uniqueStorage()._idDocument = newValue}
  }
  /// Returns true if `idDocument` has been explicitly set.
  var hasIDDocument: Bool {return _storage._idDocument != nil}
  /// Clears the value of `idDocument`. Subsequent reads from it will return its default value.
  mutating func clearIDDocument() {_uniqueStorage()._idDocument = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Io_Iohk_Cvp_Credential_Date {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// positive value
  var year: Int32 = 0

  /// value in the [1, 12] interval
  var month: Int32 = 0

  /// value in the [1, 31] interval (depending on the month, the max value might be 28
  var day: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Cvp_Credential_PersonalId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// unique identifier of the individual according to document type
  var id: String = String()

  /// E.g. passport, driver licence, national card
  var documentType: Io_Iohk_Cvp_Credential_IdDocumentType = .nationalIDCard

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
///Below we can see the messages used to exchange credentials between actors
struct Io_Iohk_Cvp_Credential_IssuerSentCredential {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: OneOf_Value? {
    get {return _storage._value}
    set {_uniqueStorage()._value = newValue}
  }

  var alphaCredential: Io_Iohk_Cvp_Credential_AlphaCredential {
    get {
      if case .alphaCredential(let v)? = _storage._value {return v}
      return Io_Iohk_Cvp_Credential_AlphaCredential()
    }
    set {_uniqueStorage()._value = .alphaCredential(newValue)}
  }

  var credential: Io_Iohk_Cvp_Credential_Credential {
    get {
      if case .credential(let v)? = _storage._value {return v}
      return Io_Iohk_Cvp_Credential_Credential()
    }
    set {_uniqueStorage()._value = .credential(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable {
    case alphaCredential(Io_Iohk_Cvp_Credential_AlphaCredential)
    case credential(Io_Iohk_Cvp_Credential_Credential)

  #if !swift(>=4.1)
    static func ==(lhs: Io_Iohk_Cvp_Credential_IssuerSentCredential.OneOf_Value, rhs: Io_Iohk_Cvp_Credential_IssuerSentCredential.OneOf_Value) -> Bool {
      switch (lhs, rhs) {
      case (.alphaCredential(let l), .alphaCredential(let r)): return l == r
      case (.credential(let l), .credential(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Io_Iohk_Cvp_Credential_Credential {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// type id to enable dispatch to correct credential processor.
  var typeID: String = String()

  /// JSON or JWT encoded credential document (to discuss)
  var credentialDocument: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Cvp_Credential_HolderSentCredential {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var credential: Io_Iohk_Cvp_Credential_AlphaCredential {
    get {return _storage._credential ?? Io_Iohk_Cvp_Credential_AlphaCredential()}
    set {_uniqueStorage()._credential = newValue}
  }
  /// Returns true if `credential` has been explicitly set.
  var hasCredential: Bool {return _storage._credential != nil}
  /// Clears the value of `credential`. Subsequent reads from it will return its default value.
  mutating func clearCredential() {_uniqueStorage()._credential = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Io_Iohk_Cvp_Credential_AtalaMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: OneOf_Message? {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  var issuerSentCredential: Io_Iohk_Cvp_Credential_IssuerSentCredential {
    get {
      if case .issuerSentCredential(let v)? = _storage._message {return v}
      return Io_Iohk_Cvp_Credential_IssuerSentCredential()
    }
    set {_uniqueStorage()._message = .issuerSentCredential(newValue)}
  }

  var holderSentCredential: Io_Iohk_Cvp_Credential_HolderSentCredential {
    get {
      if case .holderSentCredential(let v)? = _storage._message {return v}
      return Io_Iohk_Cvp_Credential_HolderSentCredential()
    }
    set {_uniqueStorage()._message = .holderSentCredential(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Message: Equatable {
    case issuerSentCredential(Io_Iohk_Cvp_Credential_IssuerSentCredential)
    case holderSentCredential(Io_Iohk_Cvp_Credential_HolderSentCredential)

  #if !swift(>=4.1)
    static func ==(lhs: Io_Iohk_Cvp_Credential_AtalaMessage.OneOf_Message, rhs: Io_Iohk_Cvp_Credential_AtalaMessage.OneOf_Message) -> Bool {
      switch (lhs, rhs) {
      case (.issuerSentCredential(let l), .issuerSentCredential(let r)): return l == r
      case (.holderSentCredential(let l), .holderSentCredential(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "io.iohk.cvp.credential"

extension Io_Iohk_Cvp_Credential_IssuerType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "University"),
    1: .same(proto: "School"),
  ]
}

extension Io_Iohk_Cvp_Credential_IdDocumentType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NationalIdCard"),
    1: .same(proto: "Passport"),
  ]
}

extension Io_Iohk_Cvp_Credential_AlphaCredential: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AlphaCredential"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "issuerType"),
    2: .same(proto: "subjectData"),
    3: .same(proto: "grantingDecision"),
    4: .same(proto: "signingAuthorities"),
    5: .same(proto: "degreeAwarded"),
    6: .same(proto: "additionalSpeciality"),
    7: .same(proto: "issuedOn"),
    8: .same(proto: "issueNumber"),
    9: .same(proto: "registrationNumber"),
    10: .same(proto: "decisionNumber"),
    15: .same(proto: "yearCompletedByStudent"),
    16: .same(proto: "description"),
    17: .same(proto: "expiresOn"),
    18: .same(proto: "admissionDate"),
    19: .same(proto: "graduationDate"),
    20: .same(proto: "attainmentDate"),
  ]

  fileprivate class _StorageClass {
    var _issuerType: Io_Iohk_Cvp_Credential_IssuerData? = nil
    var _subjectData: Io_Iohk_Cvp_Credential_SubjectData? = nil
    var _grantingDecision: String = String()
    var _signingAuthorities: [Io_Iohk_Cvp_Credential_Signer] = []
    var _degreeAwarded: String = String()
    var _additionalSpeciality: String = String()
    var _issuedOn: Io_Iohk_Cvp_Credential_Date? = nil
    var _issueNumber: String = String()
    var _registrationNumber: String = String()
    var _decisionNumber: String = String()
    var _yearCompletedByStudent: String = String()
    var _description_p: String = String()
    var _expiresOn: Io_Iohk_Cvp_Credential_Date? = nil
    var _admissionDate: Io_Iohk_Cvp_Credential_Date? = nil
    var _graduationDate: Io_Iohk_Cvp_Credential_Date? = nil
    var _attainmentDate: Io_Iohk_Cvp_Credential_Date? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _issuerType = source._issuerType
      _subjectData = source._subjectData
      _grantingDecision = source._grantingDecision
      _signingAuthorities = source._signingAuthorities
      _degreeAwarded = source._degreeAwarded
      _additionalSpeciality = source._additionalSpeciality
      _issuedOn = source._issuedOn
      _issueNumber = source._issueNumber
      _registrationNumber = source._registrationNumber
      _decisionNumber = source._decisionNumber
      _yearCompletedByStudent = source._yearCompletedByStudent
      _description_p = source._description_p
      _expiresOn = source._expiresOn
      _admissionDate = source._admissionDate
      _graduationDate = source._graduationDate
      _attainmentDate = source._attainmentDate
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._issuerType)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._subjectData)
        case 3: try decoder.decodeSingularStringField(value: &_storage._grantingDecision)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._signingAuthorities)
        case 5: try decoder.decodeSingularStringField(value: &_storage._degreeAwarded)
        case 6: try decoder.decodeSingularStringField(value: &_storage._additionalSpeciality)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._issuedOn)
        case 8: try decoder.decodeSingularStringField(value: &_storage._issueNumber)
        case 9: try decoder.decodeSingularStringField(value: &_storage._registrationNumber)
        case 10: try decoder.decodeSingularStringField(value: &_storage._decisionNumber)
        case 15: try decoder.decodeSingularStringField(value: &_storage._yearCompletedByStudent)
        case 16: try decoder.decodeSingularStringField(value: &_storage._description_p)
        case 17: try decoder.decodeSingularMessageField(value: &_storage._expiresOn)
        case 18: try decoder.decodeSingularMessageField(value: &_storage._admissionDate)
        case 19: try decoder.decodeSingularMessageField(value: &_storage._graduationDate)
        case 20: try decoder.decodeSingularMessageField(value: &_storage._attainmentDate)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._issuerType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._subjectData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._grantingDecision.isEmpty {
        try visitor.visitSingularStringField(value: _storage._grantingDecision, fieldNumber: 3)
      }
      if !_storage._signingAuthorities.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._signingAuthorities, fieldNumber: 4)
      }
      if !_storage._degreeAwarded.isEmpty {
        try visitor.visitSingularStringField(value: _storage._degreeAwarded, fieldNumber: 5)
      }
      if !_storage._additionalSpeciality.isEmpty {
        try visitor.visitSingularStringField(value: _storage._additionalSpeciality, fieldNumber: 6)
      }
      if let v = _storage._issuedOn {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._issueNumber.isEmpty {
        try visitor.visitSingularStringField(value: _storage._issueNumber, fieldNumber: 8)
      }
      if !_storage._registrationNumber.isEmpty {
        try visitor.visitSingularStringField(value: _storage._registrationNumber, fieldNumber: 9)
      }
      if !_storage._decisionNumber.isEmpty {
        try visitor.visitSingularStringField(value: _storage._decisionNumber, fieldNumber: 10)
      }
      if !_storage._yearCompletedByStudent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._yearCompletedByStudent, fieldNumber: 15)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 16)
      }
      if let v = _storage._expiresOn {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if let v = _storage._admissionDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }
      if let v = _storage._graduationDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }
      if let v = _storage._attainmentDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Credential_AlphaCredential, rhs: Io_Iohk_Cvp_Credential_AlphaCredential) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._issuerType != rhs_storage._issuerType {return false}
        if _storage._subjectData != rhs_storage._subjectData {return false}
        if _storage._grantingDecision != rhs_storage._grantingDecision {return false}
        if _storage._signingAuthorities != rhs_storage._signingAuthorities {return false}
        if _storage._degreeAwarded != rhs_storage._degreeAwarded {return false}
        if _storage._additionalSpeciality != rhs_storage._additionalSpeciality {return false}
        if _storage._issuedOn != rhs_storage._issuedOn {return false}
        if _storage._issueNumber != rhs_storage._issueNumber {return false}
        if _storage._registrationNumber != rhs_storage._registrationNumber {return false}
        if _storage._decisionNumber != rhs_storage._decisionNumber {return false}
        if _storage._yearCompletedByStudent != rhs_storage._yearCompletedByStudent {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._expiresOn != rhs_storage._expiresOn {return false}
        if _storage._admissionDate != rhs_storage._admissionDate {return false}
        if _storage._graduationDate != rhs_storage._graduationDate {return false}
        if _storage._attainmentDate != rhs_storage._attainmentDate {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Credential_IssuerData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IssuerData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "issuerLegalName"),
    2: .same(proto: "academicAuthority"),
    3: .same(proto: "issuerType"),
    4: .same(proto: "did"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.issuerLegalName)
      case 2: try decoder.decodeSingularStringField(value: &self.academicAuthority)
      case 3: try decoder.decodeSingularEnumField(value: &self.issuerType)
      case 4: try decoder.decodeSingularStringField(value: &self.did)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.issuerLegalName.isEmpty {
      try visitor.visitSingularStringField(value: self.issuerLegalName, fieldNumber: 1)
    }
    if !self.academicAuthority.isEmpty {
      try visitor.visitSingularStringField(value: self.academicAuthority, fieldNumber: 2)
    }
    if self.issuerType != .university {
      try visitor.visitSingularEnumField(value: self.issuerType, fieldNumber: 3)
    }
    if !self.did.isEmpty {
      try visitor.visitSingularStringField(value: self.did, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Credential_IssuerData, rhs: Io_Iohk_Cvp_Credential_IssuerData) -> Bool {
    if lhs.issuerLegalName != rhs.issuerLegalName {return false}
    if lhs.academicAuthority != rhs.academicAuthority {return false}
    if lhs.issuerType != rhs.issuerType {return false}
    if lhs.did != rhs.did {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Credential_Signer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Signer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "names"),
    2: .same(proto: "surnames"),
    3: .same(proto: "role"),
    4: .same(proto: "did"),
    5: .same(proto: "title"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.names)
      case 2: try decoder.decodeRepeatedStringField(value: &self.surnames)
      case 3: try decoder.decodeSingularStringField(value: &self.role)
      case 4: try decoder.decodeSingularStringField(value: &self.did)
      case 5: try decoder.decodeSingularStringField(value: &self.title)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.names.isEmpty {
      try visitor.visitRepeatedStringField(value: self.names, fieldNumber: 1)
    }
    if !self.surnames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.surnames, fieldNumber: 2)
    }
    if !self.role.isEmpty {
      try visitor.visitSingularStringField(value: self.role, fieldNumber: 3)
    }
    if !self.did.isEmpty {
      try visitor.visitSingularStringField(value: self.did, fieldNumber: 4)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Credential_Signer, rhs: Io_Iohk_Cvp_Credential_Signer) -> Bool {
    if lhs.names != rhs.names {return false}
    if lhs.surnames != rhs.surnames {return false}
    if lhs.role != rhs.role {return false}
    if lhs.did != rhs.did {return false}
    if lhs.title != rhs.title {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Credential_SubjectData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubjectData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "names"),
    2: .same(proto: "surnames"),
    3: .same(proto: "dateOfBirth"),
    4: .same(proto: "idDocument"),
  ]

  fileprivate class _StorageClass {
    var _names: [String] = []
    var _surnames: [String] = []
    var _dateOfBirth: Io_Iohk_Cvp_Credential_Date? = nil
    var _idDocument: Io_Iohk_Cvp_Credential_PersonalId? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _names = source._names
      _surnames = source._surnames
      _dateOfBirth = source._dateOfBirth
      _idDocument = source._idDocument
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedStringField(value: &_storage._names)
        case 2: try decoder.decodeRepeatedStringField(value: &_storage._surnames)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._dateOfBirth)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._idDocument)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._names.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._names, fieldNumber: 1)
      }
      if !_storage._surnames.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._surnames, fieldNumber: 2)
      }
      if let v = _storage._dateOfBirth {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._idDocument {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Credential_SubjectData, rhs: Io_Iohk_Cvp_Credential_SubjectData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._names != rhs_storage._names {return false}
        if _storage._surnames != rhs_storage._surnames {return false}
        if _storage._dateOfBirth != rhs_storage._dateOfBirth {return false}
        if _storage._idDocument != rhs_storage._idDocument {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Credential_Date: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Date"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "year"),
    2: .same(proto: "month"),
    3: .same(proto: "day"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.year)
      case 2: try decoder.decodeSingularInt32Field(value: &self.month)
      case 3: try decoder.decodeSingularInt32Field(value: &self.day)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.year != 0 {
      try visitor.visitSingularInt32Field(value: self.year, fieldNumber: 1)
    }
    if self.month != 0 {
      try visitor.visitSingularInt32Field(value: self.month, fieldNumber: 2)
    }
    if self.day != 0 {
      try visitor.visitSingularInt32Field(value: self.day, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Credential_Date, rhs: Io_Iohk_Cvp_Credential_Date) -> Bool {
    if lhs.year != rhs.year {return false}
    if lhs.month != rhs.month {return false}
    if lhs.day != rhs.day {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Credential_PersonalId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PersonalId"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "documentType"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularEnumField(value: &self.documentType)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.documentType != .nationalIDCard {
      try visitor.visitSingularEnumField(value: self.documentType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Credential_PersonalId, rhs: Io_Iohk_Cvp_Credential_PersonalId) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.documentType != rhs.documentType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Credential_IssuerSentCredential: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IssuerSentCredential"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alphaCredential"),
    2: .same(proto: "credential"),
  ]

  fileprivate class _StorageClass {
    var _value: Io_Iohk_Cvp_Credential_IssuerSentCredential.OneOf_Value?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _value = source._value
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Io_Iohk_Cvp_Credential_AlphaCredential?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .alphaCredential(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .alphaCredential(v)}
        case 2:
          var v: Io_Iohk_Cvp_Credential_Credential?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .credential(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .credential(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._value {
      case .alphaCredential(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .credential(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Credential_IssuerSentCredential, rhs: Io_Iohk_Cvp_Credential_IssuerSentCredential) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._value != rhs_storage._value {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Credential_Credential: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Credential"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "typeId"),
    2: .same(proto: "credentialDocument"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.typeID)
      case 2: try decoder.decodeSingularStringField(value: &self.credentialDocument)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.typeID.isEmpty {
      try visitor.visitSingularStringField(value: self.typeID, fieldNumber: 1)
    }
    if !self.credentialDocument.isEmpty {
      try visitor.visitSingularStringField(value: self.credentialDocument, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Credential_Credential, rhs: Io_Iohk_Cvp_Credential_Credential) -> Bool {
    if lhs.typeID != rhs.typeID {return false}
    if lhs.credentialDocument != rhs.credentialDocument {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Credential_HolderSentCredential: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HolderSentCredential"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "credential"),
  ]

  fileprivate class _StorageClass {
    var _credential: Io_Iohk_Cvp_Credential_AlphaCredential? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _credential = source._credential
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._credential)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._credential {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Credential_HolderSentCredential, rhs: Io_Iohk_Cvp_Credential_HolderSentCredential) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._credential != rhs_storage._credential {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Credential_AtalaMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AtalaMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "issuerSentCredential"),
    2: .same(proto: "holderSentCredential"),
  ]

  fileprivate class _StorageClass {
    var _message: Io_Iohk_Cvp_Credential_AtalaMessage.OneOf_Message?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _message = source._message
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Io_Iohk_Cvp_Credential_IssuerSentCredential?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .issuerSentCredential(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .issuerSentCredential(v)}
        case 2:
          var v: Io_Iohk_Cvp_Credential_HolderSentCredential?
          if let current = _storage._message {
            try decoder.handleConflictingOneOf()
            if case .holderSentCredential(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._message = .holderSentCredential(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._message {
      case .issuerSentCredential(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .holderSentCredential(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Credential_AtalaMessage, rhs: Io_Iohk_Cvp_Credential_AtalaMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._message != rhs_storage._message {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
