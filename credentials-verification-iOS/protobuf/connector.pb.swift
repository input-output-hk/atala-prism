// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: protobuf/connector.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Credential type; FIXME: is it a part of protocol?
enum Io_Iohk_Cvp_Connector_CredentialType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// random stuff
  case unknown // = 0

  /// school, university, library
  case education // = 1

  /// national id, goverment id, driver license
  case institutional // = 2

  /// banks
  case financial // = 3

  /// jobs
  case business // = 4

  /// permit to play music in parks (?)
  case entertainment // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .education
    case 2: self = .institutional
    case 3: self = .financial
    case 4: self = .business
    case 5: self = .entertainment
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .education: return 1
    case .institutional: return 2
    case .financial: return 3
    case .business: return 4
    case .entertainment: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Io_Iohk_Cvp_Connector_CredentialType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Io_Iohk_Cvp_Connector_CredentialType] = [
    .unknown,
    .education,
    .institutional,
    .financial,
    .business,
    .entertainment,
  ]
}

#endif  // swift(>=4.2)

/// Enumeration representing billing plan of Issuer. Possible values are hardcoded as new billing options would require implementation changes anyway.
enum Io_Iohk_Cvp_Connector_BillingPlan: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// participant not able to generate connection tokens
  case noPlan // = 0

  /// connections are created for free
  case freePlan // = 1

  /// side generating the token pays for the connection
  case senderPays // = 2

  /// side receiving the token and using it to instantiate connection pays for it
  case receiverPays // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .noPlan
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noPlan
    case 1: self = .freePlan
    case 2: self = .senderPays
    case 3: self = .receiverPays
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .noPlan: return 0
    case .freePlan: return 1
    case .senderPays: return 2
    case .receiverPays: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Io_Iohk_Cvp_Connector_BillingPlan: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Io_Iohk_Cvp_Connector_BillingPlan] = [
    .noPlan,
    .freePlan,
    .senderPays,
    .receiverPays,
  ]
}

#endif  // swift(>=4.2)

/// just an EC public key represented with big integers as strings
struct Io_Iohk_Cvp_Connector_PublicKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: String = String()

  var y: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Credential information; FIXME: is it a part of protocol?
struct Io_Iohk_Cvp_Connector_Credential {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var issuerInfo: Io_Iohk_Cvp_Connector_IssuerInfo {
    get {return _storage._issuerInfo ?? Io_Iohk_Cvp_Connector_IssuerInfo()}
    set {_uniqueStorage()._issuerInfo = newValue}
  }
  /// Returns true if `issuerInfo` has been explicitly set.
  var hasIssuerInfo: Bool {return _storage._issuerInfo != nil}
  /// Clears the value of `issuerInfo`. Subsequent reads from it will return its default value.
  mutating func clearIssuerInfo() {_uniqueStorage()._issuerInfo = nil}

  var subject: String {
    get {return _storage._subject}
    set {_uniqueStorage()._subject = newValue}
  }

  var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  var type: Io_Iohk_Cvp_Connector_CredentialType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var credentialData: Data {
    get {return _storage._credentialData}
    set {_uniqueStorage()._credentialData = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Information on an Issuer
struct Io_Iohk_Cvp_Connector_IssuerInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var did: String = String()

  var name: String = String()

  var logo: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Information on a Verifier
struct Io_Iohk_Cvp_Connector_VerifierInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var did: String = String()

  var name: String = String()

  var logo: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Information on a Holder
struct Io_Iohk_Cvp_Connector_HolderInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var did: String = String()

  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Type representing generic participant in the system, alternative of IssuerInfo, HolderInfo, or VerifierInfo.
struct Io_Iohk_Cvp_Connector_ParticipantInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var participant: OneOf_Participant? {
    get {return _storage._participant}
    set {_uniqueStorage()._participant = newValue}
  }

  var issuer: Io_Iohk_Cvp_Connector_IssuerInfo {
    get {
      if case .issuer(let v)? = _storage._participant {return v}
      return Io_Iohk_Cvp_Connector_IssuerInfo()
    }
    set {_uniqueStorage()._participant = .issuer(newValue)}
  }

  var holder: Io_Iohk_Cvp_Connector_HolderInfo {
    get {
      if case .holder(let v)? = _storage._participant {return v}
      return Io_Iohk_Cvp_Connector_HolderInfo()
    }
    set {_uniqueStorage()._participant = .holder(newValue)}
  }

  var verifier: Io_Iohk_Cvp_Connector_VerifierInfo {
    get {
      if case .verifier(let v)? = _storage._participant {return v}
      return Io_Iohk_Cvp_Connector_VerifierInfo()
    }
    set {_uniqueStorage()._participant = .verifier(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Participant: Equatable {
    case issuer(Io_Iohk_Cvp_Connector_IssuerInfo)
    case holder(Io_Iohk_Cvp_Connector_HolderInfo)
    case verifier(Io_Iohk_Cvp_Connector_VerifierInfo)

  #if !swift(>=4.1)
    static func ==(lhs: Io_Iohk_Cvp_Connector_ParticipantInfo.OneOf_Participant, rhs: Io_Iohk_Cvp_Connector_ParticipantInfo.OneOf_Participant) -> Bool {
      switch (lhs, rhs) {
      case (.issuer(let l), .issuer(let r)): return l == r
      case (.holder(let l), .holder(let r)): return l == r
      case (.verifier(let l), .verifier(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Information on the connection; both sides see the same connectionId and creation time, but each sees different participantInfo
struct Io_Iohk_Cvp_Connector_ConnectionInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var connectionID: String {
    get {return _storage._connectionID}
    set {_uniqueStorage()._connectionID = newValue}
  }

  /// moment of instantiation as milliseconds since the Unix Epoch
  var created: Int64 {
    get {return _storage._created}
    set {_uniqueStorage()._created = newValue}
  }

  /// information about the participant at the other end
  var participantInfo: Io_Iohk_Cvp_Connector_ParticipantInfo {
    get {return _storage._participantInfo ?? Io_Iohk_Cvp_Connector_ParticipantInfo()}
    set {_uniqueStorage()._participantInfo = newValue}
  }
  /// Returns true if `participantInfo` has been explicitly set.
  var hasParticipantInfo: Bool {return _storage._participantInfo != nil}
  /// Clears the value of `participantInfo`. Subsequent reads from it will return its default value.
  mutating func clearParticipantInfo() {_uniqueStorage()._participantInfo = nil}

  /// the token used to generate the connection
  var token: String {
    get {return _storage._token}
    set {_uniqueStorage()._token = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Request connections instantiated by us / with us possibly after a known connection
struct Io_Iohk_Cvp_Connector_GetConnectionsPaginatedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// returned credentials will have been created after the last seen connection (optional field)
  var lastSeenConnectionID: String = String()

  /// maximum number of credentials to return; must be > 0
  var limit: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Result with connections instantiated
struct Io_Iohk_Cvp_Connector_GetConnectionsPaginatedResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// connections sorted in ascending order by instantiation time
  var connections: [Io_Iohk_Cvp_Connector_ConnectionInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request to obtain information of connection token
struct Io_Iohk_Cvp_Connector_GetConnectionTokenInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// token value to get information for
  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Result with information on connection token
struct Io_Iohk_Cvp_Connector_GetConnectionTokenInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// participant who generated the code
  var creator: Io_Iohk_Cvp_Connector_ParticipantInfo {
    get {return _storage._creator ?? Io_Iohk_Cvp_Connector_ParticipantInfo()}
    set {_uniqueStorage()._creator = newValue}
  }
  /// Returns true if `creator` has been explicitly set.
  var hasCreator: Bool {return _storage._creator != nil}
  /// Clears the value of `creator`. Subsequent reads from it will return its default value.
  mutating func clearCreator() {_uniqueStorage()._creator = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Request to instantiate a connection using token
struct Io_Iohk_Cvp_Connector_AddConnectionFromTokenRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// token to instantiate connection
  var token: String {
    get {return _storage._token}
    set {_uniqueStorage()._token = newValue}
  }

  var holderPublicKey: Io_Iohk_Cvp_Connector_PublicKey {
    get {return _storage._holderPublicKey ?? Io_Iohk_Cvp_Connector_PublicKey()}
    set {_uniqueStorage()._holderPublicKey = newValue}
  }
  /// Returns true if `holderPublicKey` has been explicitly set.
  var hasHolderPublicKey: Bool {return _storage._holderPublicKey != nil}
  /// Clears the value of `holderPublicKey`. Subsequent reads from it will return its default value.
  mutating func clearHolderPublicKey() {_uniqueStorage()._holderPublicKey = nil}

  /// optional field, if present, we'll charge the user before adding the connection
  var paymentNonce: String {
    get {return _storage._paymentNonce}
    set {_uniqueStorage()._paymentNonce = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Confirmation of connection instantiation
struct Io_Iohk_Cvp_Connector_AddConnectionFromTokenResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// instantiated connection info
  var connection: Io_Iohk_Cvp_Connector_ConnectionInfo {
    get {return _storage._connection ?? Io_Iohk_Cvp_Connector_ConnectionInfo()}
    set {_uniqueStorage()._connection = newValue}
  }
  /// Returns true if `connection` has been explicitly set.
  var hasConnection: Bool {return _storage._connection != nil}
  /// Clears the value of `connection`. Subsequent reads from it will return its default value.
  mutating func clearConnection() {_uniqueStorage()._connection = nil}

  /// your generated user id
  var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Request to delete a connection
struct Io_Iohk_Cvp_Connector_DeleteConnectionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id of connection to delete
  var connectionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Confirmation of connection deletion
struct Io_Iohk_Cvp_Connector_DeleteConnectionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request to generate a connection token
struct Io_Iohk_Cvp_Connector_GenerateConnectionTokenRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Result with generated token
struct Io_Iohk_Cvp_Connector_GenerateConnectionTokenResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// generated token
  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Message received via a connection
struct Io_Iohk_Cvp_Connector_ReceivedMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  /// time when Connector received the message as milliseconds since the Unix Epoch
  var received: Int64 = 0

  /// connection where the message has been received
  var connectionID: String = String()

  /// raw message
  var message: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request to return messages for us after the given known message (if any)
struct Io_Iohk_Cvp_Connector_GetMessagesPaginatedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// returned credentials will have been received after the given message (if any)
  var lastSeenMessageID: String = String()

  /// maximum number of credentials to return, must be > 0
  var limit: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response with messages
struct Io_Iohk_Cvp_Connector_GetMessagesPaginatedResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// messages sorted in ascending order by receiving time
  var messages: [Io_Iohk_Cvp_Connector_ReceivedMessage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Cvp_Connector_GetMessagesForConnectionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var connectionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Cvp_Connector_GetMessagesForConnectionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var messages: [Io_Iohk_Cvp_Connector_ReceivedMessage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request to send message
struct Io_Iohk_Cvp_Connector_SendMessageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id of the connection
  var connectionID: String = String()

  /// raw message
  var message: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Confirmation of message sending
struct Io_Iohk_Cvp_Connector_SendMessageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request to register DID
struct Io_Iohk_Cvp_Connector_RegisterDIDRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var did: String = String()

  var diddocument: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Confirmation of DID registration
struct Io_Iohk_Cvp_Connector_RegisterDIDResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request to change the billing plan
struct Io_Iohk_Cvp_Connector_ChangeBillingPlanRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// new billing plan
  var billingPlan: Io_Iohk_Cvp_Connector_BillingPlan = .noPlan

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Confirmation of billing plan change
struct Io_Iohk_Cvp_Connector_ChangeBillingPlanResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Cvp_Connector_GetBraintreePaymentsConfigRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Cvp_Connector_GetBraintreePaymentsConfigResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tokenizationKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Cvp_Connector_ProcessPaymentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// exact decimal amount
  var amount: String = String()

  /// client nonce
  var nonce: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Cvp_Connector_ProcessPaymentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var payment: Io_Iohk_Cvp_Connector_Payment {
    get {return _storage._payment ?? Io_Iohk_Cvp_Connector_Payment()}
    set {_uniqueStorage()._payment = newValue}
  }
  /// Returns true if `payment` has been explicitly set.
  var hasPayment: Bool {return _storage._payment != nil}
  /// Clears the value of `payment`. Subsequent reads from it will return its default value.
  mutating func clearPayment() {_uniqueStorage()._payment = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Io_Iohk_Cvp_Connector_GetPaymentsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Cvp_Connector_GetPaymentsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var payments: [Io_Iohk_Cvp_Connector_Payment] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Io_Iohk_Cvp_Connector_Payment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var amount: String = String()

  var createdOn: Int64 = 0

  var status: String = String()

  var failureReason: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "io.iohk.cvp.connector"

extension Io_Iohk_Cvp_Connector_CredentialType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "EDUCATION"),
    2: .same(proto: "INSTITUTIONAL"),
    3: .same(proto: "FINANCIAL"),
    4: .same(proto: "BUSINESS"),
    5: .same(proto: "ENTERTAINMENT"),
  ]
}

extension Io_Iohk_Cvp_Connector_BillingPlan: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_PLAN"),
    1: .same(proto: "FREE_PLAN"),
    2: .same(proto: "SENDER_PAYS"),
    3: .same(proto: "RECEIVER_PAYS"),
  ]
}

extension Io_Iohk_Cvp_Connector_PublicKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PublicKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.x)
      case 2: try decoder.decodeSingularStringField(value: &self.y)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.x.isEmpty {
      try visitor.visitSingularStringField(value: self.x, fieldNumber: 1)
    }
    if !self.y.isEmpty {
      try visitor.visitSingularStringField(value: self.y, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_PublicKey, rhs: Io_Iohk_Cvp_Connector_PublicKey) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Connector_Credential: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Credential"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "issuerInfo"),
    2: .same(proto: "subject"),
    3: .same(proto: "title"),
    4: .same(proto: "type"),
    5: .same(proto: "credentialData"),
  ]

  fileprivate class _StorageClass {
    var _issuerInfo: Io_Iohk_Cvp_Connector_IssuerInfo? = nil
    var _subject: String = String()
    var _title: String = String()
    var _type: Io_Iohk_Cvp_Connector_CredentialType = .unknown
    var _credentialData: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _issuerInfo = source._issuerInfo
      _subject = source._subject
      _title = source._title
      _type = source._type
      _credentialData = source._credentialData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._issuerInfo)
        case 2: try decoder.decodeSingularStringField(value: &_storage._subject)
        case 3: try decoder.decodeSingularStringField(value: &_storage._title)
        case 4: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 5: try decoder.decodeSingularBytesField(value: &_storage._credentialData)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._issuerInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._subject.isEmpty {
        try visitor.visitSingularStringField(value: _storage._subject, fieldNumber: 2)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 3)
      }
      if _storage._type != .unknown {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 4)
      }
      if !_storage._credentialData.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._credentialData, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_Credential, rhs: Io_Iohk_Cvp_Connector_Credential) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._issuerInfo != rhs_storage._issuerInfo {return false}
        if _storage._subject != rhs_storage._subject {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._credentialData != rhs_storage._credentialData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Connector_IssuerInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IssuerInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "DID"),
    2: .same(proto: "name"),
    3: .same(proto: "logo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.did)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularBytesField(value: &self.logo)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.did.isEmpty {
      try visitor.visitSingularStringField(value: self.did, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.logo.isEmpty {
      try visitor.visitSingularBytesField(value: self.logo, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_IssuerInfo, rhs: Io_Iohk_Cvp_Connector_IssuerInfo) -> Bool {
    if lhs.did != rhs.did {return false}
    if lhs.name != rhs.name {return false}
    if lhs.logo != rhs.logo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Connector_VerifierInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerifierInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "DID"),
    2: .same(proto: "name"),
    3: .same(proto: "logo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.did)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularBytesField(value: &self.logo)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.did.isEmpty {
      try visitor.visitSingularStringField(value: self.did, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.logo.isEmpty {
      try visitor.visitSingularBytesField(value: self.logo, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_VerifierInfo, rhs: Io_Iohk_Cvp_Connector_VerifierInfo) -> Bool {
    if lhs.did != rhs.did {return false}
    if lhs.name != rhs.name {return false}
    if lhs.logo != rhs.logo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Connector_HolderInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HolderInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "DID"),
    2: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.did)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.did.isEmpty {
      try visitor.visitSingularStringField(value: self.did, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_HolderInfo, rhs: Io_Iohk_Cvp_Connector_HolderInfo) -> Bool {
    if lhs.did != rhs.did {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Connector_ParticipantInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ParticipantInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "issuer"),
    2: .same(proto: "holder"),
    3: .same(proto: "verifier"),
  ]

  fileprivate class _StorageClass {
    var _participant: Io_Iohk_Cvp_Connector_ParticipantInfo.OneOf_Participant?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _participant = source._participant
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Io_Iohk_Cvp_Connector_IssuerInfo?
          if let current = _storage._participant {
            try decoder.handleConflictingOneOf()
            if case .issuer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._participant = .issuer(v)}
        case 2:
          var v: Io_Iohk_Cvp_Connector_HolderInfo?
          if let current = _storage._participant {
            try decoder.handleConflictingOneOf()
            if case .holder(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._participant = .holder(v)}
        case 3:
          var v: Io_Iohk_Cvp_Connector_VerifierInfo?
          if let current = _storage._participant {
            try decoder.handleConflictingOneOf()
            if case .verifier(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._participant = .verifier(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._participant {
      case .issuer(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .holder(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .verifier(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_ParticipantInfo, rhs: Io_Iohk_Cvp_Connector_ParticipantInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._participant != rhs_storage._participant {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Connector_ConnectionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectionInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "connectionId"),
    2: .same(proto: "created"),
    3: .same(proto: "participantInfo"),
    4: .same(proto: "token"),
  ]

  fileprivate class _StorageClass {
    var _connectionID: String = String()
    var _created: Int64 = 0
    var _participantInfo: Io_Iohk_Cvp_Connector_ParticipantInfo? = nil
    var _token: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _connectionID = source._connectionID
      _created = source._created
      _participantInfo = source._participantInfo
      _token = source._token
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._connectionID)
        case 2: try decoder.decodeSingularInt64Field(value: &_storage._created)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._participantInfo)
        case 4: try decoder.decodeSingularStringField(value: &_storage._token)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._connectionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._connectionID, fieldNumber: 1)
      }
      if _storage._created != 0 {
        try visitor.visitSingularInt64Field(value: _storage._created, fieldNumber: 2)
      }
      if let v = _storage._participantInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._token.isEmpty {
        try visitor.visitSingularStringField(value: _storage._token, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_ConnectionInfo, rhs: Io_Iohk_Cvp_Connector_ConnectionInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._connectionID != rhs_storage._connectionID {return false}
        if _storage._created != rhs_storage._created {return false}
        if _storage._participantInfo != rhs_storage._participantInfo {return false}
        if _storage._token != rhs_storage._token {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Connector_GetConnectionsPaginatedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetConnectionsPaginatedRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lastSeenConnectionId"),
    2: .same(proto: "limit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.lastSeenConnectionID)
      case 2: try decoder.decodeSingularInt32Field(value: &self.limit)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lastSeenConnectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.lastSeenConnectionID, fieldNumber: 1)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_GetConnectionsPaginatedRequest, rhs: Io_Iohk_Cvp_Connector_GetConnectionsPaginatedRequest) -> Bool {
    if lhs.lastSeenConnectionID != rhs.lastSeenConnectionID {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Connector_GetConnectionsPaginatedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetConnectionsPaginatedResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "connections"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.connections)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.connections.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.connections, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_GetConnectionsPaginatedResponse, rhs: Io_Iohk_Cvp_Connector_GetConnectionsPaginatedResponse) -> Bool {
    if lhs.connections != rhs.connections {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Connector_GetConnectionTokenInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetConnectionTokenInfoRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.token)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_GetConnectionTokenInfoRequest, rhs: Io_Iohk_Cvp_Connector_GetConnectionTokenInfoRequest) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Connector_GetConnectionTokenInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetConnectionTokenInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "creator"),
  ]

  fileprivate class _StorageClass {
    var _creator: Io_Iohk_Cvp_Connector_ParticipantInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _creator = source._creator
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._creator)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._creator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_GetConnectionTokenInfoResponse, rhs: Io_Iohk_Cvp_Connector_GetConnectionTokenInfoResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._creator != rhs_storage._creator {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Connector_AddConnectionFromTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddConnectionFromTokenRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "holderPublicKey"),
    3: .same(proto: "paymentNonce"),
  ]

  fileprivate class _StorageClass {
    var _token: String = String()
    var _holderPublicKey: Io_Iohk_Cvp_Connector_PublicKey? = nil
    var _paymentNonce: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _token = source._token
      _holderPublicKey = source._holderPublicKey
      _paymentNonce = source._paymentNonce
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._token)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._holderPublicKey)
        case 3: try decoder.decodeSingularStringField(value: &_storage._paymentNonce)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._token.isEmpty {
        try visitor.visitSingularStringField(value: _storage._token, fieldNumber: 1)
      }
      if let v = _storage._holderPublicKey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._paymentNonce.isEmpty {
        try visitor.visitSingularStringField(value: _storage._paymentNonce, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_AddConnectionFromTokenRequest, rhs: Io_Iohk_Cvp_Connector_AddConnectionFromTokenRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._token != rhs_storage._token {return false}
        if _storage._holderPublicKey != rhs_storage._holderPublicKey {return false}
        if _storage._paymentNonce != rhs_storage._paymentNonce {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Connector_AddConnectionFromTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddConnectionFromTokenResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "connection"),
    2: .same(proto: "userId"),
  ]

  fileprivate class _StorageClass {
    var _connection: Io_Iohk_Cvp_Connector_ConnectionInfo? = nil
    var _userID: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _connection = source._connection
      _userID = source._userID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._connection)
        case 2: try decoder.decodeSingularStringField(value: &_storage._userID)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._connection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_AddConnectionFromTokenResponse, rhs: Io_Iohk_Cvp_Connector_AddConnectionFromTokenResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._connection != rhs_storage._connection {return false}
        if _storage._userID != rhs_storage._userID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Connector_DeleteConnectionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteConnectionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "connectionId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.connectionID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.connectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.connectionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_DeleteConnectionRequest, rhs: Io_Iohk_Cvp_Connector_DeleteConnectionRequest) -> Bool {
    if lhs.connectionID != rhs.connectionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Connector_DeleteConnectionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteConnectionResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_DeleteConnectionResponse, rhs: Io_Iohk_Cvp_Connector_DeleteConnectionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Connector_GenerateConnectionTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenerateConnectionTokenRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_GenerateConnectionTokenRequest, rhs: Io_Iohk_Cvp_Connector_GenerateConnectionTokenRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Connector_GenerateConnectionTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenerateConnectionTokenResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.token)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_GenerateConnectionTokenResponse, rhs: Io_Iohk_Cvp_Connector_GenerateConnectionTokenResponse) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Connector_ReceivedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReceivedMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "received"),
    3: .same(proto: "connectionId"),
    4: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularInt64Field(value: &self.received)
      case 3: try decoder.decodeSingularStringField(value: &self.connectionID)
      case 4: try decoder.decodeSingularBytesField(value: &self.message)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.received != 0 {
      try visitor.visitSingularInt64Field(value: self.received, fieldNumber: 2)
    }
    if !self.connectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.connectionID, fieldNumber: 3)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularBytesField(value: self.message, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_ReceivedMessage, rhs: Io_Iohk_Cvp_Connector_ReceivedMessage) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.received != rhs.received {return false}
    if lhs.connectionID != rhs.connectionID {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Connector_GetMessagesPaginatedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMessagesPaginatedRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lastSeenMessageId"),
    2: .same(proto: "limit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.lastSeenMessageID)
      case 2: try decoder.decodeSingularInt32Field(value: &self.limit)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lastSeenMessageID.isEmpty {
      try visitor.visitSingularStringField(value: self.lastSeenMessageID, fieldNumber: 1)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_GetMessagesPaginatedRequest, rhs: Io_Iohk_Cvp_Connector_GetMessagesPaginatedRequest) -> Bool {
    if lhs.lastSeenMessageID != rhs.lastSeenMessageID {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Connector_GetMessagesPaginatedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMessagesPaginatedResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.messages)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_GetMessagesPaginatedResponse, rhs: Io_Iohk_Cvp_Connector_GetMessagesPaginatedResponse) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Connector_GetMessagesForConnectionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMessagesForConnectionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "connectionId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.connectionID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.connectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.connectionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_GetMessagesForConnectionRequest, rhs: Io_Iohk_Cvp_Connector_GetMessagesForConnectionRequest) -> Bool {
    if lhs.connectionID != rhs.connectionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Connector_GetMessagesForConnectionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMessagesForConnectionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.messages)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_GetMessagesForConnectionResponse, rhs: Io_Iohk_Cvp_Connector_GetMessagesForConnectionResponse) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Connector_SendMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendMessageRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "connectionId"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.connectionID)
      case 2: try decoder.decodeSingularBytesField(value: &self.message)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.connectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.connectionID, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularBytesField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_SendMessageRequest, rhs: Io_Iohk_Cvp_Connector_SendMessageRequest) -> Bool {
    if lhs.connectionID != rhs.connectionID {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Connector_SendMessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendMessageResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_SendMessageResponse, rhs: Io_Iohk_Cvp_Connector_SendMessageResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Connector_RegisterDIDRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterDIDRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "DID"),
    2: .same(proto: "DIDDocument"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.did)
      case 2: try decoder.decodeSingularStringField(value: &self.diddocument)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.did.isEmpty {
      try visitor.visitSingularStringField(value: self.did, fieldNumber: 1)
    }
    if !self.diddocument.isEmpty {
      try visitor.visitSingularStringField(value: self.diddocument, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_RegisterDIDRequest, rhs: Io_Iohk_Cvp_Connector_RegisterDIDRequest) -> Bool {
    if lhs.did != rhs.did {return false}
    if lhs.diddocument != rhs.diddocument {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Connector_RegisterDIDResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterDIDResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_RegisterDIDResponse, rhs: Io_Iohk_Cvp_Connector_RegisterDIDResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Connector_ChangeBillingPlanRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChangeBillingPlanRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "billingPlan"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.billingPlan)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.billingPlan != .noPlan {
      try visitor.visitSingularEnumField(value: self.billingPlan, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_ChangeBillingPlanRequest, rhs: Io_Iohk_Cvp_Connector_ChangeBillingPlanRequest) -> Bool {
    if lhs.billingPlan != rhs.billingPlan {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Connector_ChangeBillingPlanResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChangeBillingPlanResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_ChangeBillingPlanResponse, rhs: Io_Iohk_Cvp_Connector_ChangeBillingPlanResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Connector_GetBraintreePaymentsConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBraintreePaymentsConfigRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_GetBraintreePaymentsConfigRequest, rhs: Io_Iohk_Cvp_Connector_GetBraintreePaymentsConfigRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Connector_GetBraintreePaymentsConfigResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBraintreePaymentsConfigResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenizationKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.tokenizationKey)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokenizationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenizationKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_GetBraintreePaymentsConfigResponse, rhs: Io_Iohk_Cvp_Connector_GetBraintreePaymentsConfigResponse) -> Bool {
    if lhs.tokenizationKey != rhs.tokenizationKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Connector_ProcessPaymentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProcessPaymentRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .same(proto: "nonce"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.amount)
      case 2: try decoder.decodeSingularStringField(value: &self.nonce)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 1)
    }
    if !self.nonce.isEmpty {
      try visitor.visitSingularStringField(value: self.nonce, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_ProcessPaymentRequest, rhs: Io_Iohk_Cvp_Connector_ProcessPaymentRequest) -> Bool {
    if lhs.amount != rhs.amount {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Connector_ProcessPaymentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProcessPaymentResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payment"),
  ]

  fileprivate class _StorageClass {
    var _payment: Io_Iohk_Cvp_Connector_Payment? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _payment = source._payment
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._payment)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._payment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_ProcessPaymentResponse, rhs: Io_Iohk_Cvp_Connector_ProcessPaymentResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._payment != rhs_storage._payment {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Connector_GetPaymentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetPaymentsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_GetPaymentsRequest, rhs: Io_Iohk_Cvp_Connector_GetPaymentsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Connector_GetPaymentsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetPaymentsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payments"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.payments)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.payments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.payments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_GetPaymentsResponse, rhs: Io_Iohk_Cvp_Connector_GetPaymentsResponse) -> Bool {
    if lhs.payments != rhs.payments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Io_Iohk_Cvp_Connector_Payment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Payment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "amount"),
    3: .same(proto: "createdOn"),
    4: .same(proto: "status"),
    5: .same(proto: "failureReason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.amount)
      case 3: try decoder.decodeSingularInt64Field(value: &self.createdOn)
      case 4: try decoder.decodeSingularStringField(value: &self.status)
      case 5: try decoder.decodeSingularStringField(value: &self.failureReason)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 2)
    }
    if self.createdOn != 0 {
      try visitor.visitSingularInt64Field(value: self.createdOn, fieldNumber: 3)
    }
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 4)
    }
    if !self.failureReason.isEmpty {
      try visitor.visitSingularStringField(value: self.failureReason, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Io_Iohk_Cvp_Connector_Payment, rhs: Io_Iohk_Cvp_Connector_Payment) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.createdOn != rhs.createdOn {return false}
    if lhs.status != rhs.status {return false}
    if lhs.failureReason != rhs.failureReason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
