syntax = "proto3";

package io.iohk.prism.protos;

service ConnectorService {

  // Retrieve a connection for a given connection token.
  //
  // Available to: Holder, Issuer, Validator
  rpc GetConnectionByToken (GetConnectionByTokenRequest) returns (GetConnectionByTokenResponse) {}

  // Get active connections for current participant
  //
  // Available to: Holder, Issuer, Validator
  rpc GetConnectionsPaginated (GetConnectionsPaginatedRequest) returns (GetConnectionsPaginatedResponse) {}

  // Return info about connection token such as creator info
  //
  // Available to: Holder
  //
  // Errors:
  // Token does not exist (UNKNOWN)
  rpc GetConnectionTokenInfo (GetConnectionTokenInfoRequest) returns (GetConnectionTokenInfoResponse) {}

  // Instantiate connection from connection token
  //
  // Available to: Holder
  //
  // Errors:
  // Token does not exist (UNKNOWN)
  rpc AddConnectionFromToken (AddConnectionFromTokenRequest) returns (AddConnectionFromTokenResponse) {}

  // Delete active connection
  //
  // Available to: Holder, Issuer, Validator
  //
  // Errors:
  // Connection does not exist (UNKNOWN)
  rpc DeleteConnection (DeleteConnectionRequest) returns (DeleteConnectionResponse) {}

  // Bind DID to issuer
  //
  // Available to: Issuer
  //
  // Errors:
  // Invalid DID (INVALID_ARGUMENT)
  // Invalid DID document (INVALID_ARGUMENT)
  // DID Document does not match DID (INVALID_ARGUMENT)
  rpc RegisterDID (RegisterDIDRequest) returns (RegisterDIDResponse) {}

  // Change billing plan of participant who wants to generate connection tokens
  //
  // Available to: Issuer, Validator
  //
  // Errors:
  // Unknown billing plan (UNKNOWN)
  // User not allowed to set this billing plan (PERMISSION_DENIED)
  rpc ChangeBillingPlan (ChangeBillingPlanRequest) returns (ChangeBillingPlanResponse) {}

  // Generate connection token that can be used to instantiate connection
  //
  // Available to: Issuer, Validator
  //
  // Errors:
  // Billing plan doesn't allow token generation (PERMISSION_DENIED)
  rpc GenerateConnectionToken (GenerateConnectionTokenRequest) returns (GenerateConnectionTokenResponse) {}

  // Return messages received after given time moment, sorted in ascending order by receive time
  //
  // Available to: Issuer, Holder, Validator
  rpc GetMessagesPaginated (GetMessagesPaginatedRequest) returns (GetMessagesPaginatedResponse) {}

  // Return messages received on the given connection, the number is supposed to be small, so, no pagination is required.
  rpc GetMessagesForConnection (GetMessagesForConnectionRequest) returns (GetMessagesForConnectionResponse) {}

  // Send message over a connection
  //
  // Available to: Issuer, Holder, Validator
  //
  // Errors:
  // Unknown connection (UNKNOWN)
  // Connection closed (FAILED_PRECONDITION)
  rpc SendMessage (SendMessageRequest) returns (SendMessageResponse) {}

  // Generate a URL that can be used to do a payment
  rpc GetBraintreePaymentsConfig (GetBraintreePaymentsConfigRequest) returns (GetBraintreePaymentsConfigResponse) {}
  rpc ProcessPayment (ProcessPaymentRequest) returns (ProcessPaymentResponse);
  rpc GetPayments (GetPaymentsRequest) returns (GetPaymentsResponse);

  // Return the information about the Connector and Node builds
  rpc GetBuildInfo (GetBuildInfoRequest) returns (GetBuildInfoResponse);
}

message GetConnectionByTokenRequest {
  string token = 1;
}

message GetConnectionByTokenResponse {
  Connection connection = 1;
}

// Request connections instantiated by us / with us possibly after a known connection
message GetConnectionsPaginatedRequest {
  string lastSeenConnectionId = 1; // returned credentials will have been created after the last seen connection (optional field)
  int32 limit = 2; // maximum number of credentials to return; must be > 0
}

// Result with connections instantiated
message GetConnectionsPaginatedResponse {
  repeated ConnectionInfo connections = 1; // connections sorted in ascending order by instantiation time
}

// Request to obtain information of connection token
message GetConnectionTokenInfoRequest {
  string token = 1; // token value to get information for
}

// Result with information on connection token
message GetConnectionTokenInfoResponse {
  ParticipantInfo creator = 1; // participant who generated the code
}

// Request to instantiate a connection using token
message AddConnectionFromTokenRequest {
  string token = 1; // token to instantiate connection
  ConnectorPublicKey holderPublicKey = 2;
  string paymentNonce = 3; // optional field, if present, we'll charge the user before adding the connection
  // Note that old clients will send the holderPublicKey instead, which we'll need to encode on the server.
  EncodedPublicKey holderEncodedPublicKey = 4; // Uncompressed encoded public key
}

// Confirmation of connection instantiation
message AddConnectionFromTokenResponse {
  ConnectionInfo connection = 1; // instantiated connection info
  string userId = 2; // your generated user id
}

// Request to delete a connection
message DeleteConnectionRequest {
  string connectionId = 1; // id of connection to delete
}

// Confirmation of connection deletion
message DeleteConnectionResponse {
}

// Request to generate a connection token
message GenerateConnectionTokenRequest {
}

// Result with generated token
message GenerateConnectionTokenResponse {
  string token = 1; // generated token
}

// Request to return messages for us after the given known message (if any)
message GetMessagesPaginatedRequest {
  string lastSeenMessageId = 1; // returned credentials will have been received after the given message (if any)
  int32 limit = 2; // maximum number of credentials to return, must be > 0
}

// Response with messages
message GetMessagesPaginatedResponse {
  repeated ReceivedMessage messages = 1; // messages sorted in ascending order by receiving time
}

message GetMessagesForConnectionRequest {
  string connectionId = 1;
}
message GetMessagesForConnectionResponse {
  repeated ReceivedMessage messages = 1;
}

// Request to send message
message SendMessageRequest {
  string connectionId = 1; // id of the connection
  bytes message = 2; // raw message
}

// Confirmation of message sending
message SendMessageResponse {
}

// REGISTRATION AND ACCOUNT MANAGEMENT

// Request to register DID
message RegisterDIDRequest {
  SignedAtalaOperation createDIDOperation = 1;
  Role role = 2;
  string name = 3;
  bytes logo = 4;

  enum Role {
    issuer = 0;
    verifier = 1;
  }
}

// Confirmation of DID registration
message RegisterDIDResponse {
  string did = 1;
}

// Request to change the billing plan
message ChangeBillingPlanRequest {
  BillingPlan billingPlan = 1; // new billing plan
}

// Confirmation of billing plan change
message ChangeBillingPlanResponse {
}

message GetBraintreePaymentsConfigRequest {}
message GetBraintreePaymentsConfigResponse {
  string tokenizationKey = 1;
}

message ProcessPaymentRequest {
  string amount = 1; // exact decimal amount
  string nonce = 2; // client nonce
}
message ProcessPaymentResponse {
  Payment payment = 1;
}

message GetPaymentsRequest {}
message GetPaymentsResponse {
  repeated Payment payments = 1;
}

message GetBuildInfoRequest {}
message GetBuildInfoResponse {
  string version = 1;
  string scalaVersion = 2;
  string millVersion = 3;
  string buildTime = 4;
  string nodeVersion = 5;
}

// MARK: - connector_models.proto

// GENERAL

// just an EC public key represented with big integers as strings
// TODO: merge with the node PublicKey
message ConnectorPublicKey {
    string x = 1;
    string y = 2;
}
// Public key ECPoint uncompressed encoded
message EncodedPublicKey {
    bytes publicKey = 1;
}

// Information on an Issuer
message IssuerInfo {
    string DID = 1;
    string name = 2;
    bytes logo = 3;
}

// Information on a Verifier
message VerifierInfo {
    string DID = 1;
    string name = 2;
    bytes logo = 3;
}

// Information on a Holder
message HolderInfo {
    string DID = 1;
    string name = 2;
}

// Type representing generic participant in the system, alternative of IssuerInfo, HolderInfo, or VerifierInfo.
message ParticipantInfo {
    oneof participant {
        IssuerInfo issuer = 1;
        HolderInfo holder = 2;
        VerifierInfo verifier = 3;
    }
}


// CONNECTIONS

// A connection between two parties authorizing
// the use of the connector as a messaging channel.
message Connection {
    // the connection token used to initialize the connection with the wallet
    string connectionToken = 1;
    string connectionId = 2;
}

// Information on the connection; both sides see the same connectionId and creation time, but each sees different participantInfo
message ConnectionInfo {
    string connectionId = 1;
    int64 created = 2; // moment of instantiation as milliseconds since the Unix Epoch
    ParticipantInfo participantInfo = 3; // information about the participant at the other end
    string token = 4; // the token used to generate the connection
}


// MESSAGES

// Message received via a connection
message ReceivedMessage {
    string id = 1;
    int64 received = 2; // time when Connector received the message as milliseconds since the Unix Epoch
    string connectionId = 3; // connection where the message has been received
    bytes message = 4; // raw message
}

// Enumeration representing billing plan of Issuer. Possible values are hardcoded as new billing options would require implementation changes anyway.
enum BillingPlan {
    NO_PLAN = 0; // participant not able to generate connection tokens
    FREE_PLAN = 1; // connections are created for free
    SENDER_PAYS = 2; // side generating the token pays for the connection
    RECEIVER_PAYS = 3; // side receiving the token and using it to instantiate connection pays for it
}

message Payment {
    string id = 1;
    string amount = 2;
    int64 createdOn = 3;
    string status = 4;
    string failureReason = 5;
}

// MARK: - node_models.proto

enum KeyUsage {
    // UNKNOWN_KEY is an invalid value - Protobuf uses 0 if no value is provided and we want user to explicitly choose the usage
    UNKNOWN_KEY = 0;
    MASTER_KEY = 1;
    ISSUING_KEY = 2;
    COMMUNICATION_KEY = 3;
    AUTHENTICATION_KEY = 4;
}

message ECKeyData {
    string curve = 1;
    bytes x = 2;
    bytes y = 3;
}

message PublicKey {
    string id = 1;
    KeyUsage usage = 2;
    oneof keyData {
        ECKeyData ecKeyData = 8;
    };
}

message DIDData {
    string id = 1; // DID suffix, where DID is in form did:atala:[DID suffix]
    repeated PublicKey publicKeys = 2;
}

message CredentialData {
    string id = 1;
    string issuer = 2;
    bytes contentHash = 3;
    Date issuanceDate = 4;
}

message CreateDIDOperation {
    DIDData didData = 1; // DIDData with did empty id field
}

message AddKeyAction {
    PublicKey key = 1;
}

message RemoveKeyAction {
    string keyId = 1;
}

message UpdateDIDAction {
    oneof action {
        AddKeyAction addKey = 1;
        RemoveKeyAction removeKey = 2;
    }
}

message UpdateDIDOperation {
    bytes previousOperationHash = 1;
    string id = 2;
    repeated UpdateDIDAction actions = 3;
}

message IssueCredentialOperation {
    CredentialData credentialData = 1; // credential data with id empty
}

message RevokeCredentialOperation {
    bytes previousOperationHash = 1;
    string credentialId = 2; // revoked credential id, as returned in IssueCredentialResponse
    Date revocationDate = 3;
}

message AtalaOperation {
    oneof operation {
        CreateDIDOperation createDid = 1;
        UpdateDIDOperation updateDid = 2;
        IssueCredentialOperation issueCredential = 3;
        RevokeCredentialOperation revokeCredential = 4;
    };
}

message SignedAtalaOperation {
    string signedWith = 1; // id of key used to sign
    bytes signature = 2; // signature of byte encoding of the operation
    AtalaOperation operation = 3;
}

// MARK: - common_models.proto

message Date {
    int32 year = 1; // positive value
    int32 month = 2; // value in the [1, 12] interval
    int32 day = 3; // value in the [1, 31] interval (depending on the month, the max value might be 28
}

// MARK: - credential_models.proto

/*
Based on requirements, diplomas need the following information

Universities
- Full name of the institution (Legal form with reference)
- Name of the qualifying / academic authority
- Decision on granting qualification / academic degree
- Issue Number
- Issue Date (day, month, year)
- Name and Surname of Graduate
- Qualified / academic degree awarded
- Additional specialty (if any)
- Name and surname of the head of the institution (Signature)
- Name and surname of persons / persons authorized to sign a diploma (Signature)

Given an example diploma we found a few extra fields present
- Registration number
- Decision number

Notoriously we see that national id number or other graduate date is not
required, only the name is.
We decided to add a SubjectData field with optional extra values for this.

In the case of schools, required information is:
- Name and surname School student
- Student's personal number (if any)
- Students Date of Birth
- Full legal name of Education institution
- Year completed by Student

We see that no signature is mentioned for the school diplomas

Given the schema below both types of certificates can be encoded, the distinction will be found
in IssuerData, where the IssuerType differentiate schools and universities
*/

message AlphaCredential {
    IssuerData issuerType = 1; // Data associated to the issuer organization. Currently University or School
    SubjectData subjectData = 2; // Personal data associated to the holder (student)
    string grantingDecision = 3; // e.g. [subject] was awarded Degree of Master Business Administration in Management
    repeated Signer signingAuthorities = 4; // head and other members of the institution that will sign the diploma
    string degreeAwarded = 5; // Degree name
    string additionalSpeciality = 6; // Optional additional speciality
    Date issuedOn = 7; // Date of issuance

    // Fields that are unclear. They may be updated or even deleted
    string issueNumber = 8; // NEED CLARIFICATION ON WHAT THIS IS
    string registrationNumber = 9; // NEED CLARIFICATION Registration number. This appears in the example diploma but it is unclear how this may relate to "Issue number"
    string decisionNumber = 10; //NEED CLARIFICATION Decision number. This appears in the example diploma but it is unclear how this may relate to "Issue number"
    string yearCompletedByStudent = 15; // WE NEED CLARIFICATIONS ON THIS FIELD. It is related to school diplomas
                                        // It may be replaceable by one of the fields related to OpenCerts. See below

    // Fields inspired from OpenCerts standard. See: https://github.com/OpenCerts/open-certificate/blob/master/schema/2.0/schema.json
    string description = 16; // Field reserved for general description of the credential
    Date expiresOn = 17;
    Date admissionDate = 18; // unclear meaning
    Date graduationDate = 19 ; // (OpenCerts description) The date that this student graduated from the course
    Date attainmentDate = 20 ; // (OpenCerts description) The date that this qualification was awarded to the recipient
    // Other fields we could add:
    /*
    qualificationLevel: (OpenCerts description) "This is an array of objects used to attach descriptors from
                         frameworks such as Singapore's SSEC-EQA or the internationally recognised ISCED. Multiple
                         instances are allowed to indicate either equivalents or to indicate a multi-level qualifications",
                         It consist of tuples of 4 strings
     fieldOfStudy: (OpenCerts description) "This is an array of objects used to attach descriptors from frameworks such
                   as Singapore's SSEC-FOS or the internationally recognised ISCED-F. Multiple instances are allowed to
                   indicate either equivalents or to indicate a multi-field qualification such as double degrees",
                   It consist of tuples of 4 strings
    cumulativeScore: Unclear description, it is a number. Probably applies to course certificates but not to degrees.
    transcript: It seems to consist of an array of data associated to each course that the student took to get the degree.
    additionalData: Unclear field without structure (a simple JSON object). It may be used to add extra data.
    */
}

message IssuerData {
    string issuerLegalName = 1; // Issuer legal name. E.g. "LLC BUSINESS AND TECHNOLOGY UNIVERSITY"
    string academicAuthority = 2; // In university case, this could be the faculty name.
                                  // E.g. Faculty of Business and Technology
    IssuerType issuerType = 3; // Issuer organization type. Currently University or School
    string did = 4; // public DID associated to the institution
    // OpenCerts adds some other data like URL, email, phone
}

message Signer {
    repeated string names = 1; // Names of the signer
    repeated string surnames = 2; // Surnames of the signer
    string role = 3; // Rector, Dean, etc.
    string did = 4; // public DID associated to the signer
    string title = 5; // Tittle to address the person. e.g. Mr, Dr, Prof, etc.
}

// For now Universites and schools.
enum IssuerType {
    University = 0;
    School = 1;
}

message SubjectData {
    repeated string names = 1; // Names of the subject.
    repeated string surnames = 2; // surnames of the subject.
    Date dateOfBirth = 3; // date of birth of the holder
    PersonalId idDocument = 4; // optional identification number of the holder
    // OpenCerts also adds phone, email, URL, studentId and unclear values "nric" and "fin".
}

message PersonalId {
    string id = 1; // unique identifier of the individual according to document type
    IdDocumentType documentType = 2; // E.g. passport, driver licence, national card
}

enum IdDocumentType {
    NationalIdCard = 0;
    Passport = 1;
}

/*
  Below we can see the messages used to exchange credentials between actors
*/
message IssuerSentCredential {
    oneof value {
        AlphaCredential alphaCredential = 1;
        Credential credential = 2;
    }
}

message Credential {
    // type id to enable dispatch to correct credential processor.
    string typeId = 1;

    // JSON or JWT encoded credential document (to discuss)
    string credentialDocument = 2;
}

message HolderSentCredential {
    AlphaCredential credential = 1;
}

message ProofRequest {
    repeated string typeIds = 1;
    string connectionToken = 2;
}

message AtalaMessage {
    oneof message {
        IssuerSentCredential issuerSentCredential = 1;
        HolderSentCredential holderSentCredential = 2;
        ProofRequest proofRequest = 3;
    }
}

